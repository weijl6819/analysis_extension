/*!
 * Skype Developer Platform
 * (c) 2015 Microsoft Corporation.  All rights reserved.
 */
var clienttelemetry_build;
(function (clienttelemetry_build) {
    clienttelemetry_build.version = "2.7.1";
})(clienttelemetry_build || (clienttelemetry_build = {}));
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
// 
//     Tool     : bondc, Version=3.0.1, Build=bond-git.debug.not
//     Template : Microsoft.Bond.Rules.dll#TypeScript.tt
//     File     : bond_const.ts
//
//     Changes to this file may cause incorrect behavior and will be lost when
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
var Microsoft;
(function (Microsoft) {
    var Bond;
    (function (Bond) {
        (function (BondDataType) {
            BondDataType[BondDataType["BT_STOP"] = 0] = "BT_STOP";
            BondDataType[BondDataType["BT_STOP_BASE"] = 1] = "BT_STOP_BASE";
            BondDataType[BondDataType["BT_BOOL"] = 2] = "BT_BOOL";
            BondDataType[BondDataType["BT_UINT8"] = 3] = "BT_UINT8";
            BondDataType[BondDataType["BT_UINT16"] = 4] = "BT_UINT16";
            BondDataType[BondDataType["BT_UINT32"] = 5] = "BT_UINT32";
            BondDataType[BondDataType["BT_UINT64"] = 6] = "BT_UINT64";
            BondDataType[BondDataType["BT_FLOAT"] = 7] = "BT_FLOAT";
            BondDataType[BondDataType["BT_DOUBLE"] = 8] = "BT_DOUBLE";
            BondDataType[BondDataType["BT_STRING"] = 9] = "BT_STRING";
            BondDataType[BondDataType["BT_STRUCT"] = 10] = "BT_STRUCT";
            BondDataType[BondDataType["BT_LIST"] = 11] = "BT_LIST";
            BondDataType[BondDataType["BT_SET"] = 12] = "BT_SET";
            BondDataType[BondDataType["BT_MAP"] = 13] = "BT_MAP";
            BondDataType[BondDataType["BT_INT8"] = 14] = "BT_INT8";
            BondDataType[BondDataType["BT_INT16"] = 15] = "BT_INT16";
            BondDataType[BondDataType["BT_INT32"] = 16] = "BT_INT32";
            BondDataType[BondDataType["BT_INT64"] = 17] = "BT_INT64";
            BondDataType[BondDataType["BT_WSTRING"] = 18] = "BT_WSTRING";
            BondDataType[BondDataType["BT_UNAVAILABLE"] = 127] = "BT_UNAVAILABLE";
        })(Bond.BondDataType || (Bond.BondDataType = {}));
        var BondDataType = Bond.BondDataType;
        (function (ProtocolType) {
            ProtocolType[ProtocolType["MARSHALED_PROTOCOL"] = 0] = "MARSHALED_PROTOCOL";
            ProtocolType[ProtocolType["MAFIA_PROTOCOL"] = 17997] = "MAFIA_PROTOCOL";
            ProtocolType[ProtocolType["COMPACT_PROTOCOL"] = 16963] = "COMPACT_PROTOCOL";
            ProtocolType[ProtocolType["JSON_PROTOCOL"] = 21322] = "JSON_PROTOCOL";
            ProtocolType[ProtocolType["PRETTY_JSON_PROTOCOL"] = 20554] = "PRETTY_JSON_PROTOCOL";
            ProtocolType[ProtocolType["SIMPLE_PROTOCOL"] = 20563] = "SIMPLE_PROTOCOL";
        })(Bond.ProtocolType || (Bond.ProtocolType = {}));
        var ProtocolType = Bond.ProtocolType;
    })(Bond = Microsoft.Bond || (Microsoft.Bond = {}));
})(Microsoft || (Microsoft = {}));
var Microsoft;
(function (Microsoft) {
    var Bond;
    (function (Bond) {
        var Collections;
        (function (Collections) {
            var Set = (function () {
                function Set() {
                    this._buffer = [];
                }
                Set.prototype.Add = function (t) {
                    var i = 0;
                    for (; i < this._buffer.length; ++i) {
                        if (this._buffer[i] == t) {
                            break;
                        }
                    }
                    if (i == this._buffer.length) {
                        this._buffer.push(t);
                    }
                };
                Set.prototype.Count = function () {
                    return this._buffer.length;
                };
                Set.prototype.GetBuffer = function () {
                    return this._buffer;
                };
                return Set;
            }());
            Collections.Set = Set;
            // Modified bond code to add AddorReplace and Remove for Map
            //TODO(abpanwar): Contact the bond team to add this to their library.
            var Map = (function () {
                function Map() {
                    this._buffer = [];
                }
                Map.prototype.Add = function (key, value) {
                    if (this._getIndex(key) == -1) {
                        this._buffer.push({ Key: key, Value: value });
                    }
                };
                Map.prototype.AddOrReplace = function (key, value) {
                    var i = this._getIndex(key);
                    if (i >= 0) {
                        this._buffer[i] = { Key: key, Value: value };
                    }
                    else {
                        this._buffer.push({ Key: key, Value: value });
                    }
                };
                Map.prototype.Remove = function (key) {
                    var i = this._getIndex(key);
                    if (i >= 0) {
                        this._buffer.splice(i, 1);
                    }
                };
                Map.prototype.Count = function () {
                    return this._buffer.length;
                };
                Map.prototype.GetBuffer = function () {
                    return this._buffer;
                };
                Map.prototype.ContainsKey = function (key) {
                    if (this._getIndex(key) >= 0) {
                        return true;
                    }
                    return false;
                };
                Map.prototype.Get = function (key) {
                    var i = this._getIndex(key);
                    if (i >= 0) {
                        return this._buffer[i].Value;
                    }
                    return null;
                };
                Map.prototype._getIndex = function (key) {
                    var i = 0;
                    var index = -1;
                    for (; i < this._buffer.length; ++i) {
                        if (this._buffer[i].Key == key) {
                            index = i;
                            break;
                        }
                    }
                    return index;
                };
                return Map;
            }());
            Collections.Map = Map;
        })(Collections = Bond.Collections || (Bond.Collections = {}));
    })(Bond = Microsoft.Bond || (Microsoft.Bond = {}));
})(Microsoft || (Microsoft = {}));
var Microsoft;
(function (Microsoft) {
    var Bond;
    (function (Bond) {
        var Encoding;
        (function (Encoding) {
            var Utf8 = (function () {
                function Utf8() {
                }
                Utf8.GetBytes = function (value) {
                    var array = [];
                    for (var i = 0; i < value.length; ++i) {
                        var char = value.charCodeAt(i);
                        if (char < 0x80) {
                            array.push(char);
                        }
                        else if (char < 0x800) {
                            array.push(0xc0 | (char >> 6), 0x80 | (char & 0x3f));
                        }
                        else if (char < 0xd800 || char >= 0xe000) {
                            array.push(0xe0 | (char >> 12), 0x80 | ((char >> 6) & 0x3f), 0x80 | (char & 0x3f));
                        }
                        else {
                            char = 0x10000 + (((char & 0x3ff) << 10) | (value.charCodeAt(++i) & 0x3ff));
                            array.push(0xf0 | (char >> 18), 0x80 | ((char >> 12) & 0x3f), 0x80 | ((char >> 6) & 0x3f), 0x80 | (char & 0x3f));
                        }
                    }
                    return array;
                };
                return Utf8;
            }());
            Encoding.Utf8 = Utf8;
            var Base64 = (function () {
                function Base64() {
                }
                Base64.GetString = function (inArray) {
                    var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                    var output = [];
                    var paddingBytes = inArray.length % 3;
                    var i, temp, length;
                    var toBase64 = function (num) {
                        return [lookup.charAt((num >> 18) & 0x3F),
                            lookup.charAt((num >> 12) & 0x3F),
                            lookup.charAt((num >> 6) & 0x3F),
                            lookup.charAt(num & 0x3F)].join("");
                    };
                    for (i = 0, length = inArray.length - paddingBytes; i < length; i += 3) {
                        temp = (inArray[i] << 16) + (inArray[i + 1] << 8) + (inArray[i + 2]);
                        output.push(toBase64(temp));
                    }
                    switch (paddingBytes) {
                        case 1:
                            temp = inArray[inArray.length - 1];
                            output.push(lookup.charAt(temp >> 2));
                            output.push(lookup.charAt((temp << 4) & 0x3F));
                            output.push('==');
                            break;
                        case 2:
                            temp = (inArray[inArray.length - 2] << 8) + (inArray[inArray.length - 1]);
                            output.push(lookup.charAt(temp >> 10));
                            output.push(lookup.charAt((temp >> 4) & 0x3F));
                            output.push(lookup.charAt((temp << 2) & 0x3F));
                            output.push('=');
                            break;
                    }
                    return output.join("");
                };
                return Base64;
            }());
            Encoding.Base64 = Base64;
            var Varint = (function () {
                function Varint() {
                }
                Varint.GetBytes = function (value) {
                    var array = [];
                    while (value & 0xffffff80) {
                        array.push((value & 0x7f) | 0x80);
                        value >>>= 7;
                    }
                    array.push(value & 0x7f);
                    return array;
                };
                return Varint;
            }());
            Encoding.Varint = Varint;
            var Varint64 = (function () {
                function Varint64() {
                }
                Varint64.GetBytes = function (value) {
                    var low = value.low;
                    var high = value.high;
                    var array = [];
                    while (high || (0xffffff80 & low)) {
                        array.push((low & 0x7f) | 0x80);
                        low = ((high & 0x7f) << 25) | (low >>> 7);
                        high >>>= 7;
                    }
                    array.push(low & 0x7f);
                    return array;
                };
                return Varint64;
            }());
            Encoding.Varint64 = Varint64;
            var Float = (function () {
                function Float() {
                }
                Float.GetBytes = function (value) {
                    if (Bond.BrowserChecker.IsDataViewSupport()) {
                        var view = new DataView(new ArrayBuffer(4));
                        view.setFloat32(0, value, true /*littleEndian*/);
                        var array = [];
                        for (var i = 0; i < 4; ++i) {
                            array.push(view.getUint8(i));
                        }
                        return array;
                    }
                    else {
                        return FloatUtils.ConvertNumberToArray(value, false /*isDouble*/);
                    }
                };
                return Float;
            }());
            Encoding.Float = Float;
            // Note: see notes of Float.
            var Double = (function () {
                function Double() {
                }
                Double.GetBytes = function (value) {
                    if (Bond.BrowserChecker.IsDataViewSupport()) {
                        var view = new DataView(new ArrayBuffer(8));
                        view.setFloat64(0, value, true /*littleEndian*/);
                        var array = [];
                        for (var i = 0; i < 8; ++i) {
                            array.push(view.getUint8(i));
                        }
                        return array;
                    }
                    else {
                        return FloatUtils.ConvertNumberToArray(value, true /*isDouble*/);
                    }
                };
                return Double;
            }());
            Encoding.Double = Double;
            var Zigzag = (function () {
                function Zigzag() {
                }
                Zigzag.EncodeZigzag16 = function (value) {
                    value = Bond.Number.ToInt16(value);
                    return ((value << 1) ^ (value >> (2 /*sizeof(short)*/ * 8 - 1)));
                };
                Zigzag.EncodeZigzag32 = function (value) {
                    value = Bond.Number.ToInt32(value);
                    return ((value << 1) ^ (value >> (4 /*sizeof(int)*/ * 8 - 1)));
                };
                Zigzag.EncodeZigzag64 = function (value) {
                    var low = value.low;
                    var high = value.high;
                    var tmpH = (high << 1) | (low >>> 31);
                    var tmpL = low << 1;
                    if (high & 0x80000000) {
                        tmpH = ~tmpH;
                        tmpL = ~tmpL;
                    }
                    var res = new Bond.UInt64("0");
                    res.low = tmpL;
                    res.high = tmpH;
                    return res;
                };
                return Zigzag;
            }());
            Encoding.Zigzag = Zigzag;
        })(Encoding = Bond.Encoding || (Bond.Encoding = {}));
        var Decoding;
        (function (Decoding) {
            var Utf8 = (function () {
                function Utf8() {
                }
                Utf8.GetString = function (data) {
                    var res = [];
                    for (var i = 0; i < data.length; ++i) {
                        var c1 = data[i];
                        if (c1 <= 191) {
                            res.push(String.fromCharCode(c1));
                        }
                        else if (c1 <= 223) {
                            var c2 = data[++i];
                            res.push(String.fromCharCode(((c1 & 31) << 6) | (c2 & 63)));
                        }
                        else if (c1 <= 239) {
                            var c2 = data[++i];
                            var c3 = data[++i];
                            res.push(String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63)));
                        }
                        else {
                            var c2 = data[++i];
                            var c3 = data[++i];
                            var c4 = data[++i];
                            c1 = ((c1 & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 & 63);
                            c1 -= 0x10000;
                            res.push(String.fromCharCode(0xd800 | ((c1 >> 10) & 0x3ff)));
                            res.push(String.fromCharCode(0xdc00 | (c1 & 0x3ff)));
                        }
                    }
                    return res.join("");
                };
                return Utf8;
            }());
            Decoding.Utf8 = Utf8;
            var Base64 = (function () {
                function Base64() {
                }
                Base64.GetBytes = function (base64Str) {
                    var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                    var res = [];
                    for (var i = 0; i < base64Str.length; ++i) {
                        var byte1 = lookup.indexOf(base64Str.charAt(i++));
                        var byte2 = lookup.indexOf(base64Str.charAt(i++));
                        var byte3 = lookup.indexOf(base64Str.charAt(i++));
                        var byte4 = lookup.indexOf(base64Str.charAt(i));
                        res.push(byte1 << 2 | byte2 >> 4);
                        if (byte3 >= 0) {
                            res.push((byte2 << 4) & 0xF0 | byte3 >> 2);
                            if (byte4 >= 0) {
                                res.push((byte3 << 6) & 0xC0 | byte4);
                            }
                        }
                    }
                    return res;
                };
                return Base64;
            }());
            Decoding.Base64 = Base64;
            var Varint = (function () {
                function Varint() {
                }
                Varint.GetInt64 = function (buffer) {
                    var int64 = new Microsoft.Bond.Int64("0");
                    var data = this._Read(buffer);
                    int64.low = data[0];
                    if (data.length > 1) {
                        int64.high = data[1];
                    }
                    return int64;
                };
                Varint.GetNumber = function (buffer) {
                    return this._Read(buffer)[0];
                };
                Varint._Read = function (buffer) {
                    var result = [];
                    var tmp = 0;
                    var hasMore = true;
                    var readedBits = 0;
                    // first, lets try to read the first 32 bits
                    while (hasMore) {
                        var raw = buffer.shift();
                        hasMore = (raw & 0x80) != 0;
                        raw = raw & 0x7F;
                        if (readedBits < 28) {
                            tmp |= raw << readedBits;
                            readedBits += 7;
                        }
                        else {
                            // only lower 4 bits can be put
                            tmp |= raw << readedBits;
                            result.push(tmp);
                            tmp = raw >> 4;
                            readedBits = 3;
                            break;
                        }
                    }
                    // then, read the second 32 bits
                    while (hasMore) {
                        var raw = buffer.shift();
                        hasMore = (raw & 0x80) != 0;
                        raw = raw & 0x7F;
                        tmp |= raw << readedBits;
                        readedBits += 7;
                        if (readedBits >= 32) {
                            break;
                        }
                    }
                    result.push(tmp);
                    return result;
                };
                return Varint;
            }());
            Decoding.Varint = Varint;
            var Float = (function () {
                function Float() {
                }
                Float.GetNumber = function (buffer) {
                    if (Bond.BrowserChecker.IsDataViewSupport()) {
                        var view = new DataView(new ArrayBuffer(4));
                        for (var i = 0; i < 4; ++i) {
                            view.setUint8(i, buffer[i]);
                        }
                        return view.getFloat32(0, true /*littleEndian*/);
                    }
                    else {
                        return FloatUtils.ConvertArrayToNumber(buffer, false /*isDouble*/);
                    }
                };
                return Float;
            }());
            Decoding.Float = Float;
            var Double = (function () {
                function Double() {
                }
                Double.GetNumber = function (buffer) {
                    if (Bond.BrowserChecker.IsDataViewSupport()) {
                        var view = new DataView(new ArrayBuffer(8));
                        for (var i = 0; i < 8; ++i) {
                            view.setUint8(i, buffer[i]);
                        }
                        return view.getFloat64(0, true /*littleEndian*/);
                    }
                    else {
                        return FloatUtils.ConvertArrayToNumber(buffer, true /*isDouble*/);
                    }
                };
                return Double;
            }());
            Decoding.Double = Double;
            var Zigzag = (function () {
                function Zigzag() {
                }
                Zigzag.DecodeZigzag16 = function (value) {
                    return (((0xffff & value) >>> 1) ^ (-(value & 1))) << 16 >> 16;
                };
                Zigzag.DecodeZigzag32 = function (value) {
                    return (value >>> 1) ^ (-(value & 1));
                };
                Zigzag.DecodeZigzag64 = function (value) {
                    // implement
                    // (value >>> 1) ^ (-(value & 1))
                    var tmpH = value.high & 1;
                    var high = value.high >>> 1;
                    var tmpL = value.low & 1;
                    var low = value.low >>> 1;
                    low = tmpH << 31 | low;
                    if (tmpL) {
                        low ^= 0xffffffff;
                        high ^= 0xffffffff;
                    }
                    var res = new Microsoft.Bond.UInt64("0");
                    res.low = low;
                    res.high = high;
                    return res;
                };
                return Zigzag;
            }());
            Decoding.Zigzag = Zigzag;
        })(Decoding = Bond.Decoding || (Bond.Decoding = {}));
        /** This class will be used to convert float/double to byte array on browsers which doesn't
            support html5.

            Format: IEEE-754, littleEndian, http://en.wikipedia.org/wiki/IEEE_754-1985

            \note
            1. Don't have negative zero. All zero will be positive zero.
            2. If the buffer array passed to ConvertArrayToFloat() is actual NaN or Inifinity value,
               exception will be raised.
        */
        var FloatUtils = (function () {
            function FloatUtils() {
            }
            FloatUtils.ConvertNumberToArray = function (num, isDouble) {
                if (!num) {
                    return isDouble ? this._doubleZero : this._floatZero;
                }
                var exponentBits = isDouble ? 11 : 8;
                var precisionBits = isDouble ? 52 : 23;
                // follow IEEE-754, exponent bias is 2^(k-1)-1 where k is the number of bits
                // in the exponent: http://en.wikipedia.org/wiki/Exponent_bias
                var bias = (1 << (exponentBits - 1)) - 1;
                var minExponent = 1 - bias;
                var maxExponent = bias;
                var sign = num < 0 ? 1 : 0;
                num = Math.abs(num);
                var intPart = Math.floor(num);
                var floatPart = num - intPart;
                var len = 2 * (bias + 2) + precisionBits;
                var buffer = new Array(len);
                var i = 0;
                while (i < len) {
                    buffer[i++] = 0;
                }
                // caculate the intPart
                i = bias + 2;
                while (i && intPart) {
                    buffer[--i] = intPart % 2;
                    intPart = Math.floor(intPart / 2);
                }
                // caculate the floatPart
                i = bias + 1;
                while (i < len - 1 && floatPart > 0) {
                    floatPart *= 2;
                    if (floatPart >= 1) {
                        buffer[++i] = 1;
                        --floatPart;
                    }
                    else {
                        buffer[++i] = 0;
                    }
                }
                // find the first 1
                var firstBit = 0;
                for (; firstBit < len && !buffer[firstBit]; ++firstBit)
                    ;
                // caculate exponent
                var exponent = bias + 1 - firstBit;
                // caculate round
                var lastBit = firstBit + precisionBits;
                if (buffer[lastBit + 1]) {
                    for (i = lastBit; i > firstBit; --i) {
                        if (buffer[i] = 1 - buffer[i]) {
                            break;
                        }
                    }
                    if (i == firstBit) {
                        ++exponent;
                    }
                }
                // check overflow
                if (exponent > maxExponent || intPart) {
                    if (sign) {
                        return isDouble ? this._doubleNegInifinity : this._floatNegInifinity;
                    }
                    else {
                        return isDouble ? this._doubleInifinity : this._floatInifinity;
                    }
                }
                else if (exponent < minExponent) {
                    return isDouble ? this._doubleZero : this._floatZero;
                }
                // caculate the result
                if (isDouble) {
                    var high = 0;
                    for (i = 0; i < 20; ++i) {
                        high = (high << 1) | buffer[++firstBit];
                    }
                    var low = 0;
                    for (; i < 52; ++i) {
                        low = (low << 1) | buffer[++firstBit];
                    }
                    high |= (exponent + bias) << 20;
                    high = (sign << 31) | (high & 0x7FFFFFFF);
                    var resArray = [low & 0xff, (low >> 8) & 0xff, (low >> 16) & 0xff, low >>> 24,
                        high & 0xff, (high >> 8) & 0xff, (high >> 16) & 0xff, high >>> 24];
                    return resArray;
                }
                else {
                    var result = 0;
                    for (i = 0; i < 23; ++i) {
                        result = (result << 1) | buffer[++firstBit];
                    }
                    result |= (exponent + bias) << 23;
                    result = (sign << 31) | (result & 0x7FFFFFFF);
                    var resArray = [result & 0xff, (result >> 8) & 0xff, (result >> 16) & 0xff, result >>> 24];
                    return resArray;
                }
            };
            FloatUtils.ConvertArrayToNumber = function (buffer, isDouble) {
                var exponentBits = isDouble ? 11 : 8;
                var bias = (1 << (exponentBits - 1)) - 1;
                var sign = (buffer[isDouble ? 7 : 3] & 0x80) != 0;
                var exponent = isDouble ? ((buffer[7] & 0x7f) << 4) | ((buffer[6] & 0xf0) >> 4) : ((buffer[3] & 0x7f) << 1) | ((buffer[2] & 0x80) >> 7);
                // check the buffer is valid or not. If it is invalid (NaN, Infinitive), throw execption.
                if (exponent == 0xff) {
                    throw new Bond.Exception("Not a valid float/double buffer.");
                }
                var res = 1;
                var e = 1;
                if (isDouble) {
                    var high = ((buffer[6] & 0xf) << 28) | ((buffer[5] & 0xff) << 20) | ((buffer[4] & 0xff) << 12);
                    var low = (buffer[3] << 24) | ((buffer[2] & 0xff) << 16) | ((buffer[1] & 0xff) << 8) | (buffer[0] & 0xff);
                    if (!exponent && !high && !low) {
                        return 0.0;
                    }
                    for (var i = 0; i < 20; ++i) {
                        e /= 2;
                        if (high < 0) {
                            res += e;
                        }
                        high <<= 1;
                    }
                    for (var i = 0; i < 32; ++i) {
                        e /= 2;
                        if (low < 0) {
                            res += e;
                        }
                        low <<= 1;
                    }
                }
                else {
                    var data = ((buffer[2] & 0x7f) << 25) | ((buffer[1] & 0xff) << 17) | ((buffer[0] & 0xff) << 9);
                    if (!exponent && !data) {
                        return 0.0;
                    }
                    for (var i = 0; i < 23; ++i) {
                        e /= 2;
                        if (data < 0) {
                            res += e;
                        }
                        data <<= 1;
                    }
                }
                res *= Math.pow(2, exponent - bias);
                return sign ? 0 - res : res;
            };
            FloatUtils._floatZero = [0x00, 0x00, 0x00, 0x00];
            FloatUtils._doubleZero = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
            FloatUtils._floatInifinity = [0x00, 0x00, 0x80, 0x7F];
            FloatUtils._floatNegInifinity = [0x00, 0x00, 0x80, 0xFF];
            FloatUtils._doubleInifinity = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x7f];
            FloatUtils._doubleNegInifinity = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff];
            return FloatUtils;
        }());
    })(Bond = Microsoft.Bond || (Microsoft.Bond = {}));
})(Microsoft || (Microsoft = {}));
var Microsoft;
(function (Microsoft) {
    var Bond;
    (function (Bond) {
        var IO;
        (function (IO) {
            var MemoryStream = (function () {
                function MemoryStream() {
                    this._buffer = [];
                }
                /*override*/
                MemoryStream.prototype.WriteByte = function (byte) {
                    this._buffer.push(Bond.Number.ToByte(byte));
                };
                /*override*/
                MemoryStream.prototype.Write = function (buffer, offset, count) {
                    while (count--) {
                        this.WriteByte(buffer[offset++]);
                    }
                };
                /**
                 * Returns the array of unsigned bytes from which this stream was created.
                 */
                MemoryStream.prototype.GetBuffer = function () {
                    return this._buffer;
                };
                return MemoryStream;
            }());
            IO.MemoryStream = MemoryStream;
        })(IO = Bond.IO || (Bond.IO = {}));
    })(Bond = Microsoft.Bond || (Microsoft.Bond = {}));
})(Microsoft || (Microsoft = {}));
var Microsoft;
(function (Microsoft) {
    var Bond;
    (function (Bond) {
        var FieldTag = (function () {
            function FieldTag(type, id) {
                this.Type = type;
                this.Id = id;
            }
            return FieldTag;
        }());
        Bond.FieldTag = FieldTag;
        var ContainerTag = (function () {
            function ContainerTag(elementType, size) {
                this.ElementType = elementType;
                this.Size = size;
            }
            return ContainerTag;
        }());
        Bond.ContainerTag = ContainerTag;
        var KeyValueContainerTag = (function () {
            function KeyValueContainerTag(keyType, valueType, size) {
                this.KeyType = keyType;
                this.ValueType = valueType;
                this.Size = size;
            }
            return KeyValueContainerTag;
        }());
        Bond.KeyValueContainerTag = KeyValueContainerTag;
        var Bonded = (function () {
            function Bonded() {
            }
            return Bonded;
        }());
        Bond.Bonded = Bonded;
        var Int64 = (function () {
            // BUG!!: need implement, currently, just handle 32bits number
            function Int64(numberStr) {
                this.low = 0;
                this.high = 0;
                this.low = parseInt(numberStr);
                if (this.low < 0) {
                    this.high = -1;
                }
            }
            Int64.prototype.Equals = function (numberStr) {
                var tmp = new Int64(numberStr);
                return this.low == tmp.low && this.high == tmp.high;
            };
            return Int64;
        }());
        Bond.Int64 = Int64;
        var UInt64 = (function () {
            // BUG!!: need implement, currently, just handle 32bits number
            function UInt64(numberStr) {
                this.low = 0;
                this.high = 0;
                this.low = parseInt(numberStr);
            }
            UInt64.prototype.Equals = function (numberStr) {
                var tmp = new UInt64(numberStr);
                return this.low == tmp.low && this.high == tmp.high;
            };
            return UInt64;
        }());
        Bond.UInt64 = UInt64;
        var Number = (function () {
            function Number() {
            }
            Number.ToByte = function (value) {
                return this.ToUInt8(value);
            };
            Number.ToInt8 = function (value) {
                var signMask = (value & 0x80) << 24 >> 24;
                return (value & 0x7f) | signMask;
            };
            Number.ToInt16 = function (value) {
                var signMask = (value & 0x8000) << 16 >> 16;
                return (value & 0x7fff) | signMask;
            };
            Number.ToInt32 = function (value) {
                var signMask = (value & 0x80000000);
                return (value & 0x7fffffff) | signMask;
            };
            Number.ToUInt8 = function (value) {
                return value & 0xff;
            };
            Number.ToUInt16 = function (value) {
                return value & 0xffff;
            };
            Number.ToUInt32 = function (value) {
                return value & 0xffffffff;
            };
            return Number;
        }());
        Bond.Number = Number;
        var Exception = (function () {
            function Exception(message) {
                this.Message = message;
            }
            return Exception;
        }());
        Bond.Exception = Exception;
        var KeyValuePair = (function () {
            function KeyValuePair() {
            }
            return KeyValuePair;
        }());
        Bond.KeyValuePair = KeyValuePair;
        ;
        var BrowserChecker = (function () {
            function BrowserChecker() {
            }
            BrowserChecker.IsDataViewSupport = function () {
                return typeof ArrayBuffer != "undefined" &&
                    typeof DataView != "undefined";
            };
            return BrowserChecker;
        }());
        Bond.BrowserChecker = BrowserChecker;
    })(Bond = Microsoft.Bond || (Microsoft.Bond = {}));
})(Microsoft || (Microsoft = {}));
var Microsoft;
(function (Microsoft) {
    var Bond;
    (function (Bond) {
        var CompactBinaryProtocolWriter = (function () {
            function CompactBinaryProtocolWriter(stream) {
                this._stream = stream;
            }
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteBlob = function (blob) {
                this._stream.Write(blob, 0, blob.length);
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteBool = function (value) {
                this._stream.WriteByte(value ? 1 : 0);
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteContainerBegin = function (size, elementType) {
                this.WriteUInt8(elementType);
                this.WriteUInt32(size);
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteMapContainerBegin = function (size, keyType, valueType) {
                this.WriteUInt8(keyType);
                this.WriteUInt8(valueType);
                this.WriteUInt32(size);
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteContainerEnd = function () {
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteDouble = function (value) {
                var array = Bond.Encoding.Double.GetBytes(value);
                this._stream.Write(array, 0, array.length);
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteFloat = function (value) {
                var array = Bond.Encoding.Float.GetBytes(value);
                this._stream.Write(array, 0, array.length);
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteFieldBegin = function (type, id, metadata) {
                if (id <= 5) {
                    this._stream.WriteByte(type | (id << 5));
                }
                else if (id <= 0xff) {
                    this._stream.WriteByte(type | (6 << 5));
                    this._stream.WriteByte(id);
                }
                else {
                    this._stream.WriteByte(type | (7 << 5));
                    this._stream.WriteByte(id);
                    this._stream.WriteByte(id >> 8);
                }
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteFieldEnd = function () {
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteFieldOmitted = function (type, id, metadata) {
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteInt16 = function (value) {
                value = Bond.Encoding.Zigzag.EncodeZigzag16(value);
                this.WriteUInt16(value);
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteInt32 = function (value) {
                value = Bond.Encoding.Zigzag.EncodeZigzag32(value);
                this.WriteUInt32(value);
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteInt64 = function (value) {
                this.WriteUInt64(Bond.Encoding.Zigzag.EncodeZigzag64(value));
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteInt8 = function (value) {
                this._stream.WriteByte(Bond.Number.ToInt8(value));
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteString = function (value) {
                if (value == "") {
                    this.WriteUInt32(0 /*length*/);
                }
                else {
                    var array = Bond.Encoding.Utf8.GetBytes(value);
                    this.WriteUInt32(array.length);
                    this._stream.Write(array, 0, array.length);
                }
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteStructBegin = function (metadata, isBase) {
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteStructEnd = function (isBase) {
                this.WriteUInt8(isBase ? Bond.BondDataType.BT_STOP_BASE : Bond.BondDataType.BT_STOP);
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteUInt16 = function (value) {
                var array = Bond.Encoding.Varint.GetBytes(Bond.Number.ToUInt16(value));
                this._stream.Write(array, 0, array.length);
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteUInt32 = function (value) {
                var array = Bond.Encoding.Varint.GetBytes(Bond.Number.ToUInt32(value));
                this._stream.Write(array, 0, array.length);
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteUInt64 = function (value) {
                var array = Bond.Encoding.Varint64.GetBytes(value);
                this._stream.Write(array, 0, array.length);
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteUInt8 = function (value) {
                this._stream.WriteByte(Bond.Number.ToUInt8(value));
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteWString = function (value) {
                this.WriteUInt32(value.length);
                for (var i = 0; i < value.length; ++i) {
                    var charCode = value.charCodeAt(i);
                    this._stream.WriteByte(charCode);
                    this._stream.WriteByte(charCode >>> 8);
                }
            };
            return CompactBinaryProtocolWriter;
        }());
        Bond.CompactBinaryProtocolWriter = CompactBinaryProtocolWriter;
        var CompactBinaryProtocolReader = (function () {
            function CompactBinaryProtocolReader() {
            }
            return CompactBinaryProtocolReader;
        }());
        Bond.CompactBinaryProtocolReader = CompactBinaryProtocolReader;
    })(Bond = Microsoft.Bond || (Microsoft.Bond = {}));
})(Microsoft || (Microsoft = {}));
var sct;
(function (sct) {
    var Utils = (function () {
        function Utils() {
        }
        Utils.IsSafari = function () {
            if (Utils._isSafari === null) {
                // If non-browser navigator will be undefined
                if (typeof navigator !== "undefined" && navigator.userAgent) {
                    var ua = navigator.userAgent.toLowerCase();
                    if (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0) {
                        Utils._isSafari = true;
                    }
                    else {
                        Utils._isSafari = false;
                    }
                }
                else {
                    Utils._isSafari = false;
                }
            }
            return Utils._isSafari;
        };
        Utils.IsReactNative = function () {
            if (Utils._isReactNative === null) {
                // If running in React Native, navigator.product will be populated
                if (typeof navigator !== "undefined" && navigator.product) {
                    Utils._isReactNative = navigator.product === "ReactNative";
                }
                else {
                    Utils._isReactNative = false;
                }
            }
            return Utils._isReactNative;
        };
        Utils.IsUint8ArrSupported = function () {
            // Safari & ReactNative are known to not support Uint8Array properly
            return !sct.Utils.IsSafari() && typeof Uint8Array !== "undefined" && !sct.Utils.IsReactNative();
        };
        //
        // options: {
        //      type:   "GET" or "POST",
        //      url:
        //      headers: {
        //          key1: value1
        //          key2: value2
        //      },
        //      complete: function(xhr)
        // }
        //
        Utils.ajax = function (options, syncRequest) {
            var conn = Utils._createConnection();
            if (options.headers) {
                var params = "qsp=true";
                for (var key in options.headers) {
                    params += "&";
                    params += encodeURIComponent(key);
                    params += "=";
                    params += encodeURIComponent(options.headers[key]);
                }
                if (options.url.indexOf("?") < 0) {
                    options.url += "?";
                }
                else {
                    options.url += "&";
                }
                options.url += params;
            }
            conn.open(options.type, options.url, !syncRequest);
            if (options.complete) {
                conn.onload = function () {
                    if (typeof conn.status == "undefined") {
                        conn.status = 200;
                    }
                    options.complete(conn);
                };
                conn.ontimeout = function () {
                    if (typeof conn.status == "undefined") {
                        conn.status = 500;
                    }
                    options.complete(conn);
                };
                conn.onerror = function () {
                    options.complete(conn);
                };
            }
            conn.send(options.data);
        };
        // This is a workaround for IE8. That it does not support
        // Object.keys.
        Utils.keys = function (dict) {
            if (Object.keys) {
                return Object.keys(dict);
            }
            else {
                var keys = [];
                for (var eachKey in dict) {
                    if (dict.hasOwnProperty(eachKey)) {
                        keys.push(eachKey);
                    }
                }
                return keys;
            }
        };
        Utils.IsUsingXDomainRequest = function () {
            if (Utils._usingXDomainRequest == null) {
                var conn = new XMLHttpRequest();
                if (typeof conn.withCredentials == "undefined" &&
                    typeof XDomainRequest != "undefined") {
                    Utils._usingXDomainRequest = true;
                }
                else {
                    Utils._usingXDomainRequest = false;
                }
            }
            return Utils._usingXDomainRequest;
        };
        Utils._createConnection = function () {
            // for all browsers create standard XMLHttpRequest();
            var conn = new XMLHttpRequest();
            if (Utils.IsUsingXDomainRequest()) {
                // this is IE8/IE9, we should use XDomainRequest to support cross domain
                return new XDomainRequest();
            }
            return conn;
        };
        Utils._isSafari = null;
        Utils._isReactNative = null;
        Utils._usingXDomainRequest = null;
        return Utils;
    }());
    sct.Utils = Utils;
})(sct || (sct = {}));
//------------------------------------------------------------------------------
//     This code was generated by using the bondc tool and modified to remove
//      deserialization because it is unused.
// 
//     Tool     : bondc, Version=3.0.1, Build=bond-git.debug.not
//     Template : Microsoft.Bond.Rules.dll#TypeScript.tt
//     File     : DataPackage.ts
//
//     Changes to this file may cause incorrect behavior and will be lost when
//     the code is regenerated.
//------------------------------------------------------------------------------
var microsoft;
(function (microsoft) {
    var applications;
    (function (applications) {
        var telemetry;
        (function (telemetry) {
            var datamodels;
            (function (datamodels) {
                var utils = (function () {
                    function utils() {
                    }
                    utils.GetGuid = function () {
                        var rd = function () {
                            return Math.floor((1 + Math.random()) * 0x10000)
                                .toString(16).substring(1, 5);
                        };
                        return [rd(), rd(), '-', rd(), '-', rd(), '-', rd(), '-', rd(), rd(), rd()].join("");
                    };
                    utils.GetTimeStamp = function () {
                        var val = new Date().getTime();
                        var timestamp = new Microsoft.Bond.Int64("0");
                        timestamp.low = val & 0xffffffff;
                        timestamp.high = Math.floor(val / 0x100000000);
                        return timestamp;
                    };
                    utils.GetTimeStampWithValue = function (timestamp) {
                        var bond_timestamp = new Microsoft.Bond.Int64("0");
                        bond_timestamp.low = timestamp & 0xffffffff;
                        bond_timestamp.high = Math.floor(timestamp / 0x100000000);
                        return bond_timestamp;
                    };
                    return utils;
                }());
                datamodels.utils = utils;
                (function (RecordType) {
                    RecordType[RecordType["NotSet"] = 0] = "NotSet";
                    RecordType[RecordType["Event"] = 1] = "Event";
                    // Deprecated, please use PerformanceCounterAzure and PerformanceCounterGfs instead
                    RecordType[RecordType["PerformanceCounter"] = 2] = "PerformanceCounter";
                    RecordType[RecordType["Anomaly"] = 3] = "Anomaly";
                    RecordType[RecordType["Prediction"] = 4] = "Prediction";
                    RecordType[RecordType["TraceLog"] = 5] = "TraceLog";
                    RecordType[RecordType["EventSourceLog"] = 6] = "EventSourceLog";
                    RecordType[RecordType["HttpLog"] = 7] = "HttpLog";
                    RecordType[RecordType["PerformanceCounterAzure"] = 8] = "PerformanceCounterAzure";
                    RecordType[RecordType["PerformanceCounterGfs"] = 9] = "PerformanceCounterGfs";
                })(datamodels.RecordType || (datamodels.RecordType = {}));
                var RecordType = datamodels.RecordType;
                (function (PIIScrubber) {
                    PIIScrubber[PIIScrubber["NotSet"] = 0] = "NotSet";
                    PIIScrubber[PIIScrubber["O365"] = 1] = "O365";
                    PIIScrubber[PIIScrubber["SkypeBI"] = 2] = "SkypeBI";
                    PIIScrubber[PIIScrubber["SkypeData"] = 3] = "SkypeData";
                })(datamodels.PIIScrubber || (datamodels.PIIScrubber = {}));
                var PIIScrubber = datamodels.PIIScrubber;
                (function (PIIKind) {
                    PIIKind[PIIKind["NotSet"] = 0] = "NotSet";
                    PIIKind[PIIKind["DistinguishedName"] = 1] = "DistinguishedName";
                    PIIKind[PIIKind["GenericData"] = 2] = "GenericData";
                    PIIKind[PIIKind["IPV4Address"] = 3] = "IPV4Address";
                    PIIKind[PIIKind["IPv6Address"] = 4] = "IPv6Address";
                    PIIKind[PIIKind["MailSubject"] = 5] = "MailSubject";
                    PIIKind[PIIKind["PhoneNumber"] = 6] = "PhoneNumber";
                    PIIKind[PIIKind["QueryString"] = 7] = "QueryString";
                    PIIKind[PIIKind["SipAddress"] = 8] = "SipAddress";
                    PIIKind[PIIKind["SmtpAddress"] = 9] = "SmtpAddress";
                    PIIKind[PIIKind["Identity"] = 10] = "Identity";
                    PIIKind[PIIKind["Uri"] = 11] = "Uri";
                    PIIKind[PIIKind["Fqdn"] = 12] = "Fqdn";
                    // Supports scrubbing of the last octet in a IPV4 address. E.g. 10.121.227.147 becomes 10.121.227.*
                    PIIKind[PIIKind["IPV4AddressLegacy"] = 13] = "IPV4AddressLegacy";
                })(datamodels.PIIKind || (datamodels.PIIKind = {}));
                var PIIKind = datamodels.PIIKind;
                (function (UserIdType) {
                    UserIdType[UserIdType["Unknown"] = 0] = "Unknown";
                    UserIdType[UserIdType["MSACID"] = 1] = "MSACID";
                    UserIdType[UserIdType["MSAPUID"] = 2] = "MSAPUID";
                    UserIdType[UserIdType["ANID"] = 3] = "ANID";
                    UserIdType[UserIdType["OrgIdCID"] = 4] = "OrgIdCID";
                    UserIdType[UserIdType["OrgIdPUID"] = 5] = "OrgIdPUID";
                    UserIdType[UserIdType["UserObjectId"] = 6] = "UserObjectId";
                    UserIdType[UserIdType["Skype"] = 7] = "Skype";
                    UserIdType[UserIdType["Yammer"] = 8] = "Yammer";
                    UserIdType[UserIdType["EmailAddress"] = 9] = "EmailAddress";
                    UserIdType[UserIdType["PhoneNumber"] = 10] = "PhoneNumber";
                    UserIdType[UserIdType["SipAddress"] = 11] = "SipAddress";
                    UserIdType[UserIdType["MUID"] = 12] = "MUID";
                })(datamodels.UserIdType || (datamodels.UserIdType = {}));
                var UserIdType = datamodels.UserIdType;
                var PII = (function () {
                    function PII() {
                        // 1: optional PIIScrubber ScrubType
                        this.ScrubType = telemetry.datamodels.PIIScrubber.NotSet;
                        // 2: optional PIIKind Kind
                        this.Kind = telemetry.datamodels.PIIKind.NotSet;
                        // 3: optional string RawContent
                        this.RawContent = "";
                    }
                    PII.prototype.Write = function (writer) {
                        this.WriteImpl(writer, false /*isBase*/);
                    };
                    PII.prototype.WriteImpl = function (writer, isBase) {
                        writer.WriteStructBegin(null /*metadata*/, isBase);
                        if (this.ScrubType != telemetry.datamodels.PIIScrubber.NotSet) {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_INT32, 1, null);
                            writer.WriteInt32(this.ScrubType);
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_INT32, 1, null);
                        }
                        if (this.Kind != telemetry.datamodels.PIIKind.NotSet) {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_INT32, 2, null);
                            writer.WriteInt32(this.Kind);
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_INT32, 2, null);
                        }
                        if (this.RawContent != "") {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_STRING, 3, null);
                            writer.WriteString(this.RawContent);
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_STRING, 3, null);
                        }
                        writer.WriteStructEnd(isBase);
                    };
                    PII.prototype.Read = function (reader) {
                        this.ReadImpl(reader, false /*isBase*/);
                    };
                    PII.prototype.ReadImpl = function (reader, isBase) {
                    };
                    return PII;
                }());
                datamodels.PII = PII;
                var Record = (function () {
                    function Record() {
                        // 1: optional string Id
                        this.Id = utils.GetGuid();
                        // 3: optional int64 Timestamp
                        this.Timestamp = utils.GetTimeStamp();
                        // 5: optional string Type
                        this.Type = "";
                        // 6: optional string EventType
                        this.EventType = "";
                        // 13: optional map<string, string> Extension
                        this.Extension = new Microsoft.Bond.Collections.Map();
                        // 24: optional RecordType RecordType
                        this.RecordType = telemetry.datamodels.RecordType.NotSet;
                        // 30: optional map<string, PII> PIIExtensions
                        this.PIIExtensions = new Microsoft.Bond.Collections.Map();
                    }
                    Record.prototype.AddOrReplacePII = function (key, piiValue, piiKind) {
                        var pii = new telemetry.datamodels.PII();
                        pii.RawContent = piiValue;
                        pii.Kind = piiKind;
                        pii.ScrubType = telemetry.datamodels.PIIScrubber.O365;
                        this.PIIExtensions.AddOrReplace(key, pii);
                    };
                    Record.prototype.Write = function (writer) {
                        this.WriteImpl(writer, false /*isBase*/);
                    };
                    Record.prototype.WriteImpl = function (writer, isBase) {
                        writer.WriteStructBegin(null /*metadata*/, isBase);
                        if (this.Id != "") {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_STRING, 1, null);
                            writer.WriteString(this.Id);
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_STRING, 1, null);
                        }
                        if (!this.Timestamp.Equals("0")) {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_INT64, 3, null);
                            writer.WriteInt64(this.Timestamp);
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_INT64, 3, null);
                        }
                        if (this.Type != "") {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_STRING, 5, null);
                            writer.WriteString(this.Type);
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_STRING, 5, null);
                        }
                        if (this.EventType != "") {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_STRING, 6, null);
                            writer.WriteString(this.EventType);
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_STRING, 6, null);
                        }
                        if (this.Extension.Count()) {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_MAP, 13, null);
                            writer.WriteMapContainerBegin(this.Extension.Count(), Microsoft.Bond.BondDataType.BT_STRING, Microsoft.Bond.BondDataType.BT_STRING);
                            for (var i8 = 0; i8 < this.Extension.GetBuffer().length; ++i8) {
                                writer.WriteString(this.Extension.GetBuffer()[i8].Key);
                                writer.WriteString(this.Extension.GetBuffer()[i8].Value);
                            }
                            writer.WriteContainerEnd();
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_MAP, 13, null);
                        }
                        if (this.RecordType != telemetry.datamodels.RecordType.NotSet) {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_INT32, 24, null);
                            writer.WriteInt32(this.RecordType);
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_INT32, 24, null);
                        }
                        if (this.PIIExtensions.Count()) {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_MAP, 30, null);
                            writer.WriteMapContainerBegin(this.PIIExtensions.Count(), Microsoft.Bond.BondDataType.BT_STRING, Microsoft.Bond.BondDataType.BT_STRUCT);
                            for (var i66 = 0; i66 < this.PIIExtensions.GetBuffer().length; ++i66) {
                                writer.WriteString(this.PIIExtensions.GetBuffer()[i66].Key);
                                this.PIIExtensions.GetBuffer()[i66].Value.WriteImpl(writer, false);
                            }
                            writer.WriteContainerEnd();
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_MAP, 30, null);
                        }
                        writer.WriteStructEnd(isBase);
                    };
                    Record.prototype.Read = function (reader) {
                        this.ReadImpl(reader, false /*isBase*/);
                    };
                    Record.prototype.ReadImpl = function (reader, isBase) {
                    };
                    return Record;
                }());
                datamodels.Record = Record;
                var DataPackage = (function () {
                    function DataPackage() {
                        // 2: optional string Source
                        this.Source = "";
                        // 5: optional string DataPackageId
                        this.DataPackageId = "";
                        // 6: optional int64 Timestamp
                        this.Timestamp = new Microsoft.Bond.Int64("0");
                        // 8: optional vector<clienttelemetry.data.v1.Record> Records
                        this.Records = [];
                    }
                    DataPackage.prototype.Write = function (writer) {
                        this.WriteImpl(writer, false /*isBase*/);
                    };
                    DataPackage.prototype.WriteImpl = function (writer, isBase) {
                        writer.WriteStructBegin(null /*metadata*/, isBase);
                        if (this.Source != "") {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_STRING, 2, null);
                            writer.WriteString(this.Source);
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_STRING, 2, null);
                        }
                        if (this.DataPackageId != "") {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_STRING, 5, null);
                            writer.WriteString(this.DataPackageId);
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_STRING, 5, null);
                        }
                        if (!this.Timestamp.Equals("0")) {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_INT64, 6, null);
                            writer.WriteInt64(this.Timestamp);
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_INT64, 6, null);
                        }
                        if (this.Records.length) {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_LIST, 8, null);
                            writer.WriteContainerBegin(this.Records.length, Microsoft.Bond.BondDataType.BT_STRUCT);
                            for (var i52 = 0; i52 < this.Records.length; ++i52) {
                                this.Records[i52].WriteImpl(writer, false);
                            }
                            writer.WriteContainerEnd();
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_LIST, 8, null);
                        }
                        writer.WriteStructEnd(isBase);
                    };
                    DataPackage.prototype.Read = function (reader) {
                        this.ReadImpl(reader, false /*isBase*/);
                    };
                    DataPackage.prototype.ReadImpl = function (reader, isBase) {
                    };
                    return DataPackage;
                }());
                datamodels.DataPackage = DataPackage;
                var ClientToCollectorRequest = (function () {
                    function ClientToCollectorRequest() {
                        // 1: optional vector<clienttelemetry.data.v1.DataPackage> DataPackages
                        this.DataPackages = [];
                        // 2: optional int32 RequestRetryCount
                        this.RequestRetryCount = 0;
                    }
                    ClientToCollectorRequest.prototype.Write = function (writer) {
                        this.WriteImpl(writer, false /*isBase*/);
                    };
                    ClientToCollectorRequest.prototype.WriteImpl = function (writer, isBase) {
                        writer.WriteStructBegin(null /*metadata*/, isBase);
                        if (this.DataPackages.length) {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_LIST, 1, null);
                            writer.WriteContainerBegin(this.DataPackages.length, Microsoft.Bond.BondDataType.BT_STRUCT);
                            for (var i67 = 0; i67 < this.DataPackages.length; ++i67) {
                                this.DataPackages[i67].WriteImpl(writer, false);
                            }
                            writer.WriteContainerEnd();
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_LIST, 1, null);
                        }
                        if (this.RequestRetryCount != 0) {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_INT32, 2, null);
                            writer.WriteInt32(this.RequestRetryCount);
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_INT32, 2, null);
                        }
                        writer.WriteStructEnd(isBase);
                    };
                    ClientToCollectorRequest.prototype.Read = function (reader) {
                        this.ReadImpl(reader, false /*isBase*/);
                    };
                    ClientToCollectorRequest.prototype.ReadImpl = function (reader, isBase) {
                    };
                    return ClientToCollectorRequest;
                }());
                datamodels.ClientToCollectorRequest = ClientToCollectorRequest;
            })(datamodels = telemetry.datamodels || (telemetry.datamodels = {}));
        })(telemetry = applications.telemetry || (applications.telemetry = {}));
    })(applications = microsoft.applications || (microsoft.applications = {}));
})(microsoft || (microsoft = {}));
/** \file clienttelemetry.ts
    This filed defined the _sender class.

    \author yuboxie
    \date 2013-12
*/
//TODO(abpanwar): rename files to better match the inner module
var microsoft;
(function (microsoft) {
    var applications;
    (function (applications) {
        var telemetry;
        (function (telemetry) {
            var _sender;
            (function (_sender) {
                (function (CallbackEventType) {
                    CallbackEventType[CallbackEventType["SENT"] = 0] = "SENT";
                    CallbackEventType[CallbackEventType["SEND_FAILED"] = 1] = "SEND_FAILED";
                })(_sender.CallbackEventType || (_sender.CallbackEventType = {}));
                var CallbackEventType = _sender.CallbackEventType;
                (function (DATARV_ERROR) {
                    DATARV_ERROR[DATARV_ERROR["DATARV_ERROR_OK"] = 0] = "DATARV_ERROR_OK";
                    DATARV_ERROR[DATARV_ERROR["DATARV_ERROR_INVALID_EVENT"] = 1] = "DATARV_ERROR_INVALID_EVENT";
                    DATARV_ERROR[DATARV_ERROR["DATARV_ERROR_INVALID_CONFIG"] = 2] = "DATARV_ERROR_INVALID_CONFIG";
                    DATARV_ERROR[DATARV_ERROR["DATARV_ERROR_INVALID_DEPENDENCIES"] = 3] = "DATARV_ERROR_INVALID_DEPENDENCIES";
                    DATARV_ERROR[DATARV_ERROR["DATARV_ERROR_INVALID_STATUS"] = 4] = "DATARV_ERROR_INVALID_STATUS";
                    DATARV_ERROR[DATARV_ERROR["DATARV_ERROR_INVALID_ARG"] = 5] = "DATARV_ERROR_INVALID_ARG";
                })(_sender.DATARV_ERROR || (_sender.DATARV_ERROR = {}));
                var DATARV_ERROR = _sender.DATARV_ERROR;
                var Exception = (function () {
                    function Exception(errorCode) {
                        this._errorCode = DATARV_ERROR.DATARV_ERROR_OK;
                        this._errorCode = errorCode;
                    }
                    Exception.prototype.ErrorCode = function () {
                        return this._errorCode;
                    };
                    Exception.prototype.toString = function () {
                        switch (this._errorCode) {
                            case DATARV_ERROR.DATARV_ERROR_OK:
                                return "DATARV_ERROR_OK";
                            case DATARV_ERROR.DATARV_ERROR_INVALID_EVENT:
                                return "Event is invalid. Either event.Id is empty, or event.Timestamp is empty, or event.EventType is empty.";
                            case DATARV_ERROR.DATARV_ERROR_INVALID_CONFIG:
                                return "Invalid configuration. CollectorUrl is missing.";
                            case DATARV_ERROR.DATARV_ERROR_INVALID_DEPENDENCIES:
                                return "DATARV_ERROR_INVALID_DEPENDENCIES";
                            case DATARV_ERROR.DATARV_ERROR_INVALID_STATUS:
                                return "Telemetry Manager is not initialized.";
                            case DATARV_ERROR.DATARV_ERROR_INVALID_ARG:
                                return "TenantToken is null or empty, or events is null.";
                            default:
                                return "Unknown error";
                        }
                    };
                    return Exception;
                }());
                _sender.Exception = Exception;
                /** TelemetryConfig of TelemetryManager.
        
            \note
            TelemetryManager will hold the reference of this config. After you invoke
            Initialize(), you should never modify any content of this config object.
            Otherwise, the behavior is undefined.
        */
                var TelemetryConfig = (function () {
                    function TelemetryConfig() {
                    }
                    return TelemetryConfig;
                }());
                _sender.TelemetryConfig = TelemetryConfig;
                var TelemetryManagerFactory = (function () {
                    function TelemetryManagerFactory() {
                    }
                    TelemetryManagerFactory.CreateTelemetryManager = function () {
                        return new TelemetryManagerImpl();
                    };
                    return TelemetryManagerFactory;
                }());
                _sender.TelemetryManagerFactory = TelemetryManagerFactory;
                //
                // const
                //
                var Consts = (function () {
                    function Consts() {
                    }
                    Consts.MaxPackageSizeInBytes = function () { return 3 * 1000 * 1000; }; // less than 3MB
                    Consts.TimeIntervalForNextSendInMS = function () { return 1 * 1000; }; // send 2 seconds every time
                    return Consts;
                }());
                ;
                //
                // Impl
                //
                /** TelemetryManager status.
        
           \note
           The status order is very important, don't modify it unless you know what you are doing.
        */
                var TelemetryManagerStatus;
                (function (TelemetryManagerStatus) {
                    TelemetryManagerStatus[TelemetryManagerStatus["Created"] = 0] = "Created";
                    TelemetryManagerStatus[TelemetryManagerStatus["Initialized"] = 1] = "Initialized";
                    TelemetryManagerStatus[TelemetryManagerStatus["Started"] = 2] = "Started";
                })(TelemetryManagerStatus || (TelemetryManagerStatus = {}));
                var TelemetryManagerImpl = (function () {
                    function TelemetryManagerImpl() {
                        this._MaxPackageSizeInBytes = Consts.MaxPackageSizeInBytes();
                        this._listeners = [];
                        this._status = TelemetryManagerStatus.Created;
                        //private _ecsClient: ecs.IEcsClient = null;
                        this._etag = null;
                        //private _ecsCallback: any = null;
                        this._testServerResponseHook = null;
                        this._isPaused = false;
                    }
                    TelemetryManagerImpl.prototype.Initialize = function (config) {
                        if (this._status != TelemetryManagerStatus.Created) {
                            throw new Exception(DATARV_ERROR.DATARV_ERROR_INVALID_STATUS);
                        }
                        if (!config ||
                            !config.collectorUrl) {
                            throw new Exception(DATARV_ERROR.DATARV_ERROR_INVALID_CONFIG);
                        }
                        this._config = config;
                        this._Reset();
                        this._status = TelemetryManagerStatus.Initialized;
                        /*if (config.ecsClient) {
                            this._Verbose("ECS object assigned. Do integration");
                            this._ecsClient = config.ecsClient;
                        }*/
                        this._Verbose("Initialize() done");
                    };
                    TelemetryManagerImpl.prototype.AddListener = function (func) {
                        if (this._status < TelemetryManagerStatus.Initialized) {
                            throw new Exception(DATARV_ERROR.DATARV_ERROR_INVALID_STATUS);
                        }
                        this._Verbose([
                            "AddListener(), status: ", this._status,
                            " old length: ", this._listeners.length,
                            " func: ", func
                        ].join(""));
                        for (var i = 0; i < this._listeners.length; ++i) {
                            if (this._listeners[i] == func) {
                                this._Verbose("the listener has been added already, index: " + i);
                                return;
                            }
                        }
                        this._listeners.push(func);
                        this._Verbose("AddListener() done, the new length: " + this._listeners.length);
                    };
                    TelemetryManagerImpl.prototype.RemoveListener = function (func) {
                        if (this._status < TelemetryManagerStatus.Initialized) {
                            throw new Exception(DATARV_ERROR.DATARV_ERROR_INVALID_STATUS);
                        }
                        this._Verbose([
                            "RemoveListener(), status: ", this._status,
                            " old length: ", this._listeners.length,
                            " func: ", func
                        ].join(""));
                        for (var i = 0; i < this._listeners.length; ++i) {
                            if (this._listeners[i] == func) {
                                if (this._listeners.length == 1) {
                                    this._listeners = [];
                                }
                                else if (i == this._listeners.length - 1) {
                                    this._listeners.pop();
                                }
                                else {
                                    this._listeners[i] = this._listeners.pop();
                                }
                                this._Verbose([
                                    "this listener has been found, index: ", i,
                                    "new length: ", this._listeners.length
                                ].join(""));
                                return;
                            }
                        }
                        this._Verbose("listener isn't been found, new length" + this._listeners.length);
                    };
                    TelemetryManagerImpl.prototype.Start = function () {
                        // If it hasn't been initialized, throw exception.
                        if (this._status < TelemetryManagerStatus.Initialized) {
                            throw new Exception(DATARV_ERROR.DATARV_ERROR_INVALID_STATUS);
                        }
                        this._Verbose([
                            "Start(), status:", this._status,
                            "tag:", TelemetryManagerImpl._tag
                        ].join(" "));
                        if (this._status >= TelemetryManagerStatus.Started) {
                            this._Verbose("Start() already, ignore");
                        }
                        /*if (this._ecsClient) {
                            this._ecsCallback = this._CreateEcsCallback();
                            this._ecsClient.AddListener(this._ecsCallback);
                            this._etag = this._ecsClient.GetETag();
                        }*/
                        // change the status to started.
                        ++TelemetryManagerImpl._tag;
                        this._status = TelemetryManagerStatus.Started;
                        this._Verbose([
                            "Start() done, status: ", this._status,
                            "tag: ", TelemetryManagerImpl._tag
                        ].join(""));
                    };
                    TelemetryManagerImpl.prototype.Stop = function () {
                        // If it hasn't been initialized, throw exception.
                        if (this._status < TelemetryManagerStatus.Initialized) {
                            throw new Exception(DATARV_ERROR.DATARV_ERROR_INVALID_STATUS);
                        }
                        this._Verbose("Stop(), status: " + this._status);
                        if (this._status == TelemetryManagerStatus.Initialized) {
                            this._Verbose("Stop() already, ignore");
                            return;
                        }
                        //
                        // do stop work
                        //
                        // 1. cleanup states
                        this._Reset();
                        // 2. reset status to initailzied
                        this._status = TelemetryManagerStatus.Initialized;
                        this._Verbose("Stop() done, status: " + this._status);
                    };
                    TelemetryManagerImpl.prototype.Pause = function () {
                        this._isPaused = true;
                        this._CleanTimer();
                    };
                    TelemetryManagerImpl.prototype.Resume = function () {
                        this._isPaused = false;
                        if (!this._eventsCache.IsEmpty() && !this._timer) {
                            this._ScheduleTimer(false /*isRetry*/);
                        }
                    };
                    TelemetryManagerImpl.prototype.Flush = function (func) {
                        if (!this._eventsCache.IsEmpty()) {
                            this._WorkThread(func, true);
                        }
                    };
                    TelemetryManagerImpl.prototype.SendAsync = function (tenantToken, events) {
                        if (this._status < TelemetryManagerStatus.Initialized) {
                            throw new Exception(DATARV_ERROR.DATARV_ERROR_INVALID_STATUS);
                        }
                        this._Verbose([
                            "SendAsync(), status:", this._status,
                            "tenantToken:", tenantToken,
                            "count:", events.length
                        ].join(" "));
                        if (this._status < TelemetryManagerStatus.Started) {
                            this._Info("SendAsync(), not started, ignore, return false");
                            return false;
                        }
                        // check the input parameters
                        if (!tenantToken || !events) {
                            this._Error("SendAsync(), tenantToken or events is null or empty");
                            throw new Exception(DATARV_ERROR.DATARV_ERROR_INVALID_ARG);
                        }
                        // check all events are valid, add missed fields.
                        for (var i = 0; i < events.length; ++i) {
                            if (!events[i].Id ||
                                !TelemetryManagerImpl._eventTypeRegex.test(events[i].EventType) ||
                                events[i].Timestamp.Equals("0")) {
                                this._Error([
                                    "eventId:", events[i].Id,
                                    "eventType:", events[i].EventType,
                                    "timestamp high:", events[i].Timestamp.high,
                                    "timestamp low:", events[i].Timestamp.low
                                ].join(""));
                                throw new Exception(DATARV_ERROR.DATARV_ERROR_INVALID_EVENT);
                            }
                        }
                        // put all events in events queue
                        this._eventsCache.AddEvents(tenantToken, events);
                        this._Verbose([
                            "SendAsync(), currentTimer: ", this._timer,
                            "eventsCacheIsEmpty", this._eventsCache.IsEmpty()
                        ].join(" "));
                        // if the events queue are not empty, and we haven't schedule the send
                        // action, schedule it at once.
                        // Don't invoke _WorkThread() directly, otherwise, it may block UI.
                        if (!this._eventsCache.IsEmpty() && !this._timer) {
                            this._ScheduleTimer(false /*isRetry*/);
                        }
                        this._Verbose("SendAsync() done");
                        return true;
                    };
                    TelemetryManagerImpl.prototype._WorkThread = function (flushCallback, isFlush) {
                        var _this = this;
                        try {
                            this._Verbose("_WorkThread, status: " + this._status);
                            if (this._status < TelemetryManagerStatus.Started) {
                                this._Verbose("_WorkThread, status is not started, return");
                                return;
                            }
                            // dequeue one tenants events
                            var item = this._eventsCache.DequeuEvents();
                            if (item == null) {
                                this._Verbose("_WorkThread, No events found, return");
                                // no more events need process, so clear the timer and return
                                this._CleanTimer();
                                return;
                            }
                            // pack the events and send
                            var result = this._PackEvents(item.tenantToken, item.events);
                            // add unsend events back to the queue
                            this._eventsCache.AddEvents(item.tenantToken, result.remainedEvents);
                            // check if there is anything packed
                            if (result.buffer == null || result.buffer.length == 0) {
                                // schedule for next check if necessary
                                if (!this._eventsCache.IsEmpty()) {
                                    this._Verbose("eventsCache is not empty, schedule for next run");
                                    this._ScheduleTimer(false /*isRetry*/);
                                }
                                else {
                                    this._Verbose("eventsCache is empty, stop schedule");
                                    this._CleanTimer();
                                }
                                return;
                            }
                            if (this._testServerResponseHook) {
                                //Using setTimeout with 100 ms to simulate the network time to and fro from the collector and calling _SendCallback asynchronously
                                var xhr = this._testServerResponseHook();
                                setTimeout(this._SendCallback(tag, item.tenantToken, result.sendEvents, xhr, false, null), 100);
                                return;
                            }
                            var postParams = {
                                type: "POST",
                                url: this._config.collectorUrl,
                                processData: false,
                                headers: {
                                    "content-type": "application/bond-compact-binary",
                                    "client-id": "NO_AUTH",
                                    "sdk-version": "ACT-Web-JS-" + clienttelemetry_build.version
                                },
                                complete: function (xhr) { return _this._SendCallback(tag, item.tenantToken, result.sendEvents, xhr, isFlush, flushCallback); }
                            };
                            if (!sct.Utils.IsUint8ArrSupported()) {
                                this._Verbose("Uint8Array is undefined, send with base64 encode.");
                                postParams["data"] = Microsoft.Bond.Encoding.Base64.GetString(result.buffer);
                                postParams["headers"]["content-encoding"] = "base64";
                            }
                            else {
                                this._Verbose("Uint8Array is defined, send with binary format directly.");
                                postParams["data"] = new Uint8Array(result.buffer);
                            }
                            if (item.tenantToken) {
                                postParams["headers"]["x-apikey"] = item.tenantToken;
                            }
                            // send it via jquery
                            var tag = TelemetryManagerImpl._tag;
                            this._lastActiveTime = new Date().getTime();
                            sct.Utils.ajax(postParams, isFlush);
                            this._Verbose("_Workthread, send via jquery, tag: " + tag);
                        }
                        catch (ex) {
                            this._Error("_WorkThread, exception: " + ex);
                        }
                    };
                    /** Package all events to a package.
        
                return value is json object:
                {
                    buffer: bond serialize buffer (binary data),
                    sendEvents: the events are packaged.
                },
        
                events contains unpackaged events.
            */
                    TelemetryManagerImpl.prototype._PackEvents = function (tenantToken, events) {
                        this._Verbose("_PackageEvents, total Count: " + events.length);
                        // create the client to collector request
                        var collectorRequest = new telemetry.datamodels.ClientToCollectorRequest();
                        // create the data package
                        var pkg = new telemetry.datamodels.DataPackage();
                        pkg.Source = "JS_default_source";
                        pkg.DataPackageId = telemetry.datamodels.utils.GetGuid();
                        pkg.Timestamp = telemetry.datamodels.utils.GetTimeStamp();
                        // first, try to send all events
                        var buffer;
                        var sendEvents = events;
                        events = [];
                        while (true) {
                            pkg.Records = [];
                            pkg.Records.push.apply(pkg.Records, sendEvents);
                            collectorRequest.DataPackages = [];
                            collectorRequest.DataPackages.push(pkg);
                            buffer = this._Serialize(collectorRequest);
                            this._Verbose([
                                "_PackageEvents, sendEvents.length:", sendEvents.length,
                                "buffer.length:", buffer.length,
                                "MaxPackageSize:", this._MaxPackageSizeInBytes
                            ].join(""));
                            if (buffer.length < this._MaxPackageSizeInBytes) {
                                break;
                            }
                            else if (sendEvents.length == 1) {
                                //single record larger than max package size, drop
                                sendEvents = [];
                                buffer = null;
                                break;
                            }
                            // too large, we must reduce it.
                            var tmp = sendEvents.splice(0, Math.floor(sendEvents.length / 2));
                            this._Verbose("_PackageEvents, too large, package again");
                            // add the rest events back to events;
                            events.push.apply(events, sendEvents);
                            sendEvents = tmp;
                        }
                        this._Verbose([
                            "_PakcageEvents done, sendEventsCount:", sendEvents.length,
                            "buffer.length:", buffer == null ? 0 : buffer.length,
                            "remained events:", events.length
                        ].join(""));
                        return { buffer: buffer, sendEvents: sendEvents, remainedEvents: events };
                    };
                    TelemetryManagerImpl.prototype._Serialize = function (collectorRequest) {
                        var stream = new Microsoft.Bond.IO.MemoryStream();
                        var writer = new Microsoft.Bond.CompactBinaryProtocolWriter(stream);
                        collectorRequest.Write(writer);
                        return stream.GetBuffer();
                    };
                    /** This function will handle the callback from ajax    */
                    TelemetryManagerImpl.prototype._SendCallback = function (tag, tenantToken, events, jqXHR, isCalledFromFlush, flushCallback) {
                        this._Verbose([
                            "_SendCallback",
                            "tag:", tag,
                            "current tag:", TelemetryManagerImpl._tag,
                            "tenantToken:", tenantToken,
                            "events count:", events.length,
                            "jqXHR:", jqXHR
                        ].join(""));
                        //Do the flush callback. Since this sending was scheduled synchronously don't schedule timer
                        //again for async sending.
                        if (flushCallback) {
                            flushCallback((jqXHR ? jqXHR.status : 0), tenantToken, events);
                        }
                        if (isCalledFromFlush) {
                            return;
                        }
                        var isSuccess = jqXHR != null && jqXHR.status >= 200 && jqXHR.status < 300;
                        // if the status is not sending, do nothing
                        if (this._status < TelemetryManagerStatus.Started ||
                            tag < TelemetryManagerImpl._tag) {
                            this._Verbose("_SendCallback, is not started, or tag is not the same, return");
                            return;
                        }
                        // if need retry, put the events back to the events queue and
                        // try it later. 400 means the data format is not correct, so
                        // don't retry for this case.
                        //
                        // for IE 8/IE 9, there is no way to get the status code, don't retry also.
                        if (!isSuccess && (!jqXHR || jqXHR.status && jqXHR.status != 400)) {
                            this._Verbose("retry statusCode: " + (jqXHR ? jqXHR.status : 0));
                            this._eventsCache.AddEvents(tenantToken, events);
                            this._ScheduleTimer(true /*isRetry*/);
                            return;
                        }
                        // callback to notify user send success.
                        for (var i = 0; i < this._listeners.length; ++i) {
                            this._listeners[i](isSuccess ? CallbackEventType.SENT : CallbackEventType.SEND_FAILED, (jqXHR ? jqXHR.status : 0), tenantToken, events);
                        }
                        // schedule for next check if necessary
                        if (!this._eventsCache.IsEmpty()) {
                            this._Verbose("eventsCache is not empty, schedule for next run");
                            this._ScheduleTimer(false /*isRetry*/);
                        }
                        else {
                            this._Verbose("eventsCache is empty, stop schedule");
                            this._CleanTimer();
                        }
                    };
                    TelemetryManagerImpl.prototype._CleanTimer = function () {
                        this._Verbose("_CleanTimer(), timer: " + this._timer);
                        if (this._timer) {
                            clearTimeout(this._timer);
                            this._timer = null;
                        }
                    };
                    /** Schedule Retry.
        
                This function will schedule re-try after X seconds. X value is determined
                by the following algorithm:
                1. for the 1st, X is a random value between 5~10 (5*2^0~5*2^1).
                2. for the 2nd, X is a random value between 10~20 (5*2^1~5*2^2).
                3. for the 3rd, X is a random value between 20~40 (5*2^2~5*2^3).
                4. for the 4th, X is a random value between 40~80 (5*2^3~5*2^4).
                5. for the 5th, X is a random value between 80~160 (5*2^4~5*2^5).
                6. for the 6th, X is a random value between 160~320 (5*2^5~5*2^6).
                7. Go back to 1.
            */
                    TelemetryManagerImpl.prototype._ScheduleTimer = function (isRetry) {
                        var _this = this;
                        if (!this._isPaused) {
                            this._Verbose("_ScheduleTimer: isRetry: " + isRetry);
                            // clear previous timer always.
                            this._CleanTimer();
                            if (!isRetry) {
                                // next send will be in at least 1 second later
                                var X = 0;
                                var now = new Date().getTime();
                                var late = now - this._lastActiveTime;
                                if (late > Consts.TimeIntervalForNextSendInMS()) {
                                    // we haven't scheduled in last 1 second, so schedule it at once.
                                    X = 0;
                                }
                                else {
                                    X = Consts.TimeIntervalForNextSendInMS() - late;
                                }
                                this._timer = setTimeout(function () { return _this._WorkThread(null, false); }, X);
                                this._Verbose("_ScheduleTimer, next try: " + X);
                                this._rescheduleFactor = 1;
                            }
                            else {
                                // retry
                                this._Verbose("_ScheduleTimer, current factor: " + this._rescheduleFactor);
                                var X = Math.floor(5 * this._rescheduleFactor * (1 + Math.random()));
                                this._timer = setTimeout(function () { return _this._WorkThread(null, false); }, X * 1000);
                                this._Verbose("_ScheduleTimer, next try (s): " + X);
                                this._rescheduleFactor <<= 1;
                                if (this._rescheduleFactor > 64) {
                                    this._rescheduleFactor = 1;
                                }
                            }
                        }
                    };
                    //
                    // Log functions
                    //
                    TelemetryManagerImpl.prototype._Verbose = function (msg) {
                        if (this._config.log) {
                            this._config.log.Verbose("[TelemetryManagerImpl]: " + msg);
                        }
                    };
                    TelemetryManagerImpl.prototype._Info = function (msg) {
                        if (this._config.log) {
                            this._config.log.Info("[TelemetryManagerImpl]: " + msg);
                        }
                    };
                    TelemetryManagerImpl.prototype._Error = function (msg) {
                        if (this._config.log) {
                            this._config.log.Error("[TelemetryManagerImpl]: " + msg);
                        }
                    };
                    /** Clean all stats without listener queue */
                    TelemetryManagerImpl.prototype._Reset = function () {
                        this._Verbose("Reset()");
                        this._CleanTimer();
                        this._lastActiveTime = 0;
                        this._rescheduleFactor = 1;
                        this._sendingEvents = [];
                        this._eventsCache = new TelemetryEventCache();
                        // 3. Shutdown listener
                        /* if (this._ecsClient) {
                             this._ecsClient.RemoveListener(this._ecsCallback);
                             this._ecsCallback = null;
                             // Keep _ecs uncleared, following C++ version.
                         }*/
                    };
                    /******* TEST_INJECTION_START *******/
                    TelemetryManagerImpl.prototype.__GetListenerArray = function () {
                        return this._listeners;
                    };
                    TelemetryManagerImpl.prototype.__GetTotalEventsCount = function () {
                        return this._eventsCache.GetTotalEventsCount();
                    };
                    TelemetryManagerImpl.prototype.__IsScheduled = function () {
                        return this._timer != null;
                    };
                    TelemetryManagerImpl.prototype.__ChageMaxPackageSizeInKB = function (size) {
                        this._MaxPackageSizeInBytes = size * 1024;
                    };
                    TelemetryManagerImpl.prototype.__SetTestServerResponseHook = function (callback) {
                        this._testServerResponseHook = callback;
                    };
                    /*private _CreateEcsCallback() {
                        return (status: ecs.CallbackEventType) => {
                            if (status == ecs.CallbackEventType.CONFIG_UPDATED) {
                                // Use number as status to avoid dependency.
                                this._etag = this._ecsClient.GetETag();
                            }
                        }
                    }*/
                    TelemetryManagerImpl._eventTypeRegex = /^[a-zA-Z0-9]([a-zA-Z0-9]|_){2,98}[a-zA-Z0-9]$/;
                    TelemetryManagerImpl._tag = 0;
                    return TelemetryManagerImpl;
                }());
                var TelemetryEventCache = (function () {
                    function TelemetryEventCache() {
                        this._events = {};
                        this._tokens = [];
                    }
                    TelemetryEventCache.prototype.AddEvents = function (tenantToken, events) {
                        if (!events.length) {
                            return;
                        }
                        if (!this._events[tenantToken]) {
                            this._events[tenantToken] = [];
                            this._tokens.push(tenantToken);
                        }
                        this._events[tenantToken].push.apply(this._events[tenantToken], events);
                    };
                    TelemetryEventCache.prototype.IsEmpty = function () {
                        return this._tokens.length == 0;
                    };
                    TelemetryEventCache.prototype.DequeuEvents = function () {
                        if (this._tokens.length == 0) {
                            return null;
                        }
                        var tenantToken = this._tokens.shift();
                        var events = this._events[tenantToken];
                        delete this._events[tenantToken];
                        return { tenantToken: tenantToken, events: events };
                    };
                    TelemetryEventCache.prototype.GetTotalEventsCount = function () {
                        var sum = 0;
                        for (var key in this._events) {
                            sum += this._events[key].length;
                        }
                        return sum;
                    };
                    return TelemetryEventCache;
                }());
            })(_sender = telemetry._sender || (telemetry._sender = {}));
        })(telemetry = applications.telemetry || (applications.telemetry = {}));
    })(applications = microsoft.applications || (microsoft.applications = {}));
})(microsoft || (microsoft = {}));
var microsoft;
(function (microsoft) {
    var applications;
    (function (applications) {
        var telemetry;
        (function (telemetry) {
            var globalTelemetryManager = telemetry._sender.TelemetryManagerFactory.CreateTelemetryManager();
            /**
             * Configuration for the ARIA logger.
             */
            var LogConfiguration = (function () {
                function LogConfiguration() {
                    /**
                     *  Set the collector url.
                     */
                    this.collectorUrl = null;
                    /**
                     *  Set to enable automatic instrumenting of session events.
                     */
                    this.enableAutoUserSession = false;
                    /**
                    *  Custom override methods to handle operations typically not supported in non-brower enviornment
                    */
                    this.browserOverrides = new LogConfigurationBrowserOverrides;
                }
                return LogConfiguration;
            }());
            telemetry.LogConfiguration = LogConfiguration;
            var LogConfigurationBrowserOverrides = (function () {
                function LogConfigurationBrowserOverrides() {
                    /**
                    *  Set to override the internal behaviour for persisting Aria's internal data
                    *  This method should be utilized when running this SDK in a non-brower enviornment
                    */
                    this.onSaveData = null;
                    /**
                    *  Set to override the internal behaviour for fetching data that Aria stores
                    *  This method should be utilized when running this SDK in a non-brower enviornment
                    */
                    this.onGetData = null;
                }
                return LogConfigurationBrowserOverrides;
            }());
            telemetry.LogConfigurationBrowserOverrides = LogConfigurationBrowserOverrides;
            var Property = (function () {
                function Property() {
                    this.value = null;
                    this.pii = null;
                }
                /**
                 * Checks if the pii value is in the datamodels.PIIKind enum
                 */
                Property._isPii = function (pii) {
                    if (pii === null || pii === undefined || pii === telemetry.datamodels.PIIKind.NotSet || isNaN(pii)) {
                        return false;
                    }
                    // pii must be a number at this point, check if it's in the enum
                    return telemetry.datamodels.PIIKind[pii] !== undefined;
                };
                return Property;
            }());
            /**
             * eventProperties class allows adding custom key value pairs, including PII data to events.
             */
            var EventProperties = (function () {
                function EventProperties() {
                    /**
                     * Specify a name for this event. This is required if you send any custom key, value pairs.
                     */
                    this.name = null;
                    /**
                     * Override the timestamp on the event being sent, which is set to the current time by default.
                     */
                    this.timestamp = null;
                    /**
                     * Property bag that can be used to add custom extensions to the logged event.
                     */
                    this.properties = {};
                    /**
                     * Specify a type for this event. The type provided will be prefixed with the string
                     * "Custom.".
                     */
                    this.eventType = null;
                }
                /**
                 * Add a named property and optionally tag it as PII.
                 */
                EventProperties.prototype.setProperty = function (key, value, pii) {
                    if (!key || !EventProperties._propertyNameRegex.test(key)) {
                        throw new Exception(TelemetryError.INVALID_PROPERTY_NAME);
                    }
                    if (pii) {
                        this.properties[key] = {
                            value: value,
                            pii: pii != telemetry.datamodels.PIIKind.NotSet ? pii : null
                        };
                    }
                    else {
                        this.properties[key] = {
                            value: value,
                            pii: null
                        };
                    }
                };
                //Regex for JS sdk to allow specifying common fields
                EventProperties._propertyNameRegex = /^[a-zA-Z0-9](([a-zA-Z0-9|_|\.]){0,98}[a-zA-Z0-9])?$/;
                return EventProperties;
            }());
            telemetry.EventProperties = EventProperties;
            (function (TelemetryError) {
                TelemetryError[TelemetryError["INVALID_TENANT_TOKEN"] = 1] = "INVALID_TENANT_TOKEN";
                TelemetryError[TelemetryError["MISSING_EVENT_PROPERTIES_NAME"] = 2] = "MISSING_EVENT_PROPERTIES_NAME";
                TelemetryError[TelemetryError["INVALID_PROPERTY_NAME"] = 3] = "INVALID_PROPERTY_NAME";
                TelemetryError[TelemetryError["MISSING_FAILURE_SIGNATURE"] = 5] = "MISSING_FAILURE_SIGNATURE";
                TelemetryError[TelemetryError["MISSING_FAILURE_DETAIL"] = 6] = "MISSING_FAILURE_DETAIL";
                TelemetryError[TelemetryError["MISSING_PAGEVIEW_ID"] = 7] = "MISSING_PAGEVIEW_ID";
                TelemetryError[TelemetryError["MISSING_PAGEVIEW_NAME"] = 8] = "MISSING_PAGEVIEW_NAME";
                TelemetryError[TelemetryError["INVALID_SESSION_STATE"] = 9] = "INVALID_SESSION_STATE";
                TelemetryError[TelemetryError["INVALID_CONFIGURATION_USE_CUSTOM_GET_SET"] = 10] = "INVALID_CONFIGURATION_USE_CUSTOM_GET_SET";
            })(telemetry.TelemetryError || (telemetry.TelemetryError = {}));
            var TelemetryError = telemetry.TelemetryError;
            /**
             * Helper class to throw exceptions.
             */
            var Exception = (function () {
                function Exception(errorCode) {
                    this.errorCode = null;
                    this.errorCode = errorCode;
                }
                Exception.prototype.ErrorCode = function () {
                    return this.errorCode;
                };
                Exception.prototype.toString = function () {
                    switch (this.errorCode) {
                        case TelemetryError.INVALID_TENANT_TOKEN:
                            return "Invalid tenant token";
                        case TelemetryError.MISSING_EVENT_PROPERTIES_NAME:
                            return "Eventproperties.name can not be null or empty";
                        case TelemetryError.INVALID_PROPERTY_NAME:
                            return "Invalid Key. Key does not conform to regular expression ^[a-zA-Z0-9](([a-zA-Z0-9|_|\.]){0,98}[a-zA-Z0-9])?$";
                        case TelemetryError.MISSING_FAILURE_SIGNATURE:
                            return "Failure signature can't be null or empty.";
                        case TelemetryError.MISSING_FAILURE_DETAIL:
                            return "Failure detail can't be null or empty.";
                        case TelemetryError.MISSING_PAGEVIEW_ID:
                            return "Pageview id can't be null or empty.";
                        case TelemetryError.MISSING_PAGEVIEW_NAME:
                            return "Pageview name can't be null or empty.";
                        case TelemetryError.INVALID_SESSION_STATE:
                            return "Session state has to be a value from the SessionState enum.";
                        case TelemetryError.INVALID_CONFIGURATION_USE_CUSTOM_GET_SET:
                            return "Invalid configuration provided during initialization. Both onGetConfigData and onSaveConfigData must be provided together.  These are manditory when running in a non-brower enviornment";
                        default:
                            return "Unknown error";
                    }
                };
                return Exception;
            }());
            telemetry.Exception = Exception;
            var SemanticContext = (function () {
                function SemanticContext(allowDeviceInfoFields) {
                    this.contextMap = {};
                    this.piiKind = telemetry.datamodels.PIIKind.NotSet;
                    this._allowDeviceInfoFields = false;
                    this._allowDeviceInfoFields = allowDeviceInfoFields;
                }
                SemanticContext.prototype.setAppId = function (appId) {
                    if (appId) {
                        this.contextMap["AppInfo.Id"] = appId;
                    }
                };
                SemanticContext.prototype.setAppVersion = function (appVersion) {
                    if (appVersion) {
                        this.contextMap["AppInfo.Version"] = appVersion;
                    }
                };
                SemanticContext.prototype.setAppLanguage = function (appLanguage) {
                    if (appLanguage) {
                        this.contextMap["AppInfo.Language"] = appLanguage;
                    }
                };
                SemanticContext.prototype.setDeviceId = function (deviceId) {
                    if (deviceId && this._allowDeviceInfoFields) {
                        this.contextMap["DeviceInfo.Id"] = deviceId;
                        SystemInformation.checkAndUpdateDeviceId(deviceId);
                    }
                };
                SemanticContext.prototype.setDeviceOsName = function (deviceOsName) {
                    if (deviceOsName && this._allowDeviceInfoFields) {
                        this.contextMap["DeviceInfo.OsName"] = deviceOsName;
                    }
                };
                SemanticContext.prototype.setDeviceOsVersion = function (deviceOsVersion) {
                    if (deviceOsVersion && this._allowDeviceInfoFields) {
                        this.contextMap["DeviceInfo.OsVersion"] = deviceOsVersion;
                    }
                };
                SemanticContext.prototype.setDeviceBrowserName = function (deviceBrowserName) {
                    if (deviceBrowserName && this._allowDeviceInfoFields) {
                        this.contextMap["DeviceInfo.BrowserName"] = deviceBrowserName;
                    }
                };
                SemanticContext.prototype.setDeviceBrowserVersion = function (deviceBrowserVersion) {
                    if (deviceBrowserVersion && this._allowDeviceInfoFields) {
                        this.contextMap["DeviceInfo.BrowserVersion"] = deviceBrowserVersion;
                    }
                };
                SemanticContext.prototype.setUserId = function (userId, piiKind, userIdType) {
                    if (userId) {
                        this.contextMap["UserInfo.Id"] = userId;
                    }
                    if (userIdType) {
                        this.contextMap["UserInfo.IdType"] = userIdType;
                    }
                    else {
                        var inferredUserIdType;
                        switch (piiKind) {
                            case microsoft.applications.telemetry.datamodels.PIIKind.SipAddress:
                                inferredUserIdType = microsoft.applications.telemetry.datamodels.UserIdType.SipAddress;
                                break;
                            case microsoft.applications.telemetry.datamodels.PIIKind.PhoneNumber:
                                inferredUserIdType = microsoft.applications.telemetry.datamodels.UserIdType.PhoneNumber;
                                break;
                            case microsoft.applications.telemetry.datamodels.PIIKind.SmtpAddress:
                                inferredUserIdType = microsoft.applications.telemetry.datamodels.UserIdType.EmailAddress;
                                break;
                            default:
                                inferredUserIdType = microsoft.applications.telemetry.datamodels.UserIdType.Unknown;
                                break;
                        }
                        this.contextMap["UserInfo.IdType"] = inferredUserIdType;
                    }
                    if (piiKind) {
                        if (Property._isPii(piiKind)) {
                            this.piiKind = piiKind;
                        }
                    }
                    else {
                        var inferredPiiKind;
                        switch (userIdType) {
                            case microsoft.applications.telemetry.datamodels.UserIdType.Skype:
                                inferredPiiKind = microsoft.applications.telemetry.datamodels.PIIKind.Identity;
                                break;
                            case microsoft.applications.telemetry.datamodels.UserIdType.EmailAddress:
                                inferredPiiKind = microsoft.applications.telemetry.datamodels.PIIKind.SmtpAddress;
                                break;
                            case microsoft.applications.telemetry.datamodels.UserIdType.PhoneNumber:
                                inferredPiiKind = microsoft.applications.telemetry.datamodels.PIIKind.PhoneNumber;
                                break;
                            case microsoft.applications.telemetry.datamodels.UserIdType.SipAddress:
                                inferredPiiKind = microsoft.applications.telemetry.datamodels.PIIKind.SipAddress;
                                break;
                            default:
                                inferredPiiKind = microsoft.applications.telemetry.datamodels.PIIKind.NotSet;
                                break;
                        }
                        if (Property._isPii(inferredPiiKind)) {
                            this.piiKind = inferredPiiKind;
                        }
                    }
                };
                SemanticContext.prototype.setUserMsaId = function (userMsaId) {
                    if (userMsaId) {
                        this.contextMap["UserInfo.MsaId"] = userMsaId;
                    }
                };
                SemanticContext.prototype.setUserANID = function (userANID) {
                    if (userANID) {
                        this.contextMap["UserInfo.ANID"] = userANID;
                    }
                };
                SemanticContext.prototype.setUserAdvertisingId = function (userAdvertisingId) {
                    if (userAdvertisingId) {
                        this.contextMap["UserInfo.AdvertisingId"] = userAdvertisingId;
                    }
                };
                SemanticContext.prototype.setUserTimeZone = function (userTimeZone) {
                    if (userTimeZone) {
                        this.contextMap["UserInfo.TimeZone"] = userTimeZone;
                    }
                };
                SemanticContext.prototype.setUserLanguage = function (userLanguage) {
                    if (userLanguage) {
                        this.contextMap["UserInfo.Language"] = userLanguage;
                    }
                };
                return SemanticContext;
            }());
            telemetry.SemanticContext = SemanticContext;
            var SystemInformation = (function () {
                function SystemInformation() {
                }
                SystemInformation.initialize = function (overrides) {
                    this._overrides = overrides;
                    var appLanguage = SystemInformation._getAppLanguage();
                    if (appLanguage) {
                        SystemInformation.semanticContext.setAppLanguage(appLanguage);
                    }
                    var userLanguage = SystemInformation._getUserLanguage();
                    if (userLanguage) {
                        SystemInformation.semanticContext.setUserLanguage(userLanguage);
                    }
                    var timeZone = new Date().getTimezoneOffset();
                    var minutes = timeZone % 60;
                    var hours = (timeZone - minutes) / 60;
                    var timeZonePrefix = "+";
                    if (hours > 0) {
                        timeZonePrefix = "-";
                    }
                    hours = Math.abs(hours);
                    minutes = Math.abs(minutes);
                    SystemInformation.semanticContext.setUserTimeZone(timeZonePrefix + (hours < 10 ? '0' + hours : hours.toString()) + ":"
                        + (minutes < 10 ? '0' + minutes : minutes.toString()));
                    var userAgent = SystemInformation._getUserAgent();
                    // Ensure we have a userAgent before filling in these fields automatically. Needed for compat in non-browser enviornments
                    if (userAgent) {
                        SystemInformation.semanticContext.setDeviceBrowserName(SystemInformation._getBrowserName());
                        SystemInformation.semanticContext.setDeviceBrowserVersion(SystemInformation._getBrowserVersion());
                        SystemInformation.semanticContext.setDeviceOsName(SystemInformation._getOsName());
                        SystemInformation.semanticContext.setDeviceOsVersion(SystemInformation._getOsVersion());
                    }
                    var deviceId = SystemInformation._getData(SystemInformation.DEVICE_ID_COOKIE);
                    if (!deviceId || deviceId == "") {
                        deviceId = telemetry.datamodels.utils.GetGuid();
                    }
                    SystemInformation.semanticContext.setDeviceId(deviceId);
                };
                SystemInformation.checkAndUpdateDeviceId = function (deviceId) {
                    var oldDeviceId = SystemInformation._getData(SystemInformation.DEVICE_ID_COOKIE);
                    if (oldDeviceId != deviceId) {
                        SystemInformation._saveData(SystemInformation.DEVICE_ID_COOKIE, deviceId);
                        SystemInformation._saveData(SystemInformation.FIRST_LAUNCH_TIME_COOKIE, (new Date()).getTime().toString());
                    }
                    var firstLaunchTime = SystemInformation._getData(SystemInformation.FIRST_LAUNCH_TIME_COOKIE);
                    SystemInformation.firstLaunchTime = parseInt(firstLaunchTime);
                };
                SystemInformation._saveData = function (cname, cvalue) {
                    if (this._overrides.onSaveData) {
                        this._overrides.onSaveData(cname, cvalue);
                    }
                    else if (typeof document !== "undefined" && document.cookie) {
                        var expires = "expires=Mon, 31 Dec 2029 23:59:59 GMT";
                        document.cookie = cname + "=" + cvalue + "; " + expires;
                    }
                };
                SystemInformation._getData = function (cname) {
                    if (this._overrides.onGetData) {
                        return this._overrides.onGetData(cname) || "";
                    }
                    else if (typeof document !== "undefined" && document.cookie) {
                        var name = cname + "=";
                        var ca = document.cookie.split(';');
                        for (var i = 0; i < ca.length; i++) {
                            var c = ca[i];
                            var j = 0;
                            while (c.charAt(j) == ' ') {
                                j++;
                            }
                            c = c.substring(j);
                            if (c.indexOf(name) == 0)
                                return c.substring(name.length, c.length);
                        }
                    }
                    return "";
                };
                SystemInformation._getUserAgent = function () {
                    if (typeof navigator !== "undefined") {
                        return navigator.userAgent || "";
                    }
                    // Don't return null here, this is expected to always be a string
                    return "";
                };
                SystemInformation._getAppLanguage = function () {
                    if (typeof document !== "undefined" && document.documentElement) {
                        return document.documentElement.lang;
                    }
                    return null;
                };
                SystemInformation._getUserLanguage = function () {
                    if (typeof navigator !== "undefined") {
                        return navigator.userLanguage || navigator.language;
                    }
                    return null;
                };
                SystemInformation._userAgentContainsString = function (searchString) {
                    return SystemInformation._getUserAgent().indexOf(searchString) > -1;
                };
                SystemInformation._isIe = function () {
                    return SystemInformation._userAgentContainsString('Trident');
                };
                SystemInformation._isEdge = function () {
                    return SystemInformation._userAgentContainsString(SystemInformation.BROWSERS.EDGE);
                };
                SystemInformation._isOpera = function () {
                    return SystemInformation._userAgentContainsString('OPR/');
                };
                SystemInformation._getBrowserName = function () {
                    if (SystemInformation._isOpera()) {
                        return SystemInformation.BROWSERS.UNKNOWN;
                    }
                    if (SystemInformation._userAgentContainsString(SystemInformation.BROWSERS.PHANTOMJS)) {
                        return SystemInformation.BROWSERS.PHANTOMJS;
                    }
                    if (SystemInformation._isEdge()) {
                        return SystemInformation.BROWSERS.EDGE;
                    }
                    if (SystemInformation._userAgentContainsString(SystemInformation.BROWSERS.ELECTRON)) {
                        return SystemInformation.BROWSERS.ELECTRON;
                    }
                    if (SystemInformation._userAgentContainsString(SystemInformation.BROWSERS.CHROME)) {
                        return SystemInformation.BROWSERS.CHROME;
                    }
                    if (SystemInformation._userAgentContainsString(SystemInformation.BROWSERS.FIREFOX)) {
                        return SystemInformation.BROWSERS.FIREFOX;
                    }
                    if (SystemInformation._userAgentContainsString(SystemInformation.BROWSERS.SAFARI)) {
                        return SystemInformation.BROWSERS.SAFARI;
                    }
                    if (SystemInformation._userAgentContainsString(SystemInformation.BROWSERS.SKYPE_SHELL)) {
                        return SystemInformation.BROWSERS.SKYPE_SHELL;
                    }
                    if (SystemInformation._isIe()) {
                        return SystemInformation.BROWSERS.MSIE;
                    }
                    return SystemInformation.BROWSERS.UNKNOWN;
                };
                SystemInformation._getBrowserVersion = function () {
                    if (SystemInformation._isIe()) {
                        return getIeVersion();
                    }
                    else {
                        return getOtherVersion(SystemInformation._getBrowserName());
                    }
                    function getIeVersion() {
                        var ieVersionMatches, userAgent = SystemInformation._getUserAgent(), classicIeVersionMatches = userAgent.match(new RegExp(SystemInformation.BROWSERS.MSIE + ' ' + SystemInformation.REGEX_VERSION));
                        if (classicIeVersionMatches) {
                            return classicIeVersionMatches[1];
                        }
                        else {
                            ieVersionMatches = userAgent.match(new RegExp('rv:' + SystemInformation.REGEX_VERSION));
                            if (ieVersionMatches) {
                                return ieVersionMatches[1];
                            }
                        }
                    }
                    function getOtherVersion(browserString) {
                        var matches;
                        if (browserString === SystemInformation.BROWSERS.SAFARI) {
                            browserString = 'Version';
                        }
                        matches = SystemInformation._getUserAgent().match(new RegExp(browserString + '/' + SystemInformation.REGEX_VERSION));
                        if (matches) {
                            return matches[1];
                        }
                        return SystemInformation.UNKNOWN_VERSION;
                    }
                };
                SystemInformation._getOsName = function () {
                    var win = /(windows|win32)/i, winrt = / arm;/i, winphone = /windows\sphone\s\d+\.\d+/i, osx = /(macintosh|mac os x)/i, ios = /(iPad|iPhone|iPod)(?=.*like Mac OS X)/i, linux = /(linux|joli|[kxln]?ubuntu|debian|[open]*suse|gentoo|arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk)/i, android = /android/i;
                    if (SystemInformation._getUserAgent().match(winphone)) {
                        return SystemInformation.OPERATING_SYSTEMS.WINDOWS_PHONE;
                    }
                    if (SystemInformation._getUserAgent().match(winrt)) {
                        return SystemInformation.OPERATING_SYSTEMS.WINDOWS_RT;
                    }
                    if (SystemInformation._getUserAgent().match(ios)) {
                        return SystemInformation.OPERATING_SYSTEMS.IOS;
                    }
                    if (SystemInformation._getUserAgent().match(android)) {
                        return SystemInformation.OPERATING_SYSTEMS.ANDROID;
                    }
                    if (SystemInformation._getUserAgent().match(linux)) {
                        return SystemInformation.OPERATING_SYSTEMS.LINUX;
                    }
                    if (SystemInformation._getUserAgent().match(osx)) {
                        return SystemInformation.OPERATING_SYSTEMS.MACOSX;
                    }
                    if (SystemInformation._getUserAgent().match(win)) {
                        return SystemInformation.OPERATING_SYSTEMS.WINDOWS;
                    }
                    return SystemInformation.OPERATING_SYSTEMS.UNKNOWN;
                };
                SystemInformation._getOsVersion = function () {
                    if (SystemInformation._getOsName() === SystemInformation.OPERATING_SYSTEMS.WINDOWS) {
                        return getWindowsVersion();
                    }
                    if (SystemInformation._getOsName() === SystemInformation.OPERATING_SYSTEMS.MACOSX) {
                        return getMacOsxVersion();
                    }
                    return SystemInformation.UNKNOWN_VERSION;
                    function getWindowsVersion() {
                        var ntVersionMatches = SystemInformation._getUserAgent().match(new RegExp('Windows NT ' + SystemInformation.REGEX_VERSION));
                        if (ntVersionMatches && SystemInformation.VERSION_MAPPINGS[ntVersionMatches[1]]) {
                            return SystemInformation.VERSION_MAPPINGS[ntVersionMatches[1]];
                        }
                        return SystemInformation.UNKNOWN_VERSION;
                    }
                    function getMacOsxVersion() {
                        var macOsxVersionInUserAgentMatches = SystemInformation._getUserAgent().match(new RegExp(SystemInformation.OPERATING_SYSTEMS.MACOSX + ' ' + SystemInformation.REGEX_VERSION_MAC));
                        if (macOsxVersionInUserAgentMatches) {
                            var versionString = macOsxVersionInUserAgentMatches[1].replace(/_/g, '.');
                            var components = [];
                            if (versionString) {
                                var delimiter = getDelimiter(versionString);
                                if (delimiter) {
                                    components = versionString.split(delimiter);
                                    return components[0];
                                }
                                else {
                                    return versionString;
                                }
                            }
                        }
                        return SystemInformation.UNKNOWN_VERSION;
                    }
                    function getDelimiter(versionString) {
                        if (versionString.indexOf('.') > -1) {
                            return '.';
                        }
                        if (versionString.indexOf('_') > -1) {
                            return '_';
                        }
                        return null;
                    }
                };
                SystemInformation.semanticContext = new SemanticContext(true);
                SystemInformation.firstLaunchTime = -1;
                SystemInformation.BROWSERS = {
                    MSIE: 'MSIE',
                    CHROME: 'Chrome',
                    FIREFOX: 'Firefox',
                    SAFARI: 'Safari',
                    EDGE: 'Edge',
                    ELECTRON: 'Electron',
                    SKYPE_SHELL: 'SkypeShell',
                    PHANTOMJS: 'PhantomJS',
                    UNKNOWN: 'Unknown'
                };
                SystemInformation.OPERATING_SYSTEMS = {
                    WINDOWS: 'Windows',
                    MACOSX: 'Mac OS X',
                    WINDOWS_PHONE: 'Windows Phone',
                    WINDOWS_RT: 'Windows RT',
                    IOS: 'iOS',
                    ANDROID: 'Android',
                    LINUX: 'Linux',
                    UNKNOWN: 'Unknown'
                };
                SystemInformation.VERSION_MAPPINGS = {
                    '5.1': 'XP',
                    '6.0': 'Vista',
                    '6.1': '7',
                    '6.2': '8',
                    '6.3': '8.1',
                    '10.0': '10'
                };
                SystemInformation.REGEX_VERSION = '([\\d,.]+)';
                SystemInformation.REGEX_VERSION_MAC = '([\\d,_,.]+)';
                SystemInformation.UNKNOWN_VERSION = "Unknown";
                SystemInformation.DEVICE_ID_COOKIE = "MicrosoftApplicationsTelemetryDeviceId";
                SystemInformation.FIRST_LAUNCH_TIME_COOKIE = "MicrosoftApplicationsTelemetryFirstLaunchTime";
                return SystemInformation;
            }());
            (function (SessionState) {
                SessionState[SessionState["STARTED"] = 0] = "STARTED";
                SessionState[SessionState["ENDED"] = 1] = "ENDED";
            })(telemetry.SessionState || (telemetry.SessionState = {}));
            var SessionState = telemetry.SessionState;
            /**
             * LogManager class allows initialization of the telemetry library.
             */
            var LogManager = (function () {
                function LogManager() {
                }
                LogManager.initialize = function (tenantToken, configuration) {
                    if (!LogManager._initialized) {
                        if (!tenantToken) {
                            throw new Exception(TelemetryError.INVALID_TENANT_TOKEN);
                        }
                        LogManager._defaultToken = tenantToken;
                        LogManager._tmConfig.collectorUrl = "https://browser.pipe.aria.microsoft.com/Collector/3.0/";
                        LogManager._configuration = configuration;
                        // If window isn't defined, onGetData and onSetData must be provided
                        if (typeof window === "undefined" && (!configuration || !configuration.browserOverrides || !configuration.browserOverrides.onGetData)) {
                            throw new Exception(TelemetryError.INVALID_CONFIGURATION_USE_CUSTOM_GET_SET);
                        }
                        // Initialize a new LogConfigurationBrowserOverrides so we populate all expected variables
                        var browserOverrides = new LogConfigurationBrowserOverrides();
                        if (configuration) {
                            if (configuration.collectorUrl) {
                                LogManager._tmConfig.collectorUrl = configuration.collectorUrl;
                            }
                            if (configuration.browserOverrides) {
                                // If onGet override is provided, onSave must be as well
                                if (!!configuration.browserOverrides.onGetData ? !configuration.browserOverrides.onSaveData : !!configuration.browserOverrides.onSaveData) {
                                    throw new Exception(TelemetryError.INVALID_CONFIGURATION_USE_CUSTOM_GET_SET);
                                }
                                browserOverrides.onGetData = configuration.browserOverrides.onGetData;
                                browserOverrides.onSaveData = configuration.browserOverrides.onSaveData;
                            }
                        }
                        globalTelemetryManager.Initialize(LogManager._tmConfig);
                        globalTelemetryManager.Start();
                        SystemInformation.initialize(browserOverrides);
                        LogManager._initialized = true;
                        if (typeof window !== "undefined" && window.addEventListener) {
                            if (configuration && configuration.enableAutoUserSession) {
                                LogManager._logger = new Logger();
                                LogManager._logger.logSession(SessionState.STARTED);
                            }
                            window.addEventListener("beforeunload", LogManager._teardown);
                        }
                    }
                };
                /**
                 * Pause the transmission of events.
                 */
                LogManager.pauseTransmission = function () {
                    globalTelemetryManager.Pause();
                };
                /**
                 * Resume the tranmission of events.
                 */
                LogManager.resumeTransmission = function () {
                    globalTelemetryManager.Resume();
                };
                LogManager.flush = function (func) {
                    globalTelemetryManager.Flush(func);
                };
                /**
                * When events have been sent or sent failed, you can get the notification
                * if you registered the listener. If the listener has been added already,
                * the function will do nothing.
                *
                * @param func (callbackType: microsoft.applications.telemetry._sender.CallbackEventType, responseCode: number, tenantToken: string,
                *  events: microsoft.applications.telemetry.datamodels.Record[]) => any
                */
                LogManager.addCallbackListener = function (func) {
                    if (LogManager._initialized) {
                        globalTelemetryManager.AddListener(func);
                    }
                };
                LogManager.setContext = function (key, value, pii) {
                    LogManager._contextProperties.setProperty(key, value, pii);
                };
                LogManager.isInitialized = function () {
                    return LogManager._initialized;
                };
                LogManager.getDefaultToken = function () {
                    return LogManager._defaultToken;
                };
                LogManager.getSemanticContext = function () {
                    return LogManager._semanticContext;
                };
                LogManager._getInitIdForToken = function (tenantToken) {
                    if (!LogManager._initIdMap[tenantToken]) {
                        LogManager._initIdMap[tenantToken] = telemetry.datamodels.utils.GetGuid();
                    }
                    return LogManager._initIdMap[tenantToken];
                };
                LogManager._getSequenceForToken = function (tenantToken) {
                    if (!LogManager._sequenceMap[tenantToken]) {
                        LogManager._sequenceMap[tenantToken] = 0;
                    }
                    LogManager._sequenceMap[tenantToken]++;
                    return LogManager._sequenceMap[tenantToken];
                };
                LogManager._teardown = function () {
                    //logger only exists if automatic user session is enabled
                    if (LogManager._logger) {
                        LogManager._logger.logSession(SessionState.ENDED);
                    }
                    LogManager.flush();
                };
                /******* TEST_INJECTION_START *******/
                LogManager.__backToUninitialized = function () {
                    LogManager._tmConfig = new telemetry._sender.TelemetryConfig();
                    LogManager._semanticContext = new SemanticContext(true);
                    LogManager._contextProperties = new EventProperties();
                    LogManager._configuration = null;
                    globalTelemetryManager = telemetry._sender.TelemetryManagerFactory.CreateTelemetryManager();
                    LogManager._initialized = false;
                    LogManager._initIdMap = {};
                    LogManager._sequenceMap = {};
                };
                LogManager._initialized = false;
                LogManager._defaultToken = null;
                LogManager._tmConfig = new telemetry._sender.TelemetryConfig();
                LogManager._logger = null;
                LogManager._initIdMap = {};
                LogManager._sequenceMap = {};
                LogManager._configuration = null;
                LogManager._contextProperties = new EventProperties();
                LogManager._semanticContext = new SemanticContext(true);
                return LogManager;
            }());
            telemetry.LogManager = LogManager;
            /**
             * Contains methods to log custom events.
             */
            var Logger = (function () {
                function Logger(tenantToken) {
                    this._initId = null;
                    this._tenantToken = null;
                    this._contextProperties = new EventProperties();
                    this._semanticContext = new SemanticContext(false);
                    this._sessionStartTime = 0;
                    this._sessionId = null;
                    if (!tenantToken) {
                        this._tenantToken = LogManager.getDefaultToken();
                    }
                    else {
                        this._tenantToken = tenantToken;
                    }
                    this._initId = LogManager._getInitIdForToken(this._tenantToken);
                }
                /**
                * Log a custom event, including custom key-value properties.
                * * @param {microsoft.applications.telemetry.EventProperties} eventProperties - properties of the custom event.
                */
                Logger.prototype.logEvent = function (eventProperties) {
                    if (!eventProperties.name) {
                        throw new Exception(TelemetryError.MISSING_EVENT_PROPERTIES_NAME);
                    }
                    var event = this._createEventRecord(eventProperties.name, eventProperties.eventType);
                    this._addPropertiesAndSendEvent(event, eventProperties);
                };
                /**
                 * Logs a failure event such as an application exception.
                 * @param {String} signature (req) - a detailed string that identifies the bucket of the failure.
                 * @param {String} detail (req) - details of the failure.
                 * @param {String} category - category of the failure such as application error, hang, or crash.
                 * @param {String} id - identifier that could be used to uniquely identify or reference this failure.
                 * @param {microsoft.applications.telemetry.EventProperties} properties - properties of the failure event, can be null.
                 */
                Logger.prototype.logFailure = function (signature, detail, category, id, properties) {
                    if (!signature) {
                        throw new Exception(TelemetryError.MISSING_FAILURE_SIGNATURE);
                    }
                    if (!detail) {
                        throw new Exception(TelemetryError.MISSING_FAILURE_DETAIL);
                    }
                    var event = this._createEventRecord("failure", "failure");
                    event.Extension.Add("Failure.Signature", signature);
                    event.Extension.Add("Failure.Detail", detail);
                    if (category) {
                        event.Extension.Add("Failure.Category", category);
                    }
                    if (id) {
                        event.Extension.Add("Failure.Id", id);
                    }
                    this._addPropertiesAndSendEvent(event, properties);
                };
                /**
                 * Logs a page view event which is normally a result of a user action on a UI page such as search query, content request or page navigation.
                 * @param {String} id (req) - an identifier that could be used to uniquely identify or reference this page.
                 * @param {String} pageName (req) - the name of the page.
                 * @param {String} category - the category for which this page belongs to.
                 * @param {String} uri - uri of this page.
                 * @param {String} referrerUri - uri that refers to this page.
                 * @param {microsoft.applications.telemetry.EventProperties} properties - properties of the page view event, can be null.
                 */
                Logger.prototype.logPageView = function (id, pageName, category, uri, referrerUri, properties) {
                    if (!id) {
                        throw new Exception(TelemetryError.MISSING_PAGEVIEW_ID);
                    }
                    if (!pageName) {
                        throw new Exception(TelemetryError.MISSING_PAGEVIEW_NAME);
                    }
                    var event = this._createEventRecord("pageview", "pageview");
                    event.Extension.Add("PageView.Id", id);
                    event.Extension.Add("PageView.Name", pageName);
                    if (category) {
                        event.Extension.Add("PageView.Category", category);
                    }
                    if (uri) {
                        event.Extension.Add("PageView.Uri", uri);
                    }
                    if (referrerUri) {
                        event.Extension.Add("PageView.ReferrerUri", referrerUri);
                    }
                    this._addPropertiesAndSendEvent(event, properties);
                };
                /**
                 * Logs the session state.
                 * Note: Logging session start while a session already exists will be no-op. Similarly, logging
                 * session end while a session does not exist will be no-op too.
                 * @param {microsoft.applications.telemetry.SessionState} state (req) - the session's state.
                 * @param {microsoft.applications.telemetry.EventProperties} properties - properties of the session event, can be null.
                 */
                Logger.prototype.logSession = function (state, properties) {
                    if (state !== SessionState.STARTED && state !== SessionState.ENDED) {
                        throw new Exception(TelemetryError.INVALID_SESSION_STATE);
                    }
                    var event = this._createEventRecord("session", "session");
                    if (state === SessionState.STARTED) {
                        if (this._sessionStartTime > 0) {
                            //Session already exists
                            return;
                        }
                        this._sessionStartTime = (new Date()).getTime();
                        this._sessionId = telemetry.datamodels.utils.GetGuid();
                        event.Extension.Add("Session.Id", this._sessionId);
                        event.Extension.Add("Session.State", "Started");
                    }
                    else if (state === SessionState.ENDED) {
                        if (this._sessionStartTime == 0) {
                            //Session does not exist
                            return;
                        }
                        var sessionDuration = Math.floor(((new Date()).getTime() - this._sessionStartTime) / 1000);
                        event.Extension.Add("Session.Duration", sessionDuration.toString());
                        event.Extension.Add("Session.DurationBucket", this._getSessionDurationFromTime(sessionDuration));
                        event.Extension.Add("Session.Id", this._sessionId);
                        event.Extension.Add("Session.State", "Ended");
                        this._sessionId = null;
                        this._sessionStartTime = 0;
                    }
                    event.Extension.Add("Session.FirstLaunchTime", this._getISOString(new Date(SystemInformation.firstLaunchTime)));
                    this._addPropertiesAndSendEvent(event, properties);
                };
                Logger.prototype.getSessionId = function () {
                    return this._sessionId;
                };
                Logger.prototype.setContext = function (key, value, pii) {
                    this._contextProperties.setProperty(key, value, pii);
                };
                Logger.prototype.getSemanticContext = function () {
                    return this._semanticContext;
                };
                Logger.prototype._getSessionDurationFromTime = function (timeInSec) {
                    if (timeInSec < 0) {
                        return "Undefined";
                    }
                    else if (timeInSec <= 3) {
                        return "UpTo3Sec";
                    }
                    else if (timeInSec <= 10) {
                        return "UpTo10Sec";
                    }
                    else if (timeInSec <= 30) {
                        return "UpTo30Sec";
                    }
                    else if (timeInSec <= 60) {
                        return "UpTo60Sec";
                    }
                    else if (timeInSec <= 180) {
                        return "UpTo3Min";
                    }
                    else if (timeInSec <= 600) {
                        return "UpTo10Min";
                    }
                    else if (timeInSec <= 1800) {
                        return "UpTo30Min";
                    }
                    return "Above30Min";
                };
                Logger.prototype._createEventRecord = function (eventName, recordType) {
                    var event = new telemetry.datamodels.Record();
                    if (!recordType) {
                        recordType = "custom";
                    }
                    event.EventType = eventName.toLowerCase();
                    event.Type = recordType.toLowerCase();
                    event.Extension.Add("EventInfo.Source", "JS_default_source");
                    event.Extension.Add("EventInfo.InitId", this._initId);
                    event.Extension.Add("EventInfo.Sequence", LogManager._getSequenceForToken(this._tenantToken).toString());
                    event.Extension.Add("EventInfo.Name", eventName.toLowerCase());
                    var date = new Date();
                    event.Timestamp = telemetry.datamodels.utils.GetTimeStampWithValue(date.getTime());
                    event.Extension.Add("EventInfo.Time", this._getISOString(date));
                    event.Extension.Add("EventInfo.SdkVersion", "ACT-Web-JS-" + clienttelemetry_build.version);
                    return event;
                };
                Logger.prototype._getISOString = function (date) {
                    function twoDigit(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n.toString();
                    }
                    function threeDigit(n) {
                        // Format integers to have at least three digits.
                        if (n < 10) {
                            return '00' + n;
                        }
                        else if (n < 100) {
                            return '0' + n;
                        }
                        return n.toString();
                    }
                    return date.getUTCFullYear() + '-' +
                        twoDigit(date.getUTCMonth() + 1) + '-' +
                        twoDigit(date.getUTCDate()) + 'T' +
                        twoDigit(date.getUTCHours()) + ':' +
                        twoDigit(date.getUTCMinutes()) + ':' +
                        twoDigit(date.getUTCSeconds()) + '.' +
                        threeDigit(date.getUTCMilliseconds()) + 'Z';
                };
                Logger.prototype._addCustomPropertiesToEvent = function (event, eventProperties) {
                    this._addSemanticContext(event, SystemInformation.semanticContext);
                    this._addSemanticContext(event, LogManager._semanticContext);
                    this._addSemanticContext(event, this._semanticContext);
                    if (this._sessionId) {
                        event.Extension.Add("Session.Id", this._sessionId);
                    }
                    this._addEventPropertiesToEvent(event, LogManager._contextProperties);
                    this._addEventPropertiesToEvent(event, this._contextProperties);
                    this._addEventPropertiesToEvent(event, eventProperties);
                };
                Logger.prototype._addSemanticContext = function (event, semanticContext) {
                    if (semanticContext && semanticContext.contextMap) {
                        var contextMap = semanticContext.contextMap;
                        for (var key in semanticContext.contextMap) {
                            if (key == "UserInfo.Id" && semanticContext.piiKind != telemetry.datamodels.PIIKind.NotSet) {
                                event.AddOrReplacePII(key, contextMap[key], semanticContext.piiKind);
                            }
                            else {
                                event.Extension.AddOrReplace(key, contextMap[key]);
                            }
                        }
                    }
                };
                Logger.prototype._addEventPropertiesToEvent = function (event, eventProperties) {
                    if (eventProperties) {
                        if (eventProperties.timestamp && eventProperties.timestamp >= (new Date("1/1/2000")).getTime()) {
                            event.Timestamp = telemetry.datamodels.utils.GetTimeStampWithValue(eventProperties.timestamp);
                            event.Extension.AddOrReplace("EventInfo.Time", this._getISOString(new Date(eventProperties.timestamp)));
                        }
                        if (eventProperties.name) {
                            event.EventType = eventProperties.name.toLowerCase();
                            event.Extension.AddOrReplace("EventInfo.Name", eventProperties.name.toLowerCase());
                        }
                        var properties = eventProperties.properties;
                        if (properties) {
                            for (var key in properties) {
                                if (key && (properties[key].value || properties[key].value === false || properties[key].value == 0
                                    || properties[key].value == "")) {
                                    if (Property._isPii(properties[key].pii)) {
                                        event.AddOrReplacePII(key, properties[key].value.toString(), properties[key].pii);
                                        event.Extension.Remove(key);
                                    }
                                    else {
                                        event.Extension.AddOrReplace(key, properties[key].value.toString());
                                        event.PIIExtensions.Remove(key);
                                    }
                                }
                            }
                        }
                    }
                };
                Logger.prototype._addPropertiesAndSendEvent = function (event, properties) {
                    this._addCustomPropertiesToEvent(event, properties);
                    if (LogManager.isInitialized()) {
                        this._sanitizeName(event);
                        globalTelemetryManager.SendAsync(this._tenantToken, [event]);
                    }
                };
                Logger.prototype._sanitizeName = function (event) {
                    var name = event.EventType.replace(/\./g, "_");
                    event.EventType = name;
                    event.Extension.AddOrReplace("EventInfo.Name", name);
                };
                return Logger;
            }());
            telemetry.Logger = Logger;
        })(telemetry = applications.telemetry || (applications.telemetry = {}));
    })(applications = microsoft.applications || (microsoft.applications = {}));
})(microsoft || (microsoft = {}));
if (typeof module != 'undefined') {
    module.exports = microsoft.applications.telemetry;
}
var Skype; !function $(Skype) { "use strict"; var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t;
    return { next: verb(0), "throw": verb(1), "return": verb(2) };
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var TTT;
        (function (TTT) {
            function log() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                console.log.apply(console, ['[TTT]'].concat(args));
            }
            TTT.log = log;
            (function (log) {
                function warn() {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    console.warn.apply(console, ['[TTT]'].concat(args));
                }
                log.warn = warn;
            })(log = TTT.log || (TTT.log = {}));
        })(TTT = Web.TTT || (Web.TTT = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="../pm/missing.d.ts" />
"use strict";
var Skype;
(function (Skype) {
    /** A reference to the original window object.
        TTT exports a `window` variable for the SDK. */
    Skype.$window = window;
})(Skype || (Skype = {}));
(function (Skype) {
    var Web;
    (function (Web) {
        var TTT;
        (function (TTT) {
            TTT.sId = Symbol('id');
            TTT.sModel = Symbol('model');
            TTT.sWrapper = Symbol('wrapper');
            function Symbol(name) {
                return name + ':' + Skype.$window.Math.random().toString(16).slice(2);
            }
            function assert(condition) {
                if (!condition) {
                    // bad luck - the trace must be broken or there is a bug in ttt;
                    // either way it'll be very hard to figure out how to fix that;
                    // while ttt makes debugging of the client very easy, debugging
                    // of the ttt itself is nearly impossible; there are a few common
                    // causes of this assertion:
                    //
                    //  1.  A direct call from UI to the model. UI is supposed to call
                    //      the runtime-created wrapper which records a log and invokes
                    //      the model, so if UI manages to invoke model directly, no log
                    //      can be written and thus cannot be replayed. Typically this
                    //      happens when the wrapper leaks a model to the UI layer. For
                    //      instance, some improperly written command can return a model
                    //      inside some sophisticated structure, like an array inside a
                    //      custom object; since the wrapper doesn't expect this, it won't
                    //      be able to wrap that model properly.
                    //
                    //  2.  A sophisticated sequence of synchronous calls that causes ttt
                    //      to write several logs in such a sequence, that when it attempts
                    //      to replay them, the sequence of these calls changes. This problem
                    //      is harder to identify, but if identified, it's usually solved
                    //      by making on the calls asynchronous with setTimeout, which is not
                    //      always possible because not all calls can be made asynchronous.
                    //
                    //  3.  The trace being replayed does not match the source code against
                    //      which it's being replayed. It's ok to modify the sources in such
                    //      a way that the internal state of the object model doesn't change.
                    //      For instance it's ok to add the "debugger" statement, extra logging
                    //      that doesn't throw exceptions and so on. It's not ok to make extra
                    //      calls to global functions, such as Math.random, because these
                    //      extra calls will confuse the ttt tool.
                    //
                    debugger;
                }
            }
            TTT.assert = assert;
            function extend(target, source) {
                for (var i in source)
                    target[i] = source[i];
                return target;
            }
            TTT.extend = extend;
            function stack() {
                var stack = Error().stack; // not all JS engines give it
                return stack && stack.toString().split('\n').join('\n');
            }
            TTT.stack = stack;
            Error.stackTraceLimit = Infinity;
            function clone(x) {
                return x && JSON.parse(JSON.stringify(x));
            }
            TTT.clone = clone;
        })(TTT = Web.TTT || (Web.TTT = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var TTT;
        (function (TTT) {
            function pack(records) {
                var dict = [undefined, null, '', true, false, [], {}].map(function (x) { return JSON.stringify(x); });
                var types = [];
                var args = records.map(function (record) {
                    var name = record[0], list = record.slice(1);
                    types.push(TTT.RecordType[name]);
                    return list.map(function (item) {
                        // positive 31 bit integers and zero are written as is
                        if (typeof item == 'number' && (item | 0) == item && item >= 0)
                            return item;
                        if (item === null)
                            return -1;
                        if (item === undefined)
                            return -2;
                        // everything else goes to the dictionary
                        var text = JSON.stringify(item);
                        for (var i = 0; i < dict.length; i++)
                            if (dict[i] == text)
                                return -(i + 1);
                        dict.push(text);
                        return -dict.length;
                    });
                });
                return [dict, types, args];
            }
            TTT.pack = pack;
            function unpack(data) {
                var dict = data[0], types = data[1], args = data[2];
                var recs = new Array(types.length);
                for (var i = 0; i < types.length; i++) {
                    var name_1 = TTT.RecordType[types[i]];
                    var list = args[i].map(function (id) {
                        if (id >= 0)
                            return id;
                        if (id == -1)
                            return undefined;
                        return JSON.parse(dict[-id - 1]);
                    });
                    recs[i] = [name_1].concat(list);
                }
                return recs;
            }
            TTT.unpack = unpack;
        })(TTT = Web.TTT || (Web.TTT = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var TTT;
        (function (TTT) {
            // switching to numeric record types (e.g. enum) won't
            // make the compressed version of the trace smaller
            var RecordType;
            (function (RecordType) {
                RecordType.Sync = 'sync';
                RecordType.SetProp = 'set-prop';
                RecordType.FireEvent = 'on-message';
                RecordType.FireTimer = 'fire-timer';
                RecordType.SetTimer = 'set-timer';
                RecordType.ClearTimer = 'clear-timer';
                RecordType.GetDate = 'date';
                RecordType.CreateElemenet = 'create-element';
                RecordType.AppendChild = 'append-child';
                RecordType.RemoveChild = 'remove-child';
                RecordType.PostMessage = 'post-message';
                RecordType.AddEventListener = 'add-listener';
                RecordType.Fetch = '.get()';
                RecordType.Set = 'set(...)';
                RecordType.Then = '.then()';
                RecordType.Catch = '.catch()';
                RecordType.Finally = '.finally()';
                RecordType.Cancel = '.cancel(...)';
                RecordType.Subscribe = '.subscribe()';
                RecordType.Dispose = '.dispose()';
                RecordType.Invoke = '.call(...)';
                RecordType.AddItem = '.add(...)';
                RecordType.RemoveItem = '.remove(...)';
                RecordType.LoadFrame = 'on-load';
                RecordType.CreateRoot = 'new Application(...)';
                RecordType.XhrSend = 'xhr-send';
                RecordType.XhrRecv = 'xhr-recv';
                RecordType.XhrStop = 'xhr-stop';
                RecordType.SSGetItem = 'ss-get-item';
                RecordType.SSSetItem = 'ss-set-item';
                RecordType.SSRemoveItem = 'ss-remove-item';
                RecordType.LSGetItem = 'ls-get-item';
                RecordType.LSSetItem = 'ls-set-item';
                RecordType.LSRemoveItem = 'ls-remove-item';
            })(RecordType = TTT.RecordType || (TTT.RecordType = {}));
            var id = 1;
            for (var name_2 in RecordType)
                RecordType[RecordType[id] = RecordType[name_2]] = id++;
        })(TTT = Web.TTT || (Web.TTT = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="base.ts" />
/// <reference path="pack.ts" />
/// <reference path="rectype.ts" />
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var TTT;
        (function (TTT) {
            TTT.version = '1.0.0';
            var TraceData = (function () {
                function TraceData() {
                    this.version = TTT.version;
                    this.sdk_ver = ''; // e.g. https://latest-swx.cdn.skype.com/jLync/master_0.4.440/sdk.js
                    this.debug = false;
                    this.packed = false;
                    this.randseed = 0; // used to simulate Math.random()
                    this.timestamp = 0; // used as offset to Date.now()
                    this.records = [];
                    try {
                        this.debug = !!JSON.parse(Skype.$window.localStorage.getItem('lwsdk.ttt.debug'));
                    }
                    catch (_) {
                        this.debug = false;
                    }
                }
                return TraceData;
            }());
            TTT.TraceData = TraceData;
            /** Encapsulates the ttt trace. */
            var Trace = (function () {
                function Trace(data) {
                    if (data === void 0) { data = new TraceData; }
                    this.data = data;
                    this.index = 0;
                    this.turn = 0; // event turn, incremented on every timeout, xhr response, etc.
                    this.recording = true;
                    TTT.assert(data.version == TTT.version);
                    this.recording = this.size == 0;
                    if (data.packed) {
                        data.records = TTT.unpack(data.records);
                        data.packed = false;
                    }
                }
                Object.defineProperty(Trace.prototype, "size", {
                    get: function () {
                        return this.data.records.length;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Trace.prototype, "debug", {
                    get: function () {
                        return this.data.debug;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Trace.prototype, "current", {
                    get: function () {
                        var x = this.data.records[this.index];
                        return !this.debug ? x : x && x[1];
                    },
                    enumerable: true,
                    configurable: true
                });
                Trace.prototype.write = function (type) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    if (!this.debug) {
                        this.data.records.push([type].concat(args));
                    }
                    else {
                        var tag = this.turn + '/' + this.size;
                        var cs = TTT.stack().split('\n').slice(1)
                            .map(function (s) { return s.replace(/^\s*(at )?/, '')
                            .replace(/\(https?:\/\/.+\/(.+\.js:\d+:\d+)\)/, '($1)'); });
                        this.data.records.push([tag, [type].concat(args), cs]);
                    }
                    this.index++;
                    return this.current;
                };
                Trace.prototype.read = function (type) {
                    var args = this.current;
                    if (type && args[0] != type) {
                        TTT.log(type + " expected at " + this.index);
                        TTT.assert(false);
                    }
                    this.index++;
                    return args.slice(1);
                };
                Trace.prototype.toJSON = function (tzip_url) {
                    var data = TTT.clone(this.data);
                    data.sdk_ver = Web.version;
                    if (!this.debug) {
                        data.records = TTT.pack(data.records);
                        data.packed = true;
                    }
                    if (!tzip_url)
                        return data;
                    TTT.log("Compressing logs asynchronously with " + tzip_url + "...");
                    var window = Skype.$window; // no need to intercept htese calls
                    var started = window.Date.now();
                    var id = window.Math.random().toString(16).slice(2);
                    var document = window.document;
                    var iframe = document.createElement('iframe');
                    iframe.id = 'tzip-' + id;
                    iframe.src = tzip_url;
                    iframe.style.display = 'none';
                    document.body.appendChild(iframe);
                    iframe.onload = function () {
                        var list = data.records.map(function (x) { return JSON.stringify(x); });
                        var size = list.reduce(function (n, s) { return n + s.length; }, 0) / Math.pow(2, 20);
                        TTT.log("Sending " + size.toFixed(2) + " MB logs to the compressor...");
                        var message = {
                            id: id,
                            type: 'compress',
                            data: list
                        };
                        iframe.contentWindow.postMessage(message, '*');
                    };
                    var callbacks = []; // Promise<T> uses setTimeout/postMessage and interferes with ttt
                    window.addEventListener('message', function _listener(event) {
                        var message = event.data;
                        if (message && message.id == id) {
                            window.removeEventListener('message', _listener);
                            document.body.removeChild(iframe);
                            var size = message.data.length / Math.pow(2, 20);
                            var diff = (window.Date.now() - started) / 1000;
                            TTT.log("Received " + size.toFixed(2) + " MB compressed logs in " + diff.toFixed(1) + "s");
                            data.records = message.data;
                            var text = [];
                            text.push('ttt_trace = {\n');
                            for (var key in data) {
                                text.push(key);
                                text.push(': ');
                                if (key == 'records') {
                                    text.push('(function () {');
                                    text.push(message.data);
                                    text.push('})()');
                                }
                                else {
                                    text.push(JSON.stringify(data[key]));
                                }
                                text.push(',\n');
                            }
                            text.pop();
                            text.push('\n}');
                            var json = text.join('');
                            for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {
                                var callback = callbacks_1[_i];
                                callback(json);
                            }
                        }
                    });
                    return {
                        then: function (callback) {
                            callbacks.push(callback);
                        }
                    };
                };
                return Trace;
            }());
            TTT.Trace = Trace;
        })(TTT = Web.TTT || (Web.TTT = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var TTT;
        (function (TTT) {
            function setHiddenProperty(object, name, value) {
                Object.defineProperty(object, name, {
                    value: value,
                    enumerable: false
                });
            }
            function forward(name) {
                return function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    return Web['Utils'][name].apply(this, args);
                };
            }
            // ttt needs to use certain functions from utils,
            // but it cannot import them at the beginning because
            // tt is loaded before utils
            var isProperty = forward('isProperty');
            var isCollection = forward('isCollection');
            var isFunction = forward('isFunction');
            var isArray = forward('isArray');
            var Model = forward('Model');
            var ConstProperty = forward('ConstProperty');
            var isPromise = forward('isPromise');
            var isModel = forward('isModel');
            var map = forward('map');
            var foreach = forward('foreach');
            function Wrapper(trace, window, handlers) {
                var wrappers = [];
                var subscriptions = {};
                var wrapperId = 1;
                function deferIf(condition, fn) {
                    if (condition)
                        window.setTimeout(fn, 0);
                    else
                        fn();
                }
                function wrap(obj, name) {
                    function $(is, fn, prefix) {
                        if (is(obj)) {
                            var id = wrapperId++;
                            if (trace.debug) {
                                id = "" + prefix + id + "=" + name;
                                TTT.log('wrap', id);
                            }
                            var wr = fn(obj, id, name);
                            TTT.assert(wr);
                            setHiddenProperty(wr, TTT.sModel, obj);
                            setHiddenProperty(obj, TTT.sWrapper, wr);
                            setHiddenProperty(wr, TTT.sId, id);
                            wrappers[id] = wr;
                            return wr;
                        }
                    }
                    // trying to wrap a wrapper?
                    TTT.assert(!obj || !obj[TTT.sModel]);
                    // the model may have been already wrapped
                    var wrapper = obj && obj[TTT.sWrapper];
                    // there is a peculiar case when [sWrapper] refers
                    // to a wrong wrapper: if there is a model A, and
                    // model B is the prototype of A (i.e. a Message
                    // can be the prototype of an ActivityItem), then
                    // wrapping B first creates B[sWrapper] = wrB; then
                    // wrap(A) sees that A[sWrapper] is wrB, but wrB
                    // cannot be used as a wrapper for A because A is
                    // a superset of B and wrB is missing some properties
                    // for A; hence A[sWrapper] needs to be overwritten;
                    // however this doesn't overwrite B[sWrapper] due to
                    // the way prototypes work in JS and hence A[sWrapper]
                    // and B[sWrapper] refer to different wrappers while
                    // B remains the prototype of A
                    if (wrapper && wrapper[TTT.sModel] !== obj)
                        wrapper = null;
                    return wrapper ||
                        $(isProperty, wrapProperty, 'p') ||
                        $(isCollection, wrapCollection, 'c') ||
                        $(isFunction, wrapCommand, 'f') ||
                        $(isPromise, wrapPromise, 't') ||
                        $(isModel, wrapModel, 'm');
                }
                function wrid(wrapper) {
                    return wrapper && wrapper[TTT.sId];
                }
                function serialize(wr) {
                    return wrid(wr) || TTT.clone(wr);
                }
                function deserialize(id) {
                    return wrappers[id] || id;
                }
                function unwrap(wrapper) {
                    return wrapper && wrapper[TTT.sModel] || wrapper;
                }
                function wrapModel(model, id, name) {
                    var wrModel = Model();
                    foreach(model, function (m, i) {
                        var w = wrap(m, name + '.' + i);
                        // drop all unrecognized fields
                        if (w)
                            wrModel[i] = w;
                    });
                    // TODO: by mistake, SearchQuery::keywords was done
                    // as a plain dictionary, while it should be a collection,
                    // so SWX adds items directly with keywords.id = "..."
                    if (wrModel.keywords && wrModel.getMore) {
                        var obj_1 = wrModel.keywords;
                        var key_1 = 'id';
                        Object.defineProperty(obj_1, key_1, {
                            get: function () {
                                return unwrap(obj_1)[key_1];
                            },
                            set: function (value) {
                                if (trace.recording)
                                    trace.write(TTT.RecordType.SetProp, wrid(obj_1), key_1, value);
                                unwrap(obj_1)[key_1] = value;
                            }
                        });
                    }
                    // TODO: some objects still add and remove members at runtime;
                    // once this is fixed, the "if" below can be removed
                    if (model.changed) {
                        model.changed(function () {
                            foreach(wrModel, function (val, key) {
                                if (!model[key])
                                    delete wrModel[key];
                            });
                            foreach(model, function (m, i) {
                                if (!wrModel[i]) {
                                    var w = wrap(m, name + '.' + i);
                                    if (w)
                                        wrModel[i] = w;
                                }
                            });
                        });
                    }
                    return wrModel;
                }
                //#region property
                function wrapProperty(p, id, name) {
                    var sub, init = true, cset = false;
                    // TODO: the current implementation assumes that a property
                    // can contain a primitive value only; if it can contain a model,
                    // the wrapper will need to record the model id
                    var wrProperty = p.constructor({
                        get: function () {
                            if (trace.recording)
                                trace.write(TTT.RecordType.Fetch, id);
                            // Property<Model>::get returns a Promise<Model>
                            return p.get().then(function (r) { return wrap(r, name + '.get()') || r; });
                        },
                        set: function (value, reason) {
                            if (trace.recording)
                                trace.write(TTT.RecordType.Set, id, value, reason, cset);
                            return p.set(value, reason).then(function (r) { return wrap(r, name + '.set()') || r; });
                        },
                        subscribed: function () {
                            if (trace.recording)
                                trace.write(TTT.RecordType.Subscribe, id);
                            sub = p.subscribe();
                            subscriptions[id] = sub;
                        },
                        unsubscribed: function () {
                            if (trace.recording)
                                trace.write(TTT.RecordType.Dispose, id);
                            sub.dispose();
                        }
                    });
                    // .location is a property which has attached properties:
                    // .street, .city and so on; another instance of such an
                    // "advanced" property is .note: it has .text and .type; note how
                    // "private" fields that start with _ are skipped: they
                    // could be made non-enumerable in the pm, but that would
                    // have had unpredictable impact on perf and mem consumption
                    foreach(p, function (m, i) {
                        if (isProperty(m) && !wrProperty[i] && !/^_/.test(i))
                            wrProperty[i] = wrap(m, name + '.' + i);
                    });
                    p.changed(function (value, reason) {
                        deferIf(!init && trace.recording, function () {
                            wrProperty._set(value, reason);
                        });
                    });
                    init = false;
                    // the UI shouldn't be able to invoke Promise objects directly
                    var _get = wrProperty.get;
                    wrProperty.get = function () {
                        var p = _get.call(wrProperty);
                        return wrap(p, name + '.get()');
                    };
                    var _set = wrProperty.set;
                    wrProperty.set = function (v, r) {
                        // there are two ways to invoke setter:
                        // p(...) syntax and via p.set(...)
                        // the second form creates a task that
                        // gets its wrapper and it's important
                        // that when replaying the trace, the
                        // setter is invoked the same way, as
                        // otherwise the number of wrappers
                        // created will be different
                        cset = true;
                        var p = _set.call(wrProperty, v, r);
                        cset = false;
                        return wrap(p, name + '.set()');
                    };
                    wrProperty.set.enabled = _set.enabled;
                    return wrProperty;
                }
                //#endregion
                //#region collection
                function wrapCollection(c, id, name) {
                    var sub, init = true;
                    var wrCollection = c.constructor({
                        get: function () {
                            if (trace.recording)
                                trace.write(TTT.RecordType.Fetch, id);
                            // Collection<Model>::get returns a Promise<Model[]>
                            return c.get().then(function (r) { return r.map(function (v) { return wrap(v, name + '.get()') || v; }); });
                        },
                        subscribed: function () {
                            if (trace.recording)
                                trace.write(TTT.RecordType.Subscribe, id);
                            sub = c.subscribe();
                            subscriptions[id] = sub;
                        },
                        unsubscribed: function () {
                            if (trace.recording)
                                trace.write(TTT.RecordType.Dispose, id);
                            sub.dispose();
                        }
                    });
                    c.added(function (val, key, idx) {
                        var wrItem = wrap(val, name + '[' + idx + ']') || val;
                        deferIf(!init && trace.recording, function () {
                            wrCollection.add(wrItem, key, idx);
                        });
                    });
                    c.removed(function (val, key) {
                        deferIf(trace.recording, function () {
                            wrCollection.remove(key);
                        });
                    });
                    init = false;
                    var rwCollection = wrCollection.asWritable({
                        add: function (wrapper) {
                            if (trace.recording)
                                // participants.add("sip:johndoe@contoso.com")
                                // wrid("sip:johndoe@contoso.com") == null
                                trace.write(TTT.RecordType.AddItem, id, wrid(wrapper) || wrapper);
                            return c.add(unwrap(wrapper));
                        },
                        remove: function (wrapper) {
                            if (trace.recording)
                                trace.write(TTT.RecordType.RemoveItem, id, wrid(wrapper) || wrapper);
                            return c.remove(unwrap(wrapper));
                        }
                    });
                    // the UI shouldn't be able to invoke Promise objects directly;
                    // note, that this .get(...) already returns wrappers
                    var _get = rwCollection.get;
                    rwCollection.get = function (key) { return wrap(_get.call(rwCollection, key), name + '.get()'); };
                    return rwCollection;
                }
                handlers.push(function (name, id, itemid) {
                    if (name == TTT.RecordType.AddItem) {
                        var w = wrappers[id];
                        TTT.assert(w);
                        w.add(wrappers[itemid] || itemid);
                        return true;
                    }
                });
                handlers.push(function (name, id, itemid) {
                    if (name == TTT.RecordType.RemoveItem) {
                        var w = wrappers[id];
                        TTT.assert(w);
                        w.remove(wrappers[itemid] || itemid);
                        return true;
                    }
                });
                //#endregion
                //#region command
                function wrapCommand(cmd, id, name) {
                    function fn() {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        // note, that the SDK can modify the args later
                        var _args = map(args, serialize);
                        // SWX invokes shouldNotify with the message text by mistake
                        if (TTT.nopii && /\.chatService\.(sendMessage|shouldNotify)$/.test(name) && typeof _args[0] == 'string')
                            _args[0] = '#<message-text>';
                        var rec = trace.recording && trace.write(TTT.RecordType.Invoke, id, _args);
                        // note, that an async disabled command returns a rejected promise
                        var res = cmd.apply(null, args.map(unwrap));
                        if (isPromise(res)) {
                            res = res.then(function (r) {
                                // e.g. search returns an array of contact/group objects
                                if (isArray(r))
                                    return r.map(function (v, i) { return wrap(v, name + '()[' + i + ']') || v; });
                                return wrap(r, name + '()') || r;
                            });
                        }
                        var wrs = wrap(res, name + '()') || res; // Promise<T>
                        rec && rec.push(wrid(wrs));
                        return wrs;
                    }
                    return TTT.extend(fn, {
                        enabled: wrap(cmd.enabled || ConstProperty(true), name + '.enabled'),
                        bind: null
                    });
                }
                handlers.push(function (name, id, args, resid) {
                    if (name == TTT.RecordType.Invoke) {
                        var w = wrappers[id];
                        TTT.assert(w);
                        var r = w.apply(null, args.map(deserialize));
                        TTT.assert(!resid || resid == wrid(r));
                        return true;
                    }
                });
                //#endregion command
                //#region promise
                // Only those promises must be wrapped that are returned to UI,
                // while this promise is internal, so when Collection<T> calls
                // its .then(...), ttt will add a record as though UI has made
                // this call. Moreover, this promise wrapper is not what UI gets:
                // Collection<T> will return its own promise from the .get(...)
                // call and when UI invokes .then(...) on that promise, ttt won't
                // know that. This is why there will be an unexpected setTimeout
                // or postMessage call in the ttt log for every call to .get(...).
                function wrapPromise(p, id, name) {
                    return {
                        then: function (done, fail, info) {
                            var rec = trace.recording && trace.write(TTT.RecordType.Then, id);
                            // TODO: There is a curious problem with .then(...) callbacks.
                            // Consider this example: persons.get().then(fn); // UI code
                            // When recording, UI takes the wrapped promise p = persons.get()
                            // and attaches a callback to it with p.then(fn). The .then(...)
                            // call usually results in a postMessage call made by the SDK, so
                            // in the trace there will be two records:
                            //
                            //  #1 .then(null, null, null);
                            //  #3 postMessage(...)
                            //
                            // Some time later the callback gets invoked and it may do a few
                            // .subscribe(...) calls, for example. Also, the window.onmessage
                            // handler in the SDK invokes Date.now() before and after each
                            // callback, so the trace later looks like this:
                            //
                            //  #31 window.onmessage
                            //  #32 Date.now()
                            //  #33 .subscribe(...)
                            //  #34 Date.now()
                            //
                            // When replaying the trace, there is no UI, so ttt simulates
                            // the #1 .then(...) call with null/noop callbacks. This produces
                            // the #2 postMessage call, as expected. Later it simulates the #31
                            // event, which does result in the #32 Date.now() call. However the
                            // null/noop callback that the SDK now invokes doesn't do any
                            // .subscribe(...) calls and ttt can't figure out that the #33 .subscribe(...)
                            // call needs to be done here, before proceeding to the next #34 Date.now().
                            //
                            // In a real example, .then(...) was invoked at #3794, then at #5675 its
                            // callback was invoked and produced .subscribe(...) and other records
                            // till #5856 where Date.now() was finally invoked by the onmessage handler.
                            var q = p.then(function (res) {
                                try {
                                    if (trace.debug)
                                        rec && rec.push(trace.size);
                                    return done(res);
                                }
                                finally {
                                    if (trace.debug)
                                        rec && rec.push(trace.size);
                                }
                            }, fail, info);
                            return wrap(q, name + '.then()');
                        },
                        catch: function (handler) {
                            if (trace.recording)
                                trace.write(TTT.RecordType.Catch, id);
                            var q = p.catch(handler);
                            return wrap(q, name + '.catch()');
                        },
                        finally: function (callback) {
                            if (trace.recording)
                                trace.write(TTT.RecordType.Finally, id);
                            var q = p.finally(callback);
                            return wrap(q, name + '.finally()');
                        },
                        cancel: function (reason) {
                            if (trace.recording)
                                trace.write(TTT.RecordType.Cancel, id, TTT.clone(reason));
                            p.cancel(reason);
                        }
                    };
                }
                handlers.push(function (name, id) {
                    if (name == TTT.RecordType.Then) {
                        var w = wrappers[id];
                        TTT.assert(w);
                        w.then();
                        return true;
                    }
                });
                handlers.push(function (name, id) {
                    if (name == TTT.RecordType.Catch) {
                        var w = wrappers[id];
                        TTT.assert(w);
                        w.catch();
                        return true;
                    }
                });
                handlers.push(function (name, id) {
                    if (name == TTT.RecordType.Finally) {
                        var w = wrappers[id];
                        TTT.assert(w);
                        w.finally();
                        return true;
                    }
                });
                handlers.push(function (name, id, reason) {
                    if (name == TTT.RecordType.Cancel) {
                        var w = wrappers[id];
                        TTT.assert(w);
                        w.cancel(reason);
                        return true;
                    }
                });
                //#endregion promise
                handlers.push(function (name, id) {
                    if (name == TTT.RecordType.Fetch) {
                        var w = wrappers[id];
                        TTT.assert(w);
                        w.get();
                        return true;
                    }
                });
                handlers.push(function (name, id, value, reason, cset) {
                    if (name == TTT.RecordType.Set) {
                        var w = wrappers[id];
                        TTT.assert(w);
                        if (cset)
                            w.set(value, reason); // this creates an extra Promise<T> and a wrapper for it
                        else
                            w(value, reason);
                        return true;
                    }
                });
                handlers.push(function (name, id) {
                    if (name == TTT.RecordType.Subscribe) {
                        var w = wrappers[id];
                        TTT.assert(w);
                        w.subscribe();
                        return true;
                    }
                });
                handlers.push(function (name, id) {
                    if (name == TTT.RecordType.Dispose) {
                        var w = wrappers[id];
                        TTT.assert(w);
                        subscriptions[id].dispose();
                        return true;
                    }
                });
                handlers.push(function (name, id, key, val) {
                    if (name == TTT.RecordType.SetProp) {
                        var w = wrappers[id];
                        TTT.assert(w);
                        w[key] = val;
                        return true;
                    }
                });
                return {
                    wrap: wrap
                };
            }
            TTT.Wrapper = Wrapper;
            ;
        })(TTT = Web.TTT || (Web.TTT = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var TTT;
        (function (TTT) {
            function createWindowProxy(trace, window, handlers) {
                return __assign({ Date: TTT.createDateProxy(trace, window), Math: TTT.createMathProxy(trace, window) }, TTT.createTimerProxy(trace, window, handlers), TTT.createMessageProxy(trace, window, handlers), { document: TTT.createDocumentProxy(trace, window, handlers), sessionStorage: TTT.createStorageProxy(trace, window, window.sessionStorage, TTT.RecordType.SSGetItem, TTT.RecordType.SSSetItem, TTT.RecordType.SSRemoveItem), localStorage: TTT.createStorageProxy(trace, window, window.localStorage, TTT.RecordType.LSGetItem, TTT.RecordType.LSSetItem, TTT.RecordType.RemoveItem), XMLHttpRequest: TTT.createXhrProxy(trace, window, handlers), 
                    // these don't need to be proxied
                    WeakMap: window['WeakMap'], 
                    // proxies for these are yet to be implemented
                    navigator: window.navigator, location: window.location });
            }
            TTT.createWindowProxy = createWindowProxy;
        })(TTT = Web.TTT || (Web.TTT = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var TTT;
        (function (TTT) {
            function createStorageProxy(trace, window, storage, kGet, kSet, kRemove) {
                return {
                    setItem: function (key, val) {
                        if (trace.recording) {
                            storage.setItem(key, val);
                            trace.write(kSet, key);
                        }
                        else {
                            var _key = trace.read(kSet)[0];
                            TTT.assert(_key == key);
                        }
                    },
                    getItem: function (key) {
                        if (trace.recording) {
                            var val = storage.getItem(key);
                            trace.write(kGet, key, val);
                            return val;
                        }
                        else {
                            var _a = trace.read(kGet), _key = _a[0], val = _a[1];
                            TTT.assert(_key == key);
                            return val;
                        }
                    },
                    removeItem: function (key) {
                        if (trace.recording) {
                            storage.removeItem(key);
                            trace.write(kRemove, key);
                        }
                        else {
                            var _key = trace.read(kRemove)[0];
                            TTT.assert(_key == key);
                        }
                    }
                };
            }
            TTT.createStorageProxy = createStorageProxy;
        })(TTT = Web.TTT || (Web.TTT = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var TTT;
        (function (TTT) {
            function createDateProxy(trace, window) {
                var Date = window.Date;
                if (trace.recording)
                    trace.data.timestamp = Date.now();
                var last_ts = trace.data.timestamp;
                // There is a small problem with this Date mock: the instanceof operator
                // doesn't work with it: (new Date instanceof Date) === false. If a trace
                // depends on the result of such instanceof, it's likely that the trace
                // won't be replayable.
                function tttDate(ms) {
                    // for simplicity, only "new Date()" and "new Date(n)" calls
                    // are intercepted; other forms can also be handled if needed            
                    TTT.assert(this instanceof tttDate);
                    TTT.assert(arguments.length < 2);
                    TTT.assert(/number|undefined|string/.test(typeof ms));
                    if (ms)
                        return new Date(ms);
                    if (trace.recording) {
                        var dt = new Date;
                        // recording diffs is better for compression
                        trace.write(TTT.RecordType.GetDate, +dt - last_ts);
                        last_ts = +dt;
                        return dt;
                    }
                    else {
                        var ms_1 = trace.read(TTT.RecordType.GetDate)[0];
                        last_ts += ms_1;
                        return new Date(last_ts);
                    }
                }
                return TTT.extend(tttDate, {
                    now: function () {
                        return +new this;
                    }
                });
            }
            TTT.createDateProxy = createDateProxy;
        })(TTT = Web.TTT || (Web.TTT = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var TTT;
        (function (TTT) {
            function LCG(x, a, c) {
                return {
                    next: function () {
                        return x = a * x + c | 0; // same as mod 0x80000000
                    },
                    random: function () {
                        var r = this.next() / 0x80000000;
                        return r < 0 ? -r : r; // 0..1
                    }
                };
            }
            function createMathProxy(trace, window) {
                var Math = window.Math;
                if (trace.recording)
                    trace.data.randseed = Math.random() * 0x40000000 | 0;
                // 25% of records are random() calls: they all can be replaced
                // with a randseed number with a deterministic RNG
                var rgen = LCG(trace.data.randseed, 1664525, 1013904223);
                return {
                    log: function (x) {
                        return Math.log(x);
                    },
                    pow: function (x, y) {
                        return Math.pow(x, y);
                    },
                    max: function (x, y) {
                        return Math.max(x, y);
                    },
                    min: function (x, y) {
                        return Math.min(x, y);
                    },
                    floor: function (x) {
                        return Math.floor(x);
                    },
                    round: function (x) {
                        return Math.round(x);
                    },
                    random: function () {
                        return rgen.random();
                    }
                };
            }
            TTT.createMathProxy = createMathProxy;
        })(TTT = Web.TTT || (Web.TTT = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var TTT;
        (function (TTT) {
            function createXhrProxy(trace, window, handlers) {
                var XMLHttpRequest = window.XMLHttpRequest;
                var xhrs = {};
                var xhrId = 1;
                var XHR = (function () {
                    function XHR() {
                        this.headers = {};
                        this.id = xhrId++;
                        if (trace.recording)
                            this.xhr = new XMLHttpRequest;
                        xhrs[this.id] = this;
                    }
                    XHR.prototype.open = function (type, url, async) {
                        if (async === void 0) { async = true; }
                        if (trace.recording) {
                            this.type = type;
                            this.url = url;
                            if (!async)
                                throw Error('XHR requests must be async');
                            this.xhr.open(type, url, async);
                        }
                    };
                    XHR.prototype.abort = function () {
                        if (trace.recording) {
                            trace.write(TTT.RecordType.XhrStop, this.id);
                            this.xhr.abort();
                        }
                        else {
                            var id = trace.read(TTT.RecordType.XhrStop)[0];
                            TTT.assert(id == this.id);
                        }
                    };
                    XHR.prototype.setRequestHeader = function (name, value) {
                        if (trace.recording) {
                            this.headers[name] = value;
                            this.xhr.setRequestHeader(name, value);
                        }
                    };
                    XHR.prototype.getAllResponseHeaders = function () {
                        return this.responseHeaders;
                    };
                    XHR.prototype.send = function (data) {
                        var _this = this;
                        if (trace.recording) {
                            var xhr_1 = this.xhr;
                            xhr_1.onreadystatechange = function () {
                                // for simplicity, only the final
                                // state change event is recorded
                                if (xhr_1.readyState != 4)
                                    return;
                                _this.readyState = xhr_1.readyState;
                                _this.status = xhr_1.status;
                                _this.statusText = xhr_1.statusText;
                                _this.responseHeaders = xhr_1.getAllResponseHeaders();
                                _this.responseText = xhr_1.responseText;
                                trace.turn++;
                                trace.write(TTT.RecordType.XhrRecv, _this.id, {
                                    status: _this.status,
                                    statusText: _this.statusText,
                                    headers: _this.responseHeaders.split('\r\n'),
                                    data: _this.responseText
                                });
                                _this.xhr = null;
                                _this.onreadystatechange();
                            };
                            trace.write(TTT.RecordType.XhrSend, this.id, {
                                type: this.type,
                                url: this.url,
                                headers: this.headers,
                                data: data
                            });
                            this.xhr.send(data);
                        }
                        else {
                            var id = trace.read(TTT.RecordType.XhrSend)[0];
                            TTT.assert(id == this.id);
                        }
                    };
                    XHR.prototype.recv = function (_a) {
                        var status = _a.status, statusText = _a.statusText, headers = _a.headers, data = _a.data;
                        this.readyState = 4;
                        this.status = status;
                        this.statusText = statusText;
                        this.responseHeaders = headers.join('\r\n');
                        this.responseText = data;
                        this.onreadystatechange();
                    };
                    return XHR;
                }());
                handlers.push(function (name, id, data) {
                    if (name == TTT.RecordType.XhrRecv) {
                        xhrs[id].recv(data);
                        return true;
                    }
                });
                return XHR;
            }
            TTT.createXhrProxy = createXhrProxy;
        })(TTT = Web.TTT || (Web.TTT = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var TTT;
        (function (TTT) {
            function createDocumentProxy(trace, window, handlers) {
                var document = window.document;
                var setTimeout = window.setTimeout;
                var iframes = {};
                var iframeId = 1;
                handlers.push(function (name, id) {
                    if (name == TTT.RecordType.LoadFrame) {
                        iframes[id].onload();
                        return true;
                    }
                });
                return {
                    createElement: function (name) {
                        // this is the only element that the client creates
                        TTT.assert(name == 'iframe');
                        if (trace.recording) {
                            var iframe = document.createElement(name);
                            iframe[TTT.sId] = iframeId++;
                            trace.write(TTT.RecordType.CreateElemenet, iframe[TTT.sId]);
                            return iframe;
                        }
                        else {
                            var e = trace.read(TTT.RecordType.CreateElemenet);
                            var iid = e[0];
                            var iframe = { style: {}, contentWindow: { postMessage: function () { } } };
                            iframe[TTT.sId] = iid;
                            TTT.assert(!iframes[iid]);
                            iframes[iid] = iframe;
                            return iframe;
                        }
                    },
                    body: {
                        appendChild: function (iframe) {
                            if (trace.recording) {
                                TTT.assert(iframe[TTT.sId]);
                                trace.write(TTT.RecordType.AppendChild, iframe[TTT.sId]);
                                var onload_1 = iframe.onload;
                                iframe.onload = function () {
                                    // in chrome .onload can be somehow directly called
                                    // by .appendChild: I can't explain this; setTimeout
                                    // is a workaround for this
                                    setTimeout(function () {
                                        trace.turn++;
                                        trace.write(TTT.RecordType.LoadFrame, iframe[TTT.sId]);
                                        onload_1.call(iframe);
                                    }, 0);
                                };
                                document.body.appendChild(iframe);
                            }
                            else {
                                var _id = trace.read(TTT.RecordType.AppendChild)[0];
                                TTT.assert(_id == iframe[TTT.sId]);
                            }
                        },
                        removeChild: function (iframe) {
                            if (trace.recording) {
                                trace.write(TTT.RecordType.RemoveChild, iframe[TTT.sId]);
                                document.body.removeChild(iframe);
                            }
                            else {
                                var _id = trace.read(TTT.RecordType.RemoveChild)[0];
                                TTT.assert(_id == iframe[TTT.sId]);
                            }
                        }
                    },
                    cookie: ''
                };
            }
            TTT.createDocumentProxy = createDocumentProxy;
        })(TTT = Web.TTT || (Web.TTT = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var TTT;
        (function (TTT) {
            function createTimerProxy(trace, window, handlers) {
                var setTimeout = window.setTimeout;
                var setInterval = window.setInterval;
                var clearTimeout = window.clearTimeout;
                var clearInterval = window.clearInterval;
                var timers = [];
                handlers.push(function (name, id) {
                    if (name == TTT.RecordType.FireTimer) {
                        timers[id].call();
                        return true;
                    }
                });
                return {
                    setTimeout: function (fn, dt) {
                        if (trace.recording) {
                            var id_1 = setTimeout(function () {
                                trace.turn++;
                                trace.write(TTT.RecordType.FireTimer, id_1);
                                fn();
                            }, dt);
                            trace.write(TTT.RecordType.SetTimer, id_1, dt, /*recurring=*/ 0);
                            return id_1;
                        }
                        else {
                            var _a = trace.read(TTT.RecordType.SetTimer), id = _a[0], _dt = _a[1], recurring = _a[2];
                            TTT.assert(_dt == dt);
                            TTT.assert(!recurring);
                            TTT.assert(!timers[id]);
                            timers[id] = fn;
                            return id;
                        }
                    },
                    clearTimeout: function (id) {
                        if (!id)
                            return; // this is a no-op
                        if (trace.recording) {
                            trace.write(TTT.RecordType.ClearTimer, id);
                            clearTimeout(id);
                        }
                        else {
                            var _id = trace.read(TTT.RecordType.ClearTimer)[0];
                            TTT.assert(_id == id);
                            if (timers[id])
                                timers[id] = null;
                            else
                                TTT.log.warn("Timer " + id + " has been cleared again.");
                        }
                    },
                    setInterval: function (fn, dt) {
                        if (trace.recording) {
                            var id_2 = setInterval(function () {
                                trace.turn++;
                                trace.write(TTT.RecordType.FireTimer, id_2);
                                fn();
                            }, dt);
                            trace.write(TTT.RecordType.SetTimer, id_2, dt, /*recurring=*/ 1);
                            return id_2;
                        }
                        else {
                            var _a = trace.read(TTT.RecordType.SetTimer), id = _a[0], _dt = _a[1], recurring = _a[2];
                            TTT.assert(_dt == dt);
                            TTT.assert(recurring);
                            TTT.assert(!timers[id]);
                            timers[id] = fn;
                            return id;
                        }
                    },
                    clearInterval: function (id) {
                        if (!id)
                            return; // this is a no-op
                        if (trace.recording) {
                            trace.write(TTT.RecordType.ClearTimer, id);
                            clearInterval(id);
                        }
                        else {
                            var _id = trace.read(TTT.RecordType.ClearTimer)[0];
                            TTT.assert(_id == id);
                            if (timers[id])
                                timers[id] = null;
                            else
                                TTT.log.warn("Timer " + id + " has been cleared again.");
                        }
                    }
                };
            }
            TTT.createTimerProxy = createTimerProxy;
        })(TTT = Web.TTT || (Web.TTT = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var TTT;
        (function (TTT) {
            function hash(text) {
                return '#<text:' + text.length + ':' + Web.Utils.hash(text) + '>';
            }
            function createMessageProxy(trace, window, handlers) {
                var listeners = {};
                var listenerId = 1;
                handlers.push(function (name, id, data) {
                    if (name == TTT.RecordType.FireEvent) {
                        listeners[id].call(null, { data: data });
                        return true;
                    }
                });
                return {
                    addEventListener: function (name, callback) {
                        // this is the only event that the client needs
                        TTT.assert(name == 'message');
                        if (trace.recording) {
                            var cid_1 = listenerId++;
                            trace.write(TTT.RecordType.AddEventListener, cid_1);
                            window.addEventListener('message', function (event) {
                                try {
                                    trace.turn++;
                                    var data = event.data;
                                    if (TTT.nopii && typeof data == 'string') {
                                        // remove message content from conv logs and outgoing message events
                                        data = data.replace(/(\\"(?:html|plain)Message\\":{\\"href\\":\\"data:text\/(?:html|plain);charset=utf-8,)(.*?)(\\"}})/gm, function (_, $1, $2, $3) { return $1 + hash($2) + $3; });
                                        // preview messages from convlogs too
                                        data = data.replace(/(\\"previewMessage\\":\\")(.*?)(\\")/gm, function (_, $1, $2, $3) { return $1 + hash($2) + $3; });
                                        // remove web tickets from /POST /OAuth responses
                                        data = data.replace(/\b(cwt=)([\w-]+)\b/gm, function (_, $1, $2) { return $1 + hash($2); });
                                        trace.write(TTT.RecordType.FireEvent, cid_1, data);
                                    }
                                    callback(event);
                                }
                                catch (err) {
                                }
                            });
                        }
                        else {
                            var _id = trace.read(TTT.RecordType.AddEventListener)[0];
                            TTT.assert(_id == listenerId);
                            TTT.assert(!listeners[listenerId]);
                            listeners[listenerId] = callback;
                            listenerId++;
                        }
                    },
                    attachEvent: function (name, callback) {
                        this.addEventListener('on' + name, callback);
                    },
                    postMessage: function (data, target) {
                        TTT.assert(target == '*');
                        if (trace.recording) {
                            window.postMessage(data, target);
                            trace.write(TTT.RecordType.PostMessage, data);
                        }
                        else {
                            trace.read(TTT.RecordType.PostMessage);
                        }
                    }
                };
            }
            TTT.createMessageProxy = createMessageProxy;
        })(TTT = Web.TTT || (Web.TTT = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="proxy/window.ts" />
/// <reference path="proxy/storage.ts" />
/// <reference path="proxy/date.ts" />
/// <reference path="proxy/math.ts" />
/// <reference path="proxy/xhr.ts" />
/// <reference path="proxy/document.ts" />
/// <reference path="proxy/timer.ts" />
/// <reference path="proxy/message.ts" />
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var TTT;
        (function (TTT) {
            /**
             * Records a complete trace of the SDK's activity.
             *
             * This is achieved by mocking the global environment,
             * such as the setTimeout and Math.random functions,
             * and wrapping the entire client object model into a
             * wrapper with the same interface which intercepts all the
             * calls from the UI and records them in the log.
             *
             * After the trace is recorded, it can be replayed to
             * simulate the recorded activity. This enables debugging
             * of the recorded scenario and replaying it deterministically.
             * Essentially it allows to record a hard-to-repro bug
             * once and then replay it as many times as needed.
             *
             */
            function Recorder(window, tdata) {
                var isRecording = !tdata;
                var handlers = new Array();
                var trace = new TTT.Trace(tdata);
                var wrapper = TTT.Wrapper(trace, window, handlers);
                function makeFileName() {
                    return Skype.$window.Math.random().toString(16).slice(2, 8);
                }
                ;
                function makeFiles(name) {
                    var files = {};
                    // saving .js files under non .js extensions doesn't break the .html
                    // but allows to bypass the browser's prompt for saving "dangerous" files
                    files[name + '.src'] = new Blob([
                        'var Skype; !' + $ + '(Skype = window.Skype || {});'
                    ], { type: 'application/javascript' });
                    var data = trace.toJSON();
                    files[name + '.json'] = new Blob([
                        "ttt_trace = ",
                        JSON.stringify(data, null, '\t')
                    ], { type: 'application/json' });
                    files[name + '.html'] = new Blob([
                        '<!doctype html>',
                        '<html>',
                        '<head>',
                        '<title>' + new Skype.$window.Date().toJSON().slice(0, -8) + '</title>',
                        "<script type=\"text/javascript\" src=\"" + name + ".json\"></script>",
                        '<script type="text/javascript" src= "' + name + '.src"></script>',
                        '</head>',
                        '<body><button onclick="this.disabled = true; Skype.ttt.play();">Replay</button></body>',
                        '</html>'
                    ], { type: 'text/html' });
                    return files;
                }
                function send(name, url) {
                    if (name === void 0) { name = makeFileName(); }
                    var files = makeFiles(name);
                    sendFiles(url, files);
                }
                function sendFiles(url, files) {
                    // reading from window to not use the ttt wrappers of these classes
                    var data = new window.FormData;
                    var xhr = new window.XMLHttpRequest;
                    for (var name_3 in files)
                        data.append(name_3, files[name_3], name_3);
                    xhr.open('POST', url || '/ttt');
                    xhr.send(data);
                }
                function save() {
                    var started = Skype.$window.Date.now();
                    var name = makeFileName();
                    var files = makeFiles(name);
                    var duration = Skype.$window.Date.now() - started;
                    TTT.log('Files generated in ' + duration + ' ms');
                    for (var name_4 in files)
                        saveFile(name_4, files[name_4]);
                }
                function saveFile(name, blob) {
                    var a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = name;
                    a.click();
                }
                if (tdata)
                    TTT.log('Invoke ttt.play() to replay the recorded trace.');
                // ttt doesn't override any global functions or objects
                // but instead offers to use its own version of the global
                // environment; thus whoever wants to opt-in can do so
                // by using explicitly ttt.window as the global object,
                // while those who don't want to opt-in, won't notice ttt
                return {
                    window: TTT.createWindowProxy(trace, window, handlers),
                    save: save,
                    send: send,
                    sync: function (tag) {
                        if (!trace.debug)
                            return;
                        if (trace.recording) {
                            trace.write(TTT.RecordType.Sync, tag);
                        }
                        else {
                            var x = trace.read(TTT.RecordType.Sync)[0];
                            TTT.assert(x == tag);
                        }
                    },
                    play: function () {
                        next: while (trace.current) {
                            var id = trace.index;
                            this.tick = trace.index;
                            var _a = trace.current, name_5 = _a[0], args = _a.slice(1);
                            trace.index++;
                            if (name_5 == TTT.RecordType.CreateRoot) {
                                this.root(args[0]);
                            }
                            else {
                                try {
                                    for (var _i = 0, handlers_1 = handlers; _i < handlers_1.length; _i++) {
                                        var h = handlers_1[_i];
                                        if (h.apply(void 0, [name_5].concat(args)))
                                            continue next;
                                    }
                                }
                                catch (err) {
                                    TTT.log.apply(void 0, [id, name_5].concat(args));
                                    throw err;
                                }
                                TTT.log("Record #" + id + " " + name_5 + " is not an action.");
                                TTT.assert(false);
                            }
                        }
                    },
                    toJSON: function (tzip_url) {
                        return trace.toJSON(tzip_url);
                    },
                    ctor: null,
                    root: function (args) {
                        if (isRecording) {
                            TTT.log('Recording. Invoke ttt.save() to get the recorded trace.');
                            trace.write(TTT.RecordType.CreateRoot, TTT.clone(args));
                        }
                        // ttt doesn't work well when there are multiple
                        // callbacks in one postMessage/setTimeout call:
                        // see comment for the promise object wrapper
                        Web.Utils.defer.mode = 'setTimeout';
                        Web.Utils.defer.duration = 0;
                        // when replaying, the undefined values get converted to nulls
                        var root = new this.ctor(args || undefined);
                        return wrapper.wrap(root, 'app');
                    }
                };
            }
            TTT.Recorder = Recorder;
        })(TTT = Web.TTT || (Web.TTT = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="ttt/log.ts" />
/// <reference path="ttt/trace.ts" />
/// <reference path="ttt/wrapper.ts" />
/// <reference path="ttt/recorder.ts" />
"use strict";
var Skype;
(function (Skype) {
    function $$(fn) {
        try {
            return fn();
        }
        catch (_) {
        }
    }
    var isRecording = false
        || $$(function () { return /\bttt$/.test(location.hash); }) // #foo=123&ttt
        || $$(function () { return /\bttt$/.test(location.search); }) // ?foo=123&ttt
        || $$(function () { return JSON.parse(sessionStorage.getItem('lwsdk.ttt')); })
        || $$(function () { return JSON.parse(localStorage.getItem('lwsdk.ttt')); });
    // don't enable ttt when unit tests are run
    var isBrowser = window.navigator && window.navigator.userAgent;
    // ttt has to be enabled or kept disabled at startup
    Skype.ttt = typeof ttt_trace != 'undefined' ?
        Skype.Web.TTT.Recorder(window, ttt_trace) :
        isBrowser && isRecording && Skype.Web.TTT.Recorder(window); // recording
    // it can't be set immediately because then the copy of pm in swx
    // will check for window.ttt and enter into the recording mode
    Skype.ttt && Skype.$window.setTimeout(function () {
        Skype.$window['ttt'] = Skype.ttt; // useful for debugging
    }, 1000);
})(Skype || (Skype = {}));
(function (Skype) {
    var Web;
    (function (Web) {
        // after this exports references to these symbols can be
        // intercepted by ttt: if there is a reference to a symbol
        // ts first checks whether the symbol exists in the namespace
        // and only then checks the global scope
        Web.window = Skype.ttt ? Skype.ttt.window : Skype.$window;
        try {
            // unit tests replace some of these global vars with mocks: the SDK needs to pick them up
            Object.defineProperty(Web, 'sessionStorage', { get: function () { return Web.window.sessionStorage; } });
            Object.defineProperty(Web, 'localStorage', { get: function () { return Web.window.localStorage; } });
            Object.defineProperty(Web, 'XMLHttpRequest', { get: function () { return Web.window.XMLHttpRequest; } });
            Object.defineProperty(Web, 'Date', { get: function () { return Web.window.Date; } });
            Object.defineProperty(Web, 'Math', { get: function () { return Web.window.Math; } });
            Object.defineProperty(Web, 'setTimeout', { get: function () { return Web.window.setTimeout.bind(null); } });
            Object.defineProperty(Web, 'setInterval', { get: function () { return Web.window.setInterval.bind(null); } });
            Object.defineProperty(Web, 'clearTimeout', { get: function () { return Web.window.clearTimeout.bind(null); } });
            Object.defineProperty(Web, 'clearInterval', { get: function () { return Web.window.clearInterval.bind(null); } });
        }
        catch (_) {
        }
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
(function (Skype) {
    var Web;
    (function (Web) {
        var TTT;
        (function (TTT) {
            TTT.nopii = true; // tells to remove PII from traces
        })(TTT = Web.TTT || (Web.TTT = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="missing.d.ts" />
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        /** This flag is set by the test runners. */
        Web.isUnitTested = !!Web['isUnitTested'];
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
(function (Skype) {
    var Web;
    (function (Web) {
        var Settings;
        (function (Settings) {
            Settings.dbgBreak = false;
        })(Settings = Web.Settings || (Web.Settings = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /** Uses Object.setPrototypeOf to replace the prototype of
                created properties and collection, which are functions.
                This trick reduces the memory usage, but might be unsafe. */
            Utils.replacePrototype = true;
            /** Just a function that does nothing. */
            Utils.noop = function () { };
            /** true in async functions */
            Utils.sIsAsync = Symbol('async');
            function isAsyncFunction(x) {
                return x && x[Utils.sIsAsync];
            }
            Utils.isAsyncFunction = isAsyncFunction;
            /**
             * Converts a regular function into an "async" function
             * that always returns a promise. Works similarly to
             * the "async" function from the "Q" library.
             *
             */
            function async(fn, mode, md) {
                if (isFunction(fn)) {
                    // async(async(fn)) == async(fn)
                    var fna = fn[Utils.sIsAsync] ? fn : function () {
                        try {
                            return Utils.Task.wait(fn.apply(this, arguments), mode);
                        }
                        catch (err) {
                            return new Utils.Task().reject(err).promise;
                        }
                    };
                    setHiddenProperty(fna, Utils.sIsAsync, true);
                    return fna;
                }
                else if (typeof fn === 'object' && typeof md === 'object') {
                    // async(proto, name, desc) was invoked as a decorator
                    var amd = inherit(md);
                    // when async(...) is invoked as a decorator, the `this`
                    // value can equal to "sync" to tell the async function
                    // must resolve/reject the promise immediately if the inner
                    // function (which is md.value) returns/throws something.
                    // The `this` value can be passed via async.bind("sync")
                    // and is used in one place to define the internal _setAsync
                    // method of Property.
                    amd.value = async(md.value, this);
                    return amd;
                }
                else {
                    assert(false);
                }
            }
            Utils.async = async;
            //#endregion
            //#region hidden
            /** A decorator to make a method non-enumerable. */
            function hidden(proto, name, desc) {
                desc.enumerable = false;
            }
            Utils.hidden = hidden;
            //#endregion
            //#region nothrow
            /** A decorator to suppress all exceptions thrown by the method. */
            function nothrow(proto, name, desc) {
                var fn = desc.value;
                desc = inherit(desc);
                desc.value = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    try {
                        return fn.apply(this, args);
                    }
                    catch (err) {
                    }
                };
                return desc;
            }
            Utils.nothrow = nothrow;
            //#endregion
            //#region Symbol
            /**
             * The idea is taken from the ES6 Symbol.
             *
             * A symbol is a string-like object that can be used as a key
             * to access an object's member. Its main difference from a plain
             * string is that the object's member can be accessed only if
             * a reference to the symbol is available:
             *
             *      var myObj = {};
             *      var mySym = Symbol("a descriptive name to simplify debugging");
             *      myObj[mySym] = secret;
             *
             * To a very good extent a symbol can be simulated by a random string.
             * At runtime a symbol is just a random string with a hint in it.
             * While executing unit tests a symbol is the same string that was
             * given to its constructor.
             *
             */
            function Symbol(name, addRandomTag) {
                if (name === void 0) { name = random(); }
                if (addRandomTag === void 0) { addRandomTag = !Web.isUnitTested; }
                return !addRandomTag ? '_s_' + name : name + '_' + random();
            }
            Utils.Symbol = Symbol;
            //#endregion
            //#region inherit
            /**
             * Creates an object with the given prototype
             * and optionally extends it with a set of properties.
             * As a nice side effect the created object will be
             * displayed in a debugger with the right type name,
             * i.e. inherit(ABC.prototype, { x: 1 }) will be displayed
             * as ABC { x: 1 }.
             */
            function inherit(proto, props, mode) {
                var descriptors = {};
                proto = proto || {};
                props = props || {};
                for (var key in props) {
                    if (!(key in proto) || mode != 'append')
                        descriptors[key] = {
                            value: props[key],
                            writable: true,
                            enumerable: true,
                            configurable: true
                        };
                }
                // not supported in IE 8, but there are already
                // many things here that don't work in IE 8
                return Object.create(proto, descriptors);
            }
            Utils.inherit = inherit;
            //#endregion
            //#region setHiddenProperty
            /**
             * It's typically used with Symbol:
             *
             *      var sName = Symbol('name');
             *      var myObj = {};
             *      setHiddenProperty(myObj, sName, 'Alice');
             *
             * In ES6 a function like this isn't needed and a simple
             * assignment does the job.
             */
            function setHiddenProperty(obj, sym, val, readOnly) {
                if (readOnly === void 0) { readOnly = false; }
                try {
                    Object.defineProperty(obj, sym, {
                        value: val,
                        configurable: true,
                        enumerable: false,
                        writable: !readOnly
                    });
                }
                catch (err) {
                    obj[sym] = val;
                }
            }
            Utils.setHiddenProperty = setHiddenProperty;
            //#endregion
            //#region extend
            /**
             * Copies properties from one object to another.
             * It overwrites existing properties.
             *
             * @example Returns {a:1, b:2}
             *
             *      extend({a:1}, {b:2});
             *
             * @example Returns {a:1, b: 3}
             *
             *      extend({a:1}, {a:2, b:3});
             *
             * @example Does nothing, because x.toString already exists.
             *
             *      var x = {};
             *      extend(x, {toString:function(){}});
             */
            function extend(res) {
                var args = []; /* ...srcs, mode = "override" */
                for (var _i = 1 /* ...srcs, mode = "override" */; _i < arguments.length /* ...srcs, mode = "override" */; _i++ /* ...srcs, mode = "override" */) {
                    args[_i - 1] = arguments[_i]; /* ...srcs, mode = "override" */
                }
                var src, i, name, mode = args[args.length - 1];
                res = res || {};
                mode = isString(mode) ? mode : '';
                for (i = 0; i < args.length; i++) {
                    src = args[i] || {};
                    if (src !== mode) {
                        for (name in src) {
                            if (mode != 'append' || !(name in res))
                                res[name] = src[name];
                        }
                    }
                }
                return res;
            }
            Utils.extend = extend;
            //#endregion
            /**
             * Returns a random number in the form of a hex string.
             */
            function random() {
                return Web.Math.random().toString(16).slice(2);
            }
            Utils.random = random;
            function setPrototypeOrExtend(obj, proto) {
                if (Utils.replacePrototype) {
                    if (obj.__proto__)
                        obj.__proto__ = proto;
                    else if (Object.setPrototypeOf)
                        Object.setPrototypeOf(obj, proto);
                    else
                        extend(obj, proto);
                }
                else {
                    extend(obj, proto);
                }
            }
            Utils.setPrototypeOrExtend = setPrototypeOrExtend;
            //#region Exception
            /**
             * Constructs an exception object with custom parameters.
             *
             * The constructed exception inherits from the native Error object
             * all its properties, including the captured stack trace, and adds
             * to it the "code" member and a few custom members that usually
             * include the "reason" which points to another exception object.
             *
             * To throw an exception with a code use:
             *
             *      throw Exception("InvalidArgument");
             *
             * To throw an exception with a code and a custom message use:
             *
             *      throw Exception.call("An invalid argument passed.", "InvalidArgument");
             *
             * To throw an exception with custom parameters use:
             *
             *      throw Exception("SomethingFailed", {
             *          reason: err,
             *          tag: 123
             *      });
             *
             * @param {String} code - An error code, e.g. "InvalidArgument"
             * @param {Object} [params] - An optional set of values associated with the error.
             *
             * @returns {Error}
             */
            function Exception(code, params) {
                params = extend({ code: code }, params);
                // this === window in IE9 which doesn't support the strict mode
                // this === Utils after tsc resolves Exception to Utils.Exception
                // this === "" in some special case in IE
                return extend(Error(this === Web.window || this === Utils || !this || this == '' ? code : this), params);
            }
            Utils.Exception = Exception;
            //#endregion
            //#region Common Exceptions
            function EWrongType(value, type) {
                var text = value + ' is not a ' + type;
                return Exception.call(text, 'WrongType', { value: value });
            }
            Utils.EWrongType = EWrongType;
            function EWrongArgType(name, value, type) {
                var text = '`' + name + '` = ' + value + ' is not a ' + type;
                return Exception.call(text, 'WrongArgType', { arg: name, value: value });
            }
            Utils.EWrongArgType = EWrongArgType;
            function EDoesNotEqual(lhs, rhs) {
                var text = lhs + ' != ' + rhs;
                return Exception.call(text, 'DoesNotEqual', { lhs: lhs, rhs: rhs });
            }
            Utils.EDoesNotEqual = EDoesNotEqual;
            function EInvalidArgument(name, reason) {
                var text = '`' + name + '` is invalid: ' + reason;
                return Exception.call(text, 'InvalidArgument', { arg: name, reason: reason });
            }
            Utils.EInvalidArgument = EInvalidArgument;
            function EInvalidState(state, expected) {
                var text = 'Invalid state: ' + state + ' (expected ' + expected + ')';
                return Exception.call(text, 'InvalidState', { actual: state, expected: expected });
            }
            Utils.EInvalidState = EInvalidState;
            function EKeyMissing(key, obj) {
                var text = 'the `' + key + '` property is missing';
                return Exception.call(text, 'KeyMissing', { key: key, object: obj });
            }
            Utils.EKeyMissing = EKeyMissing;
            function EAlreadyExists(item) {
                return Exception('AlreadyExists', { item: item });
            }
            Utils.EAlreadyExists = EAlreadyExists;
            function EDoesNotExist(item) {
                return Exception('DoesNotExist', { item: item });
            }
            Utils.EDoesNotExist = EDoesNotExist;
            function ENotSupported(reason) {
                return Exception('NotSupported', { reason: reason });
            }
            Utils.ENotSupported = ENotSupported;
            function ENotFound(reason) {
                return Exception('NotFoundError', { reason: reason });
            }
            Utils.ENotFound = ENotFound;
            function ECanceled(reason) {
                return Exception('Canceled', { reason: reason });
            }
            Utils.ECanceled = ECanceled;
            //#endregion
            //#region assert
            function assert(condition, message, params) {
                if (!condition) {
                    if (!Web.isUnitTested && Web.Settings.dbgBreak) {
                        /** So something went wrong and you are here. Try to reproduce the problem and record a trace:
                             
                            1. Add #ttt to the URL and reload the page.
        
                            If the original URL looked like https://contoso.com/customers?sort=descending
                            then the modified URL should look like https://contoso.com/customers?sort=descending#ttt
                            The #ttt tag in the URL will tell the SDK that it needs to start in the recording mode.
                            
                            2. Repeat whatever steps lead to this failure.
                        
                            Once this place is reached again, save the trace by either invoking ttt.save()
                            in the dev console or [TBD]. This should prompt you to download 3 files. Zip them
                            together and attach to a bug report. Note, that the trace will contain *all* the
                            data that has been seen by the SDK: all text messages sent by the SDK, the contact
                            list, the conversation history if it has been pulled by the SDK and so on. The trace
                            will not contain data outside the SDK boundary, i.e. it won't contain cookies, contents
                            of the page outside the SDK and so on. If possible, it's better to use a test account. */
                        debugger;
                    }
                    throw Exception(message || 'AssertionFailed', params);
                }
            }
            Utils.assert = assert;
            //#endregion
            //#region check    
            function check(condition, message, params) {
                if (!condition)
                    throw Exception(message || 'RuntimeCheckFailed', params);
            }
            Utils.check = check;
            (function (check) {
                function equals(a, b) {
                    if (a != b)
                        throw EDoesNotEqual(a, b);
                }
                check.equals = equals;
                function state(actual, expected) {
                    if (isArray(expected)) {
                        if (indexOf(expected, actual) == -1)
                            throw EInvalidState(actual, expected);
                    }
                    else if (actual != expected)
                        throw EInvalidState(actual, expected);
                }
                check.state = state;
                function belongs(key, object) {
                    if (!(key in object))
                        throw EKeyMissing(key, object);
                }
                check.belongs = belongs;
            })(check = Utils.check || (Utils.check = {}));
            /**
             * This is a polyfill for Array#indexOf that doesn't exist in IE 8.
             * To avoid possible interference with other JS code, it's better
             * to not extend prototypes of the global constructors such as Array.
             */
            function indexOf(a, v) {
                var i;
                if (a.indexOf) {
                    return a.indexOf(v);
                }
                else {
                    for (i = 0; i < a.length; i++) {
                        // an expression comparing objects is only true
                        // if the operands reference the same object
                        if (a[i] == v)
                            return i;
                    }
                    return -1;
                }
            }
            Utils.indexOf = indexOf;
            //#endregion
            //#region is
            function isPromise(x) {
                return x instanceof Utils.Promise;
            }
            Utils.isPromise = isPromise;
            function isCollection(x) {
                return x && x.constructor === Utils.Collection;
            }
            Utils.isCollection = isCollection;
            function isModel(x) {
                return x instanceof Utils.Model;
            }
            Utils.isModel = isModel;
            function isProperty(x) {
                // it's debatable whether a property is a collection;
                // currently a collection looks almost exactly as a
                // property object: it has .get, .changed, .call and other
                // features, but doesn't have .set (but should) and
                // .then (also should)
                return x && x.constructor === Utils.Property;
            }
            Utils.isProperty = isProperty;
            function isCommand(x) {
                return x && x.constructor === Utils.Command;
            }
            Utils.isCommand = isCommand;
            function isObject(x) {
                // IE8 thinks that {}.toString(undefined) == '[object Object]'
                return x && Object.prototype.toString.call(x) == '[object Object]';
            }
            Utils.isObject = isObject;
            function isDictionary(x) {
                return isObject(x);
            }
            Utils.isDictionary = isDictionary;
            function isArray(x) {
                return Object.prototype.toString.call(x) == '[object Array]';
            }
            Utils.isArray = isArray;
            function isArrayOf(a, is) {
                if (!isArray(a))
                    return false;
                for (var i = 0; i < a.length; i++)
                    if (!is(a[i]))
                        return false;
                return true;
            }
            Utils.isArrayOf = isArrayOf;
            function isString(x) {
                return Object.prototype.toString.call(x) == '[object String]';
            }
            Utils.isString = isString;
            function isNumber(x) {
                return Object.prototype.toString.call(x) == '[object Number]';
            }
            Utils.isNumber = isNumber;
            function isFunction(x) {
                return Object.prototype.toString.call(x) == '[object Function]';
            }
            Utils.isFunction = isFunction;
            function isBoolean(x) {
                return Object.prototype.toString.call(x) == '[object Boolean]';
            }
            Utils.isBoolean = isBoolean;
            function isNotEmptyString(x) {
                return isString(x) && x.length > 0;
            }
            Utils.isNotEmptyString = isNotEmptyString;
            function isVoid(x) {
                return x === null || x === undefined;
            }
            Utils.isVoid = isVoid;
            function isPrimitive(x) {
                return isVoid(x) || isBoolean(x) || isNumber(x) || isString(x);
            }
            Utils.isPrimitive = isPrimitive;
            function isInteger(x) {
                return isNumber(x) && (x | 0) == x;
            }
            Utils.isInteger = isInteger;
            function isArrayIndex(x, a) {
                return isInteger(x) && isArray(a) && x >= 0 && x < a.length;
            }
            Utils.isArrayIndex = isArrayIndex;
            function isInRange(min, max, x) {
                return isNumber(x) && x >= min && x <= max;
            }
            Utils.isInRange = isInRange;
            function isAjaxRequest(r) {
                return isObject(r) && isNotEmptyString(r.type) && isNotEmptyString(r.url);
            }
            Utils.isAjaxRequest = isAjaxRequest;
            function isAjaxResponse(r) {
                return isDictionary(r) && ('status' in r);
            }
            Utils.isAjaxResponse = isAjaxResponse;
            function isEmptyObject(x) {
                for (var prop in x)
                    if (x.hasOwnProperty(prop))
                        return false;
                return true;
            }
            Utils.isEmptyObject = isEmptyObject;
            function isException(x) {
                return x && x.code && x instanceof Error;
            }
            Utils.isException = isException;
            function is(item, type) {
                var i, types = type.split('|');
                for (i = 0; i < types.length; i++)
                    if (types[i] in is.types && is.types[types[i]](item))
                        return true;
                return false;
            }
            Utils.is = is;
            function isThenable(obj) {
                // take into account promises that may be created
                // by other Promises/A+ compliant libraries, such
                // as Q - this function must recognize them as well
                return obj && isFunction(obj.then);
            }
            Utils.isThenable = isThenable;
            (function (is) {
                is.types = {
                    String: isString,
                    NotEmptyString: isNotEmptyString,
                    Function: isFunction,
                    Dictionary: isDictionary,
                    Object: isObject,
                    Array: isArray,
                    Boolean: isBoolean,
                    Void: isVoid,
                    Number: isNumber,
                    Exception: isException
                };
            })(is = Utils.is || (Utils.is = {}));
            //#endregion
            //#region bind
            /**
             * This is a polyfill for Function#bind that doesn't exist in IE 8.
             * To avoid possible interference with other JS code, it's better
             * to not extend prototypes of the global constructors such as Function.
             */
            function bind(fn) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                var that = this;
                // use the native Function#bind if it's available
                return fn.bind ? fn.bind.apply(fn, [that].concat(args)) : function () {
                    return fn.apply(that, args.concat([].slice.call(arguments, 0)));
                };
            }
            Utils.bind = bind;
            //#endregion
            function removeAt(array, index) {
                array.splice(index, 1);
            }
            Utils.removeAt = removeAt;
            function insertAt(array, index, value) {
                array.splice(index, 0, value);
            }
            Utils.insertAt = insertAt;
            /**
             * Invokes a callback for each element in the array
             * or in the object.
             *
             * @example It prints 0->11 1->22 2->33
             *
             *      foreach([11, 22, 33], function (value, index) {
             *          console.log(index + "->" + value);
             *      });
             *
             * @example It prints a->1 b->2 c->3
             *
             *      foreach({a:1, b:2, c:3}, function (value, key) {
             *          console.log(key + "->" + value);
             *      });
             */
            function foreach(items, callback) {
                var retVal, i, key;
                if (isArray(items)) {
                    for (i = 0; i < items.length; ++i)
                        callback(items[i], i);
                }
                else {
                    for (key in items) {
                        retVal = callback(items[key], key);
                        assert(retVal === void 0);
                    }
                }
            }
            Utils.foreach = foreach;
            /**
             * This is an implementation of Array::map compatible with ECMAScript 5.
             *
             * @param {Array|Object} array
             * @param context
             * @param {Function} callback(value, index, array)
             *
             *      A function that takes the name and value of a source object
             *      property, and returns the result of a certain operation on that value.
             */
            function map(array, callback, context) {
                var mapped, i;
                if (isArray(array)) {
                    mapped = [];
                    for (i = 0; i < array.length; i++)
                        mapped.push(callback.call(context, array[i], i, array));
                }
                else if (isDictionary(array)) {
                    mapped = {};
                    for (i in array)
                        mapped[i] = callback.call(context, array[i], i, array);
                }
                return mapped;
            }
            Utils.map = map;
            //#endregion
            //#region values
            /**
             * Given a dictionary returns an array of dictionary values.
             */
            function values(items) {
                assert(isDictionary(items));
                var vals = [];
                foreach(items, function (value) {
                    vals.push(value);
                });
                return vals;
            }
            Utils.values = values;
            /**
             * Determines whether a collection (array or dictionary) contains an element
             * that satisfies a given condition
             */
            function contains(items, callback) {
                assert(isArray(items) || isDictionary(items));
                assert(isFunction(callback));
                var i;
                if (isArray(items)) {
                    for (i = 0; i < items.length; ++i) {
                        if (callback(items[i], i))
                            return true;
                    }
                }
                else {
                    for (i in items) {
                        if (callback(items[i], i))
                            return true;
                    }
                }
                return false;
            }
            Utils.contains = contains;
            //#endregion
            //#region deepEqual
            /**
             * Deep comparison of two objects.
             *
             * This function considers two objects as equal if they contain the
             * same list of primitive properties (object properties are compared
             * using strict comparison).
             *
             * This function may be improved in the future when there is a need
             * to compare properties at deeper levels.
             *
             */
            function deepEqual(obj1, obj2) {
                var prop, t1 = typeof obj1, t2 = typeof obj2;
                // strict comparison (this will cover primitive types, including
                // undefined and null)
                if (obj1 === obj2)
                    return true;
                // both have to be object or function before continue
                if (t1 !== t2 || t1 !== 'object' && t1 !== 'function')
                    return false;
                if (obj1 === null || obj2 === null)
                    return obj1 === obj2;
                if (obj1 instanceof Web.Date && obj2 instanceof Web.Date)
                    return +obj1 == +obj2;
                // each property in obj1 must exist in obj2
                for (prop in obj1) {
                    if (!(prop in obj2) || obj1[prop] !== obj2[prop])
                        return false;
                }
                // each property in obj2 must exist in obj1
                for (prop in obj2) {
                    if (!(prop in obj1) || obj1[prop] !== obj2[prop])
                        return false;
                }
                return true;
            }
            Utils.deepEqual = deepEqual;
            function removeItem(array, predicate) {
                for (var i = 0; i < array.length; i++) {
                    if (predicate(array[i])) {
                        removeAt(array, i);
                        return i;
                    }
                }
            }
            Utils.removeItem = removeItem;
            //#endregion
            //#region insertItem
            /** Inserts an item into a sorted array:
                var index = insertItem(array, (x, y) => x < y); */
            function insertItem(items, item, order) {
                var i = 0, n = items.length;
                while (i < n && !order(item, items[i]))
                    i++;
                insertAt(items, i, item);
                return i;
            }
            Utils.insertItem = insertItem;
            //#endregion
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            var callbacks = [];
            var messageTag = '{"websdk":"' + Utils.random() + '"}';
            function dequeue() {
                // a callback may add other callbacks, so clone
                // the list of callbacks before invoking them
                var list = callbacks.slice(0);
                callbacks.length = 0;
                var started = defer.duration && Web.Date.now();
                while (list.length > 0) {
                    var _a = list.shift(), fn = _a[0], ctx = _a[1], args = _a[2];
                    try {
                        fn.apply(ctx, args);
                    }
                    catch (err) {
                    }
                    if (defer.duration && Web.Date.now() > started + defer.duration)
                        break;
                }
                // some callbacks didn't have time to run:
                // reschedule them for the next event turn
                if (list.length > 0) {
                    callbacks.unshift.apply(callbacks, list);
                    if (defer.mode == 'setTimeout')
                        Web.setTimeout(dequeue, 0);
                    if (defer.mode == 'postMessage')
                        Web.window.postMessage(messageTag, '*');
                }
            }
            function process(message) {
                if (message.data == messageTag) {
                    // if we are here, the postMessage API works for sure
                    defer.mode = 'postMessage';
                    dequeue();
                }
            }
            /**
             * defer(fn, ...args) invokes fn(...args) at the next event loop cycle
             * if the code is run in a browser during runtime, or invokes fn(args...)
             * right away if the code is invoked by a unit test.
             */
            function defer(callback) {
                var _this = this;
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                if (Web.isUnitTested) {
                    callback.apply(this, args);
                    return;
                }
                // this mode is used when ttt is enabled
                if (!defer.duration && defer.mode == 'setTimeout') {
                    Web.setTimeout(function () { return callback.apply(_this, args); }, 0);
                    return;
                }
                callbacks.push([callback, this, args]);
                // when the 1-st callback was enqueued,
                // setTimeout/postMessage was called:
                // not need to call it again
                if (callbacks.length > 1)
                    return;
                if (defer.mode == 'setTimeout') {
                    Web.setTimeout(dequeue, 0);
                    return;
                }
                if (defer.mode == 'postMessage') {
                    Web.window.postMessage(messageTag, '*');
                    return;
                }
                if (!defer.mode) {
                    try {
                        // need to check if the postMessage API works
                        defer.mode = 'postMessage-probing';
                        Web.window.postMessage(messageTag, '*');
                        if (Web.window.addEventListener)
                            Web.window.addEventListener('message', process);
                        else
                            Web.window.attachEvent('onmessage', process); // IE
                        Web.setTimeout(function () {
                            // postMessage has set the mode first, as expected
                            if (defer.mode)
                                return;
                            // postMessage either doesn't work or is slow                        
                            defer.mode = 'setTimeout';
                            dequeue();
                        }, 0);
                    }
                    catch (err) {
                        defer.mode = 'setTimeout';
                        Web.setTimeout(dequeue, 0);
                    }
                }
            }
            Utils.defer = defer;
            (function (defer) {
                /**
                 * The max duration in milliseconds that callbacks can take at one event turn.
                 * Once the current batch of callbacks exceed this threshold, the defer function
                 * stops and continues at the next event turn. The point is to make UI more responsive.
                 * If set to zero, the defer function invokes all the scheduled callbacks not matter
                 * how long they run.
                 */
                defer.duration = 16;
            })(defer = Utils.defer || (Utils.defer = {}));
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            var isException = Utils.isException;
            var ECanceled = Utils.ECanceled;
            var sTask = Utils.Symbol('task');
            var sError = Utils.Symbol('error');
            var sResult = Utils.Symbol('result');
            function wrap(x) {
                if (Utils.isPromise(x))
                    return x;
                // note, that .then can be read only once, according to the spec
                var then = x !== true && x !== false && x !== null && x !== undefined
                    && typeof x !== 'number' && typeof x !== 'string' && x.then;
                // .then may be an object inheriting from Function.prototype
                if (typeof then === 'function')
                    return new Promise(Utils.bind.call(x, then));
            }
            /**
             * An instance of Task represents an asynchronously returned value
             * or an asynchronously thrown exception. Task corresponds to C#'s Task.
             *
             * A task can be resolved or rejected. Resolving a task means returning a value
             * asynchronously; rejecting it - throwing an exception asynchronously.
             *
             * A task is a promise to eventually return the result of an asynchronous operation.
             * If the operation succeeds the function resolves the task supplying the operation result.
             * If the operation fails the function rejects the task providing the failure reason (exception).
             *
             * There is an interesting limitation on the the implementation of Task:
             * it cannot invoke Property::set because this method creates a resolved
             * promise that invokes Property::set that creates a resolved promise...
             * However Task can invoke Property::call because it does not
             * create a promise and returns whatever was in `this` reference.
             *
             */
            var Task = (function () {
                function Task(initialStatus, options) {
                    var _this = this;
                    if (!(this instanceof Task))
                        return new Task(initialStatus, options);
                    if (!Utils.isString(initialStatus)) {
                        options = initialStatus;
                        initialStatus = void 0;
                    }
                    var args = options || {};
                    this._ = {
                        leafs: [],
                        state: 'pending',
                        status: Utils.Property({ value: initialStatus }),
                        promise: Utils.inherit(Promise.prototype)
                    };
                    var _ = this._;
                    if (args.mode)
                        _.mode = args.mode;
                    if (args.cancel)
                        _.fnCancel = args.cancel;
                    Utils.setHiddenProperty(_.promise, sTask, this);
                    this.state = function () { return _.state; };
                    this.status = _.status;
                    this.promise = _.promise;
                    this.status.changed(function () { return _this.notify(); });
                }
                Task.prototype.resolve = function (result) {
                    var self = this, _ = self._;
                    if (_.state != 'pending')
                        return self;
                    _.value = result;
                    _.state = 'resolved';
                    return self._complete();
                };
                Task.prototype.reject = function (error) {
                    var self = this, _ = self._;
                    if (_.state != 'pending')
                        return self;
                    _.value = error;
                    _.state = 'rejected';
                    return self._complete();
                };
                /**
                 * Redirects result or error from a promise to this task.
                 * It's pretty much the same as the following call to .then(...):
                 *
                 *      source.then(
                 *          r => { task.resolve(r); return r; },
                 *          e => { task.reject(e); throw e; });
                 *
                 * The only difference is special extra logic to properly remove
                 * dangling promise objects and chain cancellation.
                 */
                Task.prototype.from = function (source) {
                    var task = this, _ = task._;
                    if (_.promise[Task.sLocked])
                        return _.target.from(source);
                    _.source = source;
                    var p = _.source.then(function (res) { task.resolve(res); return res; }, function (err) { task.reject(err); throw err; }, _.status);
                    _.fnCancel = function (reason) { return _.source.cancel(reason); };
                    if (_.source[Task.sLocked])
                        _.source[sTask]._.target = task;
                    return p;
                };
                Task.prototype._complete = function () {
                    var self = this, _ = self._;
                    _.status(null);
                    for (var _i = 0, _a = _.leafs; _i < _a.length; _i++) {
                        var leaf = _a[_i];
                        this.exec(leaf);
                    }
                    _.fnCancel = null; // it holds a ref to the parent task
                    return self;
                };
                /**
                 * Once this task is completed, this method is invoked to
                 * complete tasks attached with .then(...): it invokes the
                 * associated done/fail handlers and then resolves/rejects
                 * the attached task.
                 */
                Task.prototype.exec = function (leaf, mode) {
                    var _ = this._;
                    // as required by spec, .then(...) is async by default
                    if (_.mode != 'sync' && mode != 'sync') {
                        Utils.defer.call(this, this.exec, leaf, 'sync');
                        return;
                    }
                    this.exec2(leaf, _.state, _.value);
                };
                Task.prototype.exec2 = function (leaf, state, value) {
                    var _this = this;
                    if (state == 'resolved')
                        try {
                            var p = wrap(value);
                            if (p) {
                                p.then(function (r) { return _this.exec2(leaf, 'resolved', r); }, function (e) { return _this.exec2(leaf, 'rejected', e); });
                                return;
                            }
                        }
                        catch (e) {
                            state = 'rejected';
                            value = e;
                        }
                    var done = leaf.done, fail = leaf.fail, task = leaf.task;
                    var result;
                    try {
                        if (state == 'resolved')
                            result = Utils.isFunction(done) ? done(value) : value;
                        else if (Utils.isFunction(fail))
                            result = fail(value);
                        else
                            throw value;
                    }
                    catch (error) {
                        task.reject(error);
                        return;
                    }
                    if (result === task.promise)
                        task.reject(new TypeError);
                    else
                        try {
                            var promise = wrap(result);
                            if (promise)
                                task.from(promise);
                            else
                                task.resolve(result);
                        }
                        catch (e) {
                            task.reject(e);
                        }
                };
                /** Propagates the status of this task to tasks attached with .then(...). */
                Task.prototype.notify = function () {
                    var _ = this._;
                    if (_.state != 'pending')
                        return;
                    var status = this.status();
                    var reason = this.status.reason;
                    if (status === undefined && reason === undefined)
                        return;
                    for (var _i = 0, _a = _.leafs; _i < _a.length; _i++) {
                        var _b = _a[_i], task = _b.task, info = _b.info;
                        task.status(status, reason);
                        if (Utils.isFunction(info))
                            info(status, reason);
                    }
                };
                /**
                 * If a task created by .then(...) is cancelled, it's detached
                 * from this task. If the last attached task is cancelled, this
                 * task is cancelled as well.
                 */
                Task.prototype.detach = function (leaf, reason) {
                    var _ = this._;
                    var task = leaf.task, fail = leaf.fail;
                    if (_.leafs.length < 2) {
                        _.promise.cancel(reason);
                    }
                    else {
                        Utils.removeAt(_.leafs, Utils.indexOf(_.leafs, leaf));
                        try {
                            if (Utils.isFunction(fail))
                                task.from(Task.wait(fail(reason)));
                            else
                                task.reject(reason);
                        }
                        catch (error) {
                            task.reject(error);
                        }
                    }
                };
                return Task;
            }());
            // see the explanation given in the comment for the repeat(...) function
            Task.sLocked = Utils.Symbol('locked');
            Utils.Task = Task;
            /**
             * This is the proposed in ES7 interface of a Promise to the Task class.
             * This interface is more convenient to use when constructing promise
             * objects inline. An example of use:
             *
             *      Promise((resolve, reject, notify) => {
             *          notify("waiting for 1.5 seconds");
             *          setTimeout(resolve, 1500); // resolve the promise after 1.5 seconds
             *      }).then(() => {
             *          ...
             *      });
             *
             * This way of constructing promise object doesn't allow to specify
             * the cancellation procedure or to report progress.
             */
            var Promise = (function () {
                function Promise(then) {
                    if (!(this instanceof Promise))
                        return new Promise(then);
                    var task = new Task();
                    try {
                        then(function (res) { return task.resolve(res); }, function (err) { return task.reject(err); }, task.status);
                    }
                    catch (err) {
                        // `then` may throw an exception after
                        // resolving or rejecting the promise
                        try {
                            task.reject(err);
                        }
                        catch (_) {
                        }
                    }
                    return task.promise;
                }
                /**
                 * Cancels the task.
                 *
                 * Every complex async operation, such as "sign in" consists of
                 * several stages where every stage is represented by a Task instance.
                 * For example such stages can be "awaiting xframe", "awaiting GET /me",
                 * or "waiting in the throttling queue": all these stages are
                 * essentially instances of Task that get resolved by their owners
                 * in due course.
                 *
                 * Owners of these tasks may specify a custom callback that knows
                 * how to cancel this particular task. For instance, in case of
                 * "awaiting xframe" task the cancellation routine would cancel
                 * the timer and possibly remove the xframe from the DOM tree;
                 * in case of "waiting in the throttling queue" the cancellation
                 * routine would remove the request from the queue.
                 *
                 * A task may have multiple branches (called "promises") and each branch
                 * has the "cancel" method that attempts to find the current task
                 * and invoke its cancel method. If the current task was given the
                 * cancellation routine, the Task::cancel would succeed and reject the
                 * current task (which results in invoking the "fail" handler of attached
                 * branches and those handlers may initiate other async operations).
                 * If the current task was not given the cancellation routine (because
                 * the owner of this operation was too lazy to implement it), Task::cancel
                 * would just reject the task.
                 *
                 *     state of the current task or any up-stream tasks is not pending. For
                 *     example:
                 *
                 *     var t1 = new Task(); // create a task t1
                 *     var p1 = t1.promise;
                 *     var p2 = p1.then(fnSuccess1, fnFailure); // create a sourced task from p1.
                 *     var p3 = p2.then(fnSuccess2, fnFailure2); // create another sourced task from p2.
                 *
                 *     t1.resolve('Task1 is completed'); // p1.state() is 'resolved', but has not propagated to p2 and p3
                 *     try {
                 *         p3.cancel('cancelling task 3'); // cancelling p3
                 *     } catch (err) {
                 *         console.log(err); // got InvalidState exception, since p1.state() is 'resolved'
                 *     }
                 *
                 */
                Promise.prototype.cancel = function (reason) {
                    var task = this[sTask], _ = task._;
                    // there is a fundamental flaw in this Promise#cancel approach:
                    // if there is a couple chained tasks p2 = p1.then(...) and p1
                    // gets resolved, p2 gets resolved asynchronously, according to
                    // the spec, so after p1 is resolved and before p2 is resolved,
                    // the user of p2 may reasonably assume that it's ok to cancel p2,
                    // while this isn't the case because p2 is already "almost" resolved;
                    // hence there is no point to report an error here: it would be a
                    // false positive in too many cases
                    if (_.state != 'pending')
                        return;
                    var err = isException(reason) && reason.code == 'Canceled' ? reason : ECanceled(reason);
                    if (_.fnCancel)
                        _.fnCancel(err);
                    else
                        task.reject(err);
                };
                Promise.prototype.then = function (fnDone, fnFail, fnInfo) {
                    var root = this[sTask];
                    var task = new Task({
                        cancel: function (reason) { return root.detach(leaf, reason); }
                    });
                    var leaf = {
                        task: task,
                        done: fnDone,
                        fail: fnFail,
                        info: fnInfo
                    };
                    if (root.state() == 'pending') {
                        root._.leafs.push(leaf);
                        root.notify();
                    }
                    else {
                        root.exec(leaf);
                    }
                    return task.promise;
                };
                /**
                 * Sets an error handler for an async operation.
                 *
                 * A call to .catch corresponds to wrapping an "await" into a try..catch.
                 * .catch is typically used as the very last handler of a complete async
                 * flow to handle all possible errors:
                 *
                 *     ucwa.send("GET", ".../me").catch(error => {
                 *         console.log(error);
                 *     });
                 *
                 * With the "await" keyword this code snippet can be rewritten as:
                 *
                 *     try {
                 *         await ucwa.send("GET", ".../me");
                 *     } catch (error) {
                 *         console.log(error);
                 *     }
                 *
                 * Note, that if the error handler returns a value, it essentially
                 * handles the error and the new promise returned by .catch is resolved;
                 * if it throws na exception, that promise gets rejected.
                 */
                Promise.prototype.catch = function (handler) {
                    return this.then(null, handler || Utils.noop);
                };
                /**
                 * An async version of try..finally.
                 *
                 * This method is a part of the Promise interface proposed in ES7.
                 * The intent is to simulate the try..finally construct for promises:
                 * a handler attached via .finally gets invoked no matter whether the
                 * promise has been resolved or rejected and the handler cannot read or
                 * alter the result. However if the handler fails, the thrown exception
                 * gets propagated.
                 *
                 *     ucwa.send("GET", ".../me").finally(() => {
                 *         console.log("GET has succeeded or failed");
                 *     });
                 *
                 * With the "await" keyword this code snippet can be rewritten as:
                 *
                 *     try {
                 *         await ucwa.send("GET", ".../me");
                 *     } finally {
                 *         console.log("GET has succeeded or failed");
                 *     }
                 *
                 * Typically .finally is used to add a final handler that will do some
                 * cleanup after the async operation completes.
                 */
                Promise.prototype.finally = function (handler) {
                    return this.then(function (res) { return Promise.resolve(handler()).then(function () { return res; }); }, function (err) { return Promise.resolve(handler()).then(function () { throw err; }); });
                };
                Object.defineProperty(Promise.prototype, sResult, {
                    get: function () {
                        var _ = this[sTask]._;
                        if (_.state == 'resolved')
                            return _.value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Promise.prototype, sError, {
                    get: function () {
                        var _ = this[sTask]._;
                        if (_.state == 'rejected')
                            return _.value;
                    },
                    enumerable: true,
                    configurable: true
                });
                return Promise;
            }());
            Utils.Promise = Promise;
            (function (Task) {
                //#region Task.waitAny        
                /**
                 * Awaits the given tasks and stops waiting after the any of them resolves,
                 * then it cancels all pending tasks. For example, waiting for any of a few
                 * requests to succeed (or all of them to fail) can be done like this:
                 *
                 *      Task.waitAny([
                 *          ucwa.send("GET", "/me/name"),
                 *          ucwa.send("POST", "/me/makeAvailable", { data : { ... } })
                 *      ]);
                 *
                 * If JS allowed to overload operators, then this function could be replaced
                 * with the overloaded | operator for the Promise class.
                 *
                 */
                function waitAny(promises) {
                    var nPending = promises.length;
                    var task = new Task({ cancel: cancel });
                    var promise = task.promise;
                    var statuses = [];
                    if (nPending == 1)
                        promise = Task.wait(promises[0]);
                    else if (nPending == 0)
                        task.reject(Error());
                    else {
                        Utils.foreach(promises, function (p, i) {
                            p.then(// p may already be completed
                            function (// p may already be completed
                                res) {
                                nPending--;
                                if (task) {
                                    task.resolve(res);
                                    task = null;
                                    // cancel all other tasks: they are not needed anymore
                                    cancel(Utils.Exception('CompetingTaskResolved'));
                                }
                            }, function (err) {
                                nPending--;
                                if (!nPending) {
                                    // all tasks has failed
                                    task.reject(err);
                                    task = null;
                                }
                            }, function (status) {
                                if (!task)
                                    return;
                                statuses[i] = status || '#' + i;
                                task.status(statuses.join(' || '));
                            });
                        });
                    }
                    function cancel(reason) {
                        for (var _i = 0, promises_1 = promises; _i < promises_1.length; _i++) {
                            var p = promises_1[_i];
                            try {
                                // this will cause the task returned by Task.waitAny to fail
                                p.cancel(reason);
                            }
                            catch (err) {
                            }
                        }
                    }
                    return promise;
                }
                Task.waitAny = waitAny;
                /**
                 * Creates a promise that gets resolved after all the given
                 * promises succeed and get rejected after any of the given
                 * promises fail.
                 *
                 * If JS allowed to overload operators, then this function could be replaced
                 * with the overloaded & operator for the Promise class.
                 *
                 */
                function waitAll(promises) {
                    var nPending = promises.length;
                    var task = new Task({ cancel: cancel });
                    var promise = task.promise;
                    if (nPending == 0) {
                        task.resolve([]);
                    }
                    else if (nPending == 1) {
                        promise = Task.wait(promises[0]).then(function (r) { return [r]; });
                    }
                    else {
                        var inLoop_1 = true;
                        var unresolved_1 = promises.map(wait);
                        var results_1 = promises.map(function (p) { return null; });
                        var statuses_1 = [];
                        var refresh_1 = function () { return !inLoop_1 && task && task.status(statuses_1.filter(function (_, i) { return !!unresolved_1[i]; }).join(' && ')); };
                        promises = promises.map(wait);
                        Utils.foreach(promises, function (promise, i) {
                            promise.then(function (result) {
                                results_1[i] = result;
                                unresolved_1[i] = null;
                                refresh_1();
                                nPending--;
                                if (!nPending) {
                                    task.resolve(results_1);
                                    task = null;
                                }
                            }, function (error) {
                                unresolved_1[i] = null;
                                nPending--;
                                if (task) {
                                    task.reject(error);
                                    task = null;
                                    cancel(error);
                                }
                            }, function (status) {
                                statuses_1[i] = status || '#' + i;
                                refresh_1();
                            });
                        });
                        inLoop_1 = false;
                        refresh_1();
                    }
                    function cancel(reason) {
                        for (var _i = 0, promises_2 = promises; _i < promises_2.length; _i++) {
                            var p = promises_2[_i];
                            try {
                                p.cancel(reason);
                            }
                            catch (error) {
                            }
                        }
                    }
                    return promise;
                }
                Task.waitAll = waitAll;
                function wait(obj, mode) {
                    try {
                        return wrap(obj) || new Task({ mode: mode }).resolve(obj).promise;
                    }
                    catch (err) {
                        return Promise.reject(err);
                    }
                }
                Task.wait = wait;
                //#endregion
                //#region run
                /**
                 * Invokes an async function.
                 * Same as Task.wait(null, 'sync').then(fn) but faster.
                 */
                function run(fn) {
                    try {
                        return Task.wait(fn(), 'sync');
                    }
                    catch (err) {
                        return new Task().reject(err).promise;
                    }
                }
                Task.run = run;
                //#endregion
            })(Task = Utils.Task || (Utils.Task = {}));
            (function (Promise) {
                Promise.all = Task.waitAll;
                Promise.race = Task.waitAny; // TODO: Promise.race waits for the 1st promise to be resolved or rejected.
                Promise.reject = function (err) { return new Task().reject(err).promise; };
                Promise.resolve = Task.wait;
            })(Promise = Utils.Promise || (Utils.Promise = {}));
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            if (typeof exports == 'object') {
                // see github.com/promises-aplus/promises-tests#adapters
                exports.deferred = Utils.Task;
                exports.resolved = Utils.Promise.resolve;
                exports.rejected = Utils.Promise.reject;
            }
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * It's a function that can be enabled or disabled.
             *
             * The point of commands is to bind them to certain UI elements and disable/enable
             * these elements according to state of their commands. For instance, UI may implement
             * the drag-and-drop way of adding contacts to a group: if the group model's command
             * that adds contacts is enabled, UI allows to drop a contact UI element to the group element.
             *
             * In the most general case, however, a command is callable object that contains all
             * the information needed to invoke a certain function with certain arguments. In addition
             * to that a command can be observed and it can tell whether it can be invoked with certain
             * arguments. To address that we may later extend the command class with the `bind` method:
             *
             *      var cmdSendMessage = messaging.send; // generic command
             *      var cmdSendGreeting = cmdSendMessage.bind(null, "Hello"); // specific command
             *
             *      cmdSendMessage.enabled(); // tells whether a message can be sent in general
             *      cmdSendGreeting.enabled(); // tells whether that particular message can be sent
             *
             * Thus to check whether it's ok to invoke a command with certain arguments a caller
             * may use the `bind` method and the `enabled` property:
             *
             *      if (messaging.send.bind(null, "Hello").enabled())
             *          console.log("This message can be sent.");
             *
             * The first `null` argument is needed to make `bind` be a superset of the existing Function::bind.
             * This `bind` method can be used to create UI elements that do very specific actions. For instance
             * here is how the `mute` and `unmute` buttons can be creates:
             *
             *      var btnMute = Button(audio.muted.set.bind(null, true));
             *      var btnUnmute = Button(audio.muted.set.bind(null, false));
             *
             * The first button executes audio.muted.set(true) and the second executes audio.muted.set(false).
             * Note, that the two buttons subscribe to the `enabled` property and make themselves grayed out
             * when the command cannot be executed. It's also noteworthy that one button can be enabled and
             * the other can be disabled at the same time: the two commands don't have to have the same state
             * as the underlying audio.muted.set command.
             *
             */
            function Command(invoke, enabled) {
                var pm_command = function () {
                    var enabled = pm_command.enabled;
                    if (enabled())
                        return invoke.apply(this, arguments);
                    var err = Utils.Exception('CommandDisabled', { reason: enabled.reason });
                    if (Utils.isAsyncFunction(invoke))
                        return new Utils.Task().reject(err).promise;
                    else
                        throw err;
                };
                function stringify() {
                    // make it easier to inspect commands in the dev console
                    return '[Command: enabled = ' + pm_command.enabled() + ']';
                }
                // binding of the `enabled` property via canInvoke for instance
                // is more complicated than it seems because sometimes a command
                // needs to be wrapped into another command (ttt, etc.)
                function bindContext(that) {
                    return Command(function () {
                        return pm_command.apply(that, arguments);
                    }, pm_command.enabled);
                }
                if (invoke && invoke[Utils.sIsAsync])
                    Utils.setHiddenProperty(pm_command, Utils.sIsAsync, true);
                return Utils.extend(pm_command, {
                    constructor: Command,
                    // it's absent when the first const true and false properties are constructed
                    enabled: enabled && enabled.asReadOnly(),
                    bind: bindContext,
                    toString: stringify
                });
            }
            Utils.Command = Command;
            function AsyncCommand(fn, enabled) {
                return Command(Utils.async(fn), enabled);
            }
            Utils.AsyncCommand = AsyncCommand;
            /**
             * A command that is always enabled.
             *
             * Instead of creating a full blown command with the Command
             * constructor, it creates a function that looks like a command.
             * This considerably improves performance because Property creates
             * always enabled commands.
             */
            function EnabledCommand(fn) {
                return Utils.extend(fn, {
                    constructor: Command,
                    toString: function () { return '[Command: enabled = true]'; },
                    enabled: Utils.ConstProperty(true)
                });
            }
            Utils.EnabledCommand = EnabledCommand;
            function EnabledAsyncCommand(fn) {
                return EnabledCommand(Utils.async(fn || (function () { return null; })));
            }
            Utils.EnabledAsyncCommand = EnabledAsyncCommand;
            (function (EnabledCommand) {
                EnabledCommand.async = EnabledAsyncCommand;
            })(EnabledCommand = Utils.EnabledCommand || (Utils.EnabledCommand = {}));
            /**
             * A permanently disabled command.
             *
             * Multiple calls to DisabledCommand without arguments return the very
             * same instance of a command. This considerably improves performance
             * because every property object has a disabled .set command.
             */
            function DisabledCommand(reason) {
                if (reason !== void 0)
                    return Command(Utils.noop, Utils.ConstProperty(false, reason));
                if (!DisabledCommand.instance)
                    DisabledCommand.instance = Command(Utils.noop, Utils.ConstProperty(false));
                return DisabledCommand.instance;
            }
            Utils.DisabledCommand = DisabledCommand;
            (function (DisabledCommand) {
            })(DisabledCommand = Utils.DisabledCommand || (Utils.DisabledCommand = {}));
            /**
             * A permanently disabled async command.
             *
             * Multiple calls to DisabledAsyncCommand without arguments return the very
             * same instance of a command. This considerably improves performance
             * because every property object has a disabled .set command.
             */
            function DisabledAsyncCommand(reason) {
                if (reason !== void 0)
                    return Command(Utils.async(Utils.noop), Utils.ConstProperty(false, reason));
                if (!DisabledAsyncCommand.instance)
                    DisabledAsyncCommand.instance = Command(Utils.async(Utils.noop), Utils.ConstProperty(false));
                return DisabledAsyncCommand.instance;
            }
            Utils.DisabledAsyncCommand = DisabledAsyncCommand;
            (function (DisabledAsyncCommand) {
            })(DisabledAsyncCommand = Utils.DisabledAsyncCommand || (Utils.DisabledAsyncCommand = {}));
            (function (Command) {
                Command.async = AsyncCommand;
                Command.enabled = EnabledCommand;
                Command.disabled = DisabledCommand;
            })(Command = Utils.Command || (Utils.Command = {}));
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * Encapsulates an event and provides capabilities to trigger the event and observe it.
             *
             * An event object is essentially a list of callbacks that are executed whenever the owner
             * of the event wants so. The event object is split into the event emitter that has all
             * the access to the event and the event observer that provides limited capabilities that are
             * enough to observe the event.
             *
             */
            var Event = (function () {
                function Event(options) {
                    if (options === void 0) { options = {}; }
                    if (!(this instanceof Event))
                        return new Event(options);
                    Utils.extend(this, options);
                    this._listeners = [];
                    this._modes = [];
                    this._locked = false;
                    this.observer = Event.Observer(this);
                }
                /** Invokes all listeners of the event. */
                Event.prototype.fire = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    var self = this;
                    if (self._enqueue(self, self._fire, arguments))
                        return;
                    self._fire.apply(self, arguments);
                    self._dequeue();
                };
                Event.prototype._invoke = function (fn, args, mode) {
                    var self = this;
                    /* istanbul ignore if */
                    if (mode == 'async' && !Web.isUnitTested) {
                        Utils.defer.call(self, self._invoke, fn, args, 'sync');
                    }
                    else {
                        try {
                            // this=null in event handlers
                            fn.apply(null, args);
                        }
                        catch (error) {
                            // if a handler throws an exception, it should not prevent other handlers
                            // from being invoked; however the thrown exception cannot be handled here,
                            // so it's just suppressed; Event._ie is a way for a unit test to specify
                            // an exception that needs to be ignored
                            Event.uncaught['_event'].fire(error);
                            /* istanbul ignore if */
                            if (error != Event._ie) {
                                // the error may be caused by a stack overflow and since a try..catch creates
                                // a new stack frame, this error handler cannot use another try..catch
                                if (console && console.log) {
                                    console.log(error && error.stack || error);
                                    console.log(Error().stack);
                                }
                            }
                        }
                    }
                };
                /** Tells whether the event has at least one listener. */
                Event.prototype.observed = function () {
                    return this._listeners.length > 0;
                };
                Event.prototype._fire = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    var i, self = this;
                    for (i = 0; i < self._listeners.length; i++)
                        self._invoke(self._listeners[i], arguments, self._modes[i]);
                };
                Event.prototype._enqueue = function (ctx, fn, args) {
                    var self = this;
                    if (self._locked) {
                        self._queue = self._queue || [];
                        self._queue.push([ctx, fn, args]);
                    }
                    else {
                        self._locked = true;
                    }
                    return self._queue && self._queue.length > 0;
                };
                Event.prototype._dequeue = function () {
                    var q, self = this;
                    if (self._queue) {
                        while (q = self._queue.shift())
                            q[1].apply(q[0], q[2]);
                        self._queue = null;
                    }
                    self._locked = false;
                };
                return Event;
            }());
            Utils.Event = Event;
            (function (Event) {
                var Subscription = (function () {
                    function Subscription(event, listener) {
                        this.event = event;
                        this.listener = listener;
                    }
                    Subscription.prototype.dispose = function () {
                        this.event.off(this.listener);
                    };
                    return Subscription;
                }());
                Event.Subscription = Subscription;
                var ObserverImpl = (function () {
                    function ObserverImpl(event) {
                        var observer = function (listener, mode) {
                            // addListener cannot return anything because it modifies
                            // the internal state of the event and thus a call to it
                            // may be delayed and executed later; however the corresponding
                            // removeListener call can be executed right away as the only
                            // argument it needs is the callback function which is known
                            observer.on(listener, mode);
                            // LWX/SWX wants to execute a custom function on the target
                            // property or collection after adding an event listener to it
                            if (Utils.isFunction(mode))
                                mode(this);
                            return new Event.Subscription(observer, listener);
                        };
                        Utils.setPrototypeOrExtend(observer, Event.Observer.prototype);
                        observer._event = event;
                        return observer;
                    }
                    ObserverImpl.prototype.toString = function () {
                        var n = this._event._listeners.length;
                        return '[Event' + (n ? ': ' + n + ' listener' + (n == 1 ? '' : 's') : '') + ']';
                    };
                    /**
                     * Adds an event listener that is invoked synchronously.
                     * The second argument can be set to "async" if the listener
                     * needs to be executed asynchronously. This can be used in special cases.
                     *
                     * @param {Function} listener - A callback to be executed when the event gets fired.
                     *
                     *      To add a listener that will be invoked only once, use anonymous named
                     *      functions that have reference to themselves but aren't accessible outside:
                     *
                     *          event(function fn(message) {
                     *              event.off(fn);
                     *              console.log(message);
                     *          });
                     *
                     *      Note, that fn can be accessed only from inside fn.
                     *
                     * @param {String} [mode="sync"] - Tells how the listener should be invoked.
                     *
                     *      If an object o1 goes to state s1 and fires an event e1 to notify
                     *      about this change, then a handler h1 of this event must observe
                     *      the object in state s1. If o1 fired e1 asynchronously, then h1 could
                     *      catch e1 at the moment when o1 is no longer in state s1. However if s1
                     *      is the final state of o1, then e1 may be fired asynchronously. This is
                     *      the cases for promise objects: the resolved or the rejected states are
                     *      final for them. This is why all events are synchronous by default.
                     */
                    ObserverImpl.prototype.on = function (listener, mode) {
                        var self = this._event;
                        if (self._enqueue(this, this._addListener, [listener, mode]))
                            return;
                        this._addListener(listener, mode);
                        self._dequeue();
                    };
                    ObserverImpl.prototype._addListener = function (listener, mode) {
                        var self = this._event;
                        Utils.assert(Utils.isFunction(listener));
                        if (self.adding)
                            self.adding.call(self.context, listener);
                        self._listeners.push(listener);
                        self._modes.push(mode);
                        if (self.added)
                            self.added.call(self.context, listener);
                        if (self._listeners.length == 1 && self.subscribed)
                            self.subscribed.call(self.context);
                    };
                    ObserverImpl.prototype.off = function (listener) {
                        var self = this._event;
                        if (self._enqueue(this, this._removeListener, [listener]))
                            return;
                        this._removeListener(listener);
                        self._dequeue();
                    };
                    ObserverImpl.prototype._removeListener = function (listener) {
                        var self = this._event;
                        var i = Utils.indexOf(self._listeners, listener);
                        if (i >= 0) {
                            self._listeners.splice(i, 1);
                            self._modes.splice(i, 1);
                            if (self._listeners.length == 0 && self.unsubscribed)
                                self.unsubscribed.call(self.context);
                        }
                    };
                    return ObserverImpl;
                }());
                function Observer(event) {
                    return ObserverImpl(event);
                }
                Event.Observer = Observer;
                Observer.prototype = ObserverImpl.prototype;
                Event.uncaught = new Event().observer;
            })(Event = Utils.Event || (Utils.Event = {}));
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            var Subscription = (function () {
                function Subscription(dispose) {
                    this.dispose = dispose;
                }
                return Subscription;
            }());
            Utils.Subscription = Subscription;
            /**
             * It's shared by Property::subscribe and Collection::subscribe.
             * It makes sure that the given `dispose` function is invoked only once.
             *
             */
            var RefCountedSubscription = (function () {
                function RefCountedSubscription(_callbacks) {
                    this._callbacks = _callbacks;
                    /** subs[i].dt <= subs[i+1].dt */
                    this._subscriptions = [];
                    /** polling interval in seconds */
                    this._period = Infinity;
                    /** periodically polls the value */
                    this._timer = null;
                }
                /**
                 * Most of the code here handles subscriptions via polling:
                 *
                 *      .subscribe() means a permanent subscription
                 *      .subscribe(3.5) means polling every 3.5 seconds
                 *
                 * Since .subscribe can be invoked multiple times, this object needs
                 * to aggregate such calls and switch between polling and permanent
                 * subscription and ir also needs to change the polling interval:
                 * it should be the min interval among all requested intervals.
                 */
                RefCountedSubscription.prototype.subscribe = function (dt) {
                    var _this = this;
                    if (dt === void 0) { dt = 0; }
                    var sub = new Subscription(function () {
                        if (!sub)
                            throw Utils.Exception('AlreadyDisposed');
                        Utils.removeItem(_this._subscriptions, function (x) { return x.sub === sub; });
                        sub = null;
                        _this._update();
                    });
                    Utils.insertItem(this._subscriptions, { sub: sub, dt: dt }, function (lhs, rhs) { return lhs.dt < rhs.dt; });
                    this._update();
                    return sub;
                };
                RefCountedSubscription.prototype._update = function () {
                    var newPeriod = this._subscriptions.length > 0 ? this._subscriptions[0].dt : Infinity;
                    var callbacks = this._callbacks;
                    if (newPeriod != this._period) {
                        if (this._timer)
                            Web.clearInterval(this._timer);
                        this._timer = null;
                        // period > 0, newPeriod = 0
                        if (newPeriod == 0 && callbacks.subscribed)
                            callbacks.subscribed();
                        // period = 0, newPeriod > 0
                        if (this._period == 0 && callbacks.unsubscribed)
                            callbacks.unsubscribed();
                        this._period = newPeriod;
                        if (this._period > 0 && this._period < Infinity && callbacks.updated)
                            this._timer = Web.setInterval(callbacks.updated, this._period * 1000 | 0);
                    }
                };
                return RefCountedSubscription;
            }());
            Utils.RefCountedSubscription = RefCountedSubscription;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * Unlike a regular dictionary which maps a string
             * to something, WeakMap maps an object to something.
             * This is used to attach hidden members to an object
             * without modifying that object. See ES6 WeakMap for
             * a full spec.
             *
             * This class is an incomplete and inefficient polyfill
             * for the ES6 WeakMap.
             *
             */
            var WeakMap = (function () {
                /**
                 * @param description - A short string to simplify debugging.
                 *
                 *      If a wm attached a property to an object, then in the
                 *      debugger this will be shown as a hidden property:
                 *
                 *      Object {
                 *          foo: 123,
                 *          "name:1b44hc": 456
                 *      }
                 */
                function WeakMap(description) {
                    if (description === void 0) { description = 'wm'; }
                    // each wm must have its own tag because
                    // two wms can attach properties to the
                    // same object
                    this._sTag = Utils.Symbol(description, true);
                }
                WeakMap.prototype.get = function (obj) {
                    return obj[this._sTag];
                };
                WeakMap.prototype.set = function (obj, val) {
                    Utils.setHiddenProperty(obj, this._sTag, val);
                };
                WeakMap.prototype.has = function (obj) {
                    return this._sTag in obj;
                };
                WeakMap.prototype.delete = function (obj) {
                    delete obj[this._sTag];
                };
                return WeakMap;
            }());
            Utils.WeakMap = WeakMap;
            // if WeakMap is implemented natively by the current
            // JS engine, use it instead of the clumsy polyfill
            Utils.WeakMap = !Web.isUnitTested && Web.window['WeakMap'] || WeakMap;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="Command.ts" />
/// <reference path="Event.ts" />
/// <reference path="RefCountedSubscription.ts" />
/// <reference path="WeakMap.ts" />
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * An observable property.
             *
             * An owner of this property can change its value, while others get
             * a read-only version of it and can subscribe to changes of its value.
             *
             * In this example a constructor of class Person creates an observable
             * property "name" and exposes its read-only version in its interface:
             *
             *      var name = Property();
             *      name.set('John Doe');
             *
             *      return {
             *          name: name.asReadOnly()
             *      };
             *
             * The users of the Person subscribe to the property and get notified
             * when the person property is changed:
             *
             *      var person = Person(...);
             *      person.name.changed(function (name) {
             *          console.log('New name is', name);
             *      });
             *
             * So whenever the Person invokes name.set('NewName'), the new value
             * gets printed to the console log.
             *
             * This example demonstrates how the view layer binds to the model layer.
             * The model layer in turn subscribes to the stack layer via event mechanism
             * and update the model properties when it get events from the stack.
             *
             */
            function Property(opts) {
                return PropertyImpl(opts);
            }
            Utils.Property = Property;
            /** If present, Property::call adds itself to this list,
                which is used to implement things like Property.observe. */
            var rdlog;
            // tells how many calls to .set(...) are in progress
            var psetc = new Utils.WeakMap();
            var PropertyImpl = (function () {
                function PropertyImpl(opts) {
                    var self = pm_property;
                    var fnGet = opts && opts.get;
                    var fnSet = opts && opts.set;
                    var isReadOnly = opts && opts.readOnly;
                    if (opts && opts.value !== void 0)
                        self._value = opts.value; // undefined means no value
                    if (opts && opts.reason !== void 0)
                        self.reason = opts.reason;
                    if (opts && opts.check)
                        self._check = opts.check;
                    if (fnGet)
                        self._getter = Utils.async(fnGet);
                    if (isReadOnly)
                        self._ro = self;
                    if (fnSet)
                        self._setter = Utils.async(fnSet, 'sync');
                    if (opts && opts.subscribed)
                        self._subscribed = opts.subscribed;
                    if (opts && opts.unsubscribed)
                        self._unsubscribed = opts.unsubscribed;
                    // This trick is deeper than it might look.
                    // Read the comment for Property.prototype.
                    Utils.setPrototypeOrExtend(self, Property.prototype);
                    Utils.extend(self, {
                        get: Utils.isCommand(fnGet) ?
                            Utils.Command(self._getAsync, fnGet.enabled) :
                            Utils.EnabledCommand(self._getAsync),
                        set: isReadOnly ? Utils.DisabledAsyncCommand() :
                            Utils.isCommand(fnSet) ? Utils.Command(self._setAsync, fnSet.enabled) :
                                Utils.EnabledCommand(self._setAsync)
                    });
                    Object.defineProperty(self, 'changed', {
                        get: self._getChanged
                    });
                    // this function represents the read-write instance of the property
                    // and at the same time acts as its getter and setter
                    function pm_property(value, reason) {
                        if (arguments.length == 0) {
                            if (rdlog)
                                rdlog.push(self);
                            return self._value;
                        }
                        else {
                            self._write(value, reason);
                            return this;
                        }
                    }
                    return self;
                }
                PropertyImpl.prototype.toString = function () {
                    return '[Property: value = ' + this._value + ']';
                };
                /** Simulates overloading the || operator. */
                PropertyImpl.prototype.or = function (p) {
                    return ComputedProperty([this, p], function (a, b) { return a || b; });
                };
                /** Simulates overloading the && operator. */
                PropertyImpl.prototype.and = function (p) {
                    return ComputedProperty([this, p], function (a, b) { return a && b; });
                };
                /**
                 * Creates a new property by applying the given function to the value of this property.
                 * The created property can be observed and fetched and the requests will be properly
                 * redirected to the original property.
                 *
                 *     var p1 = Property();
                 *     var p2 = p1.map(x => Math.pow(2, x));
                 *
                 *     p1(3);
                 *     p2() == 8;
                 *
                 * The created property is read-only because it's usually not possible to "unmap"
                 * values from the created property to the original one. However if the inverse mapping
                 * function is provided, the created property becomes writable:
                 *
                 *     var p1 = Property();
                 *     var p2 = p1.map(x => Math.pow(2, x), y => Math.log(y, 2));
                 *
                 *     p2(8);
                 *     p1() == 3;
                 */
                PropertyImpl.prototype.map = function (fn, ifn) {
                    var self = this, s, p = Property({
                        get: Utils.Command(function () { return self.get().then(fn); }, self.get.enabled),
                        subscribed: function () { return s = self.subscribe(); },
                        unsubscribed: function () { return s.dispose(); }
                    });
                    self.changed(function (value, reason) {
                        p(fn(value), reason);
                    });
                    return p.fork(Utils.Command(function (value) { return self.set(ifn(value)).then(fn); }, ifn ? self.set.enabled : ConstProperty(false)));
                };
                /**
                 * Adds a listener to the given value.
                 *
                 * Specifies a callback to be invoked when the property obtains the given value:
                 *
                 *     state.when("Disconnected", function (reason, oldState) {
                 *         // handling of the Disconnected state
                 *     });
                 *
                 * If the callback needs to handle multiple values, it's possible to write a
                 * predicate function that would recognize these values:
                 *
                 *     anyOf = vs => v => vs.indexOf(v) >= 0;
                 *     state.when(anyOf("Connected", "Disconnected"), function (reason) {
                 *         // the state is either Connected or Disconnected
                 *     });
                 *
                 * To remove the event listener invoke the dispose method:
                 *
                 *     sub = state.when("Connected", fn);
                 *     sub.dispose();
                 *
                 * Note, that the callback is invoked synchronously immediately after it's added
                 * if the property already had a value and thus an attempt to dispose the listener
                 * inside the callback won't work:
                 *
                 *     p = Property();
                 *     p(123);
                 *     s = p.when(123, function () {
                 *         s.dispose(); // => s is undefined at the moment
                 *     });
                 *
                 * A workaround is to dispose the listener at the next event cycle:
                 *
                 *     s = p.when(123, function () {
                 *         setTimeout(s.dispose, 0);
                 *     });
                 *
                 * Or invoke this.dispose() inside the callback, as this refers to the created
                 * subscription object:
                 *
                 *     p.when(123, function () {
                 *         // do something
                 *         this.dispose();
                 *     });
                 *
                 * Notice, that if the callback was created via .bind in order to overwrite `this`,
                 * it won't be possible to invoke the .dispose method.
                 */
                PropertyImpl.prototype.when = function (value, handler) {
                    var changed = this.changed;
                    var sub = {
                        dispose: function () { return changed.off(fn); }
                    };
                    var matches = Utils.isFunction(value) ?
                        value :
                        function (v) { return v === value; };
                    function fn(newValue, reason, oldValue) {
                        if (matches(newValue))
                            handler.call(sub, reason, oldValue);
                    }
                    changed(fn);
                    return sub;
                };
                /**
                 * Adds a one-time listener.
                 *
                 * Specifies a callback to be invoked once the property obtains the given value:
                 *
                 *     state.once("Disconnected", function (reason, oldState) {
                 *         // handling of the Disconnected state
                 *     });
                 *
                 * After the callback is invoked, it's removed from the event listeners.
                 * If the callback needs to handle multiple values, it's possible to write a
                 * predicate function that would recognize these values:
                 *
                 *     anyOf = vs => v => vs.indexOf(v) >= 0;
                 *     state.once(anyOf("Connected", "Disconnected"), function (reason) {
                 *         // the state is either Connected or Disconnected
                 *     });
                 *
                 * To remove the event listener before it's invoked, use the dispose method:
                 *
                 *     sub = state.once("Connected", fn);
                 *     sub.dispose();
                 */
                PropertyImpl.prototype.once = function (value, callback) {
                    return this.when(value, function () {
                        this.dispose();
                        callback.apply(null, arguments);
                    });
                };
                /**
                 * Returns a boolean property, which indicates whether the value of self property equals to the given value.
                 * The boolean property always gets updated when the self property changes.
                 */
                PropertyImpl.prototype.equals = function (value) {
                    return this.map(function (v) { return v == value; });
                };
                PropertyImpl.prototype.equalsAny = function () {
                    var array = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        array[_i] = arguments[_i];
                    }
                    return this.map(function (value) { return Utils.contains(array, function (x) { return x == value; }); });
                };
                PropertyImpl.prototype.fork = function (setter) {
                    var self = this;
                    var sub;
                    var enabled = Utils.isProperty(setter) ? setter : setter.enabled || ConstProperty(true);
                    var isReadOnly = enabled === ConstProperty(false);
                    var p = Property({
                        value: self._value,
                        reason: self.reason,
                        readOnly: isReadOnly,
                        set: isReadOnly ? null :
                            Utils.isProperty(setter) ? Utils.Command(function (v, r) { return self.set(v, r); }, enabled) :
                                Utils.Command(function (v, r) { return Utils.async(setter)(v, r).then(function (v) { return self.set(v, r); }); }, enabled),
                        get: self.get.bind(self),
                        subscribed: function () { return sub = self.subscribe(); },
                        unsubscribed: function () { return sub.dispose(); }
                    });
                    (self._forks = self._forks || []).push(p);
                    return p;
                };
                /**
                 * Returns a read-only property.
                 *
                 * The value of the read-only property can be modified only by its
                 * creator (this Property object).
                 *
                 * The read-only property allows the short-hand syntax to get a value
                 * and to convert it to a string:
                 *
                 *     var p = Property({ value: 123 }).asReadOnly();
                 *
                 *     assert(p() == 123);
                 *     assert(p == '123'); // instead of p().toString()
                 *
                 * The read-only property has the same interface as the regular property,
                 * but its .set command is disabled.
                 */
                PropertyImpl.prototype.asReadOnly = function () {
                    var self = this;
                    if (!self._ro)
                        self._ro = self.fork(Utils.DisabledAsyncCommand());
                    return self._ro;
                };
                PropertyImpl.prototype.observed = function () {
                    var self = this, changed = self._changed;
                    return changed && changed.observed();
                };
                /**
                 * Tells the property to keep its value always up to date.
                 *
                 * This method should be invoked if the up to date property value is needed at all times.
                 * The difference between .subscribe and .get is that .get fetches the value once, while
                 * .subscribe keeps the value always up to date. A call to .subscribe is generally heavier
                 * than a call to .get. Typically it's used to create a presence subscription:
                 *
                 *     var sub = person.status.subscribe();
                 *     person.status.changed(value => console.log(value));
                 *     setTimeout(sub.dispose, 10000); // unsubscribe after 10 seconds
                 *
                 * If the property value is needed only once, it's better to use .get.
                 *
                 * The first call to this method notifies the property's owner via the `subscribed` hook.
                 * After the last subscription is disposed, the property's owner is notified via the `unsubscribed` hook.
                 */
                PropertyImpl.prototype.subscribe = function (dt) {
                    var self = this;
                    // the first call to .subscribe creates a subscription object
                    var sub = new Utils.RefCountedSubscription({
                        unsubscribed: self._unsubscribed,
                        subscribed: self._subscribed,
                        updated: function () { return self.get(); }
                    });
                    // all subsequent calls will be handled by that object: see how
                    // the .subscribe method is being replaced here
                    self.subscribe = function (dt) { return sub.subscribe(dt); };
                    return self.subscribe(dt);
                };
                /**
                 * Changes the value bypassing the custom setter.
                 * This method isn't recommended to use because it breaks encapsulation.
                 */
                PropertyImpl.prototype._set = function (value, reason) {
                    var self = this, oldValue = self._value, i, forks = self._forks, changed = self._changed;
                    if (!self._same(value, reason)) {
                        self._value = value;
                        self.reason = reason;
                        if (changed)
                            changed.fire(value, reason, oldValue);
                        if (forks) {
                            for (i = 0; i < forks.length; i++)
                                forks[i]._set(value, reason);
                        }
                    }
                    return value;
                };
                PropertyImpl.prototype._same = function (value, reason) {
                    var self = this;
                    // TODO: the current logic will fire a changed event in the
                    // (val, oldReason) => (val, undefined) transition, which might
                    // not be expected. In fact, the idea that a different reason code
                    // would trigger the changed event to be fired needs to be revisited.
                    // Unfortunately, the SDK currently has code that depends on such
                    // event firing (see ChatService.start and AudioVideoModality.start),
                    // so we need to reconsider this logic in the future.
                    return Utils.deepEqual(value, self._value) && Utils.deepEqual(reason, self.reason);
                };
                PropertyImpl.prototype._getChanged = function () {
                    var self = this;
                    if (!self._changed) {
                        self._changed = new Utils.Event({
                            context: self,
                            added: self._listenerAdded
                        });
                    }
                    // it might be tempting to replace the property getter
                    // with the actual value which is known now by using 
                    // Object.defineProperty and thus avoid calling this getter
                    // later, but the surprising fact is that such an
                    // "optimization" makes the property with a listener about
                    // 1.5x heavier and about 1.5x slower
                    return self._changed.observer;
                };
                PropertyImpl.prototype._listenerAdded = function (listener) {
                    var self = this, changed = self._changed, value = self._value, reason = self.reason;
                    if (value !== void 0)
                        // Event::_invoke knows better how to invoke a listener properly
                        changed._invoke(listener, [value, reason]);
                };
                PropertyImpl.prototype._getAsync = function () {
                    var self = this, getter = self._getter, value = self._value;
                    if (!getter)
                        return value;
                    if (!self._dfdget)
                        self._dfdget = getter.call(self, value, self.reason);
                    return self._dfdget.then(function (value) {
                        self._dfdget = null;
                        self._set(value, self.reason);
                        return self._value;
                    }, function (error) {
                        // it can be nulled in a nicer way by .finally(...)
                        // at the expense of creating an extra promise which
                        // is not acceptable in Property::get calls as they
                        // are made frequently
                        self._dfdget = null;
                        throw error;
                    });
                };
                PropertyImpl.prototype._setAsync = function (value, reason) {
                    var self = this, check = self._check, setter = self._setter;
                    Utils.assert(arguments.length > 0);
                    this._scheck(value);
                    if (self._same(value, reason))
                        return value;
                    if (check)
                        check(value);
                    // _set could be invoked once at the price of always creating
                    // an extra task which would make the whole property model a bit slower
                    return setter ?
                        this._sinvoke(value, reason) :
                        self._set(value, reason);
                };
                PropertyImpl.prototype._write = function (value, reason) {
                    var self = this, check = self._check, setter = self._setter;
                    this._scheck(value);
                    if (self._same(value, reason))
                        return;
                    if (check)
                        check(value);
                    if (!self.set.enabled())
                        throw Error('This is a read-only property.');
                    // obj.prop(123) is a shortcut to obj.prop.set(123)
                    // except that it returns the owner object `obj`
                    // note, that f.set returns a promise; also
                    // `update` could be invoked once at the price of always creating
                    // an extra task which would make the whole property model a bit slower
                    return setter && reason !== Property.sUpdated ?
                        this._sinvoke(value, reason) :
                        self._set(value, reason);
                };
                PropertyImpl.prototype._scheck = function (value) {
                    if (psetc.get(this)) {
                        try {
                            console.warn('Property::set(' + value + ') is not re-entrant: simultaneous calls interfere with each other.');
                        }
                        catch (_) {
                        }
                    }
                };
                PropertyImpl.prototype._sinvoke = function (value, reason) {
                    var _this = this;
                    var promise = this._setter(value, reason).then(function (value) { return _this._set(value, reason); });
                    if (!Web.isUnitTested && Property.srcheck) {
                        // attaching this counter like this._n would significantly
                        // increase the memory footprint of the property object
                        var n = psetc.get(this) || 0;
                        psetc.set(this, n + 1);
                        promise.finally(function () {
                            var n = psetc.get(_this);
                            if (n == 1)
                                psetc.delete(_this);
                            else
                                psetc.set(_this, n - 1);
                        });
                    }
                    return promise;
                };
                return PropertyImpl;
            }());
            __decorate([
                Utils.async
            ], PropertyImpl.prototype, "_getAsync", null);
            __decorate([
                Utils.async.bind('sync')
            ], PropertyImpl.prototype, "_setAsync", null);
            // The created property object must be a function with a few extra methods.
            // It also must have at least .call, .apply and .bind methods that all functions have,
            // as the created property object can be used as a function. At the same time some
            // browsers do not support replacing prototype of a function and in such browsers
            // changing the prototype is replacing with copying all the methods from the desired
            // property's prototype object. This works because if replacing the prototype is not
            // supported, then the created property object remains a regular function with its
            // original prototype with .call, .bind and .apply methods, and is extended with custom
            // methods. This is why property objects behave the same way in old and new browsers,
            // though employ quite different techniques to achieve that.
            Property.prototype = Utils.extend(function () { }, PropertyImpl.prototype, { constructor: Property });
            (function (Property) {
                // Enables the re-entrance check for .set(...) calls:
                // this check creates a promise object at every call.
                Property.srcheck = false;
            })(Property = Utils.Property || (Utils.Property = {}));
            /**
             * A read only property with the given value.
             * It also acts as a cache of created const property objects.
             */
            function ConstProperty(value, reason) {
                if (reason === void 0) {
                    if (value === null)
                        return Property['null'];
                    if (value === true)
                        return Property['true'];
                    if (value === false)
                        return Property['false'];
                }
                return Property({
                    value: value,
                    reason: reason,
                    readOnly: true
                });
            }
            Utils.ConstProperty = ConstProperty;
            (function (Property) {
                // TODO: This thing is deprecated and shouldn't be used in new code.
                //
                // If a property was created with an overridden .set, i.e. p = Property({ set: fn }),
                // then in order to change the property value without triggering the custom setter
                // the owner of the property needs to use some kind of backdoor and this sUpdated
                // is this backdoor, as p.set(val, sUpdated) changes the value without invoking fn.
                //
                // A cleaner solution is to fork a property and give a custom setter to that property:
                //
                //  var pInternal = Property();
                //  var pExternal = pInternal.fork(fnSet);
                //
                // This way the owner of the property can change the value of the internal property
                // which doesn't have custom .set, while a consumer gets an external version of the property
                // with overridden .set and .get.
                Property.sUpdated = {};
                // The const true and false properties are also regular properties
                // with .get and .set commands. These commands, in turn, are regular
                // commands that have the .enabled property which is either the const true
                // or the const false property. To break this recursion, the const true
                // and false properties are created once with .get and .set commands
                // without the .enabled property and after they are created, their .get and
                // .set commands are given the .enabled properties. Thus the structure
                // of the created two properties look like this:
                //
                //      <t> = {
                //          get: { enabled: <t> },
                //          set: { enabled: <f> }
                //      };
                //
                //      <f> = {
                //          get: { enabled: <t> },
                //          set: { enabled: <f> }
                //      };
                //
                // This makes an impression that there is an infinitely long chain of
                // someProperty.get.enabled.set.enabled.set.enabled.get.enabled... while in
                // fact this chain is a loop between the two const properties.
                var $true = Property({ value: true, readOnly: true });
                var $false = Property({ value: false, readOnly: true });
                Property['true'] = $true;
                Property['false'] = $false;
                $true.get.enabled = $true;
                $true.set.enabled = $false;
                $false.get.enabled = $true;
                $false.set.enabled = $false;
                Utils.DisabledAsyncCommand.instance.enabled = $false;
                var $null = Property({ value: null, readOnly: true });
                Property['null'] = $null;
            })(Property = Utils.Property || (Utils.Property = {}));
            (function (Property) {
                /**
                 * Adds a callback to the .changed event of several properties at once.
                 * The callback is invoked whenever any property in the list changes.
                 *
                 *      const sub = Property.observe([p1, p2], (value1, value2) => {
                 *          ...
                 *      });
                 *
                 * The attached callback can be then detached from all the properties:
                 *
                 *      sub.dispose();
                 *
                 * If an empty array of deps is passed, the `observe` acts like ko.computed:
                 * it detects all deps, subscribes to them and unsubscribes from the list changes.
                 */
                function observe(properties, callback) {
                    if (properties.length == 0) {
                        observe2(callback);
                        return new Utils.Subscription(Utils.noop);
                    }
                    // note, that this `observe` essentially aggregates .changed events
                    // from the given properties, so an even more generic implementation
                    // would look like Event.all([p1.changed, p2.changed], callback); it's
                    // not clear, though, what to do with multiple event arguments
                    var psubs = properties.map(function (p) {
                        return p.changed(function () {
                            var values = properties.map(function (p) { return p(); });
                            callback.apply(null, values);
                        });
                    });
                    return new Utils.Subscription(function () {
                        for (var _i = 0, psubs_1 = psubs; _i < psubs_1.length; _i++) {
                            var s = psubs_1[_i];
                            s.dispose();
                        }
                    });
                }
                Property.observe = observe;
                function observe2(callback) {
                    var deps = [];
                    function refresh() {
                        // collect new deps
                        Utils.assert(!rdlog);
                        rdlog = [];
                        callback();
                        var newDeps = rdlog;
                        rdlog = null;
                        // unsubscribe from old deps
                        for (var _i = 0, deps_1 = deps; _i < deps_1.length; _i++) {
                            var p = deps_1[_i];
                            if (newDeps.indexOf(p) < 0)
                                p.changed.off(refresh);
                        }
                        // subscribe to new deps
                        for (var _a = 0, newDeps_1 = newDeps; _a < newDeps_1.length; _a++) {
                            var p = newDeps_1[_a];
                            if (deps.indexOf(p) < 0)
                                p.changed.on(refresh);
                        }
                        deps = newDeps;
                    }
                    refresh(); // collect initial deps
                }
            })(Property = Utils.Property || (Utils.Property = {}));
            /**
             * A property that contains an numeric value.
             * Usually it contains an integer value:
             *
             *      p = NumProperty(0);
             *      p.inc(); // p() == 1
             *      p.dec(); // p() == 2
             *
             * @method inc
             * @method dec
             *
             */
            function NumProperty(value, reason) {
                var p = Property({ value: value, reason: reason });
                // note, that p.asReadOnly() drops these
                // two methods which is fine because a read
                // only property cannot be incremented or
                // decremented
                p.inc = function () { return p(p() + 1); };
                p.dec = function () { return p(p() - 1); };
                return p;
            }
            Utils.NumProperty = NumProperty;
            /**
             * A property that contains a boolean value.
             */
            function BoolProperty(value, reason) {
                var p = Property({ value: value, reason: reason });
                p.not = function () { return p.map(function (x) { return !x; }); };
                return p;
            }
            Utils.BoolProperty = BoolProperty;
            /**
             * Constructs a property which values depends on a few other properties.
             *
             * Note, that a computed property that depends on only one property
             * can be constructed with a call to Property::map; a computed property
             * that depends on two properties corresponds to an overloaded operator
             * of the Property class (which isn't possible in JS as of today).
             *
             *      var a = Property({ value: 1 });
             *      var b = Property({ value: 2 });
             *      var c = ComputedProperty(a, b, (x, y) => x + y);
             *
             * In the knockout library there is something similar. Perhaps, the only
             * major difference between this thing and ko.observable is that ko can
             * figure out the list of dependencies on its own, which is very convenient:
             *
             *      var a = ko.observable(1);
             *      var b = ko.observable(2);
             *      var c = ko.computed(() => a() + b());
             *
             * This can be achieved by passing the empty list of deps:
             *
             *      var c = ComputedProperty([], () => a() + b());
             *
             */
            function ComputedProperty(properties, fn) {
                var psubs;
                var computed = Property({
                    get: function () {
                        var pgets = Utils.map(properties, function (p) { return p.get(); });
                        return Utils.Task.waitAll(pgets).then(function (values) {
                            return fn.apply(null, values);
                        });
                    },
                    subscribed: function () {
                        psubs = Utils.map(properties, function (p) { return p.subscribe(); });
                    },
                    unsubscribed: function () {
                        Utils.foreach(psubs, function (s) { return s.dispose(); });
                    }
                });
                Property.observe(properties, function () {
                    // the current version of ts we are using (1.5.0-beta)
                    // converts rest arguments (...values) to an array first
                    // which would be terribly inefficient if the array is
                    // only passed as-is to another function via .apply(...)
                    computed(fn.apply(null, arguments));
                });
                // if we later decide to somehow make the returned property writable,
                // this will be the right place for the change: asReadOnly will need
                // to be replaced with fork(...)
                return computed.asReadOnly();
            }
            Utils.ComputedProperty = ComputedProperty;
            (function (Property) {
                Property.computed = ComputedProperty;
                Property.bool = BoolProperty;
                Property.just = function (value) { return Property({ value: value }); };
                Property.readonly = ConstProperty;
                Property.numeric = NumProperty;
            })(Property = Utils.Property || (Utils.Property = {}));
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="base.ts" />
/// <reference path="defer.ts" />
/// <reference path="Promise.ts" />
/// <reference path="Property.ts" />
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * An observable ordered collection of items.
             *
             * A creator of this collection can add items to it, while others get a read-only
             * version of the collection and can subscribe to changes in it.
             *
             * In this example a constructor of class Conversation creates an observable
             * collection "messages" and exposes its read-only version in its interface:
             *
             *      var messages = Collection();
             *      messages.add('First Message');
             *
             *      return {
             *          messages: messages.asReadOnly()
             *      };
             *
             * The users of the Conversation subscribe to the collection and get notified
             * when the Conversation adds items to it:
             *
             *      var conversation = Conversation(...);
             *      conversation.chatService.messages.added(function (message) {
             *          console.log('New message:', message);
             *      });
             *
             * So whenever the Conversation invokes messages.add('Another Message'), the new message
             * gets printed to the console log.
             *
             * This example demonstrates how the view layer binds to the model layer.
             * The model layer in turn subscribes to the stack layer via event mechanism
             * and update the model properties when it get events from the stack.
             *
             */
            function Collection(options) {
                return CollectionImpl(options);
            }
            Utils.Collection = Collection;
            var CollectionImpl = (function () {
                function CollectionImpl(options) {
                    var self = pm_collection;
                    self._ = Utils.extend({}, options);
                    var _ = self._;
                    if (options && options.get)
                        _.get = Utils.async(options.get);
                    _.vals = []; // Map<Index, Value>
                    _.keys = []; // Map<Index, Key>
                    _.idxs = {}; // Map<Key, Index>
                    // this function represents the read-write instance of the property
                    // and at the same time acts as its getter and setter, which takes
                    // ar array of items and replaces contents of the collection with them
                    function pm_collection(key) {
                        if (arguments.length == 0) {
                            return self._asArray();
                        }
                        else if (Utils.isArray(key)) {
                            self.empty();
                            self._addArray(key);
                            return this;
                        }
                        else {
                            return self._getFromCache(key);
                        }
                    }
                    Utils.setPrototypeOrExtend(self, Collection.prototype);
                    self._init();
                    return self;
                }
                /**
                 * Tells the collection to keep its list of items always up to date.
                 *
                 * This method should be invoked if the up to date list of items is needed at all times.
                 * The difference between .subscribe and .get is that .get fetches the list once, while
                 * .subscribe keeps the list always up to date. A call to .subscribe is generally heavier
                 * than a call to .get.
                 *
                 *     var sub = client.devices.subscribe();
                 *     client.devices.changed(items => console.log(items));
                 *     setTimeout(sub.dispose, 10000); // unsubscribe after 10 seconds
                 *
                 * If the list of items is needed only once, it's better to use .get.
                 *
                 * The first call to this method notifies the collection's owner via the `subscribed` hook.
                 * After the last subscription is disposed, the collection's owner is notified via the `unsubscribed` hook.
                 */
                CollectionImpl.prototype.subscribe = function (dt) {
                    var self = this, _ = self._;
                    // the first call to .subscribe creates a subscription object
                    var sub = new Utils.RefCountedSubscription({
                        unsubscribed: _.unsubscribed,
                        subscribed: _.subscribed,
                        updated: function () { return self.get(); }
                    });
                    // all subsequent calls will be handled by that object: see how
                    // the .subscribe method is being replaced here
                    self.subscribe = function (dt) { return sub.subscribe(dt); };
                    return self.subscribe(dt);
                };
                CollectionImpl.prototype.observed = function () {
                    var _ = this._, added = _.added, removed = _.removed, changed = _.changed;
                    return added && added.observed() ||
                        removed && removed.observed() ||
                        changed && changed.observed();
                };
                /**
                 * Adds an item to the collection.
                 *
                 * If key is omitted, a random key is generated.
                 * If index is omitted, the item is appended to the end of the collection.
                 */
                CollectionImpl.prototype.add = function (val, key, idx) {
                    var _ = this._, n = _.vals.length;
                    key = key || (_.key ? _.key(val) : Utils.random());
                    if (key in _.idxs)
                        throw Utils.EAlreadyExists(key);
                    idx = Utils.isInteger(idx) ? idx : n;
                    if (idx < 0)
                        idx = 0; // .add(..., -123) works as .add(..., 0)
                    if (idx > n)
                        idx = n; // .add(..., +Infinity) works as .add(..., .size())
                    this._insert(val, key, idx);
                    if (_.size)
                        _.size.inc();
                    if (_.added)
                        _.added.fire(val, key, idx);
                    if (_.changed)
                        _.changed.fire();
                    return key;
                };
                /**
                 * Removes an item by key or index.
                 *
                 * .remove(key) removes an item by its key, which is a string.
                 * .remove(idx) removes an item from the given index.
                 */
                CollectionImpl.prototype.remove = function (key) {
                    var _ = this._, idx, val, i;
                    if (Utils.isInteger(key)) {
                        idx = key;
                        key = _.keys[idx];
                    }
                    else {
                        idx = _.idxs[key];
                    }
                    val = _.vals[idx];
                    if (idx >= 0 && idx < _.vals.length) {
                        for (i = idx + 1; i < _.keys.length; i++)
                            _.idxs[_.keys[i]]--;
                        Utils.removeAt(_.vals, idx);
                        Utils.removeAt(_.keys, idx);
                        delete _.idxs[key];
                        if (_.size)
                            _.size.dec();
                        if (_.removed)
                            _.removed.fire(val, key, idx);
                        if (_.changed)
                            _.changed.fire();
                    }
                };
                /** Removes all items chosen by a predicate function.
                    Returns the number of items removed. */
                CollectionImpl.prototype.removeAll = function (predicate) {
                    var _ = this._, n = _.vals.length, rmkeys = [];
                    for (var i = 0; i < n; i++) {
                        var v = _.vals[i];
                        var k = _.keys[i];
                        if (predicate(v))
                            rmkeys.push(k);
                    }
                    for (var _i = 0, rmkeys_1 = rmkeys; _i < rmkeys_1.length; _i++) {
                        var key = rmkeys_1[_i];
                        this.remove(key);
                    }
                    return rmkeys.length;
                };
                /**
                 * Returns an item associated with the specified key or index.
                 *
                 * .get() fetches all the items and returns them as an array.
                 * .get(key) fetches an item with the given key, which is a string.
                 * .get(index) fetches an item with the given index.
                 *
                 * Multiple calls to .get(...) invoke the custom getter, if it's set, only once.
                 */
                CollectionImpl.prototype.get = function (key) {
                    // `get` is wrapped by `async` so it may return values and promises
                    // if `key` is a string - return an item associated with this key
                    // if `key` is a number - return an item associated with this zero-based index
                    // if `key` is undefined - return all items as an array
                    var self = this, _ = self._, get = _.get, promise;
                    if (get && !_.dfdget)
                        _.dfdget = get();
                    if (_.dfdget) {
                        promise = _.dfdget.then(function (items) {
                            _.dfdget = null;
                            return self._setNewItems(items);
                        }, function (error) {
                            _.dfdget = null;
                            throw error;
                        });
                    }
                    return Utils.Task.wait(promise).then(function () {
                        return Utils.isVoid(key) ? self._asArray() : self._getFromCache(key);
                    });
                };
                CollectionImpl.prototype.index = function (key) {
                    return this._.idxs[key];
                };
                CollectionImpl.prototype.key = function (idx) {
                    return this._.keys[idx];
                };
                CollectionImpl.prototype.empty = function () {
                    var _ = this._, i;
                    if (_.removed) {
                        for (i = 0; i < _.vals.length; i++)
                            _.removed.fire(_.vals[i], _.keys[i]);
                    }
                    _.vals = [];
                    _.keys = [];
                    _.idxs = {};
                    if (_.size)
                        _.size(0);
                    if (_.changed)
                        _.changed.fire();
                };
                /** Returns a read-only version of the collection. */
                CollectionImpl.prototype.asReadOnly = function () {
                    var self = this, readonly = ro;
                    function ro(key) {
                        return arguments.length == 0 ?
                            self._asArray() :
                            self._getFromCache(key);
                    }
                    Utils.setPrototypeOrExtend(readonly, self);
                    readonly._init();
                    // the delete operator won't work deletes a member 
                    // from the object, but not from its prototype
                    readonly.add = null;
                    readonly.remove = null;
                    readonly.empty = null;
                    return readonly;
                };
                /**
                 * Creates a fork of the collection with customized .add and .remove commands.
                 *
                 * All the forks share the same state and have the same set of items.
                 * In fact they are the same instance of the collection.
                 * Different forks have different customized .add and .remove commands
                 * that can have custom logic and can be async.
                 */
                CollectionImpl.prototype.fork = function (methods) {
                    var self = this;
                    var writable = wr;
                    function wrap(fn) {
                        return Utils.isCommand(fn) ? Utils.Command(Utils.async(fn), fn.enabled) :
                            Utils.isFunction(fn) ? Utils.EnabledCommand(Utils.async(fn)) :
                                Utils.DisabledAsyncCommand(Utils.ENotSupported());
                    }
                    function wr(key) {
                        return arguments.length == 0 ? self() : self(key);
                    }
                    Utils.setPrototypeOrExtend(writable, self);
                    Utils.extend(writable, {
                        add: wrap(methods.add),
                        remove: wrap(methods.remove)
                    });
                    writable._init();
                    return writable;
                };
                /** this method is deprecated; use .fork */
                CollectionImpl.prototype.asWritable = function (methods) {
                    return this.fork(methods);
                };
                CollectionImpl.prototype.toString = function () {
                    return '[Collection: ' + this.size() + ' items]';
                };
                CollectionImpl.prototype.each = function (fn) {
                    var _ = this._;
                    for (var i = 0; i < _.vals.length; i++)
                        fn(_.vals[i], _.keys[i]);
                    return this;
                };
                CollectionImpl.prototype.contains = function (predicate) {
                    var res = false;
                    // before making this function work with
                    // primitive values, consider collections that
                    // contain functions
                    this.each(function (val) {
                        if (predicate(val))
                            res = true;
                    });
                    return res;
                };
                /**
                 * Collects batches of changes and sends them to the callback every event cycle.
                 *
                 * Whenever an item is added to the collection or removed from it, the collection
                 * fires an appropriate event. However if the UI starts updating the DOM tree
                 * after every change, it may become pretty slow. It might be better to collect
                 * all changes made within a short period of time and then update the DOM tree once.
                 * This method starts listening to the changes in the collection, summarizes these
                 * changes and invokes the specified callback at the next event cycle:
                 *
                 *     var sub = conversations.observe(function (added, removed) {
                 *         foreach(added, function (conversation, key) {
                 *             console.log("conversation has been added");
                 *         });
                 *
                 *         foreach(removed, function (conversation, key) {
                 *             console.log("conversation has been removed");
                 *         });
                 *     });
                 *
                 *     // some time later...
                 *     sub.dispose();
                 *
                 * This theoretically allows to handle the list of changes and efficiently redraw the UI.
                 */
                CollectionImpl.prototype.observe = function (callback) {
                    var hTimer, source = this, added = {}, removed = {};
                    // TODO: This observe(...) function belongs to UI, but was implemented here.
                    // When ttt is recording and UI invokes this method on a collection wrapper,
                    // it uses setTimeout/clearTimeout functions defined by ttt: this is like UI
                    // calling ttt directly, making records in the trace. Making this method use
                    // the global setTimeout/clearTimeout functions effectively moves it to UI.
                    var _a = Skype['$window'] || Web.window, setTimeout = _a.setTimeout, clearTimeout = _a.clearTimeout;
                    function itemAdded(val, key) {
                        added[key] = val;
                        delete removed[key];
                        startTimer();
                    }
                    function itemRemoved(val, key) {
                        removed[key] = val;
                        delete added[key];
                        startTimer();
                    }
                    function startTimer() {
                        if (!hTimer) {
                            hTimer = setTimeout(function () {
                                var _added = added, _removed = removed;
                                added = {}; // callback may add an item indirectly
                                removed = {}; // callback may remove an item indirectly
                                hTimer = null;
                                callback(_added, _removed);
                            }, 0);
                        }
                    }
                    function stopTimer() {
                        if (hTimer) {
                            clearTimeout(hTimer);
                            hTimer = null;
                        }
                    }
                    source.added(itemAdded);
                    source.removed(itemRemoved);
                    return {
                        dispose: function () {
                            stopTimer();
                            source.added.off(itemAdded);
                            source.removed.off(itemRemoved);
                        }
                    };
                };
                /**
                 * Creates a collection with mapped items.
                 *
                 * source.map(fn) creates a collection in which all items satisfy the following
                 * condition: source.map(fn)(i) == fn(source(i)). The created collection is
                 * observable and correctly handles calls to .get and .subscribe by routing
                 * them to the source collection:
                 *
                 *     var phones = teluris.map(formatTelUriNicely);
                 *
                 * This example maps every tel uri, which looks like "tel:+1234...", to nicely
                 * looking phone numbers like "+1 (234) 456-7890", and the created collection
                 * remains observable and thus can be attached to UI.
                 */
                CollectionImpl.prototype.map = function (fn) {
                    var source = this, sub, mapped = Collection({
                        // the call to .get cannot be directly routed to the source
                        // collection because these collections have different items,
                        // despite these items have the same keys and the same order
                        get: function (src) {
                            return source.get().then(function () {
                                return mapped(src);
                            });
                        },
                        subscribed: function () {
                            sub = source.subscribe();
                        },
                        unsubscribed: function () {
                            sub.dispose();
                        }
                    });
                    source.added(function (val, key, idx) {
                        // it's important to preserve the order of items
                        mapped.add(fn(val), key, idx);
                    });
                    source.removed(function (val, key) {
                        mapped.remove(key);
                    });
                    // theoretically the mapped collection can be left writable
                    // if it was possible to "unmap" every item with the inverse
                    // mapping function; since an arbitrary function cannot be
                    // inversed, the caller would need to pass both mapping and
                    // inverse mapping function
                    return mapped.asReadOnly();
                };
                /**
                 * Creates a collection that doesn't have certain items.
                 *
                 * source.filter(fn) creates a collection which contains all the items from
                 * the source collection except certain items that are filtered out by the
                 * given predicate:
                 *
                 *     var activityItems = conversation.historyService.activityItems;
                 *     var messages = activityItems.filter(i => i.type() == "TextMessage");
                 *
                 * The order of items in the filtered collection is preserved. The created collection
                 * handles correctly calls to .get and .subscribe and remains observable and thus can
                 * be attached to UI.
                 */
                CollectionImpl.prototype.filter = function (fn) {
                    var source = this, sub, filtered = Collection({
                        get: function (src) {
                            return source.get().then(function () {
                                return filtered(src);
                            });
                        },
                        subscribed: function () {
                            sub = source.subscribe();
                        },
                        unsubscribed: function () {
                            sub.dispose();
                        }
                    });
                    source.added(function (val, key, idx) {
                        if (!fn(val))
                            return;
                        var si = idx + 1;
                        var sn = source.size();
                        // To preserve the original order of items find
                        // the closest item in the source collection which
                        // also exists in the filtered collection and insert
                        // the new item before that item.
                        while (si < sn && !fn(source(si)))
                            si++;
                        var fi = si < sn ?
                            filtered.index(source.key(si)) :
                            filtered.size();
                        filtered.add(val, key, fi);
                    });
                    source.removed(function (val, key) {
                        filtered.remove(key);
                    });
                    return filtered.asReadOnly();
                };
                /**
                 * Creates a sorted collection.
                 *
                 * It seems obvious that one collection exposed by the model layer can be displayed
                 * in different parts of UI in different ways: one UI element may need to sort items
                 * by one criteria, while another may need to use another criteria. To meet this
                 * requirement every collection exposed by the model need to have a method that
                 * creates another collection which is sorted:
                 *
                 *     var byName = persons.sort((p1, p2) => p1.displayName() < p2.displayName());
                 *     var byDept = persons.sort((p1, p2) => p1.department() < p2.department());
                 *
                 * The created sorted collections are observable and are updated whenever the source
                 * collection is updated, but in addition to that they are sorted.
                 */
                CollectionImpl.prototype.sort = function (isOrderCorrect) {
                    var unsorted = this, sub, sorted = Collection({
                        get: function (src) {
                            // the call cannot be directly routed to the unsorted collection
                            // because the order of items in the two collections is different
                            // and thus the same .get with the same index can return different items
                            return unsorted.get().then(function () {
                                return sorted(src);
                            });
                        },
                        subscribed: function () {
                            sub = unsorted.subscribe();
                        },
                        unsubscribed: function () {
                            sub.dispose();
                        }
                    });
                    function ord(x, y) {
                        // ord(x, y) = x @ y tells whether x can precede y in the ordered collection;
                        // essentially @ is a transitive relation over the set of items;
                        // a well behaved relation must allow either (x, y) or (y, x) for any given x and y;
                        // if, however, it allows neither, it can be assumed that it doesn't care;
                        return isOrderCorrect(x, y) || !isOrderCorrect(y, x);
                    }
                    unsorted.added(function (val, key, idx) {
                        var n = sorted.size(), i = 0;
                        // The @ relation splits the entire collection into several groups:
                        // items within a group can be placed in any order as @ cannot distinguish them,
                        // but the groups must come in a certain "ascending" order.
                        // Thus the first step before inserting a new item into the sorted collection
                        // is to find the appropriate group G for that item. This loop finds the leftmost
                        // boundary of the appropriate group.
                        while (i < n && !ord(val, sorted(i)))
                            i++;
                        // After the appropriate group G is found, the item can be theoretically
                        // inserted at any position within the group, i.e. at the beginning or at the end,
                        // however it's better to consider how items in the group are ordered in
                        // the unsorted collection. The group G can be called "sorted" if for any
                        // pair of items x and y from G, if x appears before y in G, then it also appears
                        // before y in the unsorted collection. To not break this property of G, the new
                        // item must be inserted at the right position and, obviously, there is only
                        // one such position. The loop below finds this only possible position.
                        // Thus this loop makes the sorting algorithm stable.
                        while (i < n && ord(sorted(i), val) && unsorted.index(sorted.key(i)) < idx)
                            i++;
                        sorted.add(val, key, i);
                    });
                    unsorted.removed(function (val, key) {
                        sorted.remove(key);
                    });
                    return sorted.asReadOnly();
                };
                /**
                 * Aggregates the items in the collection into an observable property.
                 *
                 * The key feature of this method is that it's like ko.computed observes
                 * the list of dependent properties and updates the aggregated value
                 * whenever any of the deps changes.
                 *
                 *      const values = Collection();
                 *      const product = values.reduce((val, prop) => val ? val * prop() : 0, 1);
                 *
                 *      const x = Property(); x.set(3);
                 *      const y = Property(); y.set(5);
                 *      const z = Property(); z.set(7);
                 *
                 *      values.add(x); // product() == 3
                 *      values.add(y); // product() == 3*5
                 *      values.add(z); // product() == 3*5*7
                 *
                 *      y.set(0); // product() == 0 and z is not even being observed
                 *      y.set(11); // product() == 3*11*7 and z is being observed again
                 *
                 * A possible application is computing the number of online users:
                 *
                 *      const nOnline = persons.reduce((n, p) => n + (!!p.status() == "Online"), 0);
                 *      nOnline.changed(n => document.title = n + " people online");
                 *
                 * This works as long as the computed value doesn't depend on some external source.
                 */
                CollectionImpl.prototype.reduce = function (aggregate, initialValue) {
                    var _this = this;
                    var aggregated = Utils.Property();
                    var values = this._.vals; // this ref never changes
                    Utils.Property.observe([], function () {
                        _this.size(); // the aggregated value depends on this property as well
                        var newValue = values.reduce(aggregate, initialValue);
                        aggregated(newValue); // this might result in other properties being read
                    });
                    return aggregated.asReadOnly();
                };
                CollectionImpl.prototype._init = function () {
                    var self = this;
                    Object.defineProperties(self, {
                        added: {
                            enumerable: true,
                            get: self._initAddedEvent
                        },
                        removed: {
                            enumerable: true,
                            get: self._initRemovedEvent
                        },
                        changed: {
                            enumerable: true,
                            get: self._initChangedEvent
                        },
                        size: {
                            enumerable: true,
                            get: self._initSizeProperty
                        }
                    });
                };
                CollectionImpl.prototype._getFromCache = function (key) {
                    var _ = this._;
                    return Utils.isString(key) ?
                        _.vals[_.idxs[key]] :
                        _.vals[key]; // get by index
                };
                CollectionImpl.prototype._setNewItems = function (newItems) {
                    var self = this, _ = self._, key;
                    if (!Utils.isDictionary(newItems))
                        return;
                    for (key in _.idxs)
                        if (!(key in newItems) || _.vals[_.idxs[key]] !== newItems[key])
                            self.remove(key);
                    for (key in newItems)
                        if (!(key in _.idxs))
                            self.add(newItems[key], key);
                };
                CollectionImpl.prototype._initAddedEvent = function () {
                    var self = this, _ = self._, name = 'added', val;
                    _[name] = _[name] || new Utils.Event({
                        context: self,
                        adding: self._addedListenerAdding
                    });
                    val = _[name].observer;
                    return val;
                };
                CollectionImpl.prototype._addedListenerAdding = function (listener) {
                    var self = this, _ = self._, event = _.added;
                    Utils.foreach(_.vals, function (v, i) {
                        event._invoke(listener, [v, _.keys[i], i]);
                    });
                };
                CollectionImpl.prototype._initRemovedEvent = function () {
                    var self = this, _ = self._, name = 'removed', val;
                    _[name] = _[name] || new Utils.Event();
                    val = _[name].observer;
                    return val;
                };
                CollectionImpl.prototype._initChangedEvent = function () {
                    var self = this, _ = self._, name = 'changed', val;
                    _[name] = _[name] || new Utils.Event({
                        context: self,
                        added: self._changedListenerAdded
                    });
                    val = _[name].observer;
                    return val;
                };
                CollectionImpl.prototype._changedListenerAdded = function (listener) {
                    var self = this, _ = self._, event = _.changed;
                    event._invoke(listener, []);
                };
                CollectionImpl.prototype._initSizeProperty = function () {
                    var self = this, _ = self._, name = 'size', val;
                    _[name] = _[name] || Utils.NumProperty(_.vals.length);
                    val = _[name].asReadOnly();
                    return val;
                };
                CollectionImpl.prototype._insert = function (val, key, idx) {
                    var i, _ = this._, n = _.vals.length;
                    for (i = idx; i < n; i++)
                        _.idxs[_.keys[i]]++;
                    Utils.insertAt(_.vals, idx, val);
                    Utils.insertAt(_.keys, idx, key);
                    _.idxs[key] = idx;
                };
                CollectionImpl.prototype._addArray = function (arr) {
                    for (var i = 0; i < arr.length; i++)
                        this.add(arr[i]);
                };
                CollectionImpl.prototype._asArray = function () {
                    return this._.vals.slice(0); // clone the array
                };
                return CollectionImpl;
            }());
            // Collections are functions and in order to behave like proper functions,
            // they need to have all the function's methods like .apply and .call.
            Collection.prototype = Utils.extend(function () { }, CollectionImpl.prototype, { constructor: Collection });
            (function (Collection) {
                // An empty read only collection is useful to create stubs
                // in place of real collections. Since two empty read only
                // collections cannot be distinguished, it's reasonable to
                // have only one instance of such a collection.
                Collection.empty = Collection().asReadOnly();
            })(Collection = Utils.Collection || (Utils.Collection = {}));
            function ConstCollection(items) {
                var collection = Collection();
                collection(items);
                return collection.asReadOnly();
            }
            Utils.ConstCollection = ConstCollection;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * A property that takes its value from another (source) property.
             *
             */
            function SourcedProperty(source) {
                var src, s, cs, isSubscribed = false, enabled = Utils.Property({ value: false }), setGates = [];
                var p = Utils.Property({
                    get: function () {
                        return src && src.get();
                    },
                    set: Utils.Command(function (value, reason) {
                        function updateSource(value, reason) {
                            return src.set(value, reason).then(function () { return p(); });
                        }
                        if (!src)
                            return;
                        /*
                         * This debouncing is necessary due to a bug caused by the interaction
                         * of SourcedProperty and Property. It is possible for 2 consecutive
                         * sets of a SourcedProperty to interfere with each other because the
                         * final ._set in Property after calling the SourcedProperty setter the
                         * first time combined with the ._set in the src changed listener of the
                         * SourcedProperty can produce inconsistent results if the calls to the
                         * setter of the src Property aren't debounced like this.
                         *
                         * This array of 'setGates' ensures that the calls to the src property
                         * setter occur in sequence whether the actual call to the setter is
                         * rejected or not, but returns the appropriately resolved or rejected promise
                         * to the caller of each setter.
                         */
                        var lastGate = setGates.length == 0 ?
                            Utils.Promise.resolve(null, 'sync') :
                            setGates[setGates.length - 1].promise;
                        setGates.push(new Utils.Task());
                        return lastGate.then(function () { return updateSource(value, reason); }).finally(function () {
                            setGates.shift().resolve();
                        });
                    }, enabled),
                    subscribed: function () {
                        isSubscribed = true;
                        s = src && src.subscribe();
                    },
                    unsubscribed: function () {
                        isSubscribed = false;
                        if (s) {
                            s.dispose();
                            s = null;
                        }
                    }
                });
                p.setSource = function (source) {
                    Utils.assert(Utils.isProperty(source) || !source);
                    if (src === source)
                        return;
                    src = source;
                    enabled(!!src);
                    if (cs) {
                        cs.dispose();
                        cs = null;
                    }
                    if (src) {
                        cs = src.changed(function (value, reason) {
                            p._set(value, reason);
                        });
                        if (src() === void 0)
                            p._set(src());
                    }
                    if (s) {
                        s.dispose();
                        s = null;
                    }
                    if (isSubscribed && src)
                        s = src.subscribe();
                    if (!src)
                        p._set(void 0);
                };
                p.setSource(source);
                return p;
            }
            Utils.SourcedProperty = SourcedProperty;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * A command that delegates its execution to another (source) command.
             *
             * @method setSource(source) - Sets source cmd
             *
             * NB: it is assumed that source command is not using "this" in its implementation -
             * its context is coming from the closures.
             *
             */
            function SourcedCommand() {
                var src, enabled = Utils.SourcedProperty();
                // cmd with undefined source is disabled
                enabled.setSource(Utils.ConstProperty(false));
                var cmd = Utils.Command(function () {
                    return src.apply(null, arguments);
                }, enabled);
                cmd.setSource = function (source) {
                    Utils.assert(Utils.isCommand(source) || !source);
                    src = source;
                    enabled.setSource(src ? src.enabled : Utils.ConstProperty(false));
                };
                return cmd;
            }
            Utils.SourcedCommand = SourcedCommand;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * A model composed of properties sourced by properties of another (source) model.
             *
             * @param {Model} model - A model used as a blueprint for sourced model construction.
             *
             * @method setSource(source) - Sets source model
             *
             */
            function SourcedModel(model) {
                var m = Utils.Model(Utils.map(model, function (member) {
                    return Utils.isProperty(member) ? Utils.SourcedProperty() :
                        Utils.isModel(member) ? SourcedModel(member) :
                            Utils.isCommand(member) ? Utils.SourcedCommand() :
                                // TODO: add collections
                                Utils.assert(false);
                }));
                Utils.setHiddenProperty(m, 'setSource', function (source) {
                    for (var i in m)
                        m[i].setSource(source && source[i]);
                });
                return m;
            }
            Utils.SourcedModel = SourcedModel;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="Collection.ts" />
/// <reference path="SourcedProperty.ts" />
/// <reference path="SourcedCommand.ts" />
/// <reference path="SourcedModel.ts" />
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            function Model(members) {
                return Utils.inherit(Model.prototype, members);
            }
            Utils.Model = Model;
            function toJSON(object, mask) {
                if (Utils.isModel(object))
                    return object.toJSON(mask);
                if (Utils.isCollection(object))
                    return Utils.map(object(), function (x) { return toJSON(x, mask); });
                if (Utils.isProperty(object))
                    return toJSON(object(), mask);
                if (Utils.isCommand(object))
                    return { enabled: !!object.enabled() };
                if (Utils.isFunction(object))
                    return { enabled: true };
                if (object instanceof Web.Date)
                    return object.toJSON();
                return object;
            }
            var BaseModel = (function () {
                function BaseModel() {
                }
                /**
                 * Takes a snapshot of the model object and returns
                 * it as a plain JS object with primitive properties.
                 * The `toJSON` name wasn't a good choice because it
                 * conflicts with the .toJSON method which is supposed
                 * to return a string and is used by JSON.stringify to
                 * adjust the generated json string; a more accurate
                 * name would be `snapshot`.
                 */
                BaseModel.prototype.toJSON = function (mask) {
                    return Utils.map(this, function (member, name) {
                        if (name == 'constructor')
                            return undefined;
                        var submask = mask && mask[name];
                        if (mask && !submask)
                            return undefined;
                        return toJSON(member, submask === true ? null : submask);
                    });
                };
                BaseModel.prototype.toString = function (indent) {
                    if (indent === void 0) { indent = 4; }
                    return JSON.stringify(this.toJSON(), null, indent)
                        .replace(/{\s*\n\s*("\w+"):\s*(\w+)\s*\n\s*}/gm, '{ $1: $2 }');
                };
                return BaseModel;
            }());
            __decorate([
                Utils.hidden
            ], BaseModel.prototype, "toJSON", null);
            __decorate([
                Utils.hidden
            ], BaseModel.prototype, "toString", null);
            Utils.BaseModel = BaseModel;
            Model.prototype = BaseModel.prototype;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * A pattern is an object with a parsing function that
             * reads a given input string from a given position,
             * parses it and returns whatever it has parsed with
             * the position where the parsing ended. A composition
             * of such parsing function constitutes an LL(k) recursive
             * descent parser.
             *
             */
            var Pattern = (function () {
                // the "private" modifier tells ts to create a class member with this name
                // and make an assignment in the constructor: this._exec = _exec
                function Pattern(_exec) {
                    this._exec = _exec;
                }
                // this method implements both signatures above; note that
                // the return type is "any" - that's the only common type
                // between T and [T, number]; also note the
                // default value for pos: ts determines the absence of the
                // parameter by comparing it with (void 0), not by checking
                // the number of arguments
                Pattern.prototype.exec = function (str, pos) {
                    if (pos === void 0) { pos = 0; }
                    var r = this._exec(str, pos);
                    if (arguments.length == 2)
                        return r;
                    if (!r || r[1] != str.length)
                        return null;
                    return r[0];
                };
                Pattern.prototype.then = function (fn) {
                    var _this = this;
                    return new Pattern(function (str, pos) {
                        // note, how the arrow function captures `this` from outside
                        var r = _this.exec(str, pos);
                        if (!r)
                            return null;
                        var res = r[0], end = r[1];
                        return [fn(res, str, pos, end), end];
                    });
                };
                Pattern.prototype.text = function () {
                    return this.then(function (res, str, pos, end) { return str.slice(pos, end); });
                };
                Pattern.prototype.select = function (key) {
                    return this.then(function (r) { return r[key]; });
                };
                // ts lacks a way to express the fact that this method
                // can  be called only if T is an array type, i.e. any[]
                Pattern.prototype.merge = function (sep) {
                    if (sep === void 0) { sep = ''; }
                    // ...so I had to trick ts and coerce T to any[]
                    return this.then(function (r) { return r.join(sep); });
                };
                Pattern.prototype.join = function (key, val) {
                    return this.then(function (r) {
                        var map = {};
                        for (var _i = 0, _a = r; _i < _a.length; _i++) {
                            var pair = _a[_i];
                            map[pair[key]] = pair[val];
                        }
                        return map;
                    });
                };
                return Pattern;
            }());
            Utils.Pattern = Pattern;
            /** txt = "abc" */
            function txt(text) {
                return new Pattern(function (str, pos) {
                    if (str.slice(pos, pos + text.length) == text)
                        return [text, pos + text.length];
                });
            }
            Utils.txt = txt;
            /** rgx = /[a-z]+/ */
            function rgx(regexp) {
                return new Pattern(function (str, pos) {
                    var m = regexp.exec(str.slice(pos));
                    if (m && m.index == 0)
                        return [m[0], pos + m[0].length];
                });
            }
            Utils.rgx = rgx;
            /** opt = [something] */
            function opt(p, defvalue) {
                return new Pattern(function (str, pos) { return p.exec(str, pos) || [defvalue, pos]; });
            }
            Utils.opt = opt;
            /** escaped-char = any-char ~ double-quote */
            function exc(pattern, except) {
                return new Pattern(function (str, pos) { return !except.exec(str, pos) && pattern.exec(str, pos); });
            }
            Utils.exc = exc;
            /** seq = abc def ghi ... */
            function seq() {
                var patterns = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    patterns[_i] = arguments[_i];
                }
                return new Pattern(function (str, pos) {
                    var results = [];
                    for (var _i = 0, patterns_1 = patterns; _i < patterns_1.length; _i++) {
                        var p = patterns_1[_i];
                        var r = p.exec(str, pos);
                        if (!r)
                            return;
                        results.push(r[0]);
                        pos = r[1];
                    }
                    return [results, pos];
                });
            }
            Utils.seq = seq;
            /** any = abc | def | ghi | ... */
            function any() {
                var patterns = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    patterns[_i] = arguments[_i];
                }
                return new Pattern(function (str, pos) {
                    for (var _i = 0, patterns_2 = patterns; _i < patterns_2.length; _i++) {
                        var p = patterns_2[_i];
                        var r = p.exec(str, pos);
                        if (r)
                            return r;
                    }
                });
            }
            Utils.any = any;
            /** rep = *pattern */
            function rep(pattern) {
                return new Pattern(function (str, pos) {
                    var r, results = [];
                    while (r = pattern.exec(str, pos)) {
                        results.push(r[0]);
                        pos = r[1];
                    }
                    return [results, pos];
                });
            }
            Utils.rep = rep;
            /** sep = [attr *(comma attr)] */
            function sep(pattern, separator) {
                var separated = seq(separator, pattern).select(1);
                var sequence = seq(pattern, rep(separated)).then(function (r) { return [r[0]].concat(r[1]); });
                return opt(sequence, []);
            }
            Utils.sep = sep;
            function quoted(lquote, rquote) {
                var esc = rgx(/\\./).then(function (str) { return str.slice(1); });
                var chr = any(esc, exc(rgx(/./), rquote));
                return seq(lquote, rep(chr), rquote).select(1).merge();
            }
            Utils.quoted = quoted;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * Parses a URI, provides API to edit its parts and to stringify
             * the changed URI parts into a URI string:
             *
             *      uri = URI("http://contoso.com/data?tag=1");
             *      uri.scheme("https").port(443);
             *      uri == "https://contoso.com:443/data?tag=1");
             *
             * @property {String} scheme - e.g. "https"
             * @property {String} user - e.g. "johndoe:123"
             * @property {String} host - e.g. "contoso.com"
             * @property {String} port - e.g. "8081"
             * @property {String} path - e.g. "/ucwa/oauth/v1/me/name"
             * @property {String} query - e.g. "groupId=wnm176snmq=&tag=2"
             * @property {String} hash - e.g. "Introduction"
             * @property {String} origin - e.g. "https://contoso.com:443"
             *
             */
            var URI = (function () {
                function URI(text) {
                    var _this = this;
                    var parts;
                    if (!(this instanceof URI))
                        return new URI(text);
                    parts = URI.pattern.exec((text || '') + '');
                    // the regexp is written in such a way, that it matches any string,
                    // so this exception is never thrown; this may change once the regexp
                    // is written more accurately
                    if (!parts)
                        throw new SyntaxError('Invalid URI: ' + text);
                    function bind(name) {
                        var prop = function (value) {
                            if (arguments.length == 0)
                                return (parts[name] || '') + '';
                            parts[name] = (value || '') + '';
                            return this;
                        };
                        prop.toString = function () {
                            return prop();
                        };
                        return prop;
                    }
                    this.scheme = bind('scheme');
                    this.user = bind('user');
                    this.host = bind('host');
                    this.port = bind('port');
                    this.path = bind('path');
                    this.query = bind('query');
                    this.hash = bind('hash');
                    this.query.get = function (arg) {
                        return URI.Query(_this.query())[arg];
                    };
                    this.query.set = function (arg, val) {
                        var q = URI.Query(_this.query());
                        q[arg] = val;
                        _this.query(q + '');
                    };
                    this.origin = function () {
                        var prefixed = function (prefix, value) { return value ? prefix + value : ''; };
                        var authority = (!_this.user() ? '' : _this.user() + '@') + (_this.host() || '') + prefixed(':', _this.port());
                        return (_this.scheme() ? _this.scheme() + ':' : '') +
                            prefixed('//', authority);
                    };
                }
                URI.prototype.toString = function () {
                    var prefixed = function (prefix, value) { return value ? prefix + value : ''; };
                    var authority = (!this.user() ? '' : this.user() + '@') + (this.host() || '') + prefixed(':', this.port());
                    return (this.scheme() ? this.scheme() + ':' : '') +
                        prefixed('//', authority) + this.path() +
                        prefixed('?', this.query()) +
                        prefixed('#', this.hash());
                };
                return URI;
            }());
            Utils.URI = URI;
            (function (URI) {
                URI.pattern = {
                    // RFC 3986 specifies an ABNF of URI, but since we don't have an ABNF parser and since that particular
                    // ABNF can be represented with a regular expression, I chose to write a regexp here. The mentioned ABNF
                    // has the following form: [scheme ":"] ["//" [user "@"] host [":" port]] path ["?" query] ["#" hash]
                    regexp: /^(?:([a-zA-Z][\w+-.]*):)?(?:\/\/(?:([^/@]*)@)?([^:/?#]*)(?:\:(\d*))?)?([^?#]*)(?:\?([^#]*))?(?:#(.*))?$/,
                    exec: function (text) {
                        var p = this.regexp.exec(text);
                        return p && { scheme: p[1], user: p[2], host: p[3], port: p[4], path: p[5], query: p[6], hash: p[7] };
                    }
                };
                /**
                 * Parses the query part of the URI
                 * and lets stringify it back:
                 *
                 *      var uri = URI.Query("a=1&b=2&c=3");
                 *
                 *      uri.a = 111;
                 *      delete uri.b;
                 *      uri.d = 444;
                 *
                 *      uri == "a=111&c=3&d=444";
                 *
                 */
                function Query(text) {
                    if (!(this instanceof Query))
                        return new Query(text);
                    var self = this;
                    if (Utils.isString(text)) {
                        Utils.foreach(text.split('&'), function (pair) {
                            var k, v, i = pair.indexOf('=');
                            if (i < 0) {
                                k = pair;
                                v = '';
                            }
                            else {
                                k = pair.slice(0, i);
                                v = pair.slice(i + 1);
                            }
                            if (k)
                                self[Utils.DataUri.decodeData(k)] = Utils.DataUri.decodeData(v);
                        });
                    }
                    else if (text) {
                        // note how clone gets rid of the object's prototype
                        Utils.foreach(Utils.clone(text), function (v, k) {
                            self[k] = v;
                        });
                    }
                }
                URI.Query = Query;
                Query.prototype.toString = function () {
                    var pairs = [];
                    // note how clone(this) gets rid of this.toString
                    Utils.foreach(Utils.clone(this), function (v, k) {
                        pairs.push(v ?
                            Utils.DataUri.encodeData(k) + '=' + Utils.DataUri.encodeData(v) :
                            Utils.DataUri.encodeData(k));
                    });
                    return pairs.join('&');
                };
                // a = extend({}, something) where something has a Query object as one of the properties
                // causes the toString in the prototype of Query to get copied over.
                // Now if a.toString() it actually enters Query.prototype.toString which does a clone
                // of itself and triggers a recursion of Query.prototype.toString.
                Object.defineProperty(Query.prototype, 'toString', { enumerable: false });
                /**
                 * Adds query args to a URL with possibly existing query args.
                 * If query args already exist in the URL, they are overwritten.
                 * The undefined arg values are ignored, the null values aren't.
                 *
                 * @param url e.g. /my/url?a=1&b=2
                 * @param args e.g. { b: 3, c: 4 }
                 */
                function mergeQuery(url, args) {
                    if (!args)
                        return url;
                    var uri = new URI(url);
                    var query = URI.Query(uri.query());
                    for (var name_6 in args)
                        if (args[name_6] !== undefined)
                            query[name_6] = args[name_6];
                    uri.query(query + '');
                    return uri + '';
                }
                URI.mergeQuery = mergeQuery;
            })(URI = Utils.URI || (Utils.URI = {}));
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * Parses or constructs a data uri string compliant with RFC 2397.
             *
             * UCWA server sends instant messages in the data uri format and
             * this class can be involved to parse them.
             *
             * Data URLs have to be parsed because SkypeWeb needs to extract separate
             * attributes from them and this cannot be done with a regular expression.
             *
             * @example
             *
             *      var uri = DataUri('data:text/plain;charset=utf-8,How+are+you%3f');
             *
             *      uri.mime == 'text/plain';
             *      uri.attributes.charset == 'utf-8';
             *      uri.data == 'How are you?';
             *
             */
            function DataUri(string) {
                var parts = DataUri.pattern.exec(string);
                if (!parts)
                    throw new SyntaxError('Invalid data URL: ' + string);
                return parts;
            }
            Utils.DataUri = DataUri;
            (function (DataUri) {
                function encodeData(data) {
                    return encodeURIComponent(data).replace(/%20/gm, '+');
                }
                DataUri.encodeData = encodeData;
                function decodeData(data) {
                    return decodeURIComponent(data.replace(/\+/gm, ' '));
                }
                DataUri.decodeData = decodeData;
                ;
            })(DataUri = Utils.DataUri || (Utils.DataUri = {}));
            /**
             * Parsing rules (ABNF) from RFC 2397 and RFC 2045:
             *
             *      dataurl     := "data:" [ mediatype ] [ ";base64" ] "," data
             *      mediatype   := [ token "/" token ] *( ";" parameter )
             *      data        := *urlchar
             *      parameter   := attribute "=" value
             *      attribute   := token ; Matching of attributes is ALWAYS case-insensitive.
             *      value       := token / quoted-string
             *      token       := 1*<any (US-ASCII) CHAR except SPACE, CTLs, or tspecials>
             *      tspecials   :=  "(" / ")" / "<" / ">" / "@" / "," / ";" / ":" / "\" / <"> / "/" / "[" / "]" / "?" / "="
             */
            (function (DataUri) {
                var token = Utils.rgx(/[^()<>@,;:\\\x22/\[\]?=\s]+/);
                var mime = Utils.seq(token, Utils.txt('/'), token).merge();
                var data = Utils.rgx(/[^\uffff]*/).then(DataUri.decodeData);
                var str = Utils.quoted(Utils.txt('"'), Utils.txt('"'));
                var val = Utils.seq(Utils.rgx(/\s*=\s*/), Utils.any(str, token)).select(1);
                var attr = Utils.seq(Utils.rgx(/\s*;\s*/), token, Utils.opt(val, true));
                DataUri.pattern = Utils.seq(Utils.txt('data:'), Utils.opt(mime), Utils.rep(attr).join(1, 2), Utils.rgx(/\s*,\s*/), data)
                    .then(function (_a) {
                    var m = _a[1], a = _a[2], d = _a[4];
                    return ({ mime: m, attributes: a, data: d, base64: !!a['base64'] });
                });
            })(DataUri = Utils.DataUri || (Utils.DataUri = {}));
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * Parses a CSS style of the following form:
             *
             *      position: fixed;
             *      color: red;
             *      font: Arial 10px;
             *
             */
            function Style(text) {
                if (!(this instanceof Style))
                    return new Style(text);
                var parsed = Style.pattern.exec(text);
                if (!parsed)
                    throw new SyntaxError('Invalid CSS style: ' + text);
                Utils.extend(this, parsed);
            }
            Utils.Style = Style;
            /**
             * Parsing rules (ABNF):
             *
             *      style       := kvpair *( ";" kvpair ) ";"?
             *      kvpair      := name ":" 1*value
             *      name        := <dashes are allowed in names>
             *      value       := string / measure / name / color
             *      string      := <single-quoted or double-quoted string>
             *      measure     := number ["%" / "pt" / "px" / "em"]
             *      number      := <floating point number>
             *      color       := "#" 1*hexdigit
             *
             */
            (function (Style) {
                // parsing a style could've been as simple as splitting
                // the input at ";" symbols and then at ":" symbols if
                // css didn't allow quoted and double-quoted strings in
                // style values, i.e. font: "Arial";
                var wsp = Utils.rgx(/[\x00-\x20]+/);
                var wspComma = Utils.rgx(/[,\x00-\x20]+/);
                var color = Utils.rgx(/#[\da-fA-F]+/i); // in css #f80 = #ff8800
                var number = Utils.rgx(/[+-]?(\d+[\.]?\d*|\.\d+)/); // that's a bit stricter than needed
                var measure = Utils.seq(number, Utils.opt(Utils.rgx(/%|[a-z]+/i))).text(); // ie. 12.3px
                var string = Utils.any(Utils.quoted(Utils.txt('"'), Utils.txt('"')), Utils.quoted(Utils.txt("'"), Utils.txt("'")));
                var name = Utils.rgx(/[a-z][a-z-]*[a-z]|[a-z]/i); // dashes are allowed only inside the name
                var value = Utils.any(measure, string, name, color).text(); // url('...')-like things aren't handled
                var kvpair = Utils.seq(name.text(), Utils.opt(wsp), Utils.txt(':'), Utils.opt(wsp), Utils.sep(value, wspComma));
                var separator = Utils.seq(Utils.opt(wsp), Utils.txt(';'), Utils.opt(wsp));
                // another option would be to allow empty styles between semicolons:
                // this would simplify this pattern, but the .join(...) below will have
                // to become more complicated in order to handle empty styles
                var style = Utils.seq(Utils.sep(kvpair, separator), Utils.opt(separator)).select(0);
                // well, .join(...) won't work if the same style name appears twice,
                // which is allowed in css and means that the style definition is
                // split across multiple lines
                Style.pattern = style.join(0, 4);
            })(Style = Utils.Style || (Utils.Style = {}));
            Utils.setHiddenProperty(Style.prototype, 'toString', function () {
                var name, lines = [], styles = this;
                for (name in styles)
                    lines.push(name + ':' + styles[name].join(' '));
                return lines.join(';');
            });
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            var entities = {
                'lt': '<',
                'gt': '>',
                'amp': '&',
                'nbsp': '\xA0',
                'quot': '"'
            };
            /**
             * Unescapes XML entities, such as &amp; and &#160;.
             * Such escaped entities can be found in XML tags.
             *
             *      unescapeXml('123 &amp; 456') == '123 & 456';
             *
             */
            function unescapeXml(escaped) {
                return escaped.replace(/&(#?\w+);/gm, function (str, num) {
                    return num.charAt(0) == '#' ? String.fromCharCode(+num.slice(1)) : entities[num];
                });
            }
            /**
             * Reconstitutes a tree of XML nodes from their textual representation.
             *
             * @method {String} name - Returns the tag name of the node.
             * @method {String} text - Returns the text content of the node.
             * @method {String} attr - Returns value of the given attribute.
             *
             * @member {Map<String, String>} attrs - All attributes as a dictionary.
             * @member {XmlNode[]} nodes - All inner nodes.
             *
             * @method {XmlNode} selectOne - Searches for a specific child node.
             *
             */
            function XmlNode(input) {
                if (!(Utils.isString(input) || input && input.ast))
                    throw new Error('Invalid argument: ' + input);
                if (!(this instanceof XmlNode))
                    return new XmlNode(input);
                var ast, err;
                try {
                    ast = input.ast || XmlNode.pattern.exec(input); // AST of the XML
                    if (!ast)
                        throw void 0;
                }
                catch (reason) {
                    err = new SyntaxError('Invalid XML: ' + input);
                    err.reason = reason;
                    throw err;
                }
                var attrs = ast.attrs || {};
                var nodes = (ast.nodes || []).map(function (node) {
                    return XmlNode({ ast: Utils.isString(node) ? { text: node } : node });
                });
                var join = function (text, node) { return text + node.text(); };
                var name = function () { return ast.name; };
                var text = function () { return ast.text || nodes.reduce(join, ''); };
                this.attrs = attrs;
                this.nodes = nodes;
                this.name = name;
                this.text = text;
            }
            Utils.XmlNode = XmlNode;
            XmlNode.prototype.toString = function () {
                var attrs = '', content = '', root = this, name = root.name();
                Utils.foreach(root.attrs, function (val, key) {
                    attrs += ' ' + key;
                    if (!Utils.isVoid(val))
                        attrs += '="' + val.replace(/\x22/gm, '&quot;') + '"';
                });
                Utils.foreach(root.nodes, function (node) {
                    content += node;
                });
                content = content || root.text().replace(/</gm, '&lt;').replace(/>/gm, '&gt;');
                return !name ? content :
                    !content ? '<' + name + attrs + '/>' :
                        '<' + name + attrs + '>' + content + '</' + name + '>';
            };
            XmlNode.prototype.attr = function (name) {
                Utils.assert(name in this.attrs, 'Attribute does not exist: ' + this.name() + '.' + name);
                return this.attrs[name];
            };
            XmlNode.prototype.selectOne = function (name, attrs) {
                var nodes = Utils.filter(this.nodes, Utils.isFunction(name) ? name : function (node) {
                    var attr, lca;
                    // attribute names are lower cased by the parser
                    if (attrs) {
                        for (attr in attrs) {
                            lca = attr.toLowerCase();
                            if (attrs[lca] != node.attrs[lca])
                                return false;
                        }
                    }
                    // node names are lower cased by the parser
                    return node.name() == name.toLowerCase();
                });
                Utils.assert(nodes.length == 1, 'Single node expected: ' + name);
                return nodes[0];
            };
            /**
             * Parsing rules (ABNF) for the XML subset supported by this implementation:
             *
             *      xml-node    := open-tag *(xml-node / text) close-tag / empty-tag
             *      open-tag    := "<" name *attr ">"
             *      close-tag   := "</" name ">"
             *      empty-tag   := "<" name *attr "/>"
             *      attr        := name ["=" quoted-string]
             *      text        := <an xml-escaped text>
             *      name        := <a case insensitive name>
             */
            (function (XmlNode) {
                var wsp = Utils.rgx(/[\x00-\x20]*/);
                var qstr = Utils.rgx(/\x22[^\x22]*\x22/).then(function (s) { return s.slice(+1, -1); });
                var rawval = Utils.rgx(/[^\s<>\x22]+/);
                var value = Utils.any(qstr, rawval).then(unescapeXml);
                var text = Utils.rgx(/[^<]+/m).then(unescapeXml);
                var name = Utils.rgx(/[\w:-]+/).then(function (s) { return s.toLowerCase(); });
                var attr = Utils.seq(name, Utils.opt(Utils.seq(wsp, Utils.txt('='), wsp, value).select(3)));
                var attrs = Utils.sep(attr, wsp).join(0, 1);
                var opentag = Utils.seq(Utils.txt('<'), wsp);
                var closetag = Utils.seq(wsp, Utils.txt('>'));
                var comment = Utils.rgx(/<!--[\s\S]*?-->/m).then(function (r) { return ({ name: '--' }); });
                var open = Utils.seq(opentag, name, wsp, attrs, closetag).then(function (r) { return ({ name: r[1], attrs: r[3] }); });
                var empty = Utils.seq(opentag, name, wsp, attrs, Utils.seq(wsp, Utils.txt('/>'))).then(function (r) { return ({ name: r[1], attrs: r[3] }); });
                var close = Utils.seq(Utils.txt('</'), wsp, name, closetag).select(2);
                var node = new Utils.Pattern(function (str, pos) { return XmlNode.pattern.exec(str, pos); });
                var full = Utils.seq(open, Utils.rep(Utils.any(node, text, comment)), close).then(function (_a) {
                    var open = _a[0], nodes = _a[1], close = _a[2];
                    if (open.name != close)
                        throw new SyntaxError('</' + close + '> does not match <' + open.name + '>');
                    return { name: close, nodes: nodes, attrs: open.attrs };
                });
                XmlNode.pattern = Utils.any(full, empty);
            })(XmlNode = Utils.XmlNode || (Utils.XmlNode = {}));
            /**
             * @param {String} src - XML representation of the document.
             *
             * @member {XmlNode} root
             */
            function XmlDoc(src) {
                return {
                    // <?xml version="1.0" encoding="utf-8"?>
                    // needs to be removed before parsing XML
                    root: XmlNode(Utils.trim(src.replace(/^<\?.+?\?>/, '')))
                };
            }
            Utils.XmlDoc = XmlDoc;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            var rxSafeTags = /^(body|b|i|u|s|span|table|tr|td|th|br|div|hr|p|h\d|font|a)$/i;
            var rxSafeAttrs = /^(style|width|height|color|face|size|href)$/i;
            var rxSafeStyles = /^(font(-[a-z]+)?|margin(-[a-z]+)?|line(-[a-z]+)?|color)$/i;
            function parseHtml(html) {
                // Since a linebreak <br> is a void element, which doesn't require a closing tag, it violates
                // the parsing pattern for XML node. Have to replace any single linebreak with a space here.
                // Other void elements (such as <hr>, <img>, <input>, etc.), are not considered here, since
                // the lync client doesn't send them.
                var s = html.replace(/<(br|meta)\b(.*?)\/?>/gim, '<$1$2/>');
                s = /^\s*<html\b[\s\S]*<\/html>\s*$/igm.test(s) ?
                    Utils.trim(s) : '<html><body>' + s + '</body></html>';
                return Utils.XmlNode(s).selectOne('body');
            }
            //#region convertTextToHtml
            /**
             * Escapes certain HTML (XML) characters to make a text input
             * usable as a HTML string. Consider the case when e remote party
             * sends a text/plain message with "<script>alert(1)</script>"
             * content and this text needs to be shown in HTML.
             */
            function convertTextToHtml(text) {
                return text
                    .replace(/[<>&;#/]/gm, function (chr) { return '&#' + chr.charCodeAt(0) + ';'; })
                    .replace(/\r\n|\n/gm, function () { return '<br>'; });
            }
            Utils.convertTextToHtml = convertTextToHtml;
            //#endregion
            //#region convertHtmlToText
            /**
             * Extracts text from html. This is done by parsing the given html
             * and merging all text nodes from it. It's useful to get the plain
             * text representation of an html message if the only format known is
             * html.
             *
             */
            function convertHtmlToText(html) {
                return parseHtml(html.replace(/<br\s*\/?>/gi, '\x0D\x0A')
                    .replace(/&(nbsp|#160);/gi, '\x20')).text();
            }
            Utils.convertHtmlToText = convertHtmlToText;
            //#endregion convertHtmlToText
            //#region sanitizeHtml
            /**
             * Removes everything that can be used in an XSS attack.
             *
             * This is a basic sanitizer based on allow list. It first parses
             * html and css and then removes all not listed html tags, attributes
             * and css styles. This sanitizer is necessary to prevent XSS if
             * the UI developer makes a very common mistake:
             *
             *      document.getElementById(...).innerHTML = message.html();
             *
             * If the message html contains scripts or specially styled html tags,
             * that UI will be subject to XSS attacks.
             *
             * Obviously, there are quite safe html messages that will be corrupted
             * by this sanitizer, but their fraction is assumed to be small and the
             * allow list can be extended any time later.
             *
             */
            function sanitizeHtml(html) {
                function removeUnsafeAttrs(root) {
                    var name, attrs = root.attrs;
                    for (name in attrs) {
                        if (!rxSafeAttrs.test(name))
                            delete attrs[name];
                    }
                }
                function removeUnsafeStyles(root) {
                    var styles, name, str = root.attrs.style;
                    if (str) {
                        styles = Utils.Style(str);
                        for (name in styles) {
                            if (!rxSafeStyles.test(name))
                                delete styles[name];
                        }
                        root.attrs.style = styles + '';
                    }
                }
                function sanitize(root) {
                    var i, name, nodes = root.nodes;
                    removeUnsafeAttrs(root);
                    removeUnsafeStyles(root);
                    for (i = 0; i < nodes.length; i++) {
                        name = nodes[i].name();
                        if (name && !rxSafeTags.test(name))
                            Utils.removeAt(nodes, i--);
                        else
                            sanitize(nodes[i]);
                    }
                    return root;
                }
                try {
                    return html && sanitize(parseHtml(html)).nodes.join('');
                }
                catch (_) {
                    // Someone sent a broken html? This might be an XSS attack.
                    // But in case it's not, present at least the raw html contents
                    // with all html disabled: the message may contain something
                    // important to the user.
                    return disableHtmlInText(html);
                }
            }
            Utils.sanitizeHtml = sanitizeHtml;
            //#endregion
            //#region disableHtmlInText
            /**
             * An attacker may send a message in the text/plain format with html inside:
             * the html can either aim at injecting a script into the destination page
             * or inject certain tags that would break the layout or show a popup window.
             * The problem applies not only to messages that can be sent in a conversation,
             * but also to all text data, such as a contact's note, a distribution group's
             * title, a conversation's subject and so on: they all can potentially contain
             * harmful html. Many webapps that uses the SDK contain a typical mistake:
             *
             *  document.getElementById("text123").innerHTML = message.text();
             *
             * In this case the attacker will be able to inject a script into such page.
             * To prevent this, the SDK alters all the text that comes from the server and
             * can be displayed in UI in such a way, that the text's appearance isn't affected,
             * but all potential harmful html constructs are disabled.
             *
             */
            function disableHtmlInText(text) {
                // U+2329 and U+232A are misc technical punctuation symbols
                return text && text.replace(/</gm, '\u2329').replace(/>/gm, '\u232a');
            }
            Utils.disableHtmlInText = disableHtmlInText;
            //#endregion
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * Represents the "WWW-Authenticate" HTTP header
             * that contains information about how to get the auth token.
             * Here is an example of how it may look:
             *
             *      Basic realm="johndoe@contoso.com",Digest realm="testrealm@host.com", qop="auth,auth-int"
             *
             * @param {string} text - The value of the "WWW-Authenticate" header.
             *
             * @example
             *
             *      var auth = WWWAuthenticateHeader(
             *          'Bearer client_id="0", uri="qq://login" + '\n' +
             *          'MsRtcOAuth href="qq://login/token",grant_type="urn:microsoft.rtc:passive,urn:microsoft.rtc:anonmeeting"');
             *
             *      auth.Bearer.client_id === "0";
             *      auth.Bearer.uri === "qq://login";
             *      auth.MsRtcOAuth.href === "qq://login/token";
             *      auth.MsRtcOAuth.grant_type === "urn:microsoft.rtc:passive,urn:microsoft.rtc:anonmeeting";
             *
             */
            function WWWAuthenticateHeader(text) {
                var parts = WWWAuthenticateHeader.pattern.exec(text || '');
                if (parts)
                    return parts;
                throw new SyntaxError('Invalid WWW-Authenticate header:\n' + text);
            }
            Utils.WWWAuthenticateHeader = WWWAuthenticateHeader;
            /**
             *  ABNF rules for the WWW-Authenticate header:
             *
             *  www-auth        := *( challenge )
             *  challenge       := scheme *( param )
             *  param           := param-name "=" param-value
             *  scheme          := token
             *  param-name      := token
             *  param-value     := quoted-string
             */
            (function (WWWAuthenticateHeader) {
                var comma = Utils.rgx(/[\s,]*/);
                var name = Utils.rgx(/[^\s,=]+/);
                var value = Utils.quoted(Utils.txt('"'), Utils.txt('"'));
                var attr = Utils.seq(name, Utils.rgx(/\s*=\s*/), value);
                var attrs = Utils.sep(attr, comma).join(0, 2);
                var challenge = Utils.seq(name, comma, attrs);
                WWWAuthenticateHeader.pattern = Utils.sep(challenge, comma).join(0, 2);
            })(WWWAuthenticateHeader = Utils.WWWAuthenticateHeader || (Utils.WWWAuthenticateHeader = {}));
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            var Http;
            (function (Http) {
                ;
                function isSuccess(status) {
                    return 200 <= status && status < 300;
                }
                Http.isSuccess = isSuccess;
            })(Http = Utils.Http || (Utils.Http = {}));
            //#region HttpHeaders
            /**
             * This is a collection of HTTP headers.
             * jQuery returns HTTP headers as a string, so it needs
             * to be parsed before use.
             *
             * @param {string} text - A multiline string with all the headers.
             *
             * @method {string} get(name) - Returns the value associated with the header.
             * @method add(name, value) - Adds a new value for a header.
             * @method {string} toString - Returns the textual representation of the headers.
             *
             * @example
             *
             *      var headers = HttpHeaders('Authorization: Bearer cwt=abcdef\nH: Qwerty\n\n');
             *      headers.get('authorization') == 'Bearer cwt=abcdef';
             *      headers.get('h') == 'Qwerty';
             *
             */
            function HttpHeaders(text) {
                // the header names are normalized, i.e. look like dash-separated
                // sequences of words in which the first letter is capital: X-Ms-Server-Fqdn
                var headers = {};
                var normalize = function (name) { return name.toLowerCase().replace(/\b(\w)/g, function (char) { return char.toUpperCase(); }); };
                /**
                 * Parses the multi-line string containing the headers.
                 */
                function parse(text) {
                    Utils.assert(Utils.isString(text));
                    var lines = text.split('\r\n');
                    var sep, name, value, line;
                    for (var i = 0; i < lines.length; i++) {
                        if (line = Utils.trim(lines[i])) {
                            sep = line.indexOf(':');
                            // silently skip invalid headers
                            if (sep >= 0) {
                                name = Utils.trim(line.substr(0, sep));
                                value = Utils.trim(line.substr(sep + 1));
                                add(name, value);
                            }
                        }
                    }
                }
                /**
                 * Copies headers from another list of headers.
                 */
                function copy(hdrs) {
                    Utils.assert(Utils.isDictionary(hdrs));
                    for (var name in hdrs)
                        add(name, hdrs[name] + '');
                }
                /**
                  * Gets the value of the header.
                  *
                  * @param {string} name
                  * @returns {string}
                  */
                function get(name) {
                    Utils.assert(Utils.isNotEmptyString(name));
                    return headers[normalize(name)];
                }
                /**
                 * Adds a new value to a header.
                 *
                 * @param {string} name - The name of the header.
                 * @param {string} value - The new value for the header.
                 */
                function add(name, value) {
                    Utils.assert(Utils.isNotEmptyString(name));
                    name = normalize(name);
                    if (headers[name])
                        headers[name] += '\n' + value;
                    else
                        headers[name] = value;
                }
                /**
                 * Returns a text representation of the headers.
                 *
                 * @returns {string}
                 */
                function stringify() {
                    var i, name, values, text = '';
                    for (name in headers) {
                        values = headers[name].split('\n');
                        for (i = 0; i < values.length; i++)
                            if (values[i])
                                text += name + ': ' + values[i] + '\r\n';
                    }
                    return text + '\r\n';
                }
                if (Utils.isNotEmptyString(text))
                    parse(text);
                else if (Utils.isDictionary(text))
                    copy(text);
                return {
                    raw: headers,
                    get: get,
                    add: add,
                    toString: stringify
                };
            }
            Utils.HttpHeaders = HttpHeaders;
            (function (HttpHeaders) {
                HttpHeaders.parse = function (data) { return HttpHeaders(data).raw; };
            })(HttpHeaders = Utils.HttpHeaders || (Utils.HttpHeaders = {}));
            //#endregion HttpHeaders    
            //#region ContentTypeHeader
            /**
             * Parses a value of the Content-Type header. An example of such as header:
             *
             *      Content-Type: multipart/related; type="text/plain"; charset=utf-8; boundary=123
             *
             * @param {String} value - The text value of the Content-Type header.
             *
             * @member {String} mimeType - e.g. "multipart/related"
             * @member {Object} attributes - e.g. {charset:"utf-8"}
             */
            function ContentTypeHeader(value) {
                // DataUri already has a parser for mime types
                var dataUri = Utils.DataUri('data:' + value.replace(/\s/g, '') + ',');
                return {
                    mimeType: dataUri.mime,
                    attributes: dataUri.attributes
                };
            }
            Utils.ContentTypeHeader = ContentTypeHeader;
            //#endregion    
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
// Right, this is nothing to do with LINQ,
// but I couldn't find a better name.
// This module contains all utils that we
// use to deal with simple objects and arrays.
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            //#region getOption
            function getOption(values, name, defaultValue) {
                return name in values ? values[name] : defaultValue;
            }
            Utils.getOption = getOption;
            //#endregion
            //#region keys
            /**
             * This is a polyfill for Object.keys that doesn't exist in IE 8.
             * To avoid possible interference with other JS code, it's better
             * to not override global function, such as Object.keys.
             */
            function keys(obj) {
                var names;
                if (Object.keys) {
                    names = Object.keys(obj);
                }
                else {
                    names = [];
                    Utils.foreach(obj, function (val, key) {
                        names.push(key);
                    });
                }
                return names;
            }
            Utils.keys = keys;
            //#endregion
            //#region all
            /**
             * Checks whether a condition is satisfied for a set of items.
             */
            function all(items, condition) {
                // `foreach` could be used here with a `throw` statement
                // to simulate a `break` in a regular `for` loop, but there
                // reasons to not do this:
                //
                //  1. at the moment `all` doesn't need to support arrays
                //  2. throw/break will be executed in almost every call to `all`
                //  3. `throw` would significantly degrade performance
                // 
                for (var name in items)
                    if (!condition(items[name], name))
                        return false;
                return true;
            }
            Utils.all = all;
            //#endregion
            //#region namespace
            /**
             * Creates or extends a namespace.
             *
             * @param {String} path - e.g. "Skype.Web.Utils"
             * @param {Object} [members] - Members to be added to the namespace.
             * @param {Object} [root=window]
             *
             * @returns {Object} - The created namespace.
             */
            function namespace(path, members, root) {
                var i, ns = root || Web.window, names = path.split('.');
                for (i = 0; i < names.length; i++)
                    ns = ns[names[i]] || (ns[names[i]] = {});
                for (i in members) {
                    Utils.assert(!(i in ns), path + '.' + i + ' already exists');
                    ns[i] = members[i];
                }
                return ns;
            }
            Utils.namespace = namespace;
            //#endregion
            //#region take
            /** take({ a:1, b:2 }, "a") -> { a:1 } */
            function take(object, key) {
                var result = {};
                result[key] = object[key];
                return result;
            }
            Utils.take = take;
            /**
             * Creates a subset with all items that pass the test implemented by the
             * callback. For an array argument this subset is a new array, for a dictionary
             * argument is a new dictionary.
             *
             * @example
             *      var res = filter([11, 22, 33], function (value) {
             *          return value > 20;
             *      });
             *      // res is [22, 33]
             *
             * @example
             *      var res = filter({a:1, b:2, c:3, d:4}, function (value, key) {
             *          return value > 3 || key < 'b';
             *      });
             *      // res is {a:1, d:4}
             */
            function filter(items, callback) {
                var res;
                if (Utils.isArray(items)) {
                    res = [];
                    Utils.foreach(items, function (val, key) {
                        if (callback(val, key))
                            res.push(val);
                    });
                }
                else {
                    res = {};
                    Utils.foreach(items, function (val, key) {
                        if (callback(val, key))
                            res[key] = val;
                    });
                }
                return res;
            }
            Utils.filter = filter;
            //#endregion        
            //#region size
            /**
             * Returns the size of a collection (array or dictionary).
             */
            function size(items) {
                Utils.assert(Utils.isArray(items) || Utils.isDictionary(items));
                return Utils.isArray(items) ? items.length :
                    keys(items).length;
            }
            Utils.size = size;
            /**
             * Determines whether a collection (array or dictionary) contains an element
             * that satisfies a given condition and returns this element or null if no
             * such element is found
             */
            function find(items, predicate) {
                if (Utils.isArray(items)) {
                    for (var i = 0; i < items.length; ++i) {
                        if (predicate(items[i], i))
                            return items[i];
                    }
                }
                else {
                    for (var i in items) {
                        if (predicate(items[i], i))
                            return items[i];
                    }
                }
                return null;
            }
            Utils.find = find;
            /**
             * Determines whether an array contains an element that satisfies a given
             * condition and returns the index of this element or -1 if no such element
             * is found. It is basically the combination of find and indexOf.
             */
            function findIndex(items, callback) {
                for (var i = 0; i < items.length; ++i) {
                    if (callback(items[i], i))
                        return i;
                }
                return -1;
            }
            Utils.findIndex = findIndex;
            //#endregion
            //#region setEqual
            /**
             * Compares two sets and determines if they are equal by checking if each is a subset of the other
             *
             * @param {Array} set1 - First set to compare
             * @param {Array} set2 - Second set to compare
             *
             * @returns {boolean} - indicates where the first and second sets are equal
             */
            function setEqual(set1, set2) {
                function isSubSet(a, b) {
                    for (var i = 0; i < a.length; i++) {
                        if (Utils.indexOf(b, a[i]) < 0) {
                            return false;
                        }
                    }
                    return true;
                }
                return isSubSet(set1, set2) && isSubSet(set2, set1);
            }
            Utils.setEqual = setEqual;
            //#endregion
            //#region removeAll
            /**
             * Removes all items matching the given criteria.
             */
            function removeAll(items, test) {
                var keys = [];
                for (var key in items)
                    if (test(items[key]))
                        keys.push(key);
                for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                    var key = keys_1[_i];
                    delete items[key];
                }
            }
            Utils.removeAll = removeAll;
            //#endregion
            /**
             * Searches through data for the specified keys and returns a new object
             * with only those keys. Keys can be nested to pick nested objects.
             *
             * eg: pick({ a: 1, b: 2, c: { d: 3, e: 4} }, ['a', 'c'])
             * = { a: 1, c: { d: 3, e: 4 } }
             *
             * eg: pick({ a: 1, b: 2, c: { d: { e: 3, f: 4 }, g: 5 } }, ['a', 'c.d'])
             *  = { a: 1, c: { d: { e: 3, f : 4 } } }
             */
            function pick(data, keys) {
                var vals = {};
                try {
                    for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
                        var key = keys_2[_i];
                        var tokens = key.split('.').filter(function (x) { return x.trim() != ''; });
                        var exists = true;
                        var input = data;
                        for (var _a = 0, tokens_1 = tokens; _a < tokens_1.length; _a++) {
                            var token = tokens_1[_a];
                            if (!(token in input)) {
                                exists = false;
                                break;
                            }
                            input = input[token];
                        }
                        if (exists) {
                            var output = vals;
                            input = data;
                            var i = 0;
                            for (; i < tokens.length - 1; i++) {
                                output[tokens[i]] = output[tokens[i]] || {};
                                output = output[tokens[i]];
                                input = input[tokens[i]];
                            }
                            output[tokens[i]] = input[tokens[i]];
                        }
                    }
                }
                catch (_) { }
                return vals;
            }
            Utils.pick = pick;
            /**
             * Flattens a tree-like structure into a flat dictionary:
             *
             *  { a: 1, b: { c: 1, d: 2 } }
             *  { a: 1, "b.c": 1, "b.d": 2 }
             *
             * Arrays are treated as dictionaries with numeric indices.
             */
            function flatten(items, 
                /** i.e. ['abc', 'def'] -> 'abc.def' */
                getPathName, 
                /** i.e. ['stack'] for error objects */
                getHiddenKeys) {
                /** i.e. ['stack'] for error objects */
                if (getHiddenKeys === void 0) { getHiddenKeys = function (x) { return []; }; }
                var res = {};
                var path = [];
                (function flatten(x) {
                    for (var _i = 0, _a = Object.keys(x).concat(getHiddenKeys(x)); _i < _a.length; _i++) {
                        var key = _a[_i];
                        path.push(key);
                        var val = x[key];
                        if (Utils.isPrimitive(val) || val instanceof Web.Date)
                            res[getPathName(path)] = val;
                        else
                            flatten(val);
                        path.pop();
                    }
                })(items);
                return res;
            }
            Utils.flatten = flatten;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * Implements a sequential state machine, i.e. the unidirectional state machine that advances
             * through an ordered set of states until it reaches the target state
             *
             * @param {Number} uninitState - Uninitialized state.
             *
             * @method defineState(state, handler)
             *
             *      Defines a state and an action needed to reach
             *      this state from the previous state.
             *
             * @method advanceTo(state) - Advances the state machine to the given state.
             * @method reset() - Reset the state machine to the uninitialized state.
             * @property {Number} state - The current state of the state machine.
             * @property {Number} target - The target state of the state machine.
             *
             * @example
             *
             *    var State = Enum('Zero', 'One', 'Two');
             *    var sm = SequentialStateMachine(State.Zero);
             *    sm.defineState(State.One, function () {
             *              // actions to get to One
             *              return 'Ok';
             *          });
             *    sm.defineState(State.Two, function () {
             *              // actions to get to Two
             *              return send('GET', '/me/name');
             *          });
             *
             *    sm.advanceTo(State.Two).then(function () {
             *          assert(sm.state() == State.Two);
             *    });
             *
             */
            function SequentialStateMachine(uninitState) {
                var current = Utils.Property({ value: uninitState }), target = Utils.Property({ value: uninitState }), handlers = {}, task, // advanceTo returns task.promise
                promise; // the current pending operation returned by handler[i]
                /**
                 * Defines machine actions for the state
                 *
                 * @param {Number} state
                 * @param {Function} handler
                 *
                 *      Action to be executed to reach this state from the previous one.
                 *      This function may return a value, a promise or throw an exception.
                 */
                function defineState(state, handler) {
                    Utils.assert(!handlers[state]);
                    Utils.assert(state > uninitState);
                    Utils.assert(Utils.isFunction(handler));
                    handlers[state] = Utils.async(handler);
                }
                /**
                 * Reset the state machine to the uninitialized state
                 *
                 *      The function will set the state machine to the uninitialized state,
                 *      keep all defined handlers, and cancel the pending promise if there is one.
                 */
                function reset() {
                    current(uninitState);
                    target(uninitState);
                    // promise already set as null if it is cancelled or resolved
                    if (promise)
                        cancel(Utils.Exception('Reset'));
                    task = null;
                    promise = null;
                }
                /**
                 * Advances the state machine to the given state
                 *
                 * @param {Number} state - The desired state.
                 */
                function advanceTo(state) {
                    Utils.check(state >= target(), 'InvalidTargetState', {
                        currentTarget: target(),
                        requestedTarget: state
                    });
                    if (state == current())
                        return;
                    if (state > target()) {
                        task = new Utils.Task('advancing to target state ' + state, {
                            cancel: cancel
                        });
                        target.set(state);
                        next(task);
                    }
                    return task.promise;
                }
                function cancel(reason) {
                    // this will invoke task.reject
                    promise.cancel(reason);
                    promise = null;
                }
                function next(task) {
                    // an existing promise signals that state transition is in progress
                    if (promise)
                        return;
                    var nextState = current() + 1;
                    task.status('advancing to state ' + nextState);
                    // the returned promise can be already resolved
                    // or rejected: to handle this case its "then"
                    // method is invoked separately
                    promise = handlers[nextState].call(null);
                    promise.then(function (result) {
                        promise = null;
                        current.set(nextState);
                        if (current() < target())
                            next(task);
                        else
                            task.resolve(result);
                    }, function (error) {
                        promise = null;
                        task.reject(error);
                    });
                }
                return {
                    defineState: defineState,
                    reset: reset,
                    advanceTo: Utils.async(advanceTo),
                    state: current.asReadOnly(),
                    target: target.asReadOnly()
                };
            }
            Utils.SequentialStateMachine = SequentialStateMachine;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            //#region repeat
            /**
             * Repeats an asynchronous function.
             *
             * Repeats a function asynchronously until the returned promise is canceled or
             * a non-recoverable error is encountered. The control over what errors can be
             * recovered can be handled (for async functions only!) by providing a failure
             * handler and preventing the exception from bubbling up which will make it
             * eligible for the next repeat cycle. The logic of `repeat` is functionally
             * equivalent to:
             *
             *      while (true)
             *          await fn();
             *
             */
            function repeat(fn) {
                // With the await keyword the repeat function can be rewritten as:
                //
                //  function repeat(fn) {
                //      await fn();
                //      await repeat(fn);
                //  }
                //
                // The last statement is a proper tail call and doesn't need to create an
                // extra frame on the stack or it's asynchronous equivalent - a new promise
                // in the chain of promises. If the n-th call to repeat returns a promise p(n)
                // and fn always succeeds, repeat creates an endless chain of promises attached
                // one to another:
                //
                //  p(0) <- p(1) <- p(2) <- ... <- p(n - 1) <- p(n) <- fn()
                //
                // It can be seen that all intermediate promises from p(1) to p(n - 1) can be
                // removed from the chain:
                //
                //  p(0) <- p(n) <- fn()
                //
                // This eliminates the memory leak. This optimization consists of two simpler
                // optimizations:
                //
                //  (p0 <- p1 <- p2) => (p0 <- p2 -> p1) => (p0 <- p2), (p1)
                //
                // The first step removes the intermediate promise p1 by lifting p0 by one level
                // and the second step discovers that nobody will ever invoke p1.then, so p1 is
                // simply detached from p2. Then p1 gets gc'd. To make the second step possible,
                // p1 - the last promise returned from inside .then - needs to be marked somehow.
                return Utils.async(fn)().then(function () {
                    return Utils.extend(repeat(fn), (_a = {}, _a[Utils.Task.sLocked] = true, _a));
                    var _a;
                });
            }
            Utils.repeat = repeat;
            //#endregion
            //#region repeatAndExit
            /**
             * Adds to repeat(...) a convenient way to return a value.
             *
             * The only way to terminate an async repeat(...) loop is to
             * throw an exception. In some cases it's useful to end an async loop
             * with a result. This function solves this by wrapping the result
             * into an exception to terminate the loop and unwrapping it at the end
             * to resolve the promise.
             *
             *      repeatAndExit(function (exit) {
             *          return ucwa.send("GET", "/status").then(function (rsp) {
             *              if (rsp.status == 409)
             *                  exit(rsp);
             *              return sleep(10);
             *          });
             *      }).then(function (rsp) {
             *          console.log(rsp); // status = 409
             *      });
             *
             * Unlike the repeat function, repeatAndExit invokes the given async function
             * with one argument - a specially constructed `exit` function that throws a
             * specially constructed exception, which is caught by repeatAndExit and used
             * to resolve the promise.
             *
             */
            function repeatAndExit(fn) {
                var res = [null];
                function exit(result) {
                    res[0] = result;
                    throw res;
                }
                return repeat(Utils.bind(fn, exit)).catch(function (err) {
                    if (err === res)
                        return res[0];
                    throw err;
                });
            }
            Utils.repeatAndExit = repeatAndExit;
            //#endregion
            //#region repeatDelayed
            /**
             * A specialized version of repeat(...) that handles delaying execution cycles
             * by sleeping a supplied amount. The logic of `repeatDelayed` is functionally
             * equivalent to:
             *
             *      while (true) {
             *          await fn();
             *          await sleep(delay);
             *      }
             *
             */
            function repeatDelayed(fn, delay) {
                // repeatDelayed(fn, 0) is equivalent to repeat(fn)
                Utils.assert(Utils.isNumber(delay) && delay > 0);
                // this will check whether fn is a function
                var afn = Utils.async(fn);
                return repeat(function () {
                    return afn().then(Utils.bind(Utils.sleep, delay));
                });
            }
            Utils.repeatDelayed = repeatDelayed;
            //#endregion
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * @param ajax - A function that sends a HTTP request.
             *
             *      This function has the same signature as jQuery.ajax:
             *
             *          function ajax(request) {
             *              return Task().promise;
             *          }
             *
             * @param size - The max number of concurrent HTTP requests.
             *
             *      This parameter limits the number of HTTP requests that can
             *      be sent at the same time. If the caller tries to send
             *      more requests, the throttle will queue them and will send them
             *      in due order after the server replies to first requests.
             *
             * @returns A function that has the same signature as jQuery.ajax.
             *
             *      In addition it has a parameter specifying the priority of the request:
             *
             *          {async Response} send(Request request, Number priority)
             *
             *      The higher the priority, the sooner the request will leave
             *      the queue and will be actually sent.
             *
             *      If the function is invoked multiple times, it will send
             *      up to the specified number of requests and will save other
             *      requests into an internal queue. Then, after the server replies
             *      to first requests, the throttle will send requests from
             *      the queue.
             *
             */
            function throttle(ajax, size) {
                Utils.assert(Utils.isFunction(ajax));
                Utils.assert(size > 0);
                ajax = Utils.async(ajax);
                var sent = 0; // the number of sent requests to which the server has not replied
                var queue = []; // the ids of requests waiting for being sent
                var results = {}; // results[id] = the deferred for the id-th request
                var requests = {}; // requests[id] = the id-th request
                var priorities = []; // priorities[i] corresponds to queue[i]
                var pending = {}; // pending[id] is a promise that observes the progress of the corresponding request
                function dequeue() {
                    Utils.assert(sent <= size);
                    while (sent < size && queue.length > 0)
                        send();
                }
                function send() {
                    var id = queue.splice(0, 1)[0];
                    var request = requests[id];
                    var result = results[id];
                    delete requests[id];
                    delete results[id];
                    priorities.splice(0, 1);
                    sent++;
                    pending[id] = ajax(request);
                    pending[id].then(function (res) { return result.resolve(res); }, function (err) { return result.reject(err); }, result.status).then(function () {
                        sent--;
                        delete pending[id];
                        dequeue();
                    });
                }
                function insert(id, priority) {
                    var i = priorities.length;
                    while (i > 0 && priority > priorities[i - 1])
                        i--;
                    priorities.splice(i, 0, priority);
                    queue.splice(i, 0, id);
                }
                function cancel(id, reason) {
                    var i;
                    if (pending[id]) {
                        // this will invoke result.reject
                        pending[id].cancel(reason);
                    }
                    else {
                        results[id].reject(reason);
                        delete requests[id];
                        delete results[id];
                        for (i = 0; i < queue.length; i++) {
                            if (queue[i] == id) {
                                queue.splice(i, 1);
                                priorities.splice(i, 1);
                                break;
                            }
                        }
                    }
                }
                return function (request, priority) {
                    if (priority == Infinity)
                        return ajax(request);
                    var id = Utils.random();
                    var task = new Utils.Task('Waiting in the throttling queue.', {
                        cancel: Utils.bind(cancel, id)
                    });
                    results[id] = task;
                    requests[id] = request;
                    insert(id, priority);
                    dequeue();
                    return task.promise;
                };
            }
            Utils.throttle = throttle;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * Debounces multiple requests to an async function.
             *
             * While the promise returned by the first call is pending,
             * all subsequent calls will return the same promise and won't
             * invoke the function.
             *
             *      fetch = debounced(function () {
             *          return ucwa.send("GET", "/presence").then(r => r.get("availability"));
             *      });
             *
             *      // fetch is invoked only once
             *      status1 = fetch();
             *      status2 = fetch();
             *
             */
            function debounced(fn) {
                var res, dfd, afn = Utils.async(fn);
                return function () {
                    if (!dfd) {
                        res = dfd = afn();
                        // if dfd is completed and the underlying task is sync,
                        // this callback will be executed right away, nulling dfd
                        dfd.finally(function () {
                            dfd = null;
                        });
                    }
                    return res;
                };
            }
            Utils.debounced = debounced;
            /**
             * Debounces multiple events to one event based on a timer window.
             *
             * When a property changes very frequently, but the observer only wants to get
             * notified when the events settle for a certain time period. For example:
             *
             * var property = new Property();
             * property.changed(debounce(5000, (p) => {
             *     console.log(p); // only print out the p after the property has stopped changing for 5 seconds
             * }));
             *
             */
            function debounce(msec, fn) {
                var prev, timer;
                return function (newValue, reason, oldValue) {
                    if (prev != newValue) {
                        prev = newValue;
                        Web.clearTimeout(timer);
                        timer = Web.setTimeout(function () {
                            fn(newValue, reason, oldValue);
                        }, msec);
                    }
                };
            }
            Utils.debounce = debounce;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * JS code lives in a single-threaded event-based environment.
             * When an event occurs, a JS handler for that event may need
             * to send multiple HTTP requests in a loop and these requests
             * may be sent as a single batch request to UCWA. To achieve that
             * the function that sends HTTP requests puts a request into a
             * queue and invokes setTimeout/postMessage in order to empty the
             * queue and send the batch request after the JS code currently
             * being executed completes sending HTTP requests and quits.
             *
             * @param {Function} batch - Sends a batch request.
             *
             *  It has the following signature:
             *
             *      Response[] batch(Request[] requests)
             *
             *  It may return the results asynchronously.
             *
             * @param {Number} maxBatchSize
             *
             *      The max number of requests that the batch can send.
             *
             * @returns A function with the following signature:
             *
             *      {async Response} send(Request request, Number priority)
             *
             *          {Request} request - A request acceptable by the <batch> function.
             *          {Number} priority - Requests with higher priority are sent first.
             *
             *      The <send> function inserts <request> into an internal queue
             *      at a position appropriate to the given <priority> value: the
             *      higher priority the sooner the request will be extracted from
             *      the queue and sent with the <batch> function.
             *
             */
            function batched(batch, maxBatchSize) {
                if (maxBatchSize === void 0) { maxBatchSize = Infinity; }
                // queue[i].request is a request to be sent with <batch>.
                // queue[i].task is a task that adopts a result of <batch>.
                // queue[i].priority is the importance of the request.
                // queue[i].priority <= queue[i + 1].priority
                var queue = [];
                // a handle of the pending timer that when expired
                // reads requests from the queue and sends them in batch
                var hTimer;
                /**
                 * Inserts a pending request into the queue and
                 * associates it with the given priority.
                 *
                 * @param {Number} priority
                 * @param {Object} request
                 * @param {Task} task
                 */
                function insert(priority, request, task) {
                    Utils.assert(Utils.isNumber(priority));
                    Utils.assert(task instanceof Utils.Task);
                    var i = 0;
                    while (i < queue.length && priority > queue[i].priority)
                        i++;
                    queue.splice(i, 0, { priority: priority, request: request, task: task });
                }
                /**
                 * Finds up to the given number of most urgent pending requests,
                 * removes them from the queue and returns them as an array.
                 *
                 * @param {Number} count
                 *
                 *      The max number of requests to extract.
                 *
                 * @returns Null or an object with two keys:
                 *
                 *      {Request[]} requests - All requests from the queue that are due to the given time.
                 *      {Task[]} tasks - Corresponding tasks.
                 */
                function extract(count) {
                    Utils.assert(count > 0);
                    Utils.assert(queue.length > 0);
                    var i, requests = [], tasks = [];
                    for (i = queue.length - 1; i >= 0 && requests.length < count; i--) {
                        requests.push(queue[i].request);
                        tasks.push(queue[i].task);
                    }
                    queue.splice(i + 1, count);
                    return { requests: requests, tasks: tasks };
                }
                /**
                 * Attempts to cancel the given task.
                 */
                function cancel(task, reason) {
                    var i;
                    for (i = 0; i < queue.length; i++)
                        if (queue[i].task === task)
                            break;
                    if (i < queue.length) {
                        // the request is still waiting in the queue,
                        // so it can be just removed from and marked as cancelled
                        queue.splice(i, 1);
                        task.reject(reason);
                    }
                    else {
                        // the request has been sent in a batch of other
                        // requests to the throttling queue; it cannot be
                        // thus cancelled, but the response may be ignored
                        task.cancelled = true;
                        task.reject(reason);
                    }
                }
                /**
                 * Periodically extracts pending requests up to maximum batch size,
                 * sends them in a batch and redirects the batch response to pending tasks.
                 */
                function send() {
                    var pending = extract(maxBatchSize);
                    function forEachPendingTask(fn) {
                        Utils.foreach(pending.tasks, function (task, i) {
                            if (!task.cancelled)
                                fn(task, i);
                        });
                    }
                    Utils.Task.wait(batch(pending.requests)).then(function (responses) {
                        forEachPendingTask(function (task, i) {
                            var rsp = Utils.isArray(responses) ? responses[i] : responses;
                            Utils.Task.wait(rsp).then(function (res) { return task.resolve(res); }, function (err) { return task.reject(err); }, task.status);
                        });
                    }, function (error) {
                        forEachPendingTask(function (task) {
                            task.reject(error);
                        });
                    }, function (status) {
                        forEachPendingTask(function (task) {
                            task.status(status);
                        });
                    });
                }
                return function _batched(request, priority) {
                    if (priority === void 0) { priority = 0; }
                    var task = new Utils.Task('Waiting in the batching queue.', {
                        cancel: function (reason) {
                            cancel(task, reason);
                        }
                    });
                    if (!hTimer) {
                        hTimer = Web.setTimeout(function () {
                            hTimer = null;
                            while (queue.length > 0)
                                send();
                        }, 0);
                    }
                    insert(priority, request, task);
                    return task.promise;
                };
            }
            Utils.batched = batched;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            var keyString = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            // fix for JavaScript modulo operation bug (wrong result for negative values)
            function mod(value, modulo) {
                return ((value % modulo) + modulo) % modulo;
            }
            /**
             * Contains static methods for conversion of UTF-16 strings to UTF-8 byte arrays
             *
             * @method byteArrayToString - converts a UTF-8 byte array to a UTF-16 string
             * @method stringToByteArray - converts a UTF-16 string to a UTF-8 byte array
             *
             */
            var ByteArray;
            (function (ByteArray) {
                /**
                 * Converts a byte array representation of a Unicode (UTF-8) string to a Unicode (UTF-16) string
                 */
                function byteArrayToString(value) {
                    Utils.assert(Utils.isArray(value));
                    var str = '', curByte, byte1, byte2, byte3, i = 0;
                    while (i < value.length) {
                        curByte = value[i];
                        if ((curByte < 0) || (curByte > 0xFF))
                            throw new Error('Unexpected utf8 byte');
                        // 1 byte, < 128, up to U+007F, ascii values
                        if (curByte < 0x80) {
                            str += String.fromCharCode(curByte);
                            i++;
                        }
                        else if ((curByte & 0xE0) == 0xC0) {
                            if ((i + 1) >= value.length)
                                throw new Error("Unexpected end of array");
                            byte1 = value[i + 1];
                            // (test for 10xxxxxx)
                            if ((byte1 < 0) || (byte1 > 0xFF) || ((byte1 & 0xC0) != 0x80))
                                throw new Error("Unexpected utf8 byte");
                            // extract 5 bits from curByte and 6 bits from byte1
                            str += String.fromCharCode(((curByte & 0x1F) << 6) | (byte1 & 0x3F));
                            i += 2;
                        }
                        else if ((curByte & 0xF0) == 0xE0) {
                            if (((i + 1) >= value.length) || ((i + 2) >= value.length))
                                throw new Error("Unexpected end of array");
                            byte1 = value[i + 1];
                            byte2 = value[i + 2];
                            // (test for 10xxxxxx)
                            if ((byte1 < 0) || (byte1 > 0xFF) || ((byte1 & 0xC0) != 0x80))
                                throw new Error("Unexpected utf8 byte");
                            // (test for 10xxxxxx)
                            if ((byte2 < 0) || (byte2 > 0xFF) || ((byte2 & 0xC0) != 0x80))
                                throw new Error("Unexpected utf8 byte");
                            // extract 4 bits from curByte and 6 bits from byte1 and byte 2
                            str += String.fromCharCode(((curByte & 0x0F) << 12) | ((byte1 & 0x3F) << 6) | (byte2 & 0x3F));
                            i += 3;
                        }
                        else if ((curByte & 0xF8) == 0xF0) {
                            if (((i + 1) >= value.length) || ((i + 2) >= value.length) || ((i + 3) >= value.length))
                                throw new Error("Unexpected end of array");
                            byte1 = value[i + 1];
                            byte2 = value[i + 2];
                            byte3 = value[i + 3];
                            // (test for 10xxxxxx)
                            if ((byte1 < 0) || (byte1 > 0xFF) || ((byte1 & 0xC0) != 0x80))
                                throw new Error("Unexpected utf8 byte");
                            // (test for 10xxxxxx)
                            if ((byte2 < 0) || (byte2 > 0xFF) || ((byte2 & 0xC0) != 0x80))
                                throw new Error("Unexpected utf8 byte");
                            // (test for 10xxxxxx)
                            if ((byte3 < 0) || (byte3 > 0xFF) || ((byte3 & 0xC0) != 0x80))
                                throw new Error("Unexpected utf8 byte");
                            // Extract 3 bits from curByte and 6 bits from byte1 and byte 2 and byte 3
                            var unicodeValue = ((curByte & 0x07) << 18) | ((byte1 & 0x3F) << 12) | ((byte2 & 0x3F) << 6) | (byte3 & 0x3F);
                            // From unicode.org utf faq
                            var lead_offset = 0xD800 - (0x10000 >> 10);
                            // Equivalent of - Subtract 0x10000, split into two 10-bit pieces
                            // Add D800 to the high 10 bit piece, Add DC00 to the low 10 bit piece
                            // to get the surrogate pairs
                            var lead = lead_offset + (unicodeValue >> 10);
                            var trail = 0xDC00 + (unicodeValue & 0x3FF);
                            str += String.fromCharCode(lead);
                            str += String.fromCharCode(trail);
                            i += 4;
                        }
                        else {
                            throw new Error('Illegal utf8 converter input');
                        }
                    }
                    return str;
                }
                ByteArray.byteArrayToString = byteArrayToString;
                /**
                 * Converts a UTF-16 string to a UTF-8 byte array
                 */
                function stringToByteArray(value) {
                    Utils.assert(Utils.isString(value));
                    var bytes = [];
                    var i = 0;
                    while (i < value.length) {
                        // JavaScript encodes strings in UTF-16 - each character is represented with one or two 16-bit values
                        // Sample - "\uD834\uDD2A" - U+1D12A represented by a UTF-16 surrogate pair
                        // Sample - "\uD800\uDC00" - U+10000 (65536) represented by a UTF-16 surrogate pair
                        // A surrogate pair needs to be converted into 4-byte utf-8
                        // Illegal to take each surrogate separately and convert into two 3-byte utf-8
                        var curChar = value.charCodeAt(i);
                        // 1 byte, < 128, upto U+007F, ascii values
                        if (curChar < 0x80) {
                            bytes.push(curChar);
                            i++;
                        }
                        else if (curChar < 0x800) {
                            // 11000000 | curchar >> 6
                            bytes.push((0xC0 | (curChar >> 6)));
                            // 10000000 | curChar & 00111111
                            bytes.push((0x80 | (curChar & 0x3F)));
                            i++;
                        }
                        else if (0xD800 <= curChar && curChar <= 0xDBFF) {
                            var highSurrogate = curChar;
                            if ((i + 1) >= value.length)
                                throw new Error('High Surrogate at the end of string');
                            var lowSurrogate = value.charCodeAt(i + 1);
                            if (!(0xDC00 <= lowSurrogate && lowSurrogate <= 0xDFFF))
                                throw new Error('High Surrogate followed by invalid low surrogate');
                            // From unicode.org utf faq
                            // (highSurrogate - 0xD800) << 10) + (lowSurrogate - 0xDC00) + 0x10000
                            var surrogate_offset = 0x10000 - (0xD800 << 10) - 0xDC00;
                            var unicodeValue = (highSurrogate << 10) + lowSurrogate + surrogate_offset;
                            // 11110000 | (unicodeValue >> 18)
                            bytes.push(0xF0 | (unicodeValue >> 18));
                            // 10000000 | (unicodeValue >> 12) & 00111111
                            bytes.push(0x80 | ((unicodeValue >> 12) & 0x3F));
                            // 10000000 | (unicodeValue >> 6) & 00111111
                            bytes.push(0x80 | ((unicodeValue >> 6) & 0x3F));
                            // 10000000 | unicodeValue & 00111111
                            bytes.push(0x80 | (unicodeValue & 0x3F));
                            // Skip the next value (already account for the low surrogate)
                            i = i + 2;
                        }
                        else if (0xDC00 <= curChar && curChar <= 0xDFFF) {
                            throw new Error("Low Surrogate not preceded by high surrogate");
                        }
                        else if (curChar < 0x10000) {
                            // 11100000 | (curchar >> 12)
                            bytes.push(0xE0 | (curChar >> 12));
                            // 10000000 | (curchar >> 6) & 00111111
                            bytes.push(0x80 | ((curChar >> 6) & 0x3F));
                            // 10000000 | curChar & 00111111
                            bytes.push(0x80 | (curChar & 0x3F));
                            i++;
                        }
                        else {
                            throw new Error('Illegal utf8 converter input');
                        }
                    }
                    return bytes;
                }
                ByteArray.stringToByteArray = stringToByteArray;
            })(ByteArray = Utils.ByteArray || (Utils.ByteArray = {}));
            /**
             * Base64 encoder for Unicode (UTF-16) strings
             *
             * @method encode - converts a Unicode (UTF-16) string to a base64-encoded string
             * @method decode - converts a base64-encoded string to a Unicode (UTF-16) string
             *
             * @example
             *
             *      var base64str = Base64().encode('Hello');
             *      var str = Base64().decode(base64str);
             *      assert(str == 'Hello');
             *
             */
            var Base64;
            (function (Base64) {
                /**
                 * Converts a Unicode string to a Base64-encoded string
                 */
                function encode(str) {
                    if (Utils.isNotEmptyString(str)) {
                        var strArray = ByteArray.stringToByteArray(str);
                        return encodeBytes(strArray);
                    }
                    else
                        return str;
                }
                Base64.encode = encode;
                /**
                 * Converts a Base64-encoded string to a Unicode (UTF-16) string
                 */
                function decode(str) {
                    if (Utils.isNotEmptyString(str)) {
                        var strArray = decodeBytes(str);
                        return ByteArray.byteArrayToString(strArray);
                    }
                    else
                        return str;
                }
                Base64.decode = decode;
                function encodeBytes(input) {
                    Utils.assert(Utils.isArray(input));
                    var output = '';
                    var chr1, chr2, chr3, encoding1, encoding2, encoding3, encoding4, i = 0;
                    while (i < input.length) {
                        chr1 = input[i++];
                        chr2 = i < input.length ? input[i++] : 0;
                        chr3 = i < input.length ? input[i++] : 0;
                        // first six bits of the first character
                        encoding1 = chr1 >> 2;
                        // last two bits of the first character and first four of the second
                        encoding2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                        // last four of the second and first two of the third
                        encoding3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                        // last six of the third character
                        encoding4 = chr3 & 63;
                        if (i == input.length) {
                            if (mod(input.length, 3) == 1) {
                                encoding3 = 64;
                                encoding4 = 64;
                            }
                            else if (mod(input.length, 3) == 2) {
                                encoding4 = 64;
                            }
                        }
                        output += keyString.charAt(encoding1) + keyString.charAt(encoding2) +
                            keyString.charAt(encoding3) + keyString.charAt(encoding4);
                    }
                    return output;
                }
                Base64.encodeBytes = encodeBytes;
                function decodeBytes(input) {
                    Utils.assert(Utils.isNotEmptyString(input));
                    var output = [];
                    var chr1, chr2, chr3, encoding1, encoding2, encoding3, encoding4, i = 0;
                    while (i < input.length) {
                        encoding1 = keyString.indexOf(input.charAt(i++));
                        encoding2 = keyString.indexOf(input.charAt(i++));
                        encoding3 = keyString.indexOf(input.charAt(i++));
                        encoding4 = keyString.indexOf(input.charAt(i++));
                        chr1 = (encoding1 << 2) | (encoding2 >> 4);
                        chr2 = ((encoding2 & 15) << 4) | (encoding3 >> 2);
                        chr3 = ((encoding3 & 3) << 6) | encoding4;
                        output.push(chr1);
                        if (encoding3 != 64)
                            output.push(chr2);
                        if (encoding4 != 64)
                            output.push(chr3);
                    }
                    return output;
                }
                Base64.decodeBytes = decodeBytes;
            })(Base64 = Utils.Base64 || (Utils.Base64 = {}));
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            var Radix = (function () {
                function Radix(radix) {
                    this.radix = radix;
                }
                /** Least Significant Byte (LSB) first:
                    0xab45fc.3d -> [0xc.3d, 0xf, 0x5, 0x4, 0xb, 0xa] */
                Radix.prototype.digits = function (value) {
                    var radix = this.radix;
                    var digits = [];
                    // before you try to optimize this loop, take into account
                    // the fancy bitwise arithmetics behavior for numbers > 2 ^ 32
                    while (value > radix) {
                        var digit = value % radix;
                        value = (value - digit) / radix;
                        digits.push(digit);
                    }
                    digits.push(value);
                    return digits;
                };
                /** Least Significant Byte (LSB) first:
                    [0xc.3d, 0xf, 0x5, 0x4, 0xb, 0xa] -> 0xab45fc.3d */
                Radix.prototype.number = function (digits) {
                    var value = 0;
                    for (var i = digits.length - 1; i >= 0; i--)
                        value = value * this.radix + digits[i];
                    return value;
                };
                return Radix;
            }());
            Utils.Radix = Radix;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * RFC 4122:
             *
             * The formal definition of the UUID string representation is
             * provided by the following ABNF [7]:
             *
             * UUID                   = time-low "-" time-mid "-"
             *                          time-high-and-version "-"
             *                          clock-seq-and-reserved
             *                          clock-seq-low "-" node
             * time-low               = 4hexOctet
             * time-mid               = 2hexOctet
             * time-high-and-version  = 2hexOctet
             * clock-seq-and-reserved = hexOctet
             * clock-seq-low          = hexOctet
             * node                   = 6hexOctet
             * hexOctet               = hexDigit hexDigit
             * hexDigit =
             *       "0" / "1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9" /
             *       "a" / "b" / "c" / "d" / "e" / "f" /
             *       "A" / "B" / "C" / "D" / "E" / "F"
             *
             * The following is an example of the string representation of a UUID as
             * a URN:
             *
             * urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6
             */
            function guid() {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                    var r = Web.Math.random() * 16 | 0;
                    var v = c == 'x' ? r : r & 3 | 8;
                    return v.toString(16);
                });
            }
            Utils.guid = guid;
            /**
             * Section 4.1.2. Layout and Byte Order:
             *
             * The fields are encoded as 16 octets, with the sizes and order of the
             * fields defined above, and with each field encoded with the Most
             * Significant Byte first (known as network byte order).  Note that the
             * field names, particularly for multiplexed fields, follow historical
             * practice.
             *
             * 0                   1                   2                   3
             *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
             * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             * |                          time_low                             |
             * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             * |       time_mid                |         time_hi_and_version   |
             * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             * |clk_seq_hi_res |  clk_seq_low  |         node (0-1)            |
             * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             * |                         node (2-5)                            |
             * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             */
            (function (guid_1) {
                function bytes(guid) {
                    var bytes = [];
                    for (var _i = 0, _a = guid.split('-'); _i < _a.length; _i++) {
                        var seg = _a[_i];
                        for (var i = 0; i < seg.length; i += 2)
                            bytes.push(parseInt(seg.slice(i, i + 2), 16));
                    }
                    return bytes;
                }
                guid_1.bytes = bytes;
                function parse(bytes) {
                    return bytes.map(function (b, i) {
                        var s = (0x100 | b).toString(16).slice(1, 3);
                        return (i == 4 || i == 6 || i == 8 || i == 10) ? '-' + s : s;
                    }).join('');
                }
                guid_1.parse = parse;
            })(guid = Utils.guid || (Utils.guid = {}));
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            function padRight(str, num, char) {
                if (str.length >= num)
                    return str;
                else
                    return str + (new Array(num - str.length + 1).join(char));
            }
            /**
             * Returns a 128-bit message digest in the form of a GUID-like string.
             */
            function hash(str) {
                var state = [1578336022, 36261640, 872437806, 2915948275];
                str = padRight(str, str.length + 16 - str.length % 16, '0');
                for (var i = 0; i < str.length; i += 4) {
                    for (var j = 0; j < 4; j++) {
                        var h3 = str.charCodeAt(i) << 24;
                        var h2 = str.charCodeAt(i + 1) << 16;
                        var h1 = str.charCodeAt(i + 2) << 8;
                        var h0 = str.charCodeAt(i + 3);
                        var input = h3 + h2 + h1 + h0;
                        state[j] = ((state[j] << 5) + state[j]) ^ input; // (s*33) XOR input
                    }
                }
                var result = state.map(function (s) { return (0x100000000 + s).toString(16).slice(-8); });
                return [
                    result[0],
                    result[1].substr(0, 4),
                    result[1].substr(4, 4),
                    result[2].substr(0, 4),
                    result[2].substr(4, 4) + result[3]
                ].join('-');
            }
            Utils.hash = hash;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            var Exception = Utils.Exception;
            var async = Utils.async;
            /**
             * This class synchronizes a series of tasks and allows only one task to complete successfully.
             * When a task is synchronized by an instance of SyncLock, it waits until the all the currently
             * pending tasks are completed. Once one task succeeds, all the remaining tasks that are waiting
             * will be rejected.
             *
             * @example
             *
             *   var syncLock = new SyncLock();
             *
             *   var result = [promise1, promise2, promise3, promise4].map(promise => {
             *     return Task.wait(promise)
             *       .then(syncLock.synchronized(res => {
             *         // do the work ...
             *         ...
             *       }))
             *       .then(res => {
             *         // continue to do other stuff
             *       });
             *   });
             *
             */
            var SyncLock = (function () {
                function SyncLock(code) {
                    this.code = code;
                }
                SyncLock.prototype.synchronized = function (fn) {
                    var afn = async(fn), self = this;
                    return (function sfn() {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        if (self.dfd) {
                            return self.dfd.then(function (r) { throw Exception(self.code); }, function (e) {
                                if (e && e.code == 'Canceled')
                                    throw e;
                                self.dfd = null; // this is not a proper fix. need a rework.
                                return sfn.apply(void 0, args);
                            });
                        }
                        else {
                            var d = self.dfd = afn.apply(void 0, args);
                            return d;
                        }
                    });
                };
                return SyncLock;
            }());
            Utils.SyncLock = SyncLock;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            /**
             * @param delay Returns the next delay in seconds.
             * @param test Tells if it's ok to retry.
             */
            function retry(delay, test, fn) {
                var tryit = function () { return fn().catch(function (err) {
                    if (!test(err))
                        throw err;
                    var dt = delay(err);
                    if (dt >= 0)
                        return Utils.sleep(dt).then(tryit);
                    throw err;
                }); };
                return tryit();
            }
            Utils.retry = retry;
            /**
             * @param firstDelay The first delay in seconds.
             * @param maxAttempts The max number of attempts to try.
             * @param factor The delay is multiplied by this number after every failure.
             */
            function expdelay(firstDelay, maxAttempts, factor) {
                if (factor === void 0) { factor = 1.5; }
                var dt = firstDelay;
                var attempt = 0;
                return function () {
                    if (attempt++ < maxAttempts) {
                        var t = dt;
                        dt *= factor;
                        return t;
                    }
                };
            }
            Utils.expdelay = expdelay;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
//*******************************************************************************
//
//    Copyright 2014 Microsoft
//    
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//    
//        http://www.apache.org/licenses/LICENSE-2.0
//    
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//
//*******************************************************************************
"use strict";
/// #region JSCop/JsHint
/* global self */
/* jshint -W098 */
/* W098 is 'defined but not used'. These properties are used in other scripts. */
//  REMOVED: <reference path="jsCopDefs.js" />
// Sets the url to for this script.
// We need this to pass to webWorkers later to instantiate them.
/// <dictionary>fprng</dictionary>
/// #endregion JSCop/JsHint
/// Store the URL for this script. We will need this later to instantiate
/// new web workers (if supported).
var scriptUrl = (function () {
    /* jshint -W117 */
    if (typeof document !== "undefined") {
        // Use error.stack to find out the name of this script
        try {
            throw new Error();
        }
        catch (e) {
            if (e.stack) {
                var match = /\w+:\/\/(.+?\/)*.+\.js/.exec(e.stack);
                return (match && match.length > 0) ? match[0] : null;
            }
        }
    }
    else if (typeof self !== "undefined") {
        // If this script is being run in a WebWorker, 'document' will not exist
        //  but we can use self.        
        return self.location.href;
    }
    // We must be running in an environment without document or self.
    return null;
    /* jshint +W117 */
})();
// Indication if the user provided entropy into the entropy pool.
var fprngEntropyProvided = false;
// Support for webWorkers IE10+.
var webWorkerSupport = (typeof Worker !== "undefined");
// Is this script running in an instance of a webWorker?
var runningInWorkerInstance = (typeof importScripts !== "undefined");
// Typed Arrays support?
var typedArraySupport = (typeof Uint8Array !== "undefined");
// Property setter/getter support IE9+.
var setterSupport = (function () {
    try {
        Object.defineProperty({}, "oncomplete", {});
        return true;
    }
    catch (ex) {
        return false;
    }
}());
// Run in async mode (requires web workers) and user can override to sync mode
//  by setting the .forceSync property to true on the subtle interface
//  this can be changes 'on the fly'.
var asyncMode = webWorkerSupport;
var createProperty = function (parentObject, propertyName, /*@dynamic*/ initialValue, getterFunction, setterFunction) {
    /// <param name="parentObject" type="Object"/>
    /// <param name="propertyName" type="String"/>
    /// <param name="initialValue" type="Object"/>
    /// <param name="getterFunction" type="Function"/>
    /// <param name="setterFunction" type="Function" optional="true"/>
    if (!setterSupport) {
        parentObject[propertyName] = initialValue;
        return;
    }
    var setGet = {};
    getterFunction && (setGet.get = getterFunction);
    setterFunction && (setGet.set = setterFunction);
    Object.defineProperty(parentObject, propertyName, setGet);
};
// Collection of hash functions for global availability.
// Each hashfunction will add itself to the collection as it is evaluated.
var msrcryptoHashFunctions = {};
//*******************************************************************************
//
//    Copyright 2014 Microsoft
//    
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//    
//        http://www.apache.org/licenses/LICENSE-2.0
//    
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//
//*******************************************************************************
"use strict";
/// #region JSCop/JsHint
/* jshint -W016 */
/// <reference path="global.js" />
//  REMOVED: <reference path="jsCopDefs.js" />
/// <dictionary>
///    msrcrypto, Btoa, uint, hexval, res, xor
/// </dictionary>
/// #endregion JSCop/JsHint
var msrcryptoUtilities = (function () {
    var encodingChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var btoaSupport = (typeof btoa !== "undefined");
    function toBase64(data, base64Url) {
        /// <signature>
        ///     <summary>Converts byte data to Base64 string</summary>
        ///     <param name="data" type="Array">An array of bytes values (numbers from 0-255)</param>
        ///     <param name="base64Url" type="Boolean" optional="true">Converts to a Base64Url string if True (default = false)</param>
        ///     <returns type="String" />
        /// </signature>
        /// <signature>
        ///     <summary>Converts byte data to Base64 string</summary>
        ///     <param name="data" type="UInt8Array">A UInt8Array</param>
        ///     <param name="base64Url" type="Boolean" optional="true">Converts to a Base64Url string if True (default = false)</param>
        ///     <returns type="String" />
        /// </signature>
        /// <signature>
        ///     <summary>Converts text to Base64 string</summary>
        ///     <param name="data" type="String">Text string</param>
        ///     <param name="base64Url" type="Boolean" optional="true">Converts to a Base64Url string if True (default = false)</param>
        ///     <returns type="String" />
        /// </signature>
        var output = "";
        if (!base64Url) {
            base64Url = false;
        }
        // If the input is an array type, convert it to a string.
        // The built-in btoa takes strings.
        if (data.pop || data.subarray) {
            data = String.fromCharCode.apply(null, data);
        }
        if (btoaSupport) {
            output = btoa(data);
        }
        else {
            var char1, char2, char3, enc1, enc2, enc3, enc4;
            var i;
            for (i = 0; i < data.length; i += 3) {
                // Get the next three chars.
                char1 = data.charCodeAt(i);
                char2 = data.charCodeAt(i + 1);
                char3 = data.charCodeAt(i + 2);
                // Encode three bytes over four 6-bit values.
                // [A7,A6,A5,A4,A3,A2,A1,A0][B7,B6,B5,B4,B3,B2,B1,B0][C7,C6,C5,C4,C3,C2,C1,C0].
                // [A7,A6,A5,A4,A3,A2][A1,A0,B7,B6,B5,B4][B3,B2,B1,B0,C7,C6][C5,C4,C3,C2,C1,C0].
                // 'enc1' = high 6-bits from char1
                enc1 = char1 >> 2;
                // 'enc2' = 2 low-bits of char1 + 4 high-bits of char2
                enc2 = ((char1 & 0x3) << 4) | (char2 >> 4);
                // 'enc3' = 4 low-bits of char2 + 2 high-bits of char3
                enc3 = ((char2 & 0xF) << 2) | (char3 >> 6);
                // 'enc4' = 6 low-bits of char3
                enc4 = char3 & 0x3F;
                // 'char2' could be 'nothing' if there is only one char left to encode
                //   if so, set enc3 & enc4 to 64 as padding.
                if (isNaN(char2)) {
                    enc3 = enc4 = 64;
                }
                else if (isNaN(char3)) {
                    enc4 = 64;
                }
                // Lookup the base-64 value for each encoding.
                output = output +
                    encodingChars.charAt(enc1) +
                    encodingChars.charAt(enc2) +
                    encodingChars.charAt(enc3) +
                    encodingChars.charAt(enc4);
            }
        }
        if (base64Url) {
            return output.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
        }
        return output;
    }
    function base64ToString(encodedString) {
        /// <signature>
        ///     <summary>Converts a Base64/Base64Url string to a text</summary>
        ///     <param name="encodedString" type="String">A Base64/Base64Url encoded string</param>
        ///     <returns type="String" />
        /// </signature>
        if (btoaSupport) {
            // This could be encoded as base64url (different from base64)
            encodedString = encodedString.replace(/-/g, "+").replace(/_/g, "/");
            // In case the padding is missing, add some.
            while (encodedString.length % 4 !== 0) {
                encodedString += "=";
            }
            return atob(encodedString);
        }
        return String.fromCharCode.apply(null, base64ToBytes(encodedString));
    }
    function base64ToBytes(encodedString) {
        /// <signature>
        ///     <summary>Converts a Base64/Base64Url string to an Array</summary>
        ///     <param name="encodedString" type="String">A Base64/Base64Url encoded string</param>
        ///     <returns type="Array" />
        /// </signature>
        // This could be encoded as base64url (different from base64)
        encodedString = encodedString.replace(/-/g, "+").replace(/_/g, "/");
        // In case the padding is missing, add some.
        while (encodedString.length % 4 !== 0) {
            encodedString += "=";
        }
        var output = [];
        var char1, char2, char3;
        var enc1, enc2, enc3, enc4;
        var i;
        // Remove any chars not in the base-64 space.
        encodedString = encodedString.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        for (i = 0; i < encodedString.length; i += 4) {
            // Get 4 characters from the encoded string.
            enc1 = encodingChars.indexOf(encodedString.charAt(i));
            enc2 = encodingChars.indexOf(encodedString.charAt(i + 1));
            enc3 = encodingChars.indexOf(encodedString.charAt(i + 2));
            enc4 = encodingChars.indexOf(encodedString.charAt(i + 3));
            // Convert four 6-bit values to three characters.
            // [A7,A6,A5,A4,A3,A2][A1,A0,B7,B6,B5,B4][B3,B2,B1,B0,C7,C6][C5,C4,C3,C2,C1,C0].
            // [A7,A6,A5,A4,A3,A2,A1,A0][B7,B6,B5,B4,B3,B2,B1,B0][C7,C6,C5,C4,C3,C2,C1,C0].
            // 'char1' = all 6 bits of enc1 + 2 high-bits of enc2.
            char1 = (enc1 << 2) | (enc2 >> 4);
            // 'char2' = 4 low-bits of enc2 + 4 high-bits of enc3.
            char2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            // 'char3' = 2 low-bits of enc3 + all 6 bits of enc4.
            char3 = ((enc3 & 3) << 6) | enc4;
            // Convert char1 to string character and append to output
            output.push(char1);
            // 'enc3' could be padding
            //   if so, 'char2' is ignored.
            if (enc3 !== 64) {
                output.push(char2);
            }
            // 'enc4' could be padding
            //   if so, 'char3' is ignored.
            if (enc4 !== 64) {
                output.push(char3);
            }
        }
        return output;
    }
    function getObjectType(object) {
        /// <signature>
        ///     <summary>Returns the name of an object type</summary>
        ///     <param name="object" type="Object"></param>
        ///     <returns type="String" />
        /// </signature>
        return Object.prototype.toString.call(object).slice(8, -1);
    }
    function bytesToHexString(bytes, separate) {
        /// <signature>
        ///     <summary>Converts an Array of bytes values (0-255) to a Hex string</summary>
        ///     <param name="bytes" type="Array"/>
        ///     <param name="separate" type="Boolean" optional="true">Inserts a separator for display purposes (default = false)</param>
        ///     <returns type="String" />
        /// </signature>
        var result = "";
        if (typeof separate === "undefined") {
            separate = false;
        }
        for (var i = 0; i < bytes.length; i++) {
            if (separate && (i % 4 === 0) && i !== 0) {
                result += "-";
            }
            var hexval = bytes[i].toString(16).toUpperCase();
            // Add a leading zero if needed.
            if (hexval.length === 1) {
                result += "0";
            }
            result += hexval;
        }
        return result;
    }
    function bytesToInt32(bytes, index) {
        /// <summary>
        /// Converts four bytes to a 32-bit int
        /// </summary>
        /// <param name="bytes">The bytes to convert</param>
        /// <param name="index" optional="true">Optional starting point</param>
        /// <returns type="Number">32-bit number</returns>
        index = (index || 0);
        return (bytes[index] << 24) |
            (bytes[index + 1] << 16) |
            (bytes[index + 2] << 8) |
            bytes[index + 3];
    }
    function stringToBytes(messageString) {
        /// <signature>
        ///     <summary>Converts a String to an Array of byte values (0-255)</summary>
        ///     <param name="messageString" type="String"/>
        ///     <returns type="Array" />
        /// </signature>
        var bytes = new Array(messageString.length);
        for (var i = 0; i < bytes.length; i++) {
            bytes[i] = messageString.charCodeAt(i);
        }
        return bytes;
    }
    function hexToBytesArray(hexString) {
        /// <signature>
        ///     <summary>Converts a Hex-String to an Array of byte values (0-255)</summary>
        ///     <param name="hexString" type="String"/>
        ///     <returns type="Array" />
        /// </signature>
        hexString = hexString.replace(/\-/g, "");
        var result = [];
        while (hexString.length >= 2) {
            result.push(parseInt(hexString.substring(0, 2), 16));
            hexString = hexString.substring(2, hexString.length);
        }
        return result;
    }
    function clone(object) {
        /// <signature>
        ///     <summary>Creates a shallow clone of an Object</summary>
        ///     <param name="object" type="Object"/>
        ///     <returns type="Object" />
        /// </signature>
        var newObject = {};
        for (var propertyName in object) {
            if (object.hasOwnProperty(propertyName)) {
                newObject[propertyName] = object[propertyName];
            }
        }
        return newObject;
    }
    function unpackData(base64String, arraySize, toUint32s) {
        /// <signature>
        ///     <summary>Unpacks Base64 encoded data into arrays of data.</summary>
        ///     <param name="base64String" type="String">Base64 encoded data</param>
        ///     <param name="arraySize" type="Number" optional="true">Break data into sub-arrays of a given length</param>
        ///     <param name="toUint32s" type="Boolean" optional="true">Treat data as 32-bit data instead of byte data</param>
        ///     <returns type="Array" />
        /// </signature>
        var bytes = base64ToBytes(base64String), data = [], i;
        if (isNaN(arraySize)) {
            return bytes;
        }
        else {
            for (i = 0; i < bytes.length; i += arraySize) {
                data.push(bytes.slice(i, i + arraySize));
            }
        }
        if (toUint32s) {
            for (i = 0; i < data.length; i++) {
                data[i] = (data[i][0] << 24) + (data[i][1] << 16) + (data[i][2] << 8) + data[i][3];
            }
        }
        return data;
    }
    function int32ToBytes(int32) {
        /// <signature>
        ///     <summary>Converts a 32-bit number to an Array of 4 bytes</summary>
        ///     <param name="int32" type="Number">32-bit number</param>
        ///     <returns type="Array" />
        /// </signature>
        return [(int32 >>> 24) & 255, (int32 >>> 16) & 255, (int32 >>> 8) & 255, int32 & 255];
    }
    function int32ArrayToBytes(int32Array) {
        /// <signature>
        ///     <summary>Converts an Array 32-bit numbers to an Array bytes</summary>
        ///     <param name="int32Array" type="Array">Array of 32-bit numbers</param>
        ///     <returns type="Array" />
        /// </signature>
        var result = [];
        for (var i = 0; i < int32Array.length; i++) {
            result = result.concat(int32ToBytes(int32Array[i]));
        }
        return result;
    }
    function xorVectors(a, b) {
        /// <signature>
        ///     <summary>Exclusive OR (XOR) two arrays.</summary>
        ///     <param name="a" type="Array">Input array.</param>
        ///     <param name="b" type="Array">Input array.</param>
        ///     <returns type="Array">XOR of the two arrays. The length is minimum of the two input array lengths.</returns>
        /// </signature>
        var length = Math.min(a.length, b.length), res = new Array(length);
        for (var i = 0; i < length; i += 1) {
            res[i] = a[i] ^ b[i];
        }
        return res;
    }
    function getVector(length, fillValue) {
        /// <signature>
        ///     <summary>Get an array filled with zeroes (or optional fillValue.)</summary>
        ///     <param name="length" type="Number">Requested array length.</param>
        ///     <param name="fillValue" type="Number" optional="true"></param>
        ///     <returns type="Array"></returns>
        /// </signature>
        // Use a default value of zero
        fillValue || (fillValue = 0);
        var res = new Array(length);
        for (var i = 0; i < length; i += 1) {
            res[i] = fillValue;
        }
        return res;
    }
    function toArray(typedArray) {
        /// <signature>
        ///     <summary>Converts a UInt8Array to a regular JavaScript Array</summary>
        ///     <param name="typedArray" type="UInt8Array"></param>
        ///     <returns type="Array"></returns>
        /// </signature>
        // If undefined or null return an empty array
        if (!typedArray) {
            return [];
        }
        // If already an Array return it
        if (typedArray.pop) {
            return typedArray;
        }
        // If it's an ArrayBuffer, convert it to a Uint8Array first
        if (typedArray.isView) {
            typedArray = Uint8Array(typedArray);
        }
        // A single element array will cause a new Array to be created with the length
        // equal to the value of the single element. Not what we want.
        // We'll return a new single element array with the single value.
        return (typedArray.length === 1) ? [typedArray[0]] : Array.apply(null, typedArray);
    }
    function padEnd(array, value, finalLength) {
        /// <signature>
        ///     <summary>Pads the end of an array with a specified value</summary>
        ///     <param name="array" type="Array"></param>
        ///     <param name="value" type="Number">The value to pad to the array</param>
        ///     <param name="finalLength" type="Number">The final resulting length with padding</param>
        ///     <returns type="Array"></returns>
        /// </signature>
        while (array.length < finalLength) {
            array.push(value);
        }
        return array;
    }
    function padFront(array, value, finalLength) {
        /// <signature>
        ///     <summary>Pads the front of an array with a specified value</summary>
        ///     <param name="array" type="Array"></param>
        ///     <param name="value" type="Number">The value to pad to the array</param>
        ///     <param name="finalLength" type="Number">The final resulting length with padding</param>
        ///     <returns type="Array"></returns>
        /// </signature>
        while (array.length < finalLength) {
            array.unshift(value);
        }
        return array;
    }
    function arraysEqual(array1, array2) {
        /// <signature>
        ///     <summary>Checks if two Arrays are equal by comparing their values.</summary>
        ///     <param name="array1" type="Array"></param>
        ///     <param name="array2" type="Array"></param>
        ///     <returns type="Array"></returns>
        /// </signature>
        var result = true;
        if (array1.length !== array2.length) {
            result = false;
        }
        for (var i = 0; i < array1.length; i++) {
            if (array1[i] !== array2[i]) {
                result = false;
            }
        }
        return result;
    }
    function verifyByteArray(array) {
        /// <signature>
        ///     <summary>Verify that an Array contains only byte values (0-255)</summary>
        ///     <param name="array" type="Array"></param>
        ///     <returns type="Boolean">Returns true if all values are 0-255</returns>
        /// </signature>
        if (getObjectType(array) !== "Array") {
            return false;
        }
        var element;
        for (var i = 0; i < array.length; i++) {
            element = array[i];
            if (isNaN(element) || element < 0 || element > 255) {
                return false;
            }
        }
        return true;
    }
    return {
        toBase64: toBase64,
        base64ToString: base64ToString,
        base64ToBytes: base64ToBytes,
        getObjectType: getObjectType,
        bytesToHexString: bytesToHexString,
        bytesToInt32: bytesToInt32,
        stringToBytes: stringToBytes,
        unpackData: unpackData,
        hexToBytesArray: hexToBytesArray,
        int32ToBytes: int32ToBytes,
        int32ArrayToBytes: int32ArrayToBytes,
        toArray: toArray,
        arraysEqual: arraysEqual,
        clone: clone,
        xorVectors: xorVectors,
        padEnd: padEnd,
        padFront: padFront,
        getVector: getVector,
        verifyByteArray: verifyByteArray
    };
})();
//*******************************************************************************
//
//    Copyright 2014 Microsoft
//    
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//    
//        http://www.apache.org/licenses/LICENSE-2.0
//    
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//
//*******************************************************************************
"use strict";
var operations = {};
operations.register = function (operationType, algorithmName, functionToCall) {
    if (!operations[operationType]) {
        operations[operationType] = {};
    }
    var op = operations[operationType];
    if (!op[algorithmName]) {
        op[algorithmName] = functionToCall;
    }
};
operations.exists = function (operationType, algorithmName) {
    if (!operations[operationType]) {
        return false;
    }
    return (operations[operationType][algorithmName]) ? true : false;
};
/// #region JSCop/JsHint
"use strict";
/// <disable>
/// JS2025.InsertSpaceBeforeCommentText,
/// JS2027.PunctuateCommentsCorrectly,
/// JS2074.IdentifierNameIsMisspelled,
/// JS3056.DeclareVariablesOnceOnly,
/// JS3053.IncorrectNumberOfArguments,
/// JS2005.UseShortFormInitializations,
/// JS2073.CommentIsMisspelled,
/// JS3092.DeclarePropertiesBeforeUse
/// </disable>
/// #endregion JSCop/JsHint
//*******************************************************************************
//
//    Copyright 2014 Microsoft
//    
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//    
//        http://www.apache.org/licenses/LICENSE-2.0
//    
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//
//*******************************************************************************
function BlockFunctionTypeDef(message, blockIndex, initialHashValues, k, w) {
    /// <signature>
    ///     <summary>
    ///         Type definition for block function
    ///     </summary>
    ///     <param name="message" type="Array">Block data</param>
    ///     <param name="blockIndex" type="Number">Block number to operate on</param>
    ///     <param name="initialHashValues" type="Array"></param>
    ///     <param name="k" type="Array">K constants</param>
    ///     <param name="w" type="Array">Array to hold w values</param>
    ///     <returns type="Array">Hash values</returns>
    /// </signature>
    return [];
}
var msrcryptoSha = function (name, der, h, k, blockBytes, blockFunction, truncateTo) {
    /// <summary>
    /// Returns a hash function using the passed in parameters.
    /// </summary>
    /// <param name="name" type="String">Name of the hash function.</param>
    /// <param name="der" type="Array"></param>
    /// <param name="h" type="Array"></param>
    /// <param name="k" type="Array"></param>
    /// <param name="blockBytes" type="Number">The number of bytes in a block.</param>
    /// <param name="blockFunction" type="BlockFunctionTypeDef">Function for processing blocks.</param>
    /// <param name="truncateTo" type="Number">Truncate the resulting hash to a fixed length.</param>
    /// <returns type="Object"></returns>
    var utils = msrcryptoUtilities;
    // Make a copy of h so we don't alter the initialization array.
    var hv = h.slice(), w = new Array(blockBytes), buffer = [], blocksProcessed = 0;
    function hashBlocks(message) {
        /// <summary>
        /// Breaks a array of data into full blocks and hashes each block in sequence.
        /// Data at the end of the message that does not fill an entire block is
        /// returned.
        /// </summary>
        /// <param name="message" type="Array">Byte data to hash</param>
        /// <returns type="Array">Unprocessed data at the end of the message that did
        /// not fill an entire block.</returns>
        var blockCount = Math.floor(message.length / blockBytes);
        // Process each  block of the message
        for (var block = 0; block < blockCount; block++) {
            blockFunction(message, block, hv, k, w);
        }
        // Keep track of the number of blocks processed.
        // We have to put the total message size into the padding.
        blocksProcessed += blockCount;
        // Return the unprocessed data.
        return message.slice(blockCount * blockBytes);
    }
    function hashToBytes() {
        /// <summary>
        /// Converts stored hash values (32-bit ints) to bytes.
        /// </summary>
        /// <returns type="Array"></returns>
        // Move the results to an uint8 array.
        var hash = [];
        for (var i = 0; i < hv.length; i++) {
            hash = hash.concat(utils.int32ToBytes(hv[i]));
        }
        // Truncate the results depending on the hash algorithm used.
        hash.length = (truncateTo / 8);
        return hash;
    }
    function addPadding(messageBytes) {
        /// <summary>
        /// Builds and appends padding to a message
        /// </summary>
        /// <param name="messageBytes" type="Array">Message to pad</param>
        /// <returns type="Array">The message array + padding</returns>
        var padLen = blockBytes - messageBytes.length % blockBytes;
        // If there is 8 (16 for sha-512) or less bytes of padding, pad an additional block.
        (padLen <= (blockBytes / 8)) && (padLen += blockBytes);
        // Create a new Array that will contain the message + padding
        var padding = utils.getVector(padLen);
        // Set the 1 bit at the end of the message data
        padding[0] = 128;
        // Set the length equal to the previous data len + the new data len
        var messageLenBits = (messageBytes.length + blocksProcessed * blockBytes) * 8;
        // Set the message length in the last 4 bytes
        padding[padLen - 4] = messageLenBits >>> 24 & 255;
        padding[padLen - 3] = messageLenBits >>> 16 & 255;
        padding[padLen - 2] = messageLenBits >>> 8 & 255;
        padding[padLen - 1] = messageLenBits & 255;
        return messageBytes.concat(padding);
    }
    function computeHash(messageBytes) {
        /// <summary>
        /// Computes the hash of an entire message.
        /// </summary>
        /// <param name="messageBytes" type="Array">Byte array to hash</param>
        /// <returns type="Array">Hash of message bytes</returns>
        buffer = hashBlocks(messageBytes);
        return finish();
    }
    function process(messageBytes) {
        /// <summary>
        /// Call process repeatedly to hash a stream of bytes. Then call 'finish' to
        /// complete the hash and get the final result.
        /// </summary>
        /// <param name="messageBytes" type="Array"></param>
        // Append the new data to the buffer (previous unprocessed data)
        buffer = buffer.concat(messageBytes);
        // If there is at least one block of data, hash it
        if (buffer.length >= blockBytes) {
            // The remaining unprocessed data goes back into the buffer
            buffer = hashBlocks(buffer);
        }
        return;
    }
    function finish() {
        /// <summary>
        /// Called after one or more calls to process. This will finalize the hashing
        /// of the 'streamed' data and return the hash.
        /// </summary>
        /// <returns type="Array">Hash of message bytes</returns>
        // All the full blocks of data have been processed. Now we pad the rest and hash.
        // Buffer should be empty now.
        if (hashBlocks(addPadding(buffer)).length !== 0) {
            throw new Error("buffer.length !== 0");
        }
        // Convert the intermediate hash values to bytes
        var result = hashToBytes();
        // Reset the buffer
        buffer = [];
        // Restore the initial hash values
        hv = h.slice();
        // Reset the block counter
        blocksProcessed = 0;
        return result;
    }
    return {
        name: name,
        computeHash: computeHash,
        process: process,
        finish: finish,
        der: der,
        hashLen: truncateTo,
        maxMessageSize: 0xFFFFFFFF // (2^32 - 1 is max array size in JavaScript)
    };
};
//*******************************************************************************
//
//    Copyright 2014 Microsoft
//    
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//    
//        http://www.apache.org/licenses/LICENSE-2.0
//    
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//
//*******************************************************************************
"use strict";
/// #region JSCop/JsHint
/* global operations */
/* jshint -W016 */
/* jshint -W052 */
/// <reference path="operations.js" />
/// <dictionary>msrcrypto, der, sha</dictionary>
/// <disable>JS3057.AvoidImplicitTypeCoercion</disable>
/// #endregion JSCop/JsHint
var msrcryptoSha256 = (function () {
    var utils = msrcryptoUtilities;
    function hashBlock(message, blockIndex, hv, k, w) {
        /// <summary>
        /// Block function for hashing algorithm to use.
        /// </summary>
        /// <param name="message" type="Array">Block data to hash</param>
        /// <param name="blockIndex" type="Number">The block of the data to hash</param>
        /// <param name="hv" type="Array">Initial hash values</param>
        /// <param name="k" type="Array">K constants</param>
        /// <param name="w" type="Array">Buffer for w values</param>
        /// <returns type="Array">Updated initial hash values</returns>
        var t, i, temp, x0, x1, blockSize = 64, mask = 0xFFFFFFFF;
        var ra = hv[0], rb = hv[1], rc = hv[2], rd = hv[3], re = hv[4], rf = hv[5], rg = hv[6], rh = hv[7];
        // 0 â‰¤ t â‰¤ 15
        for (i = 0; i < 16; i++) {
            w[i] = utils.bytesToInt32(message, blockIndex * blockSize + i * 4);
        }
        // 16 â‰¤ t â‰¤ 63
        for (t = 16; t < 64; t++) {
            x0 = w[t - 15];
            x1 = w[t - 2];
            w[t] = (((x1 >>> 17) | (x1 << 15)) ^ ((x1 >>> 19) | (x1 << 13)) ^ (x1 >>> 10))
                + w[t - 7]
                + (((x0 >>> 7) | (x0 << 25)) ^ ((x0 >>> 18) | (x0 << 14)) ^ (x0 >>> 3))
                + w[t - 16];
            w[t] = w[t] & mask;
        }
        for (i = 0; i < 64; i++) {
            temp = rh +
                ((re >>> 6 | re << 26) ^ (re >>> 11 | re << 21) ^ (re >>> 25 | re << 7)) +
                ((re & rf) ^ ((~re) & rg)) +
                k[i] + w[i];
            rd += temp;
            temp += ((ra >>> 2 | ra << 30) ^ (ra >>> 13 | ra << 19) ^ (ra >>> 22 | ra << 10)) +
                ((ra & (rb ^ rc)) ^ (rb & rc));
            rh = rg; // 'h' = g
            rg = rf; // 'g' = f
            rf = re; // 'f' = e
            re = rd; // 'e' = d
            rd = rc; // 'd' = c
            rc = rb; // 'c' = b
            rb = ra; // 'b' = a
            ra = temp; // 'a' = temp
        }
        // Update the hash values
        hv[0] += ra & mask;
        hv[1] += rb & mask;
        hv[2] += rc & mask;
        hv[3] += rd & mask;
        hv[4] += re & mask;
        hv[5] += rf & mask;
        hv[6] += rg & mask;
        hv[7] += rh & mask;
        return hv;
    }
    var k256, h224, h256, der224, der256, upd = utils.unpackData;
    h224 = upd("wQWe2DZ81QcwcN0X9w5ZOf/ACzFoWBURZPmPp776T6Q", 4, 1);
    h256 = upd("agnmZ7tnroU8bvNypU/1OlEOUn+bBWiMH4PZq1vgzRk", 4, 1);
    k256 = upd("QoovmHE3RJG1wPvP6bXbpTlWwltZ8RHxkj+CpKscXtXYB6qYEoNbASQxhb5VDH3Dcr5ddIDesf6b3AanwZvxdOSbacHvvkeGD8GdxiQMocwt6SxvSnSEqlywqdx2+YjamD5RUqgxxm2wAyfIv1l/x8bgC/PVp5FHBspjURQpKWcntwqFLhshOE0sbfxTOA0TZQpzVHZqCruBwskuknIshaK/6KGoGmZLwkuLcMdsUaPRkugZ1pkGJPQONYUQaqBwGaTBFh43bAgnSHdMNLC8tTkcDLNO2KpKW5zKT2gub/N0j4LueKVjb4TIeBSMxwIIkL7/+qRQbOu++aP3xnF48g", 4, 1);
    // SHA-224 DER encoding
    // 0x30, 0x2d, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x04, 0x05, 0x00, 0x04, 0x1C
    der224 = upd("MC0wDQYJYIZIAWUDBAIEBQAEHA");
    // SHA-256 DER encoding
    // 0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20
    der256 = upd("MDEwDQYJYIZIAWUDBAIBBQAEIA");
    return {
        sha224: msrcryptoSha("SHA-224", der224, h224, k256, 64, hashBlock, 224),
        sha256: msrcryptoSha("SHA-256", der256, h256, k256, 64, hashBlock, 256)
    };
})();
if (typeof operations !== "undefined") {
    msrcryptoSha256.hash256 = function (/*@dynamic*/ p) {
        if (p.operationSubType === "process") {
            msrcryptoSha256.sha256.process(p.buffer);
            return;
        }
        if (p.operationSubType === "finish") {
            return msrcryptoSha256.sha256.finish();
        }
        return msrcryptoSha256.sha256.computeHash(p.buffer);
    };
    msrcryptoSha256.hash224 = function (/*@dynamic*/ p) {
        if (p.operationSubType === "process") {
            msrcryptoSha256.sha224.process(p.buffer);
            return;
        }
        if (p.operationSubType === "finish") {
            return msrcryptoSha256.sha224.finish();
        }
        return msrcryptoSha256.sha224.computeHash(p.buffer);
    };
    operations.register("digest", "sha-224", msrcryptoSha256.hash224);
    operations.register("digest", "sha-256", msrcryptoSha256.hash256);
}
msrcryptoHashFunctions["sha-224"] = msrcryptoSha256.sha224;
msrcryptoHashFunctions["sha-256"] = msrcryptoSha256.sha256;
/// <reference path="../../Libs/msrCrypto/utilities.js" />
/// <reference path="../../Libs/msrCrypto/operations.js" />
/// <reference path="../../Libs/msrCrypto/sha.js" />
/// <reference path="../../Libs/msrCrypto/sha256.js" />
"use strict";
/**
 * A simple Sha256 hash function to protect PII sent as part of telemetry.
 *
 * Built on top of functions defined in the msrcrypto project, v1.4, which
 * is licensed under the Apache license
 * http://research.microsoft.com/en-us/projects/msrjscrypto/
 *
 */
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            function sha256Hash(input) {
                var iBytes = Utils.ByteArray.stringToByteArray(input);
                var hBytes = operations['digest']['sha-256']({ buffer: iBytes });
                var hexOut = '';
                hBytes.forEach(function (b) { hexOut += padByte(b.toString(16)); });
                return hexOut;
            }
            Utils.sha256Hash = sha256Hash;
            // make sure that each hex byte is 2 string characters by adding a
            // 0 before any byte whose value is less than 16 
            // ('0'-'f') => ('00'-'0f') 
            function padByte(bHexStr) {
                Utils.assert(bHexStr.length <= 2 && bHexStr.length > 0);
                return bHexStr.length == 2 ? bHexStr : '0' + bHexStr;
            }
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        /**
         * Reads and merges all matching entries in SS/LS.
         * For instance, if the given path is "a.b.c", then
         * this function first checks if such an entry already
         * exists and returns it if it does. Otherwise if finds
         * all keys starting with the path, e.g. "a.b.c.d", "a.b.c.e.f",
         * and merges corresponding values, so the result would
         * look like { d: ?, e: { f: ? } }.
         */
        function read(storage, root) {
            var val = storage.getItem(root);
            if (val !== null && val !== undefined)
                return JSON.parse(val);
            var keys = [];
            for (var key in storage)
                if (key.slice(0, root.length + 1) == root + '.')
                    keys.push(key);
            if (!keys.length)
                return;
            var res = {};
            for (var _i = 0, keys_3 = keys; _i < keys_3.length; _i++) {
                var key = keys_3[_i];
                var val_1 = JSON.parse(storage.getItem(key));
                var rel = key.slice(root.length + 1).split('.');
                var r = res;
                for (var i = 0; i < rel.length - 1; i++) {
                    var k = rel[i];
                    r[k] = r[k] || {};
                    r = r[k];
                }
                r[rel[rel.length - 1]] = val_1;
            }
            return res;
        }
        var LSProp = (function () {
            function LSProp(path, prep) {
                this.path = path;
                this.prep = prep;
            }
            LSProp.prototype.get = function () {
                var val;
                try {
                    val = read(Web.localStorage, this.path);
                }
                catch (err) {
                }
                return this.prep(val);
            };
            return LSProp;
        }());
        var ls;
        (function (ls) {
            /** the `settings` parameter for the Application ctor, that usually comes from ECS */
            ls.ctor = new LSProp('lwsdk.ctor', function (x) { return x || {}; });
            /** enables logging of UCWA traffic: requests, responses, events */
            ls.logs = new LSProp('lwsdk.logs', function (x) { return !!x; });
            /** enables custom object formatters in Chrome's dev console */
            ls.cfmt = new LSProp('lwsdk.cfmt', function (x) { return x; });
            /** enables the prefix for text analysis tools, e.g. [EVENT] and [REQUEST] */
            ls.pref = new LSProp('lwsdk.pref', function (x) { return x; });
            /** enables breakpoints in certain places */
            var bp;
            (function (bp) {
                bp.ctor = new LSProp('lwsdk.bp.ctor', function (x) { return !!x; });
            })(bp = ls.bp || (ls.bp = {}));
        })(ls = Web.ls || (Web.ls = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            Utils.BROWSERS = {
                MSIE: 'MSIE',
                CHROME: 'Chrome',
                FIREFOX: 'Firefox',
                SAFARI: 'Safari',
                EDGE: 'Edge',
                ELECTRON: 'Electron',
                SKYPE_SHELL: 'SkypeShell',
                PHANTOMJS: 'PhantomJS',
                UNKNOWN: 'Unknown'
            }, Utils.OPERATING_SYSTEMS = {
                WINDOWS: 'Windows',
                MACOSX: 'Mac OS X',
                WINDOWS_PHONE: 'Windows Phone',
                WINDOWS_RT: 'Windows RT',
                IOS: 'iOS',
                ANDROID: 'Android',
                LINUX: 'Linux',
                UNKNOWN: 'Unknown'
            }, Utils.DEVICE_TYPES = {
                DESKTOP: 1,
                MOBILE: 2,
                TABLET: 8
            }, Utils.VERSION_MAPPINGS = {
                '5.1': 'XP',
                '6.0': 'Vista',
                '6.1': '7',
                '6.2': '8',
                '6.3': '8.1',
                '10.0': '10'
            }, Utils.CSS_PROPERTIES = {
                OBJECT_FIT: 'objectFit'
            }, Utils.UNKNOWN_VERSION = 'U', Utils.CHROME_NPAPI_NOT_SUPPORTED_VERSION_MAJOR = '42', Utils.REGEX_VERSION = '([\\d,.]+)', Utils.REGEX_VERSION_MAC = '([\\d,_,.]+)';
            var EnvInfo = (function () {
                function EnvInfo() {
                }
                EnvInfo.getHostname = function () {
                    return location.hostname;
                };
                EnvInfo.getUserAgent = function () {
                    return Web.window.navigator.userAgent;
                };
                EnvInfo.userAgentContainsString = function (searchString) {
                    return this.getUserAgent().indexOf(searchString) > -1;
                };
                EnvInfo.isIe = function () {
                    return this.userAgentContainsString('Trident');
                };
                EnvInfo.isEdge = function () {
                    return this.userAgentContainsString(Utils.BROWSERS.EDGE);
                };
                EnvInfo.isOpera = function () {
                    return this.userAgentContainsString('OPR/');
                };
                EnvInfo.getBrowserName = function () {
                    if (this.isOpera()) {
                        return Utils.BROWSERS.UNKNOWN;
                    }
                    if (this.userAgentContainsString(Utils.BROWSERS.PHANTOMJS)) {
                        return Utils.BROWSERS.PHANTOMJS;
                    }
                    if (this.isEdge()) {
                        return Utils.BROWSERS.EDGE;
                    }
                    if (this.userAgentContainsString(Utils.BROWSERS.ELECTRON)) {
                        return Utils.BROWSERS.ELECTRON;
                    }
                    if (this.userAgentContainsString(Utils.BROWSERS.CHROME)) {
                        return Utils.BROWSERS.CHROME;
                    }
                    if (this.userAgentContainsString(Utils.BROWSERS.FIREFOX)) {
                        return Utils.BROWSERS.FIREFOX;
                    }
                    if (this.userAgentContainsString(Utils.BROWSERS.SAFARI)) {
                        return Utils.BROWSERS.SAFARI;
                    }
                    if (this.userAgentContainsString(Utils.BROWSERS.SKYPE_SHELL)) {
                        return Utils.BROWSERS.SKYPE_SHELL;
                    }
                    if (this.isIe()) {
                        return Utils.BROWSERS.MSIE;
                    }
                    return Utils.BROWSERS.UNKNOWN;
                };
                EnvInfo.getBrowserVersion = function () {
                    if (this.isIe()) {
                        return getIeVersion.call(this);
                    }
                    else {
                        return getOtherVersion.call(this, this.getBrowserName());
                    }
                    function getIeVersion() {
                        var ieVersionMatches, userAgent = this.getUserAgent(), classicIeVersionMatches = userAgent.match(new RegExp(Utils.BROWSERS.MSIE + ' ' + Utils.REGEX_VERSION));
                        if (classicIeVersionMatches) {
                            return classicIeVersionMatches[1];
                        }
                        else {
                            ieVersionMatches = userAgent.match(new RegExp('rv:' + Utils.REGEX_VERSION));
                            if (ieVersionMatches) {
                                return ieVersionMatches[1];
                            }
                        }
                        return undefined;
                    }
                    function getOtherVersion(browserString) {
                        var matches;
                        if (browserString === Utils.BROWSERS.SAFARI) {
                            browserString = 'Version';
                        }
                        matches = this.getUserAgent().match(new RegExp(browserString + '/' + Utils.REGEX_VERSION));
                        if (matches) {
                            return matches[1];
                        }
                        return Utils.UNKNOWN_VERSION;
                    }
                };
                EnvInfo.deviceType = function () {
                    var mobile = /(android|ipod|windows phone|wpdesktop|windows ce|blackberry\w*|meego|webos|palm|symbian|pda|\w*?mobile\w*?|\w*?phone\w*?)/i, tablet = /tablet|ipad/i;
                    if (this.getUserAgent().match(mobile)) {
                        return Utils.DEVICE_TYPES.MOBILE;
                    }
                    if (this.getUserAgent().match(tablet)) {
                        return Utils.DEVICE_TYPES.TABLET;
                    }
                    return Utils.DEVICE_TYPES.DESKTOP;
                };
                EnvInfo.getOsName = function () {
                    var win = /(windows|win32)/i, winrt = / arm;/i, winphone = /windows\sphone\s\d+\.\d+/i, osx = /(macintosh|mac os x)/i, ios = /(iPad|iPhone|iPod)(?=.*like Mac OS X)/i, linux = /(linux|joli|[kxln]?ubuntu|debian|[open]*suse|gentoo|arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|cros)/i, android = /android/i;
                    var userAgent = this.getUserAgent();
                    if (userAgent.match(winphone)) {
                        return Utils.OPERATING_SYSTEMS.WINDOWS_PHONE;
                    }
                    if (userAgent.match(winrt)) {
                        return Utils.OPERATING_SYSTEMS.WINDOWS_RT;
                    }
                    if (userAgent.match(ios)) {
                        return Utils.OPERATING_SYSTEMS.IOS;
                    }
                    if (userAgent.match(android)) {
                        return Utils.OPERATING_SYSTEMS.ANDROID;
                    }
                    if (userAgent.match(linux)) {
                        return Utils.OPERATING_SYSTEMS.LINUX;
                    }
                    if (userAgent.match(osx)) {
                        return Utils.OPERATING_SYSTEMS.MACOSX;
                    }
                    if (userAgent.match(win)) {
                        return Utils.OPERATING_SYSTEMS.WINDOWS;
                    }
                    return Utils.OPERATING_SYSTEMS.UNKNOWN;
                };
                EnvInfo.getOsVersion = function () {
                    if (this.getOsName() === Utils.OPERATING_SYSTEMS.WINDOWS) {
                        return getWindowsVersion.call(this);
                    }
                    if (this.getOsName() === Utils.OPERATING_SYSTEMS.MACOSX) {
                        return getMacOsxVersion.call(this);
                    }
                    return Utils.UNKNOWN_VERSION;
                    function getWindowsVersion() {
                        var ntVersionMatches = this.getUserAgent().match(new RegExp('Windows NT ' + Utils.REGEX_VERSION));
                        if (ntVersionMatches && Utils.VERSION_MAPPINGS[ntVersionMatches[1]]) {
                            return Utils.VERSION_MAPPINGS[ntVersionMatches[1]];
                        }
                        return Utils.UNKNOWN_VERSION;
                    }
                    function getMacOsxVersion() {
                        var macOsxVersionInUserAgentMatches = this.getUserAgent().match(new RegExp(Utils.OPERATING_SYSTEMS.MACOSX + ' ' + Utils.REGEX_VERSION_MAC));
                        if (macOsxVersionInUserAgentMatches) {
                            return parseVersion(macOsxVersionInUserAgentMatches[1].replace(/_/g, '.')).getMajor();
                        }
                        return Utils.UNKNOWN_VERSION;
                    }
                };
                EnvInfo.mapWindowsVersion = function (version) {
                    if (Utils.VERSION_MAPPINGS[version])
                        return Utils.VERSION_MAPPINGS[version];
                    else
                        return version;
                };
                /**
                 * This code is borrowed from SWX, but existing webSDK telemetry uses slightly
                 * different consts for some things. This function maps SWX consts to webSdk ones.
                 */
                EnvInfo.castSWXConstToWebSDK = function (c) {
                    switch (c) {
                        case Utils.BROWSERS.EDGE:
                            return 'Microsoft Edge';
                        case Utils.BROWSERS.MSIE:
                            return 'IExplorer';
                        case Utils.OPERATING_SYSTEMS.MACOSX:
                            return 'Mac OSX';
                        case Utils.UNKNOWN_VERSION:
                            return 'Unknown';
                        default:
                            return c;
                    }
                };
                return EnvInfo;
            }());
            Utils.EnvInfo = EnvInfo;
            var Version = (function () {
                function Version(versionString) {
                    this.unknownVersionString = 'U';
                    this.isVersionValid = true;
                    this.versionString = versionString;
                    this.parseComponents();
                }
                Version.prototype.getMajor = function () {
                    return this.components[0];
                };
                Version.prototype.getMinor = function () {
                    return this.components[1];
                };
                Version.prototype.getAllComponents = function () {
                    return this.components;
                };
                Version.prototype.getOriginalString = function () {
                    return this.versionString;
                };
                Version.prototype.isValid = function () {
                    return this.isVersionValid;
                };
                Version.prototype.compareTo = function (otherVersion) {
                    var component = 0, otherVersionComponent = 0, otherVersionComponents = otherVersion.getAllComponents();
                    if (!this.isValid() || !otherVersion.isValid()) {
                        throw new Error('Invalid version cannot be compared');
                    }
                    for (var i = 0; i < otherVersionComponents.length; ++i) {
                        component = parseInt(this.components[i], 10);
                        otherVersionComponent = parseInt(otherVersionComponents[i], 10);
                        if (!component || component < otherVersionComponent) {
                            return -1;
                        }
                        else if (component > otherVersionComponent) {
                            return 1;
                        }
                    }
                    return 0;
                };
                Version.prototype.parseComponents = function () {
                    if (!this.versionString) {
                        this.components = [this.unknownVersionString, this.unknownVersionString];
                        this.isVersionValid = false;
                        return;
                    }
                    var delimiter = this.getDelimiter();
                    if (delimiter) {
                        this.components = this.versionString.split(delimiter);
                        this.validateComponents();
                    }
                    else {
                        this.components = [this.versionString, this.unknownVersionString];
                        this.isVersionValid = false;
                    }
                };
                Version.prototype.validateComponents = function () {
                    for (var i = 0; i < this.components.length; ++i) {
                        if (!this.components[i] || isNaN(parseInt(this.components[i], 10))) {
                            this.components.push(this.unknownVersionString);
                            this.isVersionValid = false;
                            break;
                        }
                    }
                };
                Version.prototype.getDelimiter = function () {
                    if (this.versionString.indexOf('.') > -1) {
                        return '.';
                    }
                    if (this.versionString.indexOf('_') > -1) {
                        return '_';
                    }
                    return null;
                };
                return Version;
            }());
            var parseVersion = function (versionString) { return new Version(versionString); };
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="pm/Model.ts" />
/// <reference path="utils/Pattern.ts" />
/// <reference path="utils/URI.ts" />
/// <reference path="utils/DataURI.ts" />
/// <reference path="utils/CSS.ts" />
/// <reference path="utils/XML.ts" />
/// <reference path="utils/HTML.ts" />
/// <reference path="utils/W3A.ts" />
/// <reference path="utils/HTTP.ts" />
/// <reference path="utils/LINQ.ts" />
/// <reference path="utils/StateMachine.ts" />
/// <reference path="utils/repeat.ts" />
/// <reference path="utils/throttled.ts" />
/// <reference path="utils/debounced.ts" />
/// <reference path="utils/batched.ts" />
/// <reference path="utils/Base64.ts" />
/// <reference path="utils/Radix.ts" />
/// <reference path="utils/GUID.ts" />
/// <reference path="utils/hash.ts" />
/// <reference path="utils/SyncLock.ts" />
/// <reference path="utils/retry.ts" />
/// <reference path="utils/msrcrypto.ts" />
/// <reference path="utils/lsm.ts" />
/// <reference path="utils/env.ts" />
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        // 0.4.545 master number is injected from build system
        Web.version = '0.4.545 master'.replace(/[{}]/g, ''); // major.minor.patch+build (see semver.org)
        /** This simple pattern is known as "monad" and it's useful
            to chain dependent objects in a type safe manner. */
        var Identity = (function () {
            function Identity(value) {
                this.value = value;
            }
            Identity.prototype.map = function (fn) {
                return new Identity(fn(this.value));
            };
            return Identity;
        }());
        Web.Identity = Identity;
        var Settings;
        (function (Settings) {
            /** Add timestamps to logs (There are no native timestamps in Microsoft Edge/IE console);
                const declaration allows to change the value in console only */
            Settings.timestamps = false;
            Settings.saveConsole = false;
            Settings.logSize = 0;
        })(Settings = Web.Settings || (Web.Settings = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            var sha256 = Utils.sha256Hash;
            var debug;
            (function (debug) {
                debug.debugInfo = {};
                var consoleLogs;
                function initLogBuffer() {
                    consoleLogs = Utils.extend([], {
                        size: 0,
                        maxSize: Web.Settings.logSize || Math.pow(2, 22) // 4 MB
                    });
                }
                function stringifyDebugInfo() {
                    var dbgString = "";
                    function addIfDefined(name, value) {
                        if (value !== undefined)
                            dbgString += (name + ": " + value + "\r\n");
                    }
                    Object.keys(debug.debugInfo).forEach(function (propName) {
                        if (propName == "correlation_ids") {
                            Object.keys(debug.debugInfo[propName]).forEach(function (cidName) {
                                addIfDefined("cid_" + cidName, debug.debugInfo[propName][cidName]);
                            });
                        }
                        else {
                            addIfDefined(propName, debug.debugInfo[propName]);
                        }
                    });
                    return dbgString;
                }
                function dumpDebugInfo() {
                    console.log(stringifyDebugInfo());
                }
                debug.dumpDebugInfo = dumpDebugInfo;
                function logToBuffer() {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    if (!Web.Settings.saveConsole)
                        throw Error('Logging to file is disabled');
                    if (!consoleLogs)
                        initLogBuffer();
                    var s = args.map(function (x) { return Utils.isObject(x) ? JSON.stringify(x) : x + ''; }).join(' ') + '\r\n';
                    consoleLogs.push(s);
                    consoleLogs.size += s.length * 2;
                    var newSize = consoleLogs.size, i = 0;
                    while (newSize > consoleLogs.maxSize) {
                        newSize -= consoleLogs[i].length * 2;
                        i++;
                    }
                    consoleLogs.size = newSize;
                    consoleLogs.splice(0, i);
                }
                function saveConsole(fileName) {
                    if (fileName === void 0) { fileName = new Web.Date().toJSON() + '.log'; }
                    if (!Web.Settings.saveConsole)
                        throw Error('Logging to file is disabled.');
                    consoleLogs.splice(0, 0, stringifyDebugInfo());
                    var browser = Utils.EnvInfo.getBrowserName();
                    if (browser == Utils.BROWSERS.MSIE || browser == Utils.BROWSERS.EDGE) {
                        var blob = new Blob(consoleLogs, { type: 'text/plain' });
                        navigator.msSaveOrOpenBlob(blob, fileName);
                    }
                    else if (browser == Utils.BROWSERS.SAFARI) {
                        // Safari makes downloading a file client side exceptionally difficult.
                        // The best solution I found online was this:
                        // Save data as blob with mimetype text/plain
                        // createObjectURL of the blob
                        // Call window.open on that url, then user has to manually Cmd-S save the file
                        // However, can't simply call window.open because it needs to be triggered by some
                        // kind of trusted user action, hence briefly setting it to be triggered when the
                        // user clicks anywhere on the page.
                        if (!(Web.window && Web.window.onclick)) {
                            throw Error('Cannot save to console - browser not supported');
                        }
                        var blob = new Blob(consoleLogs, { type: 'text/plain' });
                        var blobURL_1 = URL.createObjectURL(blob);
                        var oldOnClick_1 = Web.window.onclick;
                        Web.window.onclick = function () {
                            Web.window.open(blobURL_1);
                            Web.window.onclick = oldOnClick_1;
                            URL.revokeObjectURL(blobURL_1);
                        };
                    }
                    else {
                        var blob = new Blob(consoleLogs, { type: 'text/plain' });
                        var a = document.createElement('a');
                        a.href = URL.createObjectURL(blob);
                        a['download'] = fileName;
                        a.click();
                    }
                }
                debug.saveConsole = saveConsole;
                function prependTimestamp() {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    var d = new Web.Date;
                    var s = d.toTimeString();
                    s = s.slice(0, 8) + ':' + d.getMilliseconds() + ' ';
                    // if the first argument is a string prepend it with 
                    // the generated timestamp
                    if (Utils.isString(args[0]))
                        s += args.splice(0, 1)[0];
                    args.splice(0, 0, s);
                    return args;
                }
                function logToConsole() {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    if (!Web.isUnitTested) {
                        try {
                            // A log statement may have Chrome/FF-style format specifiers 
                            // (developers.google.com/web/tools/chrome-devtools/console/console-write)
                            // '%c' encountered in the first parameter (a string, in this case) applies 
                            // CSS style rules  to the output string as specified by the second parameter. 
                            // If the caller of this method inserts a string tag (as this SDK does in all
                            // log statements) before the format string containing '%c' specifier, we need 
                            // to concatenate it with the formatted string
                            if (Utils.isString(args[0]) && Utils.isString(args[1]) && args[1].indexOf('%c') != -1)
                                args.splice(0, 2, args[0] + args[1]);
                            // In IE/Edge console.log doesn't support some features like rendering
                            // preview of objects/arrays in the middle of the argument list.
                            if (/\b(Trident)|(Edge)\b/i.test(navigator.userAgent)) {
                                args = args.map(function (x) { return Utils.isPrimitive(x) ? x : JSON.stringify(x); });
                                // %c in console.log isn't supported by IE/Edge
                                if (typeof args[0] == 'string') {
                                    var fmt = args[0];
                                    var idx = 1;
                                    for (var i = 0; i < fmt.length; i++) {
                                        if (fmt[i] == '%' && /^[a-z]$/i.test(fmt[i + 1])) {
                                            if (fmt[i + 1] == 'c') {
                                                fmt = fmt.slice(0, i) + fmt.slice(i + 2);
                                                args.splice(idx, 1);
                                                i--;
                                                idx--;
                                            }
                                            idx++;
                                        }
                                    }
                                    args[0] = fmt;
                                }
                            }
                            console.log.apply(console, args);
                        }
                        catch (err) {
                        }
                    }
                }
                /**
                 * The flag parameter allows different module-specific log functions
                 * to only log to the console based on a setting specific to that module,
                 * such as 'Settings.logModel'
                 */
                function watch(flag, description, p) {
                    p.changed(function (val, reason, old) {
                        if (old === void 0)
                            return;
                        var args = [
                            description + ": %c " + old + " -> " + val,
                            'color:green;font-weight:bold'
                        ];
                        if (reason) {
                            args.push('Reason:');
                            args.push(reason);
                        }
                        var tsArgs = prependTimestamp(args);
                        if (flag) {
                            if (Web.Settings.timestamps)
                                logToConsole.apply(void 0, tsArgs);
                            else
                                logToConsole.apply(void 0, args);
                        }
                        if (Web.Settings.saveConsole)
                            logToBuffer.apply(void 0, tsArgs);
                    });
                }
                debug.watch = watch;
                /**
                 * Depending on ECS settings, log to either the developer console, to a
                 * circular log buffer that can be saved as a file, or both.
                 *
                 * If Settings.saveConsole is true, all log statements will be written to
                 * the buffer to potentially be saved. If the flag passed as a parameter
                 * is true, log to the console as well. In this way, module-specific log
                 * functions can wrap this log function and control whether they log to the
                 * console based on a setting specific to that module, such as
                 * 'Settings.logModel'
                 */
                function log(flag) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    var tsArgs = prependTimestamp.apply(void 0, args);
                    if (flag) {
                        if (Web.Settings.timestamps)
                            logToConsole.apply(void 0, tsArgs);
                        else
                            logToConsole.apply(void 0, args);
                    }
                    if (Web.Settings.saveConsole)
                        logToBuffer.apply(void 0, tsArgs);
                }
                debug.log = log;
            })(debug = Utils.debug || (Utils.debug = {}));
            var SipUri;
            (function (SipUri) {
                /** Checks if a string is a valid SIP URI. */
                SipUri.test = function (s) { return /\^sips?:/i; };
            })(SipUri = Utils.SipUri || (Utils.SipUri = {}));
            Utils.cleanwsp = function (s) { return s.replace(/\s*\n\s*/gm, ''); };
            /** Tag functions for ES6 template strings. */
            var TSTags;
            (function (TSTags) {
                /** Removes indentation and line breaks from simple multiline strings. */
                function merge() {
                    var strings = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        strings[_i] = arguments[_i];
                    }
                    return Utils.cleanwsp(strings.join(''));
                }
                TSTags.merge = merge;
            })(TSTags = Utils.TSTags || (Utils.TSTags = {}));
            //#region various utils
            //#region sleep
            /**
             * Returns a promise that gets resolved after the given delay.
             *
             * @param {Number} delay - The delay in seconds, e.g. 1.5 means 1500 milliseconds.
             * @returns {Promise}
             * @example
             *
             *      sleep(1.5).then(function () {
             *          alert("1.5 seconds has left.");
             *      });
             */
            function sleep(delay) {
                Utils.assert(delay >= 0);
                var task = new Utils.Task(delay + ' sec timeout', {
                    cancel: function (reason) {
                        Web.clearTimeout(id);
                        task.reject(reason);
                    }
                });
                var id = Web.setTimeout(function () { return task.resolve(); }, (delay * 1000) | 0);
                return task.promise;
            }
            Utils.sleep = sleep;
            //#endregion
            //#region trim
            function trim(s) {
                return s.trim ? s.trim() : s.replace(/^\s+|\s+$/gm, '');
            }
            Utils.trim = trim;
            //#endregion
            //#region freeze
            /**
             * Freezes the object (makes the object immutable)
             *
             * @param {Object} obj - an object to freeze
             * @returns {Object} obj - the object passed to this function
             */
            function freeze(obj) {
                return Object.freeze ? Object.freeze(obj) : obj;
            }
            Utils.freeze = freeze;
            //#endregion
            //#region enums
            /**
             * Creates a string enumeration.
             *
             * @param {arguments} - a collection of strings.
             * @returns {object} -  an object which has property names-values equal to each string
             *                      in the arguments collection
             *
             * @example
             *      var se = StringEnum('red', 'green', 'blue');
             *      assert(se.red === 'red');
             *      var yellow = se.yellow; will throw
             */
            function StringEnum() {
                var values = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    values[_i] = arguments[_i];
                }
                var obj = {}, name, i;
                for (i = 0; i < values.length; i++) {
                    name = values[i];
                    obj[name] = name;
                }
                return freeze(obj);
            }
            Utils.StringEnum = StringEnum;
            /**
             * Creates an enumeration.
             *
             * @param {arguments} - a collection of strings.
             * @returns {object} - an object which has property names equal to argument strings
             *      and property values equal to argument string positions
             *
             * @example
             *      var se = Enum('red', 'green', 'blue');
             *      assert(se.red === 0);
             *      var yellow = se.yellow; will throw
             *
             * or an enumeration can be set explicitly by using
             * @param {object} - a dictionary of name-value pairs
             * @returns {object} - the frozen parameter object
             *
             * @example
             *   var se = Enum({red: 1, green: 5, blue: 8});
             *   assert(se.green == 5);
             *
             * @remark use the companion function enumName to get the enum name from its value
             */
            function Enum() {
                var values = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    values[_i] = arguments[_i];
                }
                var obj, i;
                if (values.length == 1 && Utils.isDictionary(values[0])) {
                    obj = arguments[0];
                }
                else {
                    obj = {};
                    for (i = 0; i < values.length; i++)
                        obj[values[i]] = i;
                }
                return freeze(obj);
            }
            Utils.Enum = Enum;
            /**
             * Returns enum name from its value
             */
            function enumName(enumObj, enumVal) {
                for (var name in enumObj) {
                    if (enumObj[name] == enumVal)
                        return name;
                }
                return '';
            }
            Utils.enumName = enumName;
            //#endregion
            //#region clone
            /**
             * Returns an exact copy of the given object.
             * The copy has no relationships with the original
             * object, so if the original object gets modified,
             * the copy doesn't change.
             *
             */
            function clone(object) {
                return object && JSON.parse(JSON.stringify(object));
            }
            Utils.clone = clone;
            //#endregion
            //#endregion various utils          
            //#region singleton
            /**
             * Returns a single instance of an object constructed by the argument function
             *
             * @example
             *      var s = singleton(function() {
             *                  return { ticks: (new Date).getTime() };
             *              });
             *      var t0 = s().ticks, t1 = s().ticks;
             *      assert(t0 == t1);
             */
            function singleton(ctor) {
                Utils.assert(Utils.isFunction(ctor));
                var instance = null;
                return function () {
                    return instance || (instance = ctor());
                };
            }
            Utils.singleton = singleton;
            //#endregion
            //#region timeStampToDate
            /**
             * Converts a UCWA-style text representation of a timestamp
             * into a Date object: "/Date(11111111111)/" => new Date(11111111111)
             */
            function timeStampToDate(ts) {
                if (!ts) {
                    return ts;
                }
                // "/Date(11111111111)/" => new Date(11111111111)
                var p = /\d+/.exec(ts);
                return new Web.Date(p && +p[0]);
            }
            Utils.timeStampToDate = timeStampToDate;
            //#endregion
            //#region dateToTimeStamp
            /**
             * Converts a Date object into a formatted string
             *
             * @param {Date} date
             *
             * @returns {string} - in the form of '/Date(123)/'
             */
            function dateToTimeStamp(date) {
                if (!date) {
                    return date;
                }
                // Date(11111111111) => "/Date(11111111111)/"
                return '\/Date(' + (+date) + ')\/';
            }
            Utils.dateToTimeStamp = dateToTimeStamp;
            //#region currentUTCms
            /**
             * Returns current UTC time as the number of milliseconds from epoch (UTC).
             * Note: Calculation is current local computer time plus the timezone offset from UTC
             *
             * @returns {number} - the sum of current local computer time and the timezone offset from UTC
             */
            function currentUTCms() {
                return Web.Date.now() + new Web.Date().getTimezoneOffset() * 60 * 1000;
            }
            Utils.currentUTCms = currentUTCms;
            //#endregion
            Utils.max = function (a, b) { return a > b ? a : b; };
            Utils.min = function (a, b) { return a < b ? a : b; };
            /**
             * Returns the number of 1-char edits to turn one string into another.
             * For instance, "abc" can be turned with 1 edit into "abd" or "bc",
             * and with 2 edits can be turned into "a" or "12c".
             */
            function sdist(a, b) {
                var d = function (i, j) { return d[i + ',' + j]; };
                for (var i = 0; i <= a.length; i++)
                    for (var j = 0; j <= b.length; j++)
                        d[i + ',' + j] = !i || !j ? i || j :
                            Utils.min(d(i - 1, j - 1) + (a[i - 1] != b[j - 1]), // edit i-th or j-th char
                            1 + Utils.min(d(i - 1, j), d(i, j - 1))); // remove i-th or j-th char
                return d(a.length, b.length);
            }
            Utils.sdist = sdist;
            function obscureAuthHeader(req, authHeaderName) {
                if (authHeaderName === void 0) { authHeaderName = 'Authorization'; }
                var hash = function (s) { return '<hash:' + s.length + ':' + sha256(s).slice(0, 6) + '>'; };
                var authHeader = req && req.headers && req.headers[authHeaderName];
                try {
                    // deliberately adding the '_' so that the value doesn't get hashed again for telemetry
                    if (authHeader)
                        req.headers[authHeaderName] = authHeader.replace(/\b(Bearer [a-z]+=|Bearer |cwt=|psat=)([.\w-]+)/img, function (_, $1, $2) { return '_' + $1 + hash($2); });
                }
                catch (_) {
                    if (authHeader)
                        req.headers[authHeaderName] = '<hashed>';
                }
                return req;
            }
            Utils.obscureAuthHeader = obscureAuthHeader;
            /**
             * decorated([a, b, c], f) is same as a(b(c(f)))
             * and in addition to that any of a, b, c can be null.
             *
             * Once decorators for function expressions/arrow functions
             * become supported in typescript, this function can be removed.
             */
            function decorated(decorators, fn) {
                for (var i = decorators.length - 1; i >= 0; i--) {
                    var d = decorators[i];
                    if (d)
                        fn = d(fn);
                }
                return fn;
            }
            Utils.decorated = decorated;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var guid = Web.Utils.guid;
        var extend = Web.Utils.extend;
        var sha256 = Web.Utils.sha256Hash;
        var flatten = Web.Utils.flatten;
        var nothrow = Web.Utils.nothrow;
        var isFunction = Web.Utils.isFunction;
        var isPrimitive = Web.Utils.isPrimitive;
        var EnvInfo = Web.Utils.EnvInfo;
        var defaultTenantToken = 'afe05df65cc74b958837195cd87d2ff0-e0f88ee6-25f5-49b5-ae35-25c6b40faa7f-7176';
        var hash = function (s) { return '<hash:' + s.length + ':' + sha256(s).slice(0, 6) + '>'; };
        var tttkey = 'ttt_trace';
        function getProperties(properties) {
            try {
                return isFunction(properties) ? properties() : properties;
            }
            catch (ex) {
                return {};
            }
        }
        var TelemetryRecorder = (function () {
            function TelemetryRecorder(telemetryManager, tenantToken, disabled, ttt_events, tzip_url) {
                if (tenantToken === void 0) { tenantToken = defaultTenantToken; }
                this.telemetryManager = telemetryManager;
                this.tenantToken = tenantToken;
                this.disabled = disabled;
                this.ttt_events = ttt_events;
                this.tzip_url = tzip_url;
                /** These props are attached to every telemetry record. */
                this.defaults = {
                    hostName: EnvInfo.getHostname(),
                    sdkVersion: Web.version
                };
                this.cidProps = {};
                /**
                 * Strings listed here are removed from all telemetry reports.
                 * Only keys of excluded are used, values are ignored.
                 */
                this.excluded = {};
                this.collectOII = true;
                /**
                 * If reason property is the result of a monitored promise being rejected, it may
                 * contain fields whose values are OII. In this case, we remove all these properties
                 * after flattening the reason except for those whose names are matched by this list.
                 */
                this.knownSafeReasonProperties = new RegExp("\\b(" +
                    "reason" +
                    "|[\\w\\d_]*stack" +
                    "|[\\w_]*code" +
                    "|[\\w_]*subcode" +
                    "|[\\w_]*message" +
                    "|code" +
                    "|[\\w_]*status" +
                    "|[\\w_]*statusText" +
                    "|[\\w_]*headers_Date" +
                    "|[\\w_]*headers_X_Ms_Correlation_Id" +
                    ")\\b", 'i');
            }
            TelemetryRecorder.prototype.addCorrelationIds = function (initParams) {
                if (!initParams || !initParams.correlationIds) {
                    return;
                }
                var MAX_ID_SIZE = 128, MAX_IDS = 10;
                var correlationIdCount = 0;
                for (var key in initParams.correlationIds) {
                    var value = initParams.correlationIds[key];
                    if (correlationIdCount < MAX_IDS && value && isPrimitive(value) && (value.length ? value.length <= MAX_ID_SIZE : true)) {
                        correlationIdCount++;
                        if (key == 'upn')
                            this.cidProps['cid_' + key] = [value,
                                initParams.dogfood == true ? TelemetryRecorder.PIIType.NotSet : TelemetryRecorder.PIIType.Identity];
                        else
                            this.cidProps['cid_' + key] = value;
                    }
                }
            };
            /** Only primitive types (and no undefineds) should be allowed else the event fails to get sent */
            TelemetryRecorder.prototype.checkValue = function (value) {
                return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean';
            };
            /**
             * only add properties here which simplify things in Aria graphs by allowing you to
             *choose a single property vs choosing multiple properties.
             * eg. response_status
             */
            TelemetryRecorder.prototype.addDashboardProps = function (p) {
                // For RequestFailed errors, the response status is in the #rsp field
                // For other errors, the response (if existing) status is in the #response field
                // or in the p.reason.p.reason.status;
                p.response_status =
                    p.reason.rsp && p.reason.rsp.status ||
                        p.reason.response && p.reason.response.status ||
                        p.reason.reason && p.reason.reason.response && p.reason.reason.response.status;
                p.srv_err_code = p.reason.rsp && p.reason.rsp.data && p.reason.rsp.data.code ||
                    p.reason.reason && p.reason.reason.code; // Don't add p.reason.code here since that is usually a field set by the sdk in an exception.
                p.srv_err_subcode = p.reason.rsp && p.reason.rsp.data && p.reason.rsp.data.subcode ||
                    p.reason.subcode ||
                    p.reason.reason && p.reason.reason.subcode; // eg. promise is rejected with an exception with event.reason
                p.srv_err_msg = p.reason.rsp && p.reason.rsp.data && p.reason.rsp.data.message ||
                    p.reason.message ||
                    p.reason.reason && p.reason.reason.message; // eg. promise is rejected with event.reason without wrapping in an exception
            };
            /** Discard any properties whose values aren't primitive or 2 element arrays where
             *  the second element denotes a PII type for Aria
             */
            TelemetryRecorder.prototype.discardInvalidProperties = function (properties) {
                for (var propertyName in properties) {
                    var propertyValue = properties[propertyName];
                    if (Array.isArray(propertyValue)) {
                        if (!this.checkValue(propertyValue[0]) || (propertyValue[1] && typeof propertyValue[1] !== 'number'))
                            delete properties[propertyName];
                    }
                    else {
                        if (!this.checkValue(propertyValue))
                            delete properties[propertyName];
                    }
                }
            };
            /**
             * Wrap a property value in the oiiPropertyValue format
             * If collectOII is not disabled, TelemetryRecorder.record will automatically
             * promote the 'value' so that the data that reaches Aria will just be
             * the key-value pair { OIIProp: 'oii' }. If collectOII is disabled, the whole
             * property and value will be deleted before being sent to Aria.
             */
            TelemetryRecorder.prototype.oiiPropertyValue = function (v) {
                return { value: v, isOII: true };
            };
            // Remove all properties from a flattened 'reason' object except for
            // those explicitly deemed safe
            TelemetryRecorder.prototype.removeOIIReasonProperties = function (reason) {
                for (var p in reason) {
                    if (!this.knownSafeReasonProperties.test(p))
                        delete reason[p];
                }
                return reason;
            };
            /** Looks for properties with values of the form { value: v, isOII: true }
             * If collectOII is disabled, deletes them. Otherwise sets their value to v.
             * Note this function searches structures for values tagged as OII but will not continue
             * searching for values tagged as OII within a structure tagged as OII.
             *
             * ie. this is invalid, and the inner structure won't be modified by this function:
             * tr.record('xyz', {
             *      reason: {
             *          value: {
             *              nested_oii: {
             *                  value: 'oii',
             *                  isOII: true
             *              }
             *          },
             *          isOII: true
             *      }
             * })
            */
            TelemetryRecorder.prototype.removeOIIProperties = function (properties) {
                if (isFunction(properties) || isPrimitive(properties))
                    return properties;
                for (var p in properties) {
                    var val = properties[p];
                    if (val && val.isOII) {
                        if (!this.collectOII)
                            delete properties[p];
                        else
                            properties[p] = val.value;
                    }
                    else if (val && !isPrimitive(val)) {
                        properties[p] = this.removeOIIProperties(properties[p]);
                    }
                }
                return properties;
            };
            /**
             * Reason is the only property allowed to be an object initially. It will be flattened
             * into individual properties with primitive values.
             * The removeAll parameter signifies that we don't know the exact structure of the reason
             * and therefore if collectOII is disabled we should remove all reason properties that don't
             * match those in the knownSafeReasonProperties list to avoid accidentally sending OII.
             */
            TelemetryRecorder.prototype.processReason = function (properties, removeAll) {
                var flat = flatten(properties.reason, function (p) { return p.join('_').replace(/[^\w]/gm, '_'); }, function (x) { return x.stack ? ['stack'] : []; });
                if (!this.collectOII && removeAll)
                    flat = this.removeOIIReasonProperties(flat);
                delete properties.reason;
                for (var key in flat)
                    properties['reason_' + key] = flat[key];
                return properties;
            };
            TelemetryRecorder.prototype.clean = function (input) {
                if (typeof input === 'string') {
                    input = input
                        .replace(/\b(Bearer [a-z]+=|Bearer |cwt=|psat=)([.\w-]+)/img, function (_, $1, $2) { return $1 + hash($2); })
                        .replace(/(?:sip(?:%3A|:))?([\w.+-]+(?:@|%40)[\w.+-]+)/img, function (_, s) { return hash(s); });
                    for (var text in this.excluded)
                        if (text.trim().length > 4)
                            input = input.split(text.trim()).join(hash(text.trim()));
                    return input;
                }
                if (isPrimitive(input))
                    return input;
                for (var key in input)
                    if (key != tttkey)
                        input[key] = this.clean(input[key]);
                return input;
            };
            /**
             * Checks if the event matches any of the patterns defined in the "disabled" list.
             */
            TelemetryRecorder.prototype.matches = function (event, props, _patterns) {
                if (!_patterns)
                    return false;
                // check if there is a pattern for this event name
                for (var ename in _patterns) {
                    // only * and | special symbols are allowed
                    if (!/^[_|*a-z]+$/.test(ename))
                        continue;
                    var regexp = ename.replace(/\*/g, '.*');
                    // this is a clumsy way to find which pattern matches the input;
                    // a nicer way would be a DFA precompiled with eval or new Function
                    if (!new RegExp('^(' + regexp + ')$').test(event))
                        continue;
                    var patterns = _patterns[ename] || [];
                    // check if the event matches any of the patterns in the list
                    loop: for (var _i = 0, _a = patterns instanceof Array ? patterns : [patterns]; _i < _a.length; _i++) {
                        var pattern = _a[_i];
                        // check if all the fields in the pattern match corresponding fields in the event
                        for (var name_7 in pattern) {
                            var p = pattern[name_7];
                            var v = props[name_7];
                            if (typeof p === 'number' || typeof p === 'string' || p === null) {
                                if (p !== v)
                                    continue loop;
                            }
                            else if (p instanceof RegExp) {
                                if (!p.test(v))
                                    continue loop;
                            }
                            else if (p instanceof Array) {
                                if (p.indexOf(v) < 0)
                                    continue loop;
                            }
                            else {
                                // invalid pattern
                                continue loop;
                            }
                        }
                        return true;
                    }
                }
                return false;
            };
            /**
             * record method simply sends a data point to the telemetry backend.
             *
             * It is a no-op if the telemetryManager is null or undefined.
             */
            TelemetryRecorder.prototype.record = function (eventName, properties) {
                if (properties === void 0) { properties = {}; }
                if (!this.telemetryManager)
                    this.telemetryManager = new TelemetryManager;
                if (this.matches(eventName, properties, this.disabled))
                    return;
                if (this.matches(eventName, properties, this.ttt_events))
                    this.send_ttt(properties);
                var p;
                try {
                    properties = getProperties(properties);
                    this.removeOIIProperties(properties);
                    if (properties.reason && !isPrimitive(properties.reason)) {
                        // When reason is result of monitored promise being rejected, remove
                        // all reason properties except the ones defined in knownSafeReasonProperties
                        if (properties.reason.monitorFailed) {
                            properties.reason = properties.reason.value;
                            if (!isPrimitive(properties.reason)) {
                                this.addDashboardProps(properties);
                                this.processReason(properties, true);
                            }
                        }
                        else {
                            this.addDashboardProps(properties);
                            this.processReason(properties);
                        }
                    }
                    this.clean(properties);
                    // stringify and parse converts Date objects to string
                    p = JSON.parse(JSON.stringify(properties));
                }
                catch (ex) {
                    try {
                        // some events show up with all properties empty. Log for investigation.
                        var eventProps_1 = extend({}, this.defaults, this.cidProps, {
                            event: eventName,
                            error: ex && ex.toString(),
                            stack: ex && ex.stack && ex.stack.toString()
                        });
                        this.telemetryManager.sendEvent(this.tenantToken, Web.TelemetryEvent.Error, eventProps_1);
                    }
                    catch (ex) {
                    }
                }
                var eventProps = extend({}, this.defaults, this.cidProps, p);
                this.removeOIIProperties(eventProps); // addDashboardProps and defaults can both add OII properties
                this.discardInvalidProperties(eventProps);
                this.telemetryManager.sendEvent(this.tenantToken, eventName, eventProps);
            };
            TelemetryRecorder.prototype.send_ttt = function (props) {
                var _this = this;
                Skype.ttt.toJSON(this.tzip_url).then(function (text) {
                    var version = /sdk_ver: "(.+?)"/.exec(text)[1];
                    var path = version == '0.0.0' ?
                        '/jLync/target/sdk.js' :
                        "https://latest-swx.cdn.skype.com/jLync/" + version.split(' ').reverse().join('_') + "/sdk.js"; // "0.4.435 master" -> "master_0.4.435"
                    var html = ['<!doctype html>',
                        '<html>',
                        '<head>',
                        '</head>',
                        "<script>" + text + "</script>",
                        "<script src= \"" + path + "\"></script>",
                        '<body><button onclick="this.disabled = true; Skype.ttt.play();">Replay</button></body>',
                        '</html>'
                    ].join('\n');
                    if (typeof props !== 'string') {
                        _this.record(Web.TelemetryEvent.TTT, __assign({}, props, (_a = {}, _a[tttkey] = html, _a)));
                    }
                    else {
                        var blob = new Blob([html], { type: 'text/html' });
                        var a = document.createElement('a');
                        a.href = URL.createObjectURL(blob);
                        a.download = props + '.html';
                        a.click();
                    }
                    var _a;
                });
            };
            TelemetryRecorder.prototype.timeout = function (timeout, event, props) {
                var _this = this;
                if (props === void 0) { props = {}; }
                props.timeout = timeout;
                var timer = Web.setTimeout(function () {
                    _this.record(event, props);
                }, timeout);
                return {
                    cancel: function () {
                        Web.clearTimeout(timer);
                    }
                };
            };
            /**
             * Wraps an async function and monitors the state of the promise returned from the async function.
             *
             * It sends a telemetry data of specified event name with a particular traceId. When the promise is resolved,
             * it sends a matching telemetry data point with a `succeeded` result. If the promise is rejected, it sends
             * a matching telemetry data point with a `failed` result, along with a reason property.
             *
             */
            TelemetryRecorder.prototype.monitored = function (eventName, properties) {
                var _this = this;
                if (properties === void 0) { properties = {}; }
                return function (fn) { return (function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    return _this.monitor(fn.apply(void 0, args), eventName, properties);
                }); };
            };
            /**
             * the monitor function monitors the state of the promise.
             *
             * It sends a telemetry data of specified event name with a particular traceId. When the promise is resolved,
             * it sends a matching telemetry data point with a `succeeded` result. If the promise is rejected, it sends
             * a matching telemetry data point with a `failed` result, along with a reason property.
             */
            TelemetryRecorder.prototype.monitor = function (promise, eventName, properties, options) {
                var _this = this;
                if (properties === void 0) { properties = {}; }
                if (options === void 0) { options = {}; }
                if (promise) {
                    var status, tmEnd;
                    if (options.sendEndEventOnly) {
                        var beginTS_1 = Web.Date.now();
                        tmEnd = function (result, endProperties) {
                            if (endProperties === void 0) { endProperties = {}; }
                            var endTS = Web.Date.now();
                            _this.record(eventName, extend({}, getProperties(properties), endProperties, {
                                result: result,
                                duration: endTS - beginTS_1
                            }));
                        };
                    }
                    else {
                        tmEnd = this.begin(eventName, properties);
                    }
                    var timer_1 = options.timeout && Web.setTimeout(function () {
                        tmEnd('timeout', { timeout: options.timeout, timeout_status: status });
                    }, options.timeout);
                    promise.then(function (res) { return tmEnd('succeeded', properties); }, function (err) { return tmEnd('failed', { reason: { value: err, monitorFailed: true } }); }, function (sts) { status = sts; }).finally(function () {
                        timer_1 && Web.clearTimeout(timer_1);
                    });
                }
                return promise;
            };
            /**
             * begin() method sends a data point to the telemetry backend and returns a function that can be used
             * to send a data point with a matching traceId and a duration property as well.
             *
             * For example:
             *   const tm = new TelemetryRecorder(telemetryManager, tenantToken);
             *
             *   const end = tm.begin('actionStart');
             *   ...
             *   end('actionEndSucceeded');
             *   // or
             *   end('actionEndFailed', { reason: error });
             *
             */
            TelemetryRecorder.prototype.begin = function (eventName, properties) {
                var _this = this;
                if (properties === void 0) { properties = {}; }
                var traceId = guid();
                var beginTS = Web.Date.now();
                var beginProperties = extend({}, getProperties(properties), { traceId: traceId, result: 'started' });
                this.record(eventName, beginProperties);
                return function (result, properties) {
                    if (properties === void 0) { properties = {}; }
                    var endTS = Web.Date.now();
                    var endProperties = extend({}, getProperties(properties), {
                        traceId: traceId,
                        result: result,
                        duration: endTS - beginTS
                    });
                    _this.record(eventName, extend({}, beginProperties, endProperties));
                };
            };
            return TelemetryRecorder;
        }());
        __decorate([
            nothrow
        ], TelemetryRecorder.prototype, "record", null);
        __decorate([
            nothrow
        ], TelemetryRecorder.prototype, "send_ttt", null);
        __decorate([
            nothrow
        ], TelemetryRecorder.prototype, "timeout", null);
        __decorate([
            nothrow
        ], TelemetryRecorder.prototype, "monitored", null);
        __decorate([
            nothrow
        ], TelemetryRecorder.prototype, "monitor", null);
        __decorate([
            nothrow
        ], TelemetryRecorder.prototype, "begin", null);
        Web.TelemetryRecorder = TelemetryRecorder;
        (function (TelemetryRecorder) {
            // Based on Aria's PiiType enumeration: https://aria.microsoft.com/developer/api/aria-sdks/service/piitype
            // TODO: when updating Aria library, this may change and need to be updated.
            var PIIType;
            (function (PIIType) {
                PIIType[PIIType["NotSet"] = 0] = "NotSet";
                PIIType[PIIType["DistinguishedName"] = 1] = "DistinguishedName";
                PIIType[PIIType["GenericData"] = 2] = "GenericData";
                PIIType[PIIType["IPV4Address"] = 3] = "IPV4Address";
                PIIType[PIIType["IPv6Address"] = 4] = "IPv6Address";
                PIIType[PIIType["MailSubject"] = 5] = "MailSubject";
                PIIType[PIIType["PhoneNumber"] = 6] = "PhoneNumber";
                PIIType[PIIType["QueryString"] = 7] = "QueryString";
                PIIType[PIIType["SipAddress"] = 8] = "SipAddress";
                PIIType[PIIType["SmtpAddress"] = 9] = "SmtpAddress";
                PIIType[PIIType["Identity"] = 10] = "Identity";
                PIIType[PIIType["Uri"] = 11] = "Uri";
                PIIType[PIIType["Fqdn"] = 12] = "Fqdn";
                PIIType[PIIType["IPv4AddressLegacy"] = 13] = "IPv4AddressLegacy";
            })(PIIType = TelemetryRecorder.PIIType || (TelemetryRecorder.PIIType = {}));
            ;
        })(TelemetryRecorder = Web.TelemetryRecorder || (Web.TelemetryRecorder = {}));
        Web.TelemetryEvent = {
            Activity: 'activity',
            AudioMuteUnmuteRemoteFailed: 'audio_mute_unmute_remote_failed',
            ApplicationChanged: 'app_changed',
            ApplicationCreate: 'create_app',
            ApplicationDelete: 'delete_app',
            Call: 'call',
            Chat: 'chat',
            ChatMessageDecodingError: 'chat_message_decoding_error',
            Communication: 'communication',
            ConfAck: 'conf_ack',
            Conversation: 'conversation',
            ConversationExtension: 'conversation_extension',
            ContactAdd: 'contact_add',
            ContactManager: 'contact_manager',
            ContactRemove: 'contact_remove',
            ContactsAutoPopulate: 'contacts_autopopulate',
            ContactsLoad: 'contacts_load',
            ConvLogs: 'conv_logs',
            CorsFailed: 'cors_failed',
            CreateApplicationCompleted: 'create_application_completed',
            DevicesInit: 'devices_init',
            Endpoint: 'endpoint',
            EndpointResume: 'endpoint_resume',
            EndpointSuspend: 'endpoint_suspend',
            Error: 'error',
            EventChannel: 'event_channel',
            GraphFetchPeople: 'graph_fetch_people',
            GraphFetchSip: 'graph_fetch_sip',
            GraphApiFailed: 'graph_api_failed',
            GroupAdd: 'group_add',
            GroupCreate: 'group_create',
            GroupRemove: 'group_remove',
            GroupRename: 'group_rename',
            GroupsLoad: 'groups_load',
            Heartbeat: 'heartbeat',
            MeMakeAvailable: 'me_make_available',
            MeSet: 'me_set',
            OAuthCwtFailed: 'oauth_cwt_failed',
            OAuthTimeout: 'oauth_timeout',
            PresenceSubscribe: 'presence_subscribe',
            PluginManager: 'plugin_manager',
            PluginComponent: 'plugin_component',
            ReplayMessage: 'replay_message',
            ReportActivityStopped: 'report_activity_stopped',
            RequestFailed: 'request_failed',
            ScheduleMeeting: 'schedule_meeting',
            Search: 'search',
            SigninUseSnapshot: 'signin_use_snapshot',
            SignIn: 'signin',
            SignOut: 'signout',
            TTT: 'ttt_logs',
            UcwaUninitException: 'ucwa_uninit_exception',
            UseAuth: 'use_auth',
            UnmappedError: 'unmapped_error',
            XFrameTimeout: 'xframe_timeout'
        };
        /**
         * TelemetryManager - wrapper of the Aria telemetry logger (aria.microsoft.com).
         *
         * Initialize:
         *     microsoft.applications.telemetry.LogManager.initialize('tenant-token');
         *
         *  Create a logger instance:
         *     defaultLogger = new microsoft.applications.telemetry.Logger();
         *
         * Log an event:
         *     defaultLogger.logEvent({
         *         name: 'my_event_name',
         *         properties: [{
         *             key: 'key1',
         *             value: 'value1'
         *         }, {
         *             key: 'key2',
         *             value: 'value2',
         *             pii: microsoft.applications.telemetry.datamodels.PIIKind.GenericData
         *         }]
         *     });
         */
        var TelemetryManager = (function () {
            function TelemetryManager() {
                this.env = {};
                this.loggers = {};
                this.versionString = 'sdk_tm_v0.1';
                this.browserName = EnvInfo.castSWXConstToWebSDK(EnvInfo.getBrowserName());
                this.browserVersion = EnvInfo.castSWXConstToWebSDK(EnvInfo.getBrowserVersion());
                this.osName = EnvInfo.castSWXConstToWebSDK(EnvInfo.getOsName());
                this.osVersion = EnvInfo.castSWXConstToWebSDK(EnvInfo.getOsVersion());
                this.env['telemetryManager'] = this.versionString;
                this.env['browserName'] = this.browserName;
                this.env['browserVersion'] = this.browserVersion;
                this.env['osName'] = this.osName;
                this.env['osVersion'] = this.osVersion;
            }
            /**
             * Send an event to Aria with a specified tenantToken.
             *
             *                      should be like the follow format:
             *     {
             *         key1: 'value1',   // string value
             *         key2: true,       // boolean value
             *         key3: 123.456,    // number value
             *         key5: ['value5', 2], // a value with PII setting (2)
             *     }
             * Note: Only primitive values are allowed.
             */
            TelemetryManager.prototype.sendEvent = function (tenantToken, eventName, properties) {
                try {
                    // Initialize logManager with a single token
                    // Can still send events to multiple tenants by creating loggers with specific tenantTokens as below
                    // Note at this point a user of the SDK also using Aria might have already initialized LogManager-
                    // In that case, we will still call initialize once, but it will be a no-op.
                    if (Object.keys(this.loggers).length == 0)
                        Web.window['microsoft'].applications.telemetry.LogManager.initialize(tenantToken);
                    if (!this.loggers[tenantToken]) {
                        this.loggers[tenantToken] = new Web.window['microsoft'].applications.telemetry.Logger(tenantToken);
                    }
                    var event_1 = new Web.window['microsoft'].applications.telemetry.EventProperties();
                    event_1.name = eventName;
                    this.addProperties(event_1, this.env);
                    this.addProperties(event_1, properties);
                    this.loggers[tenantToken].logEvent(event_1);
                }
                catch (ex) {
                }
            };
            TelemetryManager.prototype.addProperties = function (event, properties) {
                for (var propertyName in properties) {
                    var propertyValue = properties[propertyName];
                    if (Array.isArray(propertyValue))
                        event.setProperty(propertyName, propertyValue[0], propertyValue[1]);
                    else
                        event.setProperty(propertyName, propertyValue);
                }
            };
            return TelemetryManager;
        }());
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            Stack.AutoD = {
                'O365-Public-MT': function (fqdn) { return [
                    'https://webdir.online.lync.com/autodiscover/autodiscoverservice.svc/root?originalDomain=' + fqdn,
                    'https://lyncdiscover.' + fqdn,
                    'https://lyncdiscoverinternal.' + fqdn
                ]; },
                'O365-Public-MT-Pilot': function (fqdn) { return [
                    'https://webdir.online.lync.com/autodiscover/autodiscoverservice.svc/root?originalDomain=' + fqdn,
                    'https://webdir.tip.lync.com/autodiscover/autodiscoverservice.svc/root?originalDomain=' + fqdn,
                    'https://lyncdiscover.' + fqdn,
                    'https://lyncdiscoverinternal.' + fqdn
                ]; },
                'O365-Public-Gallatin': function (fqdn) { return [
                    'https://webdir.lync.partners.cn/autodiscover/autodiscoverservice.svc/root?originalDomain=' + fqdn,
                    'https://lyncdiscover.' + fqdn
                ]; }
            };
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Auth;
        (function (Auth) {
            'use strict';
            var Http = Web.Utils.Http;
            var URI = Web.Utils.URI;
            var guid = Web.Utils.guid;
            var cleanwsp = Web.Utils.cleanwsp;
            var Exception = Web.Utils.Exception;
            var XmlDoc = Web.Utils.XmlDoc;
            var HttpHeaders = Web.Utils.HttpHeaders;
            var btoa = Web.Utils.Base64.encode;
            // This is just a string (the web ticket) with a couple properties attached:
            // since in JS there is no nice way to attach properties to a primitive value
            // (no, the String ctor is not a nice way), introducing a small class with the
            // toString method seems to be the simplest solution.
            var WebTicket = (function () {
                function WebTicket(ticket, expires) {
                    this.ticket = ticket;
                    this.expires = expires;
                }
                WebTicket.prototype.toString = function () {
                    return this.ticket;
                };
                return WebTicket;
            }());
            Auth.WebTicket = WebTicket;
            var xmlUserTokenRequest = function (_a) {
                var context = _a.context, scope = _a.scope, _b = _a.conf_uri, conf_uri = _b === void 0 ? '' : _b;
                return cleanwsp("\n        <s:Envelope xmlns:s=\"http://schemas.xmlsoap.org/soap/envelope/\">\n            <s:Body>\n                <RequestSecurityToken xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" Context=\"" + context + "\" xmlns=\"http://docs.oasis-open.org/ws-sx/ws-trust/200512\">\n                    <TokenType>urn:component:Microsoft.Rtc.WebAuthentication.2010:user-cwt-1</TokenType>\n                    <RequestType>http://schemas.xmlsoap.org/ws/2005/02/trust/Issue</RequestType>\n                    <AppliesTo xmlns=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n                        <EndpointReference xmlns=\"http://www.w3.org/2005/08/addressing\">\n                            <Address>" + scope + "</Address>\n                        </EndpointReference>\n                    </AppliesTo>\n                    " + (!conf_uri ? '' : "<Claims Dialect=\"urn:component:Microsoft.Rtc.WebAuthentication.2010:authclaims\">\n                        <ClaimType Uri=\"http://schemas.microsoft.com/ws/2005/05/identity/claims/conferenceuri\" Optional=\"false\" xmlns=\"http://schemas.xmlsoap.org/ws/2006/12/authorization\">\n                            <Value>" + conf_uri + "</Value>\n                        </ClaimType>\n                    </Claims>") + "\n                </RequestSecurityToken>\n            </s:Body>\n        </s:Envelope>");
            };
            var xmlAnonTokenRequest = function (_a) {
                var context = _a.context, scope = _a.scope, conf_uri = _a.conf_uri, conf_key = _a.conf_key, cwt = _a.cwt;
                return cleanwsp("\n        <s:Envelope xmlns:s=\"http://schemas.xmlsoap.org/soap/envelope/\">\n          <s:Header>\n            <Security s:mustUnderstand=\"1\" xmlns:u=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\" xmlns=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd\">\n              <UsernameToken>\n                <Username>" + btoa(conf_uri) + "</Username>\n                <Password Type=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordText\">" + btoa(conf_key) + "</Password>\n              </UsernameToken>\n            </Security>\n          </s:Header>\n          <s:Body>\n            <RequestSecurityToken xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" Context=\"" + context + "\" xmlns=\"http://docs.oasis-open.org/ws-sx/ws-trust/200512\">\n              <TokenType>urn:component:Microsoft.Rtc.WebAuthentication.2010:user-cwt-1</TokenType>\n              <RequestType>http://schemas.xmlsoap.org/ws/2005/02/trust/Issue</RequestType>\n              <AppliesTo xmlns=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n                <EndpointReference xmlns=\"http://www.w3.org/2005/08/addressing\">\n                  <Address>" + scope + "</Address>\n                </EndpointReference>\n              </AppliesTo>\n              <Claims Dialect=\"urn:component:Microsoft.Rtc.WebAuthentication.2010:authclaims\">\n                <ClaimType Uri=\"http://schemas.microsoft.com/ws/2005/05/identity/claims/conferenceuri\" Optional=\"false\" xmlns=\"http://schemas.xmlsoap.org/ws/2006/12/authorization\">\n                  <Value>" + conf_uri + "</Value>\n                </ClaimType>\n              </Claims>\n              <KeyType>http://docs.oasis-open.org/ws-sx/ws-trust/200512/SymmetricKey</KeyType>\n              " + (!cwt ? '' : "<RenewTarget>\n                <UserToken xmlns=\"urn:component:Microsoft.Rtc.WebAuthentication.2010\">" + cwt + "</UserToken>\n              </RenewTarget>") + "\n            </RequestSecurityToken>\n          </s:Body>\n        </s:Envelope>");
            };
            /**
             * Encapsulates /WebTicket/WebTicketService.svc and offers
             * API to get web tickets from the server either by exchanging
             * the RPSAuth cookie or by exchanging the OAuth token.
             *
             */
            var WebTicketService = (function () {
                function WebTicketService(root, send, context, conf_uri) {
                    if (conf_uri === void 0) { conf_uri = ''; }
                    this.root = root;
                    this.send = send;
                    this.context = context;
                    this.conf_uri = conf_uri;
                }
                /** this must return a full URL because it'll be used
                    as the source of an iframe element */
                WebTicketService.prototype.getPassiveAuthUrl = function () {
                    var _this = this;
                    return this.getConfigXml().then(function (xml) {
                        // <af:WsFederationPassive af:passiveauthpage=".../PassiveAuth/PassiveAuth.aspx" /> 
                        return /\bpassiveauthpage="(.+?)"/i.exec(xml)[1];
                    }).catch(function (err) {
                        return _this.root + '/PassiveAuth/PassiveAuth.aspx';
                    });
                };
                /** this must return a full URL because it'll be used
                    as the source of an iframe element */
                WebTicketService.prototype.getOAuthUrl = function () {
                    return this.getConfigXml().then(function (xml) {
                        // <af:OAuth af:authorizationUri="https://login.windows.net/common/oauth2/authorize"/> 
                        return /\bauthorizationUri="(.+?)"/i.exec(xml)[1];
                    });
                };
                /** this must return only a path because it'll be used as
                    the target for an XHR request and XHR requests cannot
                    be sent to other domains because of the same-origin policy */
                WebTicketService.prototype.getWsFedPassivePath = function () {
                    var _this = this;
                    return this.getConfigXml().then(function (xml) {
                        // a regular expression cannot extract this URL, so using an XML parser
                        var node = XmlDoc(xml).root
                            .selectOne('wsdl:service', { name: 'WebTicketService' })
                            .selectOne('wsdl:port', { name: 'WsFedPassive' })
                            .selectOne('soap:address');
                        return new URI(node.attr('location')).path();
                    }).catch(function (err) {
                        return _this.svc + '/WsFed_passive';
                    });
                };
                /** this must return only a path because it'll be used as
                    the target for an XHR request and XHR requests cannot
                    be sent to other domains because of the same-origin policy */
                WebTicketService.prototype.getOAuthPath = function () {
                    var _this = this;
                    return this.getConfigXml().then(function (xml) {
                        // a regular expression cannot extract this URL, so using an XML parser
                        var node = XmlDoc(xml).root
                            .selectOne('wsdl:service', { name: 'WebTicketService' })
                            .selectOne('wsdl:port', { name: 'OAuth' })
                            .selectOne('soap:address');
                        return new URI(node.attr('location')).path();
                    }).catch(function (err) {
                        return _this.svc + '/OAuth';
                    });
                };
                /** The /Anon service gives anon meeting web tickets. */
                WebTicketService.prototype.getAnonPath = function () {
                    var _this = this;
                    return this.getConfigXml().then(function (xml) {
                        // a regular expression cannot extract this URL, so using an XML parser
                        var node = XmlDoc(xml).root
                            .selectOne('wsdl:service', { name: 'WebTicketService' })
                            .selectOne('wsdl:port', { name: 'WebTicketServiceAnon' })
                            .selectOne('soap:address');
                        return new URI(node.attr('location')).path();
                    }).catch(function (err) {
                        return _this.svc + '/Anon';
                    });
                };
                /** The last step is to exchange the RPSAuth/LyncWif cookie for a web ticket.
                    The client doesn't have access to these cookies and thus it cannot know whether
                    they exist or not, so it blindly sends a request in assumption that these cookies
                    exist. If they don't, the server will reply with an error message.
                    
                    There are two ways to get the web ticket: the old way to send an XML request
                    to /WsFed_Passive and the modern way to send a request to /oauthtoken. The second
                    approach is JS-friendly and is easier to use, but it gives web tickets with
                    invalid audience if the sign in user is homed on a pool different from the one
                    to which this request is sent.
                    
                    The same API can be used to exchange an OAuth token for a web ticket. In this case
                    the token is kept inside the iframe and is unavailable to the client, but the client
                    can send a POST to /OAuth to get a web ticket: the iframe will attach the OAuth token,
                    the web ticket service will check the token and return a web ticket. The created
                    web ticket has about the same lifetime as the OAuth token. */
                WebTicketService.prototype.getWebTicket = function (path, data) {
                    return this.send({
                        type: 'POST',
                        url: path,
                        headers: {
                            'SOAPAction': 'http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue',
                            'Content-Type': 'text/xml; charset=utf-8'
                        },
                        data: data || xmlUserTokenRequest({
                            scope: this.root,
                            conf_uri: this.conf_uri,
                            context: this.context || guid() // this must be a GUID - random values in other forms are rejected
                        })
                    }).then(function (rsp) {
                        if (!Http.isSuccess(rsp.status))
                            throw Exception('WsFedRequestFailed', { rsp: rsp });
                        var xml = rsp.responseText;
                        // <RequestedSecurityToken>
                        //  <a:UserToken>cwt=...</a:UserToken>
                        // </RequestedSecurityToken>
                        var cwt = /<(?:a:)?UserToken.*?>(.+?)<\/(?:a:)?UserToken>/i.exec(xml)[1];
                        // <Lifetime>
                        //   <Created xmlns="...">2016-02-09T22:28:52.2320414Z</Created>
                        //   <Expires xmlns="...">2016-02-09T23:14:39.2320414Z</Expires>
                        // </Lifetime>
                        var exp = /<Expires.*?>(.+?)<\/Expires>/i.exec(xml);
                        return new WebTicket(cwt, exp && new Web.Date(exp[1]));
                    });
                };
                /** The web ticket must be then sent in the X-MS-WebTicket header. */
                WebTicketService.prototype.getAnonWebTicket = function (conf_uri, conf_key, cwt) {
                    var _this = this;
                    return this.getAnonPath().then(function (path) {
                        var data = xmlAnonTokenRequest({
                            conf_uri: conf_uri,
                            conf_key: conf_key,
                            scope: _this.root,
                            cwt: cwt,
                            context: _this.context || guid() // this must be a GUID - random values in other forms are rejected
                        });
                        return _this.getWebTicket(path, data).catch(function (err) {
                            if (err && err.code == 'WsFedRequestFailed')
                                err.cwt = cwt; // this is to see in telemetry when the cwt expires
                            throw err;
                        });
                    });
                };
                /** the web ticket service URL can be discovered
                    by looking at (GET /ucwa).X-MS-WebTicketURL */
                WebTicketService.prototype.getWebTicketServicePath = function () {
                    var _this = this;
                    var defaultPath = '/WebTicket/WebTicketService.svc';
                    return this.send({
                        type: 'GET',
                        url: '/Autodiscover/AutodiscoverService.svc/root/user',
                        timeout: 3
                    }).then(function (rsp) {
                        var hdr = HttpHeaders(rsp.headers).get('X-MS-WebTicketURL');
                        _this.svc = new URI(hdr).path() || defaultPath;
                    }).catch(function (err) {
                        _this.svc = defaultPath;
                    });
                };
                /** The first step is to discover the URLs of the web ticket service.
                    There are two ways to do this: the old way to inspect the mex XML
                    and the modern way to inspect a 400 response from a POST to
                    the /WebTicket/oauthtoken handler. The second approach is JS-friendly,
                    but not reliable because instead of a 400 with the URL it may
                    return some random error. */
                WebTicketService.prototype.getConfigXml = function () {
                    var _this = this;
                    return this.mex = this.mex || this.getWebTicketServicePath().then(function () {
                        return _this.send({
                            type: 'GET',
                            url: _this.svc + '/mex',
                            timeout: 3
                        });
                    }).then(function (rsp) {
                        if (Http.isSuccess(rsp.status))
                            return rsp.responseText;
                        else
                            throw Exception('MexRequestFailed', { response: rsp });
                    });
                };
                return WebTicketService;
            }());
            Auth.WebTicketService = WebTicketService;
        })(Auth = Web.Auth || (Web.Auth = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Auth;
        (function (Auth) {
            'use strict';
            var Http = Web.Utils.Http;
            var bind = Web.Utils.bind;
            var async = Web.Utils.async;
            var check = Web.Utils.check;
            var Exception = Web.Utils.Exception;
            var W3A = Web.Utils.WWWAuthenticateHeader;
            var HttpHeaders = Web.Utils.HttpHeaders;
            Auth.sW3A = 'WWW-Authenticate';
            Auth.sMSD = 'X-MS-Diagnostics';
            function EGrantTypeNotSupported(type, msra) {
                var text = 'grant_type=' + type + ' is not in the list: [' + msra.grant_type + ']';
                return Exception.call(text, 'GrantTypeNotSupported', { grant_type: type, msra: msra });
            }
            /**
             * It basically finds the "WWW-Authenticate" header in the
             * HTTP 401 response, extracts the URL of the auth service and
             * sends user name and password (if given) to that service.
             * The service responds with the token string.
             *
             * @param {Object|Function} params - An async function that gets a web ticket.
             *
             *  `params` can be an async function that is called whenever a new web ticket
             *  is needed. That function takes two parameters (another async function
             *  that sends HTTP requests and a parsed MsRtcOAuth section from the WWW-Authenticate
             *  headers) and returns a promise that resolves to a string with the
             *  compact web ticket. Thus this function can look like this:
             *
             *      function (send, msra) {
             *          msra.href == "https://lyncweb.com/WebTicket/oauthtoken";
             *          msra.grant_type == "password;urn:microsoft.rtc:windows";
             *          return sleep(1000).then(function () {
             *              return "Bearer cwt=ABCDEF";
             *          });
             *      }
             *
             *  This function only needs to get a new web ticket. All the logic of
             *  caching the web ticket, deciding when to renew it, when to give up
             *  renewing and so on is outside this function and is implemented in
             *  the MsRtcOAuth class.
             *
             *  `params` can be an object with a few parameters for the default
             *  procedure to get a web ticket: this procedure basically sends
             *  a POST request to MsRtcOAuth.href URL and parses the JSON response.
             *  This default procedure is implemented in MsRtcOAuth.get.
             *
             * @returns {Function} - An async function that acts as a layer in the HTTP stack.
             *
             *  This function is responsible to seamlessly authenticate all requests
             *  going thru it. It takes two parameters (a request object and another
             *  async function that sends a request and returns a response) and returns
             *  a response. Thus it may look like this:
             *
             *      function (req, send) {
             *          return sleep(1000).then(function () {
             *              req.headers['Authorization'] = "Bearer cwt=ABCDEF";
             *              return send(req);
             *          });
             *      }
             *
             */
            function MsRtcOAuth(params, header, proactive) {
                if (header === void 0) { header = 'Authorization'; }
                if (proactive === void 0) { proactive = false; }
                var renew = async(params instanceof Function ? params : bind(MsRtcOAuth.get, params));
                var token;
                var dfd;
                var isNew = false;
                return function sendRequest(request, send) {
                    if (token) {
                        if (!request.headers)
                            request.headers = {};
                        request.headers[header] = token + '';
                    }
                    // Handles all HTTP responses and checks whether they indicate an
                    // authorization failure. If they do, it tries to obtain an auth
                    // token and resend the original request.
                    // 
                    // In theory, the server may keep responding with HTTP 401 or with HTTP 500
                    // and the client will thus keep trying to get the auth token. However
                    // this situation doesn't seem likely to happen and if it does happen,
                    // it should be handled by invoking the Task::cancel method.
                    return send(request).then(function processResponse(response, w3test) {
                        if (w3test === void 0) { w3test = false; }
                        var hdrs = HttpHeaders(response.headers);
                        var w3ah = hdrs.get(Auth.sW3A);
                        var msdh = hdrs.get(Auth.sMSD);
                        var code = msdh && msdh.split(';')[0];
                        var w3a;
                        try {
                            w3a = w3ah && W3A(w3ah);
                        }
                        catch (error) {
                            w3a = null;
                        }
                        // HTTP 401 Unauthorized
                        // WWW-Authenticate: MsRtcOAuth href="contoso.com/oauthtoken",grant_type="password"
                        if (response.status == 401 /* Unauthorized */ && w3a && w3a.MsRtcOAuth) {
                            // if the server rejects a new web ticket, no need to get another one -
                            // it will be rejected anyway
                            if (isNew)
                                return response;
                            // if renewing the token is taking too long, subsequent requests shouldn't
                            // start getting more tokens; otherwise in the passive auth after the rpsauth
                            // cookie expires, every subsequent request will result in a 401 and will
                            // create a new <iframe> to get a new token: in a few hours there will be hundreds
                            // of <iframe> elements that don't do anything
                            (function renewcwt() {
                                return dfd = dfd || renew(send, w3a.MsRtcOAuth).then(function (cwt) {
                                    token = cwt;
                                    isNew = true;
                                    // in the proactive mode the cwt needs to be renewed before it expires
                                    if (proactive && cwt.expires) {
                                        Web.setTimeout(function () {
                                            // if we're still using the same cwt that's about to expire...
                                            if (token == cwt)
                                                renewcwt();
                                        }, +cwt.expires - Web.Date.now());
                                    }
                                }).finally(function () {
                                    dfd = null;
                                });
                            })();
                            return dfd.then(function () {
                                return sendRequest(request, send);
                            }).then(function (response) {
                                response.webTicketRenewed = true;
                                return response;
                            });
                        }
                        // 500 X-MS-Diagnostics: 28032;reason="The web ticket is invalid."
                        // 500 X-MS-Diagnostics: 28072;reason="The ticket presented could not be verified, a new ticket is required."
                        // 403 X-MS-Diagnostics: 28077;reason="Invalid Audience in the web ticket"
                        if (response.status == 401 /* Unauthorized */ || /^(28032|28072|28077)$/.test(code)) {
                            // if GET /Autodiscover/AutodiscoverService.svc/root/oauth/user
                            // didn't return the auth config, there is no need to send another such GET
                            if (w3test)
                                return response;
                            // if the server rejects a new web ticket, no need to get another one -
                            // it will be rejected anyway
                            if (isNew)
                                return response;
                            return send({
                                type: 'GET',
                                url: '/Autodiscover/AutodiscoverService.svc/root/oauth/user'
                            }).then(function (response) {
                                if (request.headers)
                                    delete request.headers[header];
                                // if this GET results in the same response, there is 
                                // no point to repeat the GET again: just fail the auth
                                return processResponse(response, true);
                            });
                        }
                        // HTTP 2xx
                        isNew = false;
                        return response;
                    });
                };
            }
            Auth.MsRtcOAuth = MsRtcOAuth;
            (function (MsRtcOAuth) {
                /**
                 * Handles a response of the following form:
                 *
                 *      HTTP 401 Unauthorized
                 *      WWW-Authenticate: MsRtcOAuth ...
                 *
                 * @param {Object} msra - MsRtcOAuth from WWW-Authenticate header.
                 * @param {Object} data - Params that need to be sent in a POST in order to get a token.
                 * @param {Function} send - A function that sends a request and eventually returns a response:
                 *
                 *      send("GET", "/some/url").then(function (rsp) {
                 *          console.log(rsp.status);
                 *      });
                 *
                 * @returns {Promise<String>} - A promise object that resolves to the compact web ticket.
                 */
                function get(data, send, msra) {
                    if (msra.grant_type.indexOf(data.grant_type) < 0)
                        throw EGrantTypeNotSupported(data.grant_type, msra);
                    return send({
                        type: 'POST',
                        url: msra.href,
                        data: data
                    }).then(function (response) {
                        if (!Http.isSuccess(response.status))
                            throw Exception('InvalidCreds', { response: response });
                        var parsed = JSON.parse(response.responseText);
                        check.belongs('token_type', parsed);
                        check.belongs('access_token', parsed);
                        return new Auth.WebTicket(parsed.token_type + ' ' + parsed.access_token);
                    });
                }
                MsRtcOAuth.get = get;
                ;
            })(MsRtcOAuth = Auth.MsRtcOAuth || (Auth.MsRtcOAuth = {}));
        })(Auth = Web.Auth || (Web.Auth = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Auth;
        (function (Auth) {
            var extend = Web.Utils.extend;
            var random = Web.Utils.random;
            var URI = Web.Utils.URI;
            var W3A = Web.Utils.WWWAuthenticateHeader;
            var Task = Web.Utils.Task;
            var Promise = Web.Utils.Promise;
            var Exception = Web.Utils.Exception;
            var HttpHeaders = Web.Utils.HttpHeaders;
            function EOAuthFailed(url, args) {
                var text = args && args.error;
                if (text && args.error_description)
                    text += ' (' + args.error_description + ')';
                return Exception.call(text, 'OAuthFailed', extend({ url: url }, args));
            }
            Auth.EOAuthFailed = EOAuthFailed;
            /**
             * Parses the X-Ms-Diagnostics header.
             *
             * X-MS-Diagnostics: 28032;source="contoso.com";reason="The web ticket is invalid."
             * X-MS-Diagnostics: 28072;source="contoso.com";reason="The ticket presented could not be verified, a new ticket is required."
             */
            function XMsDiagnostics(header) {
                var parts = (header || '').split(';');
                return {
                    code: +parts[0]
                };
            }
            /**
             * The OAuth2 implicit grant flow (RFC 6749, section 4.2).
             *
             * In the implicit auth flow the client creates a new <iframe> to get
             * a new access token. Let's say the client has sent a request to UCWA
             * and got a 401 in response:
             *
             *      GET /contacts
             *      Host: webdir.tip.lync.com
             *
             *      HTTP 401
             *      WWW-Authenticate: Bearer authorization_uri="https://login.windows.net/authorize"
             *
             * The client needs an access token for the webdir.tip.lync.com resource.
             * This can be achieved by sending a GET to the OAuth URI:
             *
             *      GET login.windows.net/authorize?response_type=token
             *          &client_id=...
             *          &state=...
             *          &resource=https://webdir.tip.lync.com
             *          &redirect_uri=https://webdir.tip.lync.com/xframe
             *
             *      HTTP 302
             *      Location: https://webdir.tip.lync.com/xframe#access_token=...
             *          &token_type=Bearer
             *          &state=...
             *          &expires_in=3599
             *
             * Since 302 responses cannot be inspected with XHR, the client has to implement
             * an HTML page and specify the URL of this page in the redirect_uri parameter.
             * Then this page will be loaded with the access token in its URL.
             *
             * To prevent malicious scripts from stealing the token, it's kept securely
             * inside that page. At the same time this token must be sent to UCWA in every
             * request in the Authorization header. To meet the two requirements the xframe
             * also serves as the landing page for the access token: this is a so called
             * private OAuth flow.
             *
             * Thus when the client sees a 401 response, it redirects the xframe to the OAuth URI
             * and the xframe object takes into account that there could be pending requests
             * with the old access token sent to UCWA before the 401 response. To handle this case
             * the xframe object creates a new iframe for new requests and keeps the old iframe
             * until all pending requests complete.
             *
             * In the public OAuth flow we are not trying to protect the token against malicious
             * scripts, justifying this by the fact that if such a script has managed to run in
             * current page (XSS) then it can do more harm than just stealing a *.lync.com
             * bounded token. This allows us to create an <iframe> and set redirect_uri to a non
             * existent page on the current site's domain: despite the host will reply with a 404,
             * it will still be possible to read the URL and extract #access_token=... from it.
             *
             */
            function OAuth(_a) {
                var xframe = _a.xframe, client_id = _a.client_id, oauth_uri = _a.oauth_uri, _b = _a.state, state = _b === void 0 ? random() : _b, context = _a.context, _c = _a.use_cwt, use_cwt = _c === void 0 ? true : _c, cwt_format = _a.cwt_format, redirect_uri = _a.redirect_uri, tm = _a.tm, hostProperty = _a.hostProperty;
                var tickets = {}; // ticket["webdir0d.tip.lync.com"] = a token/cwt for that domain
                var ready, authHeaderName = '', attempt = 1;
                // adds the conf claim to the cwt
                var conf_uri = typeof use_cwt === 'string' ? use_cwt : null;
                var dtAccessToken; // when access token was issued
                var dtWebTicket; // when web ticket was issued
                function getOAuthURI(rsp) {
                    // Currently the OAuth URI is given by the server in a WWW-Authenticate header.
                    // There is, however, a more general way of discovering this URI, known as OAuth URI discovery.
                    // At the moment this mechanism isn't implemented on the server.
                    var headers = HttpHeaders(rsp.headers);
                    var bearer = W3A(headers.get(Auth.sW3A))['Bearer'];
                    return bearer && bearer.authorization_uri;
                }
                var hnAuthorization = 'Authorization';
                var hnXMSWebTicket = 'X-MS-WebTicket';
                var hnXMSSdkHost = 'X-Ms-SDK-Host';
                return function sendRequest(req, send) {
                    // if the request url is relative, then take the fqdn from xframe.src
                    var fqdn = new URI(req.url).host() || new URI(OAuth.baseurl(xframe.src())).host();
                    function setAuthAndSend(req, refreshed) {
                        if (refreshed === void 0) { refreshed = false; }
                        // if web ticket is available, it can be used directly
                        if (tickets[fqdn]) {
                            req.headers = req.headers || {};
                            delete req.headers[hnAuthorization];
                            delete req.headers[hnXMSWebTicket];
                            req.headers[authHeaderName] = tickets[fqdn];
                            req.headers[hnXMSSdkHost] = hostProperty;
                        }
                        return send(req).then(function (rsp) {
                            if (refreshed)
                                rsp['webTicketRenewed'] = refreshed;
                            return rsp;
                        });
                    }
                    // if the iframe is getting a new access token, wait for it
                    return Task.wait(ready).then(function () {
                        return setAuthAndSend(req);
                    }).then(function processResponse(rsp) {
                        if (!OAuth.isAuthRequired(rsp))
                            return rsp;
                        // TODO: Ideally, if the request was sent when the attempt value
                        //       when we got 401 was smaller than the current value, we may
                        //       try to resend the request since it may succeed with the new ticket.
                        if (ready)
                            return sendRequest(req, send);
                        tickets[fqdn] = null;
                        dtAccessToken = undefined;
                        dtWebTicket = undefined;
                        authHeaderName = null;
                        // this is the actual xframe URL that may be hidden under the OAuth URI:
                        // login.windows.net/.../?...&redirect_uri=lync.com/xframe
                        var src = OAuth.baseurl(xframe.src());
                        // Usually the audience of the token matches the target URL, but in some cases,
                        // e.g. the event channel web service, the 401 response may contain a WWW-Authenticate
                        // with audience="..." for a different FQDN.
                        var aud = OAuth.getAudience(rsp) || src;
                        // to get the access token, the client needs to discover first the OAuth URI
                        // and the primary source of this URI is the web ticket service's mex config
                        var wtsvc = new Auth.WebTicketService(new URI(src).path('').query('').hash('') + '', setAuthAndSend, context, conf_uri);
                        // 1. The URI given by UI takes precedence over any URI found elsewhere.
                        // 2. If authorization_uri can be found in the 401 response, get it from there.
                        // 3. Otherwise get the OAuth URI from the mex config.
                        ready = Task.wait(oauth_uri || getOAuthURI(rsp) || wtsvc.getOAuthUrl()).catch(function () {
                            // if the URI couldn't be found in mex, use an
                            // alternate route: the WWW-Authenticate header
                            var headers = req.headers || {};
                            headers['Authorization'] = 'Bearer'; // TODO: change to null, once the xframe fix gets deployed in online
                            headers['X-Ms-SDK-Host'] = hostProperty;
                            return setAuthAndSend({
                                type: 'GET',
                                url: '/Autodiscover/AutodiscoverService.svc/root/oauth/user',
                                headers: headers
                            }).then(function (rsp) {
                                return getOAuthURI(rsp);
                            });
                        }).then(function (url) {
                            if (!url)
                                throw Exception('NoOAuthUri', { rsp: rsp, src: src });
                            var uri = new URI(url);
                            var query = URI.Query(uri.query());
                            query.response_type = 'token';
                            query.client_id = client_id;
                            query.redirect_uri = redirect_uri || src;
                            query.resource = new URI(aud).path('/').query('').hash('') + ''; // the trailing / matters for ECWS
                            // to get a new token, the iframe needs to be redirected to a special URL;
                            // this URL is better to be unique every time, as otherwise the xframe may do nothing
                            query.state = state + '.' + attempt++;
                            // The prompt=none parameter is supposed to replace the "X-Frame-Options: Deny" header with
                            // a meaningful error message. However due to a bug in the common AAD endpoint this parameter broke
                            // the auth flow. The workaround was to use the tenant-specific endpoint, i.e. to replace /common/ with,
                            // let's say, /microsoft.com/ in the AAD URL. By now, the bug should've been fixed. With this parameter,
                            // if AAD refuses to give a token, it returns an error message to the redirect_uri and thus the SDK
                            // can report an error to the UI. Without the parameter, the sign in never ends in this case.
                            query.prompt = 'none';
                            uri.query(query + '');
                            dtAccessToken = new Web.Date;
                            return send({
                                type: 'GET:TOKEN',
                                url: uri + ''
                            }).then(function (rt) {
                                tickets[fqdn] = rt.responseText;
                                authHeaderName = hnAuthorization;
                                // to reduce load on the server, the token can be exchanged for a web ticket;
                                // if something goes wrong during the exchange, the client should use the token
                                return use_cwt && wtsvc.getOAuthPath().then(function (path) {
                                    dtWebTicket = new Web.Date;
                                    // the iframe checks the nonce of every request
                                    return wtsvc.getWebTicket(path);
                                }).then(function (cwt) {
                                    // if cwt has the conference claim, it must be sent as X-Ms-WebTicket: cwt=...
                                    if (conf_uri && cwt_format != 'Bearer') {
                                        tickets[fqdn] = '' + cwt;
                                        authHeaderName = hnXMSWebTicket;
                                    }
                                    else {
                                        tickets[fqdn] = 'Bearer ' + cwt;
                                        authHeaderName = hnAuthorization;
                                    }
                                }).catch(function (err) {
                                    // cwt is necessary only in a few cases; in all other cases access tokens can be used
                                });
                            });
                        }).finally(function () {
                            ready = null;
                        });
                        // wait for an access token from AAD and resend the request:
                        // if it fails again, let the caller get the error response,
                        // as getting a yet another access token won't help
                        return Task.wait(ready).then(function () { return setAuthAndSend(req, true); }).then(function (r) {
                            // these two fields are useful for debugging auth-related issues                    
                            if (OAuth.isAuthRequired(r)) {
                                r.token_issued = dtAccessToken;
                                r.cwt_issued = dtWebTicket;
                                var t = new Web.Date, hr = 3600 * 1000;
                                // if the 401 comes again, the SDK gives up and returns the error;
                                // however if the tab is throttled the 401 may come after a delay
                                // that is longer than the token/webticket lifetime: in this case
                                // it makes sense to get a new token/webticket and resend the request
                                if (dtAccessToken && +t > +dtAccessToken + hr / 2 || dtWebTicket && +t > +dtWebTicket + hr / 2) {
                                    tm && tm.record('slow_401', { rsp: r });
                                    return processResponse(r);
                                }
                            }
                            return r;
                        });
                    });
                };
            }
            Auth.OAuth = OAuth;
            (function (OAuth) {
                /**
                 * Sends a GET to the given URL by creating a hidden <iframe>
                 * and extracts #access_token from the response.
                 *
                 * The URL must contain prompt=none in the query. Otherwise if
                 * AAD refuses to give a token, it will return a consent page
                 * with X-Frame-Options: Deny and the returned promise will never
                 * complete.
                 */
                function getToken(uri, location, document) {
                    if (location === void 0) { location = Web.window.location; }
                    if (document === void 0) { document = Web.window.document; }
                    return new Promise(function (resolve, reject, progress) {
                        var redirect_uri = new URI(uri.query.get('redirect_uri'));
                        if (!redirect_uri.host())
                            uri.query.set('redirect_uri', new URI(location.href).path(redirect_uri.path()).query('').hash('') + '');
                        // another way to get a token is to create an iframe and use it to make
                        // the OAuth request with redirect_uri pointing to the current site:
                        // this will allow to read the actual iframe's URL with #access_token in it
                        var iframe = document.createElement('iframe');
                        iframe.style.display = 'none';
                        iframe.src = uri + '';
                        document.body.appendChild(iframe);
                        iframe.onload = function () {
                            try {
                                // the same origin policy allows to read the iframe's URL if that
                                // URL and the current page's URL belong to the same domain: this
                                // trick allows to read the access token and discard the <iframe>
                                var args = URI.Query(iframe.contentWindow.location.hash.slice(1));
                                document.body.removeChild(iframe);
                                if (args.error) {
                                    // ...#error=invalid_resource&error_description=...
                                    reject(EOAuthFailed(uri + '', args));
                                }
                                else {
                                    // ...#access_token=ABC&token_type=Bearer&state=123
                                    resolve(args.token_type + ' ' + args.access_token);
                                }
                            }
                            catch (err) {
                            }
                        };
                        progress('GET ' + uri);
                    });
                }
                OAuth.getToken = getToken;
                function baseurl(url) {
                    var uri = new URI(url);
                    return URI.Query(uri.query()).redirect_uri || url;
                }
                OAuth.baseurl = baseurl;
                function audfqdn(url) {
                    var uri = new URI(url);
                    var res = URI.Query(uri.query()).resource;
                    return new URI(res).host();
                }
                OAuth.audfqdn = audfqdn;
                function isAuthRequired(rsp) {
                    // the implicit auth implementation needs to handle web ticket related error codes
                    // because it always exchanges the OAuth token for a web ticket to reduce load on the server
                    if (rsp.status == 401)
                        return true;
                    // sometimes the server doesn't send a 401 with the WWW-Authenticate header,
                    // but sends some random errors with the X-MS-Diagnostics header with a certain code:
                    // if this happens, the client can send a GET to /Autodiscover/AutodiscoverService.svc/root/oauth/user
                    // to get a proper 401 response
                    if (rsp.status == 500 || rsp.status == 403) {
                        var headers = HttpHeaders(rsp.headers);
                        var xmsdiag = XMsDiagnostics(headers.get(Auth.sMSD));
                        var code = xmsdiag.code;
                        // 500 X-MS-Diagnostics: 28032;reason="The web ticket is invalid."
                        // 500 X-MS-diagnostics: 28033;reason="The web ticket has expired."
                        // 500 X-MS-Diagnostics: 28072;reason="The ticket presented could not be verified, a new ticket is required."
                        // 403 X-MS-diagnostics: 28077;reason="Invalid Audience in the web ticket"
                        // 403 X-Ms-diagnostics: 28055;reason="The OAuth token is invalid.";faultcode="wsse:FailedAuthentication"
                        // 403 WWW-Authenticate: authorization_uri="..." audience="..."
                        return code == 28032 || code == 28033 || code == 28072 || code == 28077 || code == 28055 || !!headers.get(Auth.sW3A);
                    }
                    return false;
                }
                OAuth.isAuthRequired = isAuthRequired;
                function getAudience(rsp) {
                    var headers = HttpHeaders(rsp.headers);
                    var bearer = W3A(headers.get(Auth.sW3A))['Bearer'];
                    return bearer && bearer.audience;
                }
                OAuth.getAudience = getAudience;
            })(OAuth = Auth.OAuth || (Auth.OAuth = {}));
        })(Auth = Web.Auth || (Web.Auth = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Auth;
        (function (Auth) {
            'use strict';
            var URI = Web.Utils.URI;
            var Task = Web.Utils.Task;
            var Exception = Web.Utils.Exception;
            /**
             * The ADFS auth is about exchanging a cookie set for a Lync server FQDN
             * for an access token for that FQDN. The full authentication flow consists of
             * three steps:
             *
             *  1. Redirect the user to the login page and let him sign in.
             *  2. Discover the Lync's passive auth URL and use it to get the cookie.
             *  3. Exchange the cookie for an access token.
             *
             * The first step requires the full page redirect and involves UI, so it's beyond
             * the scope of this library.
             *
             * The second step is meant to be done via a POST request to /oauthtoken which is
             * designed for JS web apps, but because of several bugs in /oauthtoken that do not
             * have workarounds, this library reads XML from /mex and finds there the passive
             * auth URL that usually ends with /PassiveAuth.aspx This URL is then used as the
             * source of a hidden iframe that loads the page, follows redirects if any and executes
             * JS code downloaded from a trusted site. The JS code sends a request to the Lync
             * server and in a response the server sends the RPSAuth or LyncWif cookie.
             *
             * The third step is meant to be done via the very same POST to /oauthtoken which is
             * designed for JS web apps, but because of another bug on the server, the library has
             * to send a SOAP request to /WsFed_Passive and extract the access token from a SOAP
             * response.
             *
             */
            function ADFS(doc) {
                // to simplify writing unit tests
                var document = doc || Web.window.document;
                // The function given to MsRtcOAuth is invoked every time a new web ticket
                // is needed. That function takes two parameters: 
                //
                //  1. A function to send HTTP requests on behalf of the Lync pool for which the web ticket is needed.
                //  2. The parsed MsRtcOAuth section from the WWW-Authenticate header.
                //
                // The function returns a promise that resolves to the web ticket.
                return Auth.MsRtcOAuth(function (send, msra) {
                    // The scope of the required web ticket can be extracted from MsRtcOAuth.
                    var aspx, cwts, root = new URI(msra.href).path('') + '', wtsvc = new Auth.WebTicketService(root, send);
                    return Task.wait(0).then(function () {
                        // The Task.waitAll below handles three possible error cases:
                        //
                        //  1. If the GET fails, the two default URLs must be taken.
                        //  2. If the GET succeeds but the regexp fails, only the default aspx URL must be taken.
                        //  3. If the GET succeeds but XmlDoc fails, only the default WsFed URL must be taken.
                        // 
                        return Task.waitAll([
                            wtsvc.getPassiveAuthUrl().then(function (url) {
                                aspx = url;
                            }),
                            wtsvc.getWsFedPassivePath().then(function (url) {
                                cwts = url;
                            })
                        ]);
                    }).then(function () {
                        // The second step is to use the OrgID service URL to get the RPSAuth or LyncWif
                        // cookie for the Lync server FQDN. This can be done implicitly, without prompting
                        // for user credentials, because the user has already signed in to OrgID and the
                        // client browser has remembered auth cookies for the OrgID FQDNs.
                        //
                        // In order to get the RPSAuth/LyncWif cookie the client needs to download the HTML
                        // page located at the passive auth URL and process it as any other regular HTML page.
                        // This can be done with a hidden iframe.
                        var n = 0, tasks = [];
                        function awaitLoad(i) {
                            tasks[i] = new Task('waiting for the ' + i + '-th onload event from iframe at ' + aspx);
                            return tasks[i].promise;
                        }
                        var iframe = document.createElement('iframe');
                        iframe.style.display = 'none';
                        iframe.src = aspx;
                        // The onload event may be fired multiple times:
                        //
                        //  - once if the RPSAuth/LyncWif cookie already exists
                        //  - twice if the OrgID cookies exist, but RPSAuth/LyncWif doesn't
                        //  - three times if the signed in user is federated and doesn't have OrgID cookies
                        //
                        iframe.onload = function () {
                            tasks[++n].resolve();
                        };
                        document.body.appendChild(iframe);
                        // Federated users aren't supported, so this implementation expects
                        // up to two onload events.
                        return Task.waitAny([
                            // one request to be sent immediately in case the RPSAuth cookie already exists
                            Task.wait(0).then(function () { return wtsvc.getWebTicket(cwts); }),
                            // one request to be sent after the frame loads one time in case Lync server doesn't redirect to OrgID
                            awaitLoad(1).then(function () { return wtsvc.getWebTicket(cwts); }),
                            // one request to be sent after the frame loads twice in case Lync server redirects to OrgID
                            awaitLoad(2).then(function () { return wtsvc.getWebTicket(cwts); })
                        ]).then(function (cwt) {
                            return new Auth.WebTicket('Bearer ' + cwt);
                        }).finally(function () {
                            // No matter whether the web ticket received,
                            // the iframe needs to be removed. Notice, how
                            // this clean-up code doesn't alter the result
                            // and doesn't modify the exception.
                            document.body.removeChild(iframe);
                        });
                    }).catch(function (err) {
                        // If the web ticket cannot be obtained, provide the URL
                        // that needs to be followed to sign the user in.
                        throw aspx ? Exception('NotSignedIn', { aspx: aspx, reason: err }) : err;
                    });
                });
            }
            Auth.ADFS = ADFS;
        })(Auth = Web.Auth || (Web.Auth = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Auth;
        (function (Auth) {
            'use strict';
            /**
             * It sends the credentials in plain text with grant_type=password
             * to get the auth token. Note, that the user name may differ from
             * the sign in address (which is used for auto discovery). For instance
             * auto discovery starts from "user1@contoso.com" but when asked
             * for credentials, the client is supposed to provide "group1\user1"
             * as the user name.
             *
             */
            function Basic(username, password) {
                return Auth.MsRtcOAuth({
                    grant_type: 'password',
                    username: username,
                    password: password
                });
            }
            Auth.Basic = Basic;
        })(Auth = Web.Auth || (Web.Auth = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Auth;
        (function (Auth) {
            'use strict';
            /**
             * It sends grant_type=urn:microsoft.rtc:windows to the auth service, the latter
             * sends a special reply that is handled by the browser (it shows a popup window
             * to prompt for credentials) and then the browser sends a reply with the token
             * as though there was no NTLM negotiation between the first request and the last
             * response.
             *
             * Note, that not all browsers support this authentication.
             *
             */
            function Integrated() {
                return Auth.MsRtcOAuth({
                    grant_type: 'urn:microsoft.rtc:windows'
                });
            }
            Auth.Integrated = Integrated;
        })(Auth = Web.Auth || (Web.Auth = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Auth;
        (function (Auth) {
            'use strict';
            /**
             * This kind of authentication is used to join an online meeting anonymously.
             * The client must know the URI of the meeting to sign in.
             *
             */
            function AnonMeeting(uri, key) {
                // this is how an online meeting uri looks like:
                // sip:user5@contoso.com;gruu;opaque=app:conf:focus:id:QHJ72TKK
                return Auth.MsRtcOAuth({
                    grant_type: 'urn:microsoft.rtc:anonmeeting',
                    ms_rtc_conferenceuri: uri,
                    password: key || uri.match(/:(\w+)$/)[1]
                });
            }
            Auth.AnonMeeting = AnonMeeting;
        })(Auth = Web.Auth || (Web.Auth = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Auth;
        (function (Auth) {
            'use strict';
            var URI = Web.Utils.URI;
            /**
             * For most conferences the anon cwt must be issued by /WebTicket/oauthtoken,
             * while for some conferences the token must be issued by /WebTicket/WebTicketService.svc/Anon:
             *
             *      GET /WebTicket/WebTicketService.svc/mex
             *      POST /WebTicket/WebTicketService.svc/Anon + base64-encoded conference URI
             *      POST /ucwa/v1/applications + X-MS-WebTicket: cwt=...
             *
             */
            function AnonMeetingInternal(conf_uri, conf_key) {
                if (conf_key === void 0) { conf_key = conf_uri.match(/:(\w+)$/)[1]; }
                var cwt;
                return Auth.MsRtcOAuth(function (send, msra) {
                    var root = new URI(msra.href).path('') + '';
                    var wtsvc = new Auth.WebTicketService(root, send);
                    return wtsvc.getAnonWebTicket(conf_uri, conf_key, cwt).then(function (t) {
                        // the cwt must be valid when it's renewed, so renew it 10 mins before it expires
                        t.expires = t.expires && new Web.Date(+t.expires - 10 * 60 * 1000);
                        return cwt = t;
                    });
                }, 'X-MS-WebTicket', true);
            }
            Auth.AnonMeetingInternal = AnonMeetingInternal;
        })(Auth = Web.Auth || (Web.Auth = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Auth;
        (function (Auth) {
            'use strict';
            /**
             * Adds a token to every request:
             *
             *      Authorization: Bearer cwt=AAB...
             *
             * Once the token is given, it cannot be renewed.
             * The token is generated by the calling app and
             * is usually valid for 8 hours.
             *
             * The second param tells which request should be
             * sent without a token.
             */
            function Token(token, exurl) {
                return function (req, send) {
                    if (req.url != exurl)
                        req.headers['Authorization'] = token;
                    return send(req);
                };
            }
            Auth.Token = Token;
        })(Auth = Web.Auth || (Web.Auth = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Auth;
        (function (Auth) {
            var URI = Web.Utils.URI;
            var Http = Web.Utils.Http;
            var Task = Web.Utils.Task;
            var random = Web.Utils.random;
            var Exception = Web.Utils.Exception;
            var OAuthTokenRetriever = (function () {
                /**
                 * Creates an iframe and navigates to the specified OAuthCallback javascript file.
                 * Each request to get a token is forwarded to the OAuthCallback script which retrieves the token
                 * and posts back to jLync.
                 * Only one request is sent out to the OAuthCallback iframe at a time, other requests are queued.
                 * If the callback does not respond in the specified time then the request is retried once before giving up.
                 * Failure to one request does not fail other pending requests.
                 *
                 * @param oauthCallback Url of the callback script, typically hosted on CDN and whitelisted on AAD as a valid reply url.
                 * @param timeout Time in milliseconds after which the request is retried. There is only one retry per auth request.
                 * Default is 5000.
                 */
                function OAuthTokenRetriever(oauthCallback, timeout, _window, _document) {
                    if (timeout === void 0) { timeout = 5000; }
                    if (_window === void 0) { _window = Web.window; }
                    if (_document === void 0) { _document = document; }
                    this.oauthCallback = oauthCallback;
                    this.timeout = timeout;
                    this._window = _window;
                    this._document = _document;
                    this.oauth_callback_origin = new URI(this.oauthCallback).origin();
                    this.iframe = _document.createElement('iframe');
                    this.iframe.style.display = 'none';
                    this.iframe.src = oauthCallback;
                    _document.body.appendChild(this.iframe);
                    if (_window.addEventListener)
                        _window.addEventListener('message', this.processMessage.bind(this));
                    else
                        _window.attachEvent('onmessage', this.processMessage.bind(this));
                }
                OAuthTokenRetriever.prototype.processMessage = function (message) {
                    try {
                        if (message.origin != this.oauth_callback_origin)
                            return;
                        var response = JSON.parse(message.data);
                        if (response.id != this.requestId)
                            return;
                        if (!Http.isSuccess(response.status))
                            this.tRequest && this.tRequest.reject(response.error);
                        else {
                            switch (response.code) {
                                case 'GETTOKEN':
                                    this.tRequest && this.tRequest.resolve(response.token_type + ' ' + response.access_token);
                                    break;
                            }
                        }
                    }
                    catch (e) { }
                };
                OAuthTokenRetriever.prototype.post = function (message) {
                    this.requestId = random();
                    message.id = this.requestId;
                    this.iframe.contentWindow.postMessage(JSON.stringify(message), '*');
                };
                /**
                 * Calls the OAuthCallback script to retrieve a token with the given auth uri.
                 * @param auth_request_uri The complete aad authorization uri with query parameters that is used to obtain a token.
                 */
                OAuthTokenRetriever.prototype.getToken = function (auth_request_uri) {
                    var _this = this;
                    return Task.wait(this.pRequest).catch().then(function () {
                        if (_this.pRequest)
                            return _this.getToken(auth_request_uri);
                        _this.tRequest = new Task();
                        _this.pRequest = _this.tRequest.promise;
                        var makeTokenRequest = function (isRetry) {
                            _this.post({
                                type: 'GETTOKEN',
                                uri: auth_request_uri + ''
                            });
                            _this.timerId = Web.setTimeout(function () {
                                if (!isRetry)
                                    return makeTokenRequest(true);
                                _this.tRequest && _this.tRequest.reject(Exception('OAuthCallbackTimeout', {
                                    reason: {
                                        uri: auth_request_uri
                                    }
                                }));
                            }, _this.timeout);
                        };
                        makeTokenRequest(false);
                        return _this.pRequest.then(function (token) {
                            Web.clearTimeout(_this.timerId);
                            return {
                                status: 200,
                                responseText: token
                            };
                        }).finally(function () {
                            _this.tRequest = null;
                            _this.pRequest = null;
                            Web.clearTimeout(_this.timerId);
                        });
                    });
                };
                /**
                 * Cleanup when the OAuthTokenRetriever is no longer required.
                 * Removes the iframe and cancels the pending timer.
                 */
                OAuthTokenRetriever.prototype.reset = function () {
                    try {
                        if (this.iframe) {
                            this._document.body.removeChild(this.iframe);
                            this.iframe.onload = null;
                            this.iframe = null;
                            Web.clearTimeout(this.timerId);
                        }
                    }
                    catch (_) { }
                };
                return OAuthTokenRetriever;
            }());
            Auth.OAuthTokenRetriever = OAuthTokenRetriever;
        })(Auth = Web.Auth || (Web.Auth = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
/// <reference path="auth/WebTicketService.ts" />
/// <reference path="auth/MsRtcOAuth.ts" />
/// <reference path="auth/OAuth.ts" />
/// <reference path="auth/ADFS.ts" />
/// <reference path="auth/Password.ts" />
/// <reference path="auth/Integrated.ts" />
/// <reference path="auth/AnonMeeting.ts" />
/// <reference path="auth/AnonMeetingInternal.ts" />
/// <reference path="auth/Token.ts" />
/// <reference path="auth/OAuthTokenRetriever.ts" />
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var root = 'SkypeWebSDK';
        var Stack;
        (function (Stack) {
            var StorageItem = (function () {
                /**
                 * Encapsulates access to a storage container.
                 *
                 * @param {String[]} path - Array of strings that are concatenated to form the subpath in the container
                 * @param {String} storage - an object with the Web Storage API's Storage interface. Defaults to sessionStorage.
                 *
                 */
                function StorageItem(path, storage) {
                    this.path = path;
                    this.storage = storage;
                    try {
                        if (!this.storage)
                            this.storage = Web.sessionStorage;
                    }
                    catch (_) { }
                    this.key = [root].concat(this.path).join('//');
                }
                Object.defineProperty(StorageItem.prototype, "json", {
                    get: function () {
                        var value = this.storage.getItem(this.key);
                        return value && JSON.parse(value);
                    },
                    set: function (value) {
                        this.storage.setItem(this.key, JSON.stringify(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                StorageItem.prototype.remove = function () {
                    this.storage.removeItem(this.key);
                };
                return StorageItem;
            }());
            Stack.StorageItem = StorageItem;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            var map = Web.Utils.map;
            var pick = Web.Utils.pick;
            var clone = Web.Utils.clone;
            var assert = Web.Utils.assert;
            var extend = Web.Utils.extend;
            var foreach = Web.Utils.foreach;
            var isArray = Web.Utils.isArray;
            var isEmptyObject = Web.Utils.isEmptyObject;
            var Event = Web.Utils.Event;
            var Exception = Web.Utils.Exception;
            var Collection = Web.Utils.Collection;
            var BoolProperty = Web.Utils.BoolProperty;
            function ELinkMissing(resource, rel) {
                var text = resource.rel + '/' + rel + ' link does not exist';
                return Exception.call(text, 'LinkMissing', { resource: pick(resource, ['rel', 'href']), rel: rel });
            }
            function ESingleLinkExpected(resource, rel) {
                var text = 'one ' + resource.rel + '/' + rel + ' link expected, ' + resource.links(rel).length + ' found';
                return Exception.call(text, 'SingleLinkExpected', { resource: pick(resource, ['rel', 'href']), rel: rel });
            }
            function EAttrMissing(resource, name) {
                var text = resource.rel + '.' + name + ' property does not exist';
                return Exception.call(text, 'AttrMissing', { resource: pick(resource, ['rel', 'href']), name: name });
            }
            /**
             * Resource is what UCWA server normally returns.
             *
             * The Resource concept was introduced by "Hypertext Application Language"
             * or "HAL" specification draft in
             *
             *      tools.ietf.org/html/draft-kelly-json-hal-05
             *
             * A resource has four aspects:
             *
             *      - it has a unique id (its "_links.self.href" attribute)
             *      - it has a type (its "rel" attribute)
             *      - it contains named properties (key-value pairs)
             *      - it points to other related resources
             *
             * It's noteworthy, that the related resources to which a resource
             * points, do not belong to the resource and are not embedded into
             * it - they are just somehow related. For example the "people" resource
             * is related to the "me" resource, a "contact" resource is related to
             * the "people" resource and at the same time the "me" resource
             * is related to the "contact" resource: the resource relations may
             * form loops with one or many nodes. In the implementation this
             * means that given a link to some related resource, this resource
             * can be loaded from the server and the loaded resource will have
             * links to other related resources, that can be also loaded and so on.
             *
             * @method get() - Returns a copy of all properties as a dictionary.
             *
             */
            var Resource = (function () {
                function Resource(raw) {
                    var self = { toString: toString };
                    var dirty = BoolProperty(false);
                    var isRemoved = false;
                    var rel, href, revision;
                    var related = {};
                    var embedded = {};
                    var properties = {};
                    var memberships = Collection(); // resource objects
                    var updated = new Event({
                        added: function (listener) {
                            listener();
                        }
                    });
                    var deleted = new Event({
                        added: function (listener) {
                            if (isRemoved)
                                listener();
                        }
                    });
                    // Resource(href, rel) creates an empty resource with a given href and rel
                    if (arguments.length > 1) {
                        raw = {
                            rel: arguments[1],
                            _links: {
                                self: { href: arguments[0] }
                            }
                        };
                        // the default value is revision=1, so if it's 1, it can be omitted
                        if (arguments[2] > 1) {
                            revision = arguments[2];
                            raw._links.self.revision = revision;
                        }
                    }
                    init();
                    // the server does not always provide the "rel" attribute
                    rel = raw.rel || null;
                    revision = raw._links.self.revision;
                    function init() {
                        // the "href" attribute is mandatory, because this is the
                        // unique id of the resource
                        try {
                            href = raw._links.self.href;
                        }
                        catch (err) {
                            throw ELinkMissing(raw, 'self');
                        }
                        // extract related resources from _links in which
                        // _links[rel] is a link or an array of links to
                        // related resources
                        for (var rel_1 in raw._links) {
                            var links_1 = raw._links[rel_1];
                            if (!isArray(links_1))
                                links_1 = [links_1];
                            related[rel_1] = links_1;
                        }
                        // extract related resources from _embedded in which
                        // _embedded[rel] is a resource or an array of related
                        // resources
                        if (raw._embedded) {
                            for (var rel_2 in raw._embedded) {
                                var resources = raw._embedded[rel_2];
                                if (!isArray(resources))
                                    resources = [resources];
                                for (var _i = 0, resources_1 = resources; _i < resources_1.length; _i++) {
                                    var ri = resources_1[_i];
                                    var r = new Resource(ri);
                                    // even if there is no property raw._embedded[rel].rel,
                                    // we know the type of the embedded resource
                                    r.rel = r.rel || rel_2;
                                    // Embedded mediaRelay resources of communication/mediaRelayAccessToken resource 
                                    // have the same href as the parent resource, so we fake the unique href:
                                    if (r.rel == 'mediaRelay' && r.href == href)
                                        r.href += '/' + r.properties.host + '/' + r.properties.location;
                                    embedded[r.href] = r;
                                    if (!related[rel_2])
                                        related[rel_2] = [];
                                    // the href entry may have already been added to related[rel] from raw._links
                                    if (!hasLink(rel_2, r.href))
                                        related[rel_2].push({ href: r.href });
                                }
                            }
                        }
                        // copy properties of the resource from its
                        // raw representation
                        for (var i in raw)
                            properties[i] = raw[i];
                        // "rel" is the type name;
                        // "_links" and "_embedded" are not properties and
                        // just point to other related resources
                        delete properties.rel;
                        delete properties._links;
                        delete properties._embedded;
                    }
                    //#region public methods
                    function remove(reason) {
                        if (!isRemoved) {
                            isRemoved = true;
                            deleted.fire(reason);
                        }
                    }
                    // The server may return many incomplete representations of the same resource.
                    // The client must collect all properties from all representations of the same
                    // resource and put them into one resource object.
                    // 
                    // This method takes another representation of the same resource and reads from it
                    // properties that this resource object is missing or have outdated.
                    function updateFrom(source) {
                        assert(self.href == source.href);
                        // override all properties and links of this resource
                        // with properties and links of the given resource
                        self.related = related = clone(source.related);
                        self.properties = properties = clone(source.properties);
                        self.embedded = embedded = map(source.embedded, function (r) { return new Resource(r.getSnapshot()); });
                        dirty(false);
                        updated.fire();
                    }
                    function relatedHref(rel) {
                        var link = related[rel];
                        if (link)
                            return link[0].href;
                    }
                    function getSnapshot(fn) {
                        var snapshot = { rel: rel, _links: {} };
                        for (var i in properties)
                            snapshot[i] = properties[i];
                        for (var i in related) {
                            if (i != 'self' && fn && !fn(i))
                                continue;
                            var links_2 = related[i];
                            if (links_2.length > 0)
                                snapshot._links[i] = links_2.length > 1 ? links_2 : links_2[0];
                        }
                        return clone(snapshot);
                    }
                    function toString(indent) {
                        if (indent === void 0) { indent = 4; }
                        var snapshot = getSnapshot();
                        if (!isEmptyObject(embedded))
                            snapshot._embedded = {};
                        // add embedded resources to the snapshot
                        for (var href_1 in embedded) {
                            // find the matching entry in _links;
                            // note, that rel may differ from r.rel
                            var rel_3 = void 0, i = void 0;
                            find: for (rel_3 in snapshot._links) {
                                var links_3 = snapshot._links[rel_3];
                                if (isArray(links_3)) {
                                    for (i = 0; i < links_3.length; i++) {
                                        if (links_3[i].href == href_1)
                                            break find;
                                    }
                                }
                                else if (links_3.href == href_1) {
                                    i = 0;
                                    break;
                                }
                            }
                            // this will add nested _embedded resources
                            var r = JSON.parse(embedded[href_1] + '');
                            if (!r.rel)
                                delete r.rel;
                            // add the embedded resource to the snapshot
                            snapshot._embedded = snapshot._embedded || {};
                            snapshot._embedded[rel_3] = snapshot._embedded[rel_3] || [];
                            snapshot._embedded[rel_3].push(r);
                            // now remove the entry from _links
                            if (isArray(snapshot._links[rel_3]))
                                snapshot._links[rel_3].splice(i, 1);
                            if (!isArray(snapshot._links[rel_3]) || !snapshot._links[rel_3].length)
                                delete snapshot._links[rel_3];
                        }
                        // now do some cleanup to make the snapshot nicer
                        for (var rel_4 in snapshot._embedded)
                            if (snapshot._embedded[rel_4].length == 1)
                                snapshot._embedded[rel_4] = snapshot._embedded[rel_4][0];
                        return JSON.stringify(snapshot, null, indent)
                            .replace(/{\s*\n\s*("href"):\s*(".+?")\s*\n\s*}/gm, '{ $1: $2 }');
                    }
                    // Invokes a given callback for every link in the resource
                    // and all embedded resources. Every link has at least the "href"
                    // property.
                    function forEachLink(callback) {
                        foreach(related, function (links, rel) {
                            foreach(links, function (link) {
                                if (!embedded[link.href])
                                    callback(link, rel);
                            });
                        });
                        foreach(embedded, function (resource) {
                            resource.forEachLink(callback);
                        });
                    }
                    function addLink(rel, href) {
                        if (!hasLink(rel, href)) {
                            if (!related[rel])
                                related[rel] = [];
                            related[rel].push({ href: href });
                            updated.fire();
                        }
                        return self;
                    }
                    function removeLink(rel, href) {
                        var links = related[rel];
                        if (links) {
                            for (var i = 0; i < links.length; i++) {
                                if (links[i].href == href) {
                                    links.splice(i, 1);
                                    updated.fire();
                                    break;
                                }
                            }
                        }
                        return self;
                    }
                    function link(rel) {
                        var links = related[rel];
                        if (!links || links.length == 0)
                            throw ELinkMissing(self, rel);
                        if (links.length > 1)
                            throw ESingleLinkExpected(self, rel);
                        return links[0];
                    }
                    function links(rel) {
                        return related[rel] || [];
                    }
                    function hasLink(rel, href) {
                        var links = related[rel] || [];
                        if (!href)
                            return links.length > 0;
                        for (var i = 0; i < links.length; i++)
                            if (links[i].href == href)
                                return true;
                        return false;
                    }
                    function set(name, value) {
                        properties[name] = value;
                        updated.fire();
                        return self;
                    }
                    function get(name, defaultValue) {
                        if (!name)
                            return clone(properties);
                        if (name == 'href')
                            return href;
                        if (name in properties)
                            return properties[name];
                        if (arguments.length == 1)
                            throw EAttrMissing(self, name);
                        return defaultValue;
                    }
                    function has(name) {
                        return name == 'href' || name in properties;
                    }
                    //#endregion public methods
                    // TODO: The interface of this class desperately needs refactoring.
                    // In fact, Resource needs two interfaces: one with RW access for
                    // internal use in the stack layer and one RO for external use
                    // in the model layer. Currently both the stack and the model layer
                    // have RW access to every resource object.
                    return extend(self, {
                        href: href,
                        rel: rel,
                        revision: revision,
                        memberships: memberships,
                        properties: properties,
                        related: related,
                        embedded: embedded,
                        remove: remove,
                        updateFrom: updateFrom,
                        relatedHref: relatedHref,
                        updated: updated.observer,
                        deleted: deleted.observer,
                        forEachLink: forEachLink,
                        getSnapshot: getSnapshot,
                        dirty: dirty,
                        addLink: addLink,
                        removeLink: removeLink,
                        hasLink: hasLink,
                        link: link,
                        links: links,
                        has: has,
                        set: set,
                        get: get
                    });
                }
                return Resource;
            }());
            Stack.Resource = Resource;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var extend = Web.Utils.extend;
            var foreach = Web.Utils.foreach;
            var isFunction = Web.Utils.isFunction;
            /** Represents an event received from UCWA. */
            var ResourceEvent = (function () {
                function ResourceEvent(options) {
                    if (options === void 0) { options = {}; }
                    if (!(this instanceof ResourceEvent))
                        return new ResourceEvent(options);
                    extend(this, options);
                }
                /**
                 * This method is used for writing unit tests and debugging only.
                 * When the stack receives an event, it stringifies it and prints
                 * to the browser's console as a plain string. Because this string
                 * is a valid JS expression that constructs an event, it can be
                 * copied into a JS file with unit tests.
                 */
                ResourceEvent.prototype.toString = function () {
                    var pairs = [];
                    foreach(this, function (value, key) {
                        if (key == 'resource') {
                            if (value)
                                pairs.push('    "resource": ' + value);
                        }
                        else if (!isFunction(value))
                            pairs.push('    "' + key + '": ' + JSON.stringify(value));
                    });
                    return '{\n' + pairs.reverse().join(',\n') + '\n}';
                };
                return ResourceEvent;
            }());
            Stack.ResourceEvent = ResourceEvent;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var map = Web.Utils.map;
            var clone = Web.Utils.clone;
            var assert = Web.Utils.assert;
            var extend = Web.Utils.extend;
            var values = Web.Utils.values;
            var filter = Web.Utils.filter;
            var foreach = Web.Utils.foreach;
            var indexOf = Web.Utils.indexOf;
            var isArray = Web.Utils.isArray;
            var isString = Web.Utils.isString;
            var isFunction = Web.Utils.isFunction;
            var isNotEmptyString = Web.Utils.isNotEmptyString;
            var Event = Web.Utils.Event;
            /**
             * Repository keeps all resources available to the transport layer.
             * It provides functionality to search for existing resources.
             *
             * In UCWA terms, Repository acts as the Cache.
             *
             * @param [snapshot] - The initial state of the repository.
             * @param [connection] - The source of UCWA events.
             *
             *  This is what Repository::getSnapshot returns.
             *
             * @method put(resource) - Adds or updates a resource in the repository.
             * @method remove(href) - Removes a resource from the repository.
             * @method {Resource[]} get(selector) - Finds all resources matching the selector.
             *
             *     - get({ rel: 'me' }) - finds all resources with rel="me"
             *     - get('/me/car') - finds all resources with href="/me/car"
             *
             * @method getSnapshot - Returns a snapshot of the repository.
             *
             *  The snapshot is a mapping from resource rel to array of resource snapshots
             *  with the given rel. This is how a snapshot can be used:
             *
             *      var snapshot = repository.getSnapshot();
             *      var resource = Resource(snapshot.contact[0]);
             *
             */
            var Repository = (function () {
                function Repository(_a) {
                    var _b = _a === void 0 ? {} : _a, connection = _b.connection, snapshot = _b.snapshot;
                    var self = { toString: toString };
                    var updated = new Event({
                        added: function (listener) { return listener(); }
                    });
                    // Every resource has a unique "href" value that is written in "r._links.self.href"
                    // if "r" refers to a resource returned by the server, then resources[href] is
                    // a Resource object which id is "href"
                    var resources = {};
                    // cache[rel] is an array of href values of all resources with the given "rel" attribute.
                    var cache = {};
                    //#region initialization
                    if (connection) {
                        connection.event(processEvent);
                        // Remove all resources from repository when disconnected
                        // from UCWA server to reset all properties.
                        connection.connected.when(false, function () {
                            foreach(resources, function (r) {
                                // TODO: if statement must be removed when comprehensive fix is done for all properties. 
                                // Its there to prevent breaking two unit tests.
                                if (r.rel == 'me')
                                    remove(r.href);
                            });
                        });
                    }
                    if (snapshot) {
                        foreach(snapshot, function (rs, rel) {
                            foreach(rs, function (r) {
                                r = clone(r);
                                r.rel = rel;
                                put(new Stack.Resource(r));
                            });
                        });
                    }
                    //#endregion
                    //#region private methods
                    /**
                     * Handles a UCWA event and updates resource objects in the repository.
                     * This method must be the very first handler among all handlers of UCWA
                     * events because it may need to modify the original event object to make
                     * it refer to resource objects in the repository.
                     */
                    function processEvent(event) {
                        var type = event.type;
                        var sender = event.sender;
                        var target = event.target;
                        var context = event['in'];
                        // the resource object is added to the repository even for
                        // "deleted" and "completed" events because event handlers
                        // may reasonably expect the resource from the event to be
                        // present in the repository
                        put(new Stack.Resource(sender.href, sender.rel), true);
                        if (event.resource) {
                            put(event.resource);
                            // an event handler may save a reference to event.resource
                            // and later check its state, so we want to replace event.resource
                            // with a reference to the resource in the repository, which
                            // may be updated later by UCWA events
                            event.resource = resources[event.resource.href];
                        }
                        else {
                            put(new Stack.Resource(target.href, target.rel), true);
                            // an empty "updated" event indicates that the state of the target resource
                            // has changed, but UCWA isn't sending its new state in the event: to get
                            // that state the client needs to send a GET request; so the resource object
                            // is only marked as obsolete and the stack leaves it up to the model layer
                            // to decide whether it's worth sending the GET
                            if (type == 'updated')
                                resources[target.href].dirty(true);
                        }
                        if (context) {
                            put(new Stack.Resource(context.href, context.rel), true);
                            if (type == 'added') {
                                resources[context.href].addLink(target.rel, target.href);
                                if (!resources[target.href].memberships(context.href))
                                    resources[target.href].memberships.add(resources[context.href], context.href);
                            }
                            if (type == 'deleted') {
                                resources[context.href].removeLink(target.rel, target.href);
                                if (resources[target.href].memberships(context.href))
                                    resources[target.href].memberships.remove(context.href);
                            }
                        }
                        if (type == 'deleted' || type == 'completed') {
                            // if the event target is a member of a collection then we should not delete it from
                            // the repository because the target may exist outside the collection; for instance
                            // when someone stops typing in a conversation, the server sends a "participant
                            // deleted in typingParticipants" event.
                            if (!context)
                                remove(target.href, event.reason); // event may contain a #reason property                        
                        }
                    }
                    //#endregion
                    //#region public methods
                    /**
                     * Adds a new resource to the repository or updates an existing resource
                     * in the repository.
                     *
                     * Since the resource may point to related resources, the procedure of adding
                     * a resource into the repository is recursive.
                     *
                     * @param {Resource} r
                     * @param {Boolean} isLink - Whether `r` was created from an empty link.
                     *
                     *      TODO: consider moving this parameter out of `put` and moving it
                     *      into the parameters list of the Resource's ctor.
                     */
                    function put(r, isLink) {
                        if (isLink === void 0) { isLink = false; }
                        if (!r.links)
                            r = new Stack.Resource(r);
                        if (!r.rel || !r.href)
                            return;
                        var href, rel, link, i, c;
                        var isNew = !resources[r.href];
                        updated.fire();
                        if (isNew) {
                            r.isLink = isLink;
                            resources[r.href] = r;
                            // if the only thing we know about a resource is its href,
                            // then the cached state of this resource is obviously invalid
                            if (isLink)
                                r.dirty(true);
                            if (!cache[r.rel])
                                cache[r.rel] = [];
                            cache[r.rel].push(r.href);
                        }
                        // put into the repository the minimum info ("rel" and "href"
                        // attributes) of those resources known to the given resource
                        for (rel in r.related) {
                            for (i = 0; i < r.related[rel].length; i++) {
                                link = r.related[rel][i];
                                href = link.href;
                                // we know nothing about a related resource except
                                // its "rel" and "href" attributes, so create a resource
                                // with these attributes and put it into the repository
                                //
                                // however, if the same resource is embedded, do not add
                                // it here, because this will fire the "added" event now and
                                // the "updated" event later, when the same resource gets updated
                                // from the embedded resource; this is not harmful, but the
                                // unnecessary "updated" event can be easily avoided in this case
                                if (!resources[href] && !r.embedded[href])
                                    put(new Stack.Resource(href, rel, link.revision), true);
                            }
                        }
                        // the resource also has embedded resources about which it knows
                        // more than just their "href" and "rel" attributes - put them
                        // into the repository as well
                        for (href in r.embedded)
                            put(r.embedded[href]);
                        // copy new properties of the resource into the repository
                        if (!isNew && !isLink) {
                            resources[r.href].updateFrom(r);
                            // UCWA may send a resource with one rel as a link of another resource
                            // and later send the same resource with a different rel. For instance
                            // when a rel=messagingInvitation arrives it has a rel=from link which
                            // in fact points to a rel=participant resource.
                            if (resources[r.href].isLink && resources[r.href].rel != r.rel) {
                                c = cache[resources[r.href].rel];
                                assert(c); // if this failed, `cache` and `resources` are unsynced
                                c.splice(indexOf(c, r.href), 1); // c.remove(r.href)
                                if (c.length == 0)
                                    delete cache[resources[r.href].rel];
                                if (!cache[r.rel])
                                    cache[r.rel] = [];
                                cache[r.rel].push(r.href);
                                resources[r.href].rel = r.rel;
                            }
                        }
                    }
                    /**
                     * Removes a resource from the repository.
                     */
                    function remove(href, reason) {
                        assert(isNotEmptyString(href));
                        var r = resources[href];
                        if (r) {
                            var c = cache[r.rel];
                            // remove href from cache[r.rel]
                            c.splice(indexOf(c, href), 1);
                            // remove r from resources
                            delete resources[href];
                            // mark the resource as removed
                            r.remove(reason);
                            // fire updated event to trigger updation of snapshot
                            updated.fire();
                        }
                    }
                    /**
                     * Finds all resources that match the given selector:
                     * The selector can be:
                     *
                     *      - the "rel" attribute
                     *      - the "href" attribute
                     */
                    function get(selector) {
                        assert(isNotEmptyString(selector));
                        if (resources[selector])
                            return [resources[selector]];
                        if (cache[selector]) {
                            var hrefs = cache[selector];
                            var results = [];
                            for (var _i = 0, hrefs_1 = hrefs; _i < hrefs_1.length; _i++) {
                                var href = hrefs_1[_i];
                                results.push(resources[href]);
                            }
                            return results;
                        }
                        return [];
                    }
                    /**
                     * Finds all resources that satisfies the given predicate
                     *
                     * @param {Resource => bool} predicate
                     * @returns {Resource[]} - The array of found resources, which can be empty.
                     */
                    function find(predicate) {
                        return values(filter(resources, predicate));
                    }
                    /**
                     * Gets a snapshot of the repository.
                     */
                    function getSnapshot(fn) {
                        var filteredCache = isFunction(fn) ? filter(cache, function (val, rel) { return fn(rel); }) : cache;
                        return map(filteredCache, function (hrefs) {
                            return map(hrefs, function (href) {
                                var rs = resources[href].getSnapshot(fn);
                                delete rs.rel; // no need to store "rel" as it can be inferred from the snapshot
                                return rs;
                            });
                        });
                    }
                    function toString(indent) {
                        return JSON.stringify(getSnapshot(), null, indent);
                    }
                    //#endregion
                    return extend(self, {
                        put: put,
                        get: get,
                        find: find,
                        remove: remove,
                        updated: updated.observer,
                        getSnapshot: getSnapshot,
                        toString: toString
                    });
                }
                return Repository;
            }());
            Stack.Repository = Repository;
            (function (Repository) {
                function expandSnapshot(snapshot) {
                    snapshot = clone(snapshot);
                    foreach(snapshot, function (resources, rel) {
                        if (!isArray(resources))
                            snapshot[rel] = resources = [resources];
                        foreach(resources, function (r, i) {
                            if (isString(r))
                                resources[i] = r = { _links: { self: { href: r } } };
                        });
                    });
                    return snapshot;
                }
                Repository.expandSnapshot = expandSnapshot;
            })(Repository = Stack.Repository || (Stack.Repository = {}));
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            var check = Web.Utils.check;
            /**
             * The event channel with the server (the one to which the "events" resource points)
             * sends to the client resources that have the "sender" property. This property contains
             * a batch of events.
             *
             * The EventCollection is essentially a parser for the "sender" property.
             *
             * @example
             *
             *      var events = EventCollection(...);
             *      for (var i = 0; i < events.length; i++)
             *          if (events[i].type == 'added')
             *              ...
             *
             */
            function EventCollection(senders) {
                var events = [];
                for (var _i = 0, senders_1 = senders; _i < senders_1.length; _i++) {
                    var sender = senders_1[_i];
                    for (var _a = 0, _b = sender.events; _a < _b.length; _a++) {
                        var target = _b[_a];
                        var resource = null;
                        if (target._embedded)
                            for (var rel in target._embedded) {
                                check(!resource, 'Only one resource is expected in _embedded');
                                check(!resource, 'AlreadyExists', { item: 'embedded resource', resource: target });
                                resource = new Stack.Resource(target._embedded[rel]);
                                // don't rely that the embedded resource
                                // will have a proper rel attribute
                                resource.rel = resource.rel || rel;
                            }
                        var event_2 = {
                            resource: resource,
                            sender: { rel: sender.rel, href: sender.href },
                            target: target.link
                        };
                        for (var name_8 in target)
                            event_2[name_8] = target[name_8];
                        delete event_2['_embedded'];
                        delete event_2['link'];
                        events.push(new Stack.ResourceEvent(event_2));
                    }
                }
                return events;
            }
            Stack.EventCollection = EventCollection;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            var Event = Web.Utils.Event;
            var Property = Web.Utils.Property;
            var Exception = Web.Utils.Exception;
            var BoolProperty = Web.Utils.BoolProperty;
            /**
             * The event channel is a persistent channel with the server over which it
             * sends events to the client.
             *
             * An event says that something has been changed in a particular resource.
             * In UCWA there are 2 types of resources that are structurally identical, but
             * have slightly different semantics and different sets of associated events.
             *
             * A regular resource, such as a rel=contact or a rel=participant, has three
             * associated events:
             *
             *      An "added" event says that the resource has been created.
             *      If the event contains the "in" link, then the resource has been
             *      added to a collection indicated by that "in" link.
             *
             *      An "updated" event says that the resource state has been
             *      invalidated and the next time the client needs to get any of
             *      its properties or links the client should first fetch the new resource
             *      state via a GET. The event may contain the new resource
             *      state, so that the client wouldn't need to send an extra GET.
             *
             *      A "deleted" event says that the resource has been deleted.
             *      If the event contains the "in" link, then the resource has
             *      been deleted from a collection indicated by that "in" link
             *      and can still belong to another collection or live outside
             *      any collections.
             *
             * An operation resource, such as rel=messagingInvitation, tracks the progress
             * of some asynchronous operation. Operation resources are usually returned
             * in the Location header of 201 responses to some POST requests and then
             * UCWA sends three type of events to update state of these resources:
             *
             *      A "started" event says that the operation has been started.
             *      The operation resource usually has the `operationId` property
             *      defined by the client when it sent a POST request to start the
             *      operation. The server doesn't necessarily send the "started"
             *      event: for instance when notifying of incoming messages it sends
             *      a single "message completed" event.
             *
             *      An "updated" event says that the operation state has been
             *      invalidated. Normally, the "updated" event for operation resources
             *      contains these resources, so the client doesn't need to send an extra
             *      GET to learn the new operation state.
             *
             *      A "completed" event says that the operation has succeeded or failed.
             *      After that no other events regarding this operation are sent, so
             *      the client may delete the resource.
             *
             * It's worth mentioning that the described semantics of events is implemented
             * outside the Connection class: the purpose of Connection is to get events from the
             * server and redirect them to listeners.
             *
             * The Connection is built on top of Endpoint, because it needs to seamlessly
             * bypass the authentication and get responses from the server in the form of
             * resources, and it's not built  on top of Application, because it doesn't
             * need its capability to seamlessly update the repository with arriving
             * events.
             *
             */
            var EventChannel = (function () {
                function EventChannel(endpoint, suspended, tm) {
                    var self;
                    var eEvent = new Event();
                    var eError = new Event();
                    var pConnected = BoolProperty();
                    var pStatus = Property();
                    function connect(url, instanceId) {
                        var channelId = ++self.channelId;
                        function getEvent(url, instanceId, rel, src) {
                            if (rel && src) {
                                tm && tm.record(Web.TelemetryEvent.EventChannel, {
                                    action: rel,
                                    instance: instanceId,
                                    source: src,
                                    target: url
                                });
                            }
                            endpoint.ajax({
                                type: 'GET',
                                url: url,
                                instanceId: instanceId,
                                query: { timeout: self.timeout },
                                channel: channelId,
                                resend: self.timeout && self.timeout * 1.2,
                                priority: 10000
                            }).then(function (eventBatch) {
                                if (channelId != self.channelId)
                                    return;
                                if (eventBatch.hasLink('next'))
                                    // normally the server provides the "next" link
                                    // from which the next event can be received
                                    getEvent(eventBatch.link('next').href, instanceId);
                                else if (eventBatch.hasLink('resume'))
                                    // if the client disconnects and then reconnects to the
                                    // server, the latter will provide the "resume" link
                                    getEvent(eventBatch.link('resume').href, instanceId, 'resume', url);
                                else if (eventBatch.hasLink('resync'))
                                    // if the client tries to obtain events from an improper
                                    // URL, the server will send the "resync" link
                                    getEvent(eventBatch.link('resync').href, instanceId, 'resync', url);
                                else
                                    throw Exception('NextEventLinkMissing', { resource: eventBatch, debug: eventBatch.debug });
                                pConnected(true);
                                try {
                                    notifyListeners(eventBatch.properties['sender'], eventBatch.debug);
                                }
                                catch (error) {
                                    eError.fire(error);
                                }
                            }).catch(function (err) {
                                // errors on previous event channels can be ignored
                                if (channelId != self.channelId)
                                    return;
                                if (EventChannel.is409Error(err)) {
                                    // 409.PGetReplaced happens in two cases: (1) when the tab
                                    // is duplicated, the new tab gets a copy of sessionStorage
                                    // with rel=application and rel=events URLs, sends a p-GET
                                    // to the same URL and causes the previous tab to get the 409;
                                    // (2) when the tab is refreshed, which is same as case 1,
                                    // except that the previous tab is instantly closed. In both
                                    // cases there are two tabs competing for the same rel=events
                                    // and the tab that received the 409 must change the instance-id
                                    // once the user returns to that tab: this is same as suspending
                                    // the app on 404/410 and resuming it later.
                                    suspended(true, err);
                                }
                                else if (!Stack.Endpoint.is410Error(err)) {
                                    // After the 410.LimitExceeded response, the event channel
                                    // goes into a suspended state from which it can be recovered
                                    // by another call to connect(...).
                                    pConnected(false, err);
                                }
                            }).then(null, null, function (status) {
                                pStatus(status);
                            });
                        }
                        getEvent(url, instanceId);
                    }
                    function notifyListeners(sender, debug) {
                        var exists = {}, events = Stack.EventCollection(sender || []);
                        for (var _i = 0, events_1 = events; _i < events_1.length; _i++) {
                            var e = events_1[_i];
                            var hash = e + '';
                            // There was a version of UCWA that duplicated some events
                            // for the first signed in tab in the multitab scenario.
                            // That bug duplicated events in the same event batch.
                            if (!exists[hash]) {
                                exists[hash] = true;
                                if (debug && e)
                                    Object.defineProperty(e, 'debug', { value: debug });
                                eEvent.fire(e);
                            }
                        }
                    }
                    return self = {
                        channelId: 0,
                        timeout: undefined,
                        status: pStatus.asReadOnly(),
                        connect: connect,
                        connected: pConnected.asReadOnly(),
                        error: eError.observer,
                        event: eEvent.observer
                    };
                }
                return EventChannel;
            }());
            Stack.EventChannel = EventChannel;
            (function (EventChannel) {
                EventChannel.is409 = function (rsp) { return rsp
                    && rsp.status == 409
                    && rsp.data
                    && rsp.data.subcode == 'PGetReplaced'; };
                EventChannel.is409Error = function (err) { return err
                    && err.code == 'RequestFailed'
                    && EventChannel.is409(err.rsp); };
            })(EventChannel = Stack.EventChannel || (Stack.EventChannel = {}));
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var guid = Web.Utils.guid;
            var assert = Web.Utils.assert;
            var foreach = Web.Utils.foreach;
            var isVoid = Web.Utils.isVoid;
            var isString = Web.Utils.isString;
            var isDictionary = Web.Utils.isDictionary;
            var Http = Web.Utils.Http;
            var HttpHeaders = Web.Utils.HttpHeaders;
            function getRequestBody(request) {
                if (isVoid(request.data) || request.type == 'GET')
                    return '';
                if (isString(request.data))
                    return request.data + '';
                if (isDictionary(request.data))
                    return JSON.stringify(request.data);
                return request.data + '';
            }
            function getRequestHeaders(request) {
                var headers = HttpHeaders(request.headers);
                if (isDictionary(request.data))
                    headers.add('Content-Type', 'application/json');
                // the server requires this header to be present,
                // but does not seem to use it
                headers.add('Host', 'Host');
                return headers + '';
            }
            function getRequestUrl(request) {
                var query = '';
                if (request.type == 'GET') {
                    foreach(request.data || {}, function (value, name) {
                        query += (query ? '&' : '?') + name + '=' + value;
                    });
                }
                return request.url + query;
            }
            function serializeRequest(request) {
                var headers = getRequestHeaders(request);
                var body = getRequestBody(request);
                var url = getRequestUrl(request);
                return request.type + ' ' + url + ' HTTP/1.1\r\n' + headers + body;
            }
            function composeBatchRequestBody(requests, boundary) {
                var lines = [];
                for (var _i = 0, requests_1 = requests; _i < requests_1.length; _i++) {
                    var r = requests_1[_i];
                    var text = serializeRequest(r);
                    lines.push('--' + boundary);
                    lines.push('Content-Type: application/http; msgtype=request');
                    lines.push('');
                    lines.push(text);
                }
                return lines.join('\r\n') + '\r\n--' + boundary + '--\r\n';
            }
            function getMaxPriority(requests) {
                var priority;
                for (var _i = 0, requests_2 = requests; _i < requests_2.length; _i++) {
                    var r = requests_2[_i];
                    if (r.priority > priority || priority === undefined)
                        priority = r.priority;
                }
                return priority;
            }
            /**
             * This util function takes a string representing one response in a batch response
             * and splits it into the four parts: the outer headers, the http status line,
             * the inner headers, and the response body.
             *
             * @param block A part of the batch response that represents a single HTTP response:
             *
             *      Content-Type: application/http; msgtype=response\r\n
             *      \r\n
             *      HTTP/1.1 200 OK\r\n
             *      Cache-Control: no-cache\r\n
             *      Content-Type: application/json; charset=utf-8\r\n
             *      \r\n
             *      {"location":"Office"}\r\n
             */
            function split(block) {
                block = block.substring(2, block.length - 2);
                var i = block.indexOf('\r\n\r\n');
                var j = block.indexOf('\r\n', i + 4);
                var k = block.indexOf('\r\n\r\n', i + 4);
                assert(i > 0 && j > 0 && k > 0);
                return {
                    outer: block.substring(0, i),
                    status: block.substring(i + 4, j),
                    inner: block.substring(j + 2, k),
                    body: block.substring(k + 4)
                };
            }
            /**
             * The Batch is responsible for composing a single HTTP batch request
             * from several separate HTTP requests and for decomposing a HTTP batch
             * response into separate HTTP responses.
             *
             * Batch requests are sent to the "batch" UCWA resource, which is discussed
             * here: http://ucwa.lync.com/documentation/gettingstarted-batching
             *
             * @method compose - Composes a batch request.
             * @method parse - Parses a batch response.
             *
             */
            var Batch = (function () {
                function Batch(url) {
                    this.url = url;
                }
                Batch.prototype.compose = function (requests) {
                    var boundary = guid();
                    var body = composeBatchRequestBody(requests, boundary);
                    var priority = getMaxPriority(requests);
                    return {
                        type: 'POST',
                        priority: priority,
                        url: this.url,
                        data: body,
                        headers: {
                            'Content-Type': 'multipart/batching;boundary=' + boundary,
                            'Accept': 'multipart/batching'
                        }
                    };
                };
                Batch.prototype.parse = function (response) {
                    var headers = HttpHeaders(response.headers);
                    var boundary = headers.get('Content-Type').match(/boundary="(.*?)"/i)[1];
                    var blocks = response.responseText.split('--' + boundary);
                    assert(blocks.length > 2);
                    assert(blocks[blocks.length - 1] == '--\r\n');
                    var responses = [];
                    for (var _i = 0, _a = blocks.slice(+1, -1); _i < _a.length; _i++) {
                        var b = _a[_i];
                        try {
                            var parts = split(b);
                            var status_1 = +parts.status.match(/(\d{3})/)[1];
                            assert(status_1 >= 0);
                            responses.push({
                                status: status_1,
                                headers: HttpHeaders.parse(parts.inner),
                                responseText: parts.body
                            });
                        }
                        catch (error) {
                            responses.push({
                                status: 417 /* ExpectationFailed */,
                                headers: {},
                                responseText: error + ''
                            });
                        }
                    }
                    return responses;
                };
                return Batch;
            }());
            Stack.Batch = Batch;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var async = Web.Utils.async;
            var random = Web.Utils.random;
            var foreach = Web.Utils.foreach;
            var URI = Web.Utils.URI;
            var Task = Web.Utils.Task;
            var Property = Web.Utils.Property;
            var Exception = Web.Utils.Exception;
            var HttpHeaders = Web.Utils.HttpHeaders;
            var EOAuthFailed = Web.Auth.EOAuthFailed;
            function EMixedContent(url) {
                var text = 'Insecure resource at ' + url + ' cannot be loaded.';
                return Exception.call(text, 'MixedContent', { url: url });
            }
            /**
             * Wraps the cross-domain UCWA's <iframe> element.
             *
             * The implementation is so complicated because it needs to switch
             * between xframes on different domains without dropping requests
             * that have already been sent to the previous xframe. To handle that
             * this implementation creates a new iframe when it's asked to switch
             * to a new xframe and keeps the old xframe if there are pending requests
             * in it. Once an xframe has no pending requests and is not current,
             * it's removed.
             *
             */
            var XFrame = (function () {
                function XFrame(windowmock, tm, creds, hostProperty) {
                    var wnd = windowmock || Web.window;
                    var document = wnd.document;
                    var iframe; // the current <iframe> element
                    var iframes = {}; // iframes[iid] = an <iframe> element
                    var pending = {}; // pending[iid] = the number of pending requests for the iframe
                    var loaded = {}; // loaded[iid] = a task to track the progress of loading the iframe
                    var ready = {}; // ready[iid] = a task to track the progress of loading the xframe
                    var responses = {}; // responses[iid + ":" + rid] = Task<Response>
                    var pSrc = Property({
                        set: function (url) {
                            var uri = new URI(url);
                            // http: URLs are not allowed even if the parent
                            // page was loaded from a http: URL as it is the
                            // MS wide commitment for https: for end user
                            // communication; since all traffic goes thru the
                            // xframe, it's enough to block non-https URLs here
                            if (uri.scheme() != 'https')
                                throw EMixedContent(url);
                            // The src URL changes instantly because all further
                            // requests will be sent to the new URL.
                            pSrc._set(url);
                            // Never loading xframes are usually the OAuth ones:
                            // AAD doesn't return a proper 302 and JS waits forever.
                            var timer = tm && tm.timeout(5000, Web.TelemetryEvent.XFrameTimeout, {
                                url: url
                            });
                            // However the caller may track the progress of redirecting
                            // the xframe and get notified once the new xframe is loaded.
                            return async(redirect)(url).then(function () {
                                timer && timer.cancel();
                                return url;
                            });
                        }
                    });
                    function reset() {
                        var error = Exception('Reset');
                        function reject(task) {
                            try {
                                task.reject(error);
                            }
                            catch (err) {
                            }
                        }
                        foreach(loaded, reject);
                        foreach(ready, reject);
                        foreach(responses, reject);
                        foreach(iframes, removeElement);
                        // We need to clear iframe onload handler if it exists
                        // it may be triggered and inside try to resolve promise that is already rejected
                        if (iframe)
                            iframe.onload = null;
                        iframe = null;
                        pending = {};
                        loaded = {};
                        ready = {};
                        responses = {};
                    }
                    /**
                     * Changes the "src" attribute of the <iframe>.
                     *
                     * Under the hood, it actually replaces the old <iframe>
                     * with a new one and does this in such a way that all pending
                     * requests sent thru the previous iframe don't get terminated.
                     *
                     * The `src` attribute of an iframe cannot be changed to a URL
                     * on a different domain: the same origin policy prohibits this.
                     * If JS code tries to change `src` in such a way, the browser
                     * silently removes the iframe without throwing any exceptions,
                     * keeps all the HTTP sessions initiated by the iframe open, but
                     * closes corresponding XMLHttpRequest objects with status 0, to make
                     * an impression that sessions have been terminated.
                     *
                     * To handle this the client creates a new iframe and sends all
                     * further requests thru it once it's loaded. The old iframe gets
                     * removed once all requests that were sent thru complete.
                     */
                    function redirect(url) {
                        var iid = 'ucwa-' + random();
                        // `loaded` and `ready` are different because old xframes
                        // don't support the PING request; `loaded` gets resolved when
                        // the iframe gets something from the server and `ready`
                        // gets resolved when the iframe gets the actual UCWA's xframe
                        var tLoaded = new Task('iframe at ' + url);
                        var tReady = new Task('xframe at ' + url);
                        if (iframe && !pending[iframe.id])
                            remove(iframe.id);
                        iframe = document.createElement('iframe');
                        iframe.style.display = 'none';
                        iframe.title = (new Web.Date).toJSON();
                        iframe.src = url;
                        iframe.id = iid;
                        // this event can be fired multiple times the server sends
                        // intermediate redirects or does full page posts
                        iframe.onload = function () {
                            if (tLoaded) {
                                tLoaded.resolve();
                                tLoaded = null;
                            }
                            // in IE the iframe may have been partially unloaded
                            // if the entire page is being unloaded
                            if (this.contentWindow) {
                                post(this, {
                                    type: 'PING',
                                    url: '/'
                                });
                            }
                            else {
                                tReady.reject();
                            }
                        };
                        document.body.appendChild(iframe);
                        iframes[iid] = iframe;
                        pending[iid] = 0;
                        loaded[iid] = tLoaded;
                        ready[iid] = tReady;
                        return tReady.promise;
                    }
                    function send(request) {
                        var target = iframe;
                        if (!target)
                            throw Exception('NoTarget');
                        var id = target.id + ':' + random();
                        var task = new Task({
                            cancel: function (reason) {
                                cleanup(id);
                                task.reject(reason);
                            }
                        });
                        responses[id] = task;
                        pending[target.id]++;
                        // always add X-Ms-SDK-Host header if hostProperty is present
                        if (!request.headers)
                            request.headers = {};
                        if (!request.headers['X-Ms-SDK-Host'])
                            request.headers['X-Ms-SDK-Host'] = hostProperty;
                        loaded[target.id].promise.then(function () {
                            // the request id can be extracted from telemetry and used to find corresponding server logs
                            var status = request.type + ' ' + request.url;
                            var creqid = request.headers && request.headers['Client-Request-Id'];
                            if (creqid)
                                status += ' creqid:' + creqid;
                            task.status(status);
                            post(target, request, id);
                        }, null, task.status);
                        return task.promise;
                    }
                    function post(iframe, request, id) {
                        request.messageId = id || iframe.id + ':' + random();
                        iframe.contentWindow.postMessage(JSON.stringify(request), '*');
                    }
                    function cleanup(id) {
                        var iid = id.split(':')[0]; // iframe id
                        delete responses[id];
                        pending[iid]--;
                        if (iid != iframe.id && !pending[iid])
                            remove(iid);
                    }
                    function processMessage(message) {
                        try {
                            var data = JSON.parse(message.data);
                            var id = data.messageId;
                            var iid = id.split(':')[0]; // iframe id
                            var task = responses[id];
                            if (task) {
                                cleanup(id);
                                delete data.messageId;
                                data.headers = HttpHeaders.parse(data.headers || '');
                                task.resolve(data);
                            }
                            if (ready[iid]) {
                                // the OAuth2 redirect may end up with something like
                                // 302 Location: #error=login_required&error_description=...
                                if (data.oauth2 && data.oauth2.error) {
                                    ready[iid].reject(EOAuthFailed(pSrc(), data.oauth2));
                                }
                                else {
                                    // let the xframe know that this host is whitelisted: otherwise the first request
                                    // may be sent to Graph or ECWS and instead of a meaningful response will get a 500
                                    // from the xframe because it doesn't know that the host is whitelisted; it would be
                                    // more correct to delay resolving the `ready` task until this GET comes back as there
                                    // is a chance that the next request to UCWA comes back before the GET, but this also
                                    // introduces the possibility of this GET not coming back at all, thus blocking all requests
                                    var headers = data.headers || {};
                                    headers['Authorization'] = null;
                                    headers['X-Ms-SDK-Host'] = hostProperty;
                                    post(iframes[iid], {
                                        type: 'GET',
                                        url: '/ucwa/oauth',
                                        headers: headers
                                    });
                                    ready[iid].resolve();
                                }
                                ready[iid] = null;
                            }
                        }
                        catch (_) {
                            // an error indicates that this message
                            // was sent to someone else and thus should
                            // be ignored
                            return;
                        }
                    }
                    function removeElement(element) {
                        try {
                            document.body.removeChild(element);
                        }
                        catch (err) {
                        }
                    }
                    function remove(iid) {
                        removeElement(iframes[iid]);
                        delete iframes[iid];
                        delete pending[iid];
                        delete loaded[iid];
                        delete ready[iid];
                    }
                    // when the iframe gets a request for the server, sends it to the server
                    // and gets a response, it sends that response via the "postMessage"
                    // function of the "window" object, so the message arrives in the "onmessage"
                    // event for "window"
                    if (wnd.addEventListener)
                        wnd.addEventListener('message', processMessage);
                    else
                        wnd.attachEvent('onmessage', processMessage); // IE
                    return {
                        src: pSrc,
                        send: async(send),
                        reset: reset
                    };
                }
                return XFrame;
            }());
            Stack.XFrame = XFrame;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var URI = Web.Utils.URI;
            var Promise = Web.Utils.Promise;
            var Property = Web.Utils.Property;
            var HttpHeaders = Web.Utils.HttpHeaders;
            /**
             * Encapsulates XMLHttpRequest.
             *
             * The main purpose of this class is to make XHR
             * look like XFrame interface-wise, as other stack
             * components already use XFrame.
             *
             */
            var XHR = (function () {
                /** Must be XHR level 2 to support CORS. */
                function XHR(XHR, tm, creds, hostProperty) {
                    this.XHR = XHR;
                    this.tm = tm;
                    this.creds = creds;
                    this.hostProperty = hostProperty;
                    /** Requests without FQDN are sent to this server. */
                    this.src = Property();
                }
                /**
                 * This method exists for compatibility with XFrame:
                 * different stack layers have to invoke this method
                 * to cleanup resources associated with the <iframe>
                 * element. With XHR there is nothing to deallocate.
                 */
                XHR.prototype.reset = function () {
                };
                /**
                 * Usually URL of the request is relative to the current
                 * server's URL which the stack is talking to: this URL is
                 * kept in the `src` property. However the target URL can be
                 * absolute: XHR level 2 with CORS support will be used in
                 * such cases.
                 */
                XHR.prototype.send = function (request) {
                    var _this = this;
                    return new Promise(function (resolve, reject, progress) {
                        var uri = new URI(request.url);
                        if (!uri.host()) {
                            // sending a request via XHR to a relative URL results in a request
                            // to the parent frame, which is not the desired behavior in an SDK
                            if (!_this.src())
                                throw Error('The target FQDN must be set to send relative requests.');
                            var src = new URI(_this.src());
                            uri.scheme(src.scheme()).host(src.host()).port(src.port());
                            request.url = uri + '';
                        }
                        request.headers = request.headers || {};
                        if (!request.headers['X-Ms-SDK-Host'])
                            request.headers['X-Ms-SDK-Host'] = _this.hostProperty;
                        // the absence of this header is treated differently in different browsers:
                        // some may set */*, while others may set something like application/xml
                        if (!request.headers['Accept'])
                            request.headers['Accept'] = '*/*';
                        // MsRtcOAuth needs this format
                        if (request.data && typeof request.data != 'string') {
                            request.data = URI.Query(request.data) + '';
                            request.headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
                        }
                        // TODO: it's likely that this can be removed
                        if (request.type == 'GET' && request.data) {
                            // debugger;
                            request.url = /^[^#]*/.exec(request.url)[0]; // remove the fragment after #...
                            request.url += (request.url.indexOf('?') < 0 ? '?' : '&') + request.data;
                            delete request.data;
                        }
                        var xhr = new (_this.XHR || Web.XMLHttpRequest); // this.XHR is overriden by unit tests
                        xhr.open(request.type, request.url, true);
                        for (var i in request.headers)
                            xhr.setRequestHeader(i, request.headers[i] + '');
                        /* enable using of cookies and auth headers on requests and accepting cookies on responses, if the withCreds flag is not set and the creds option
                           is set on the reques. creds option will be set on the request iff it is a CORS and non-anon request */
                        if (_this.creds !== false)
                            xhr.withCredentials = request.creds;
                        xhr.onreadystatechange = function () {
                            if (xhr.readyState == 4 /* DONE */) {
                                if (!xhr.status && _this.tm)
                                    _this.tm.record(Web.TelemetryEvent.CorsFailed, { type: request.type, url: request.url, withCreds: request.creds });
                                resolve({
                                    // in some cases IE replaces 204 with 1223
                                    status: xhr.status == 1223 ? 204 : xhr.status,
                                    statusText: xhr.statusText,
                                    headers: HttpHeaders.parse(xhr.getAllResponseHeaders()),
                                    responseText: xhr.responseText
                                });
                            }
                        };
                        var cid = request.headers && request.headers['X-MS-Correlation-Id'];
                        var rid = request.headers && request.headers['Client-Request-Id'];
                        progress(request.type + ' ' + request.url + ' ' + cid + '/' + rid);
                        // in IE sending the undefined value results in sending a string "undefined"
                        xhr.send(request.data || null);
                    });
                };
                return XHR;
            }());
            Stack.XHR = XHR;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var sleep = Web.Utils.sleep;
            var throttle = Web.Utils.throttle;
            var removeAll = Web.Utils.removeAll;
            var repeatAndExit = Web.Utils.repeatAndExit;
            var Exception = Web.Utils.Exception;
            var HttpHeaders = Web.Utils.HttpHeaders;
            function ErrHandler(send, delay, status, filter) {
                return function (req) {
                    var next = delay();
                    return repeatAndExit(function (exit) {
                        return send(req).then(function (rsp) {
                            if (rsp.status != status || filter && !filter(rsp))
                                throw exit(rsp);
                            var dt = next(); // in seconds, but can be undefined
                            if (dt >= 0)
                                return sleep(dt);
                            throw exit(rsp);
                        });
                    });
                };
            }
            /**
             * Transport allows to send cross-domain requests to the UCWA server only.
             * The UCWA server provides an iframe for this purpose, so as a web app
             * registered on the server can use its iframe to send cross domain requests
             * to it.
             *
             *      var xframe = XFrame('mydomain.com');
             *      var transport = Transport(xframe);
             *      transport.ajax({type:'GET', url:'/my/request?q=123'}).then(function(response){
             *          alert('response arrived');
             *      });
             *
             */
            var Transport = (function () {
                function Transport(xframe, _a) {
                    var _b = _a === void 0 ? {} : _a, tm = _b.tm, buffer = _b.buffer, version = _b.version, session = _b.session, hostProperty = _b.hostProperty, fmax = _b.fmax, _c = _b.fmin, fmin = _c === void 0 ? Math.pow(2, -64) : _c, _d = _b.delay, delay = _d === void 0 ? [] : _d, retry = _b.retry, _e = _b.now, now = _e === void 0 ? function () { return Web.Date.now(); } : _e;
                    var send = new Web.Identity(function (req) { return xframe.send(req); }).map(function (send) {
                        return function (req) {
                            // This layer adds the "timeout" param to all requests:
                            // if it's set, it cancels the request if the response
                            // doesn't come within the given period. This is useful
                            // for optional requests that can be skipped.
                            var dfd = send(req);
                            var dt = req.timeout;
                            if (dt > 0) {
                                var id_3 = Web.setTimeout(function () {
                                    var err = Exception('RequestTimeout', {
                                        request: req
                                    });
                                    try {
                                        dfd.cancel(err);
                                    }
                                    catch (err) {
                                    }
                                }, dt * 1000 | 0);
                                dfd.finally(function () {
                                    Web.clearTimeout(id_3);
                                });
                            }
                            return dfd;
                        };
                    }).map(function (send) {
                        if (!fmax)
                            return send;
                        // This layer is supposed to throttle identical requests:
                        // this is a defensive measure against improperly written
                        // code that keeps resending the same request in a loop.
                        // Such frequent requests are detected and reported via telemetry.
                        //
                        // The frequency of a request is a positive number defined as follows.
                        // Let's say request A has been sent 3 times: t1, t2 and t2
                        // seconds ago respectively. The frequency of A at this moment
                        // will then be:
                        //
                        //  A(0) = 2 ** -t1 + 2 ** -t2 + 2 ** -t3
                        //
                        // where 0 refers to the current moment in time. In dt seconds
                        // the frequency of A will reduce to:
                        //
                        //  A(dt) = 2 ** -(t1 + dt) + 2 ** -(t2 + dt) + 2 ** -(t3 + dt)
                        //
                        // It can be noted, that A(dt) = A(0) * 2 ** -dt. Thus
                        // the frequency of A can be recomputed any time later
                        // without the need to keep all the timestamps when A
                        // was sent.
                        //
                        // It can be seen that if A is resent every dt seconds, its frequency
                        // will approach 1/(1 - 2 ** -dt), which is 2.0 if dt = 1 second:
                        //
                        //  A(0) = 1 + 2 ** -t + 2 ** -2*t + 2 ** -3*t + ... -> 1/(1 - 2 ** -t)
                        //
                        // As long as the frequency of a request doesn't exceed a certain
                        // threshold, it's sent without a delay. Once the threshold is
                        // exceeded, the request is delayed and resent only when A(0) = the threshold.
                        //
                        // TODO: Nothing prevents to change the threshold at runtime and keep
                        // a unique threshold value for each request.
                        var freq = {};
                        var log2 = function (x) { return Web.Math.log(x) / Web.Math.log(2); };
                        // when freq[...] was last updated
                        var updated = 0;
                        return function self(req) {
                            var ts = now();
                            var dt = (ts - updated) / 1000;
                            for (var id_4 in freq)
                                freq[id_4] /= Math.pow(2, dt);
                            // it seems right to constrain the growth of freq[...]
                            // and a reasonable way to do so is to remove requests
                            // that were sent long long ago and thus are unlikely
                            // to affect the total frequency value
                            removeAll(freq, function (fq) { return fq < fmin; });
                            updated = ts;
                            var id = req.type + ' ' + req.url;
                            var fq = freq[id] || 0;
                            // the request has been sent a few times in past and thus
                            // its current frequency at the moment is fq; sending the
                            // request again would change the frequency to fq + 2 ** 0
                            // and it must be lower than the threshold fmax; if it exceeds
                            // fmax, then the request can be delayed by a short period dt;
                            // after the delay, the frequency will be fq / 2 ** dt + 1 = fmax,
                            // which implies that dt = log2(fq / (fmax - 1))
                            if (fq + 1 > fmax) {
                                var dt_1 = log2(fq / (fmax - 1));
                                // the actual delay is always a bit longer than dt and hence
                                // after the delay the frequency will be a bit less than fmax
                                return sleep(dt_1).then(function () { return self(req); });
                            }
                            else {
                                freq[id] = fq + 1;
                                return send(req);
                            }
                        };
                    }).map(function (send) {
                        // these two headers are useful for debugging
                        return function (req) {
                            req.headers = req.headers || {};
                            if (version)
                                req.headers['X-Ms-SDK-Version'] = version;
                            if (session)
                                req.headers['X-Ms-SDK-Session'] = session;
                            return send(req);
                        };
                    }).map(function (send) {
                        if (!buffer)
                            return send;
                        // this stack layer throttles requests and browsers
                        // do not like when there are too many pending requests;
                        // throttling is disabled only in some unit tests
                        var throttled = throttle(send, buffer);
                        return function (request) { return throttled(request, request.priority); };
                    }).map(function (send) {
                        // if the laptop's lid is closed and reopened, xhr
                        // will terminate all requests with status = 0;
                        // such requests need to be sent again
                        return !delay[0] ? send : ErrHandler(send, delay[0], 0);
                    }).map(function (send) {
                        // If a 404 is coming not from UCWA (the Content-Type check),
                        // it's likely that the pool is down. The suggestion from the
                        // server team is to retry with exp back-off.
                        return !delay[404] ? send : ErrHandler(send, delay[404], 404, function (r) {
                            var h = r.headers || {};
                            return !/^application\/.+/.test(h['Content-Type']) && (h['Server'] || h['X-Ms-Server-Fqdn']);
                        });
                    }).map(function (send) {
                        // If the server is unreachable for some reason, we'll be getting
                        // 502 responses. This often happens when moving from WiFi network
                        // to another.
                        // If the server is unreachable with Content-Type other than
                        // 'application/json' or 'application/xml', it indicates the
                        // HADR scenario where retrying is unlikely going to work.
                        // Currently handling is to return the error to let event
                        // channel close, causing ucwa to disconnect and application
                        // to sign out. The UI should subscribe to the application
                        // status and notify the user to re-login later.
                        //
                        // TODO: restart auto discovery without signing out.
                        return !delay[502] ? send : ErrHandler(send, delay[502], 502, function (rsp) {
                            return !rsp.headers || /^application\/.*(json|xml)/.test(HttpHeaders(rsp.headers).get('Content-Type'));
                        });
                    }).map(function (send) {
                        // A 503 service unavailable indicates that there is some maintenance activity
                        // in the data center, and the application should retry with an exponential back off.
                        // After about 10 minutes of receiving 503 responses, the application should quit
                        // retrying and start the sign in process from the beginning (using auto discovery).
                        // If the application receives another response before the retry algorithm abandons
                        // the retries, such as 404.ApplicationNotFound, it should process this response as
                        // it usually would.
                        return !delay[503] ? send : ErrHandler(send, delay[503], 503);
                    }).map(function (send) {
                        // 483 TooManyHops happens during UD-by-UD pool upgrade. UserPinService cache is valid for 5 minutes.
                        // Additional latency from Windows Fabric while it tries to change primary replica owner for a routing group.
                        //
                        // - FES03 proxies request to FES01 (because it thinks user is homed on FES01)
                        // - FES01 proxies it back to FES03 (because it thinks user is homed on FES03)
                        // - Eventually returns a failure "too many hops"
                        //
                        if (retry && retry[483] === null)
                            return send;
                        return ErrHandler(send, function () {
                            var t = 1, n = 3, max = 15 * 60, started = Web.Date.now();
                            return function () {
                                // exponential back off with the 15 mins upper
                                // limit and a stop after 3 full retry cycles
                                t *= 1.5;
                                if (t >= max) {
                                    t = max;
                                    n--;
                                    if (n < 1)
                                        throw Exception('Recurring483', { duration: Web.Date.now() - started });
                                }
                                return t;
                            };
                        }, 483);
                    }).map(function (send) {
                        // Some of the retry logic can be set in ECS.
                        if (!retry)
                            return send;
                        var dfn = function (delays) { return function () {
                            var i = 0;
                            // once undefined is returned, the err handler stops retrying
                            return function () { return delays[i++]; };
                        }; };
                        for (var status_2 in retry) {
                            var delays = retry[status_2];
                            send = ErrHandler(send, dfn(delays), status_2);
                        }
                        return send;
                    }).value;
                    return {
                        ajax: send
                    };
                }
                return Transport;
            }());
            Stack.Transport = Transport;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var map = Web.Utils.map;
            var async = Web.Utils.async;
            var repeatAndExit = Web.Utils.repeatAndExit;
            var Task = Web.Utils.Task;
            var Exception = Web.Utils.Exception;
            function EDiscoveryFailed(root, response, error) {
                var text = 'UCWA not found on ' + root;
                return Exception.call(text, 'DiscoveryFailed', { response: response, root: root, reason: error });
            }
            /**
             * Discovers the UCWA service URL.
             *
             * An instance of this class takes a domain name and
             * discovers the UCWA server. The result of the discovery is
             * the "root" resource received from the server and the "root"
             * resource has a link to the "user" resource from which the
             * authentication starts and from which the client gets links to
             * all other resources.
             *
             * @param {XFrame} xframe - The auto-discovery process updates the source of the xframe.
             * @param {string} [domain] - The domain name, e.g. "contoso.com"
             * @param {Array} [origins] - Autodiscover URLs.
             * @param {Function} [XFrame] - Constructor of XFrame. Used by unit tests.
             * @param {Function} [Transport] - Constructor of Transport. Used by unit tests.
             *
             * @member {Promise<Resource>} root - The "root" resource with a link to the "user" resource.
             *
             */
            function AutoDiscovery(options) {
                var domain = options.domain;
                var origins = options.origins;
                var TransportCtor = options.Transport || Stack.Transport;
                var XFrameCtor = options.XFrame || Stack.XFrame;
                var xframe = options.xframe;
                var hostProperty = options.hostProperty;
                function discoverRoot(options) {
                    var internal = options.internal;
                    var xframeUrl = options.xframe;
                    var originUrl = options.origin;
                    var xframe = new XFrameCtor(undefined, undefined, undefined, hostProperty);
                    // always add X-Ms-SDK-Host: hostProperty if it exists
                    var transport = new TransportCtor(xframe, { hostProperty: hostProperty });
                    xframe.src(xframeUrl);
                    // send a GET request to the current discovery URL,
                    // such as https://lyncdiscover.contoso.com
                    return transport.ajax({
                        type: 'GET',
                        url: originUrl
                    }).then(function (response) {
                        var root;
                        try {
                            // extract the response text and parse it:
                            // it's supposed to be a valid UCWA resource
                            root = new Stack.Resource(JSON.parse(response.responseText));
                        }
                        catch (err) {
                            throw EDiscoveryFailed(originUrl, response, err);
                        }
                        return repeatAndExit(function (exit) {
                            // GET webdir.online.lync.com/.../?sipuri=... doesn't return rel=user.
                            // Instead it gives a rel=redirect which is the rel=root for the given SIP URI.
                            if (!root.hasLink('redirect'))
                                return exit();
                            xframe.src(root.link('xframe').href);
                            return transport.ajax({
                                type: 'GET',
                                url: root.link('redirect').href
                            }).then(function (response) {
                                try {
                                    root = new Stack.Resource(JSON.parse(response.responseText));
                                }
                                catch (err) {
                                    throw EDiscoveryFailed(originUrl, response, err);
                                }
                            });
                        }).then(function () {
                            // the UCWA server doesn't always specify the rel for the root resource
                            root.rel = root.rel || 'root';
                            root.set('internal', internal);
                            // the UCWA server may provide a new URL of the iframe
                            if (root.hasLink('xframe'))
                                xframe.src(root.link('xframe').href);
                            else
                                root.addLink('xframe', xframe.src());
                            return root;
                        });
                    }).finally(function () {
                        // remove the xframe no matter whether the discovery succeeded or not:
                        // the caller of this function will create another xframe based on what
                        // this function returned
                        xframe.reset();
                    });
                }
                function discoverUcwa() {
                    // http://ucwa.lync.com/documentation/GettingStarted-RootURL
                    if (!origins) {
                        origins = [];
                        origins.push({
                            internal: true,
                            origin: 'https://lyncdiscoverinternal.' + domain,
                            xframe: 'https://lyncdiscoverinternal.' + domain + '/xframe'
                        });
                        origins.push({
                            internal: false,
                            origin: 'https://lyncdiscover.' + domain,
                            xframe: 'https://lyncdiscover.' + domain + '/xframe'
                        });
                        origins.push({
                            internal: true,
                            origin: 'http://lyncdiscoverinternal.' + domain,
                            xframe: 'http://lyncdiscoverinternal.' + domain + '/xframe'
                        });
                        origins.push({
                            internal: false,
                            origin: 'http://lyncdiscover.' + domain,
                            xframe: 'http://lyncdiscover.' + domain + '/xframe'
                        });
                    }
                    // try all auto-discovery URLs concurrently and if one
                    // succeeds, stop trying all other pending URLs
                    return Task.waitAny(map(origins, async(discoverRoot)));
                }
                return {
                    root: discoverUcwa().then(function (root) {
                        // The current implementation of concurrent autodiscovery
                        // creates a separate xframe for every auto-discovery URL
                        // and tries to get the rel=root resource. After one of
                        // xframes finds the rel=root, all xframes are removed and a
                        // completely separate xframe is directed to the found URL.
                        // This behavior is somewhat suboptimal and it would be better
                        // to change the interface of the auto-discovery class and
                        // make it return a pair [xframe, root] to avoid recreating
                        // an already existing xframe. But changing the interface would
                        // require to change all the stack-level samples and since I'm
                        // going to wrap all the stack layer into a UCWA class anyway,
                        // I'm postponing the change of the auto-discovery interface
                        // until that moment. But anyway, the auto-discovery time is
                        // reduced dramatically even with this suboptimal implementation.
                        xframe.src(root.link('xframe').href);
                        return root;
                    })
                };
            }
            Stack.AutoDiscovery = AutoDiscovery;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var HttpHeaders = Web.Utils.HttpHeaders;
            /**
             * Converts a multi part representation of resources into an array of resources.
             *
             * UCWA may return an HTTP response of the multipart/related type with parts
             * in the response text. Some parts contain JSON serialized resources,
             * while other parts contain data with Content-ID and Content-Type headers.
             * Resources may have links of form "cid:ABC" where "ABC" is the value of one of
             * Content-ID headers in the multipart response.
             *
             * This function parses those parts that represent resources, then checks every link
             * in these resources and if that link is something like "cid:ABC" the function looks for
             * a part with Content-ID:ABC and if such a part exists, it replaces the link with
             * a data URI that containing the found part. For example, if there was
             * a link of the following form:
             *
             *      "_links": {
             *          "mediaAnswer":{"href":"cid:0fced42f-b345-4294-95f0-9fc2f7882ade"}
             *      }
             *
             * and if there was a corresponding part:
             *
             *      Content-Type: application/sdp; charset=utf-8
             *      Content-ID: 0fced42f-b345-4294-95f0-9fc2f7882ade
             *
             *      v=0
             *      s=session
             *
             * the link will be converted to a data URI:
             *
             *      "_links": {
             *          "mediaAnswer":{"href":"data:application/sdp;charset=utf-8,v=0\r\ns=session"}
             *      }
             *
             * which can be parsed with the DataUri class.
             */
            function parseMultipartResources(/** from parseMultipartRelatedResponse */ parts) {
                var resources = [];
                var contents = {};
                for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
                    var part = parts_1[_i];
                    var content = part.responseText;
                    var headers = HttpHeaders(part.headers);
                    var contentId = headers.get('Content-ID');
                    var contentType = headers.get('Content-Type');
                    if (!contentId)
                        resources.push(new Stack.Resource(JSON.parse(content)));
                    else {
                        contents['cid:' + contentId] = {
                            data: content,
                            mime: contentType.replace(/\s/g, '')
                        };
                    }
                }
                for (var _a = 0, resources_2 = resources; _a < resources_2.length; _a++) {
                    var resource = resources_2[_a];
                    resource.forEachLink(function (link) {
                        var content = contents[link.href];
                        if (content)
                            link.href = 'data:' + content.mime + ',' + content.data;
                    });
                }
                return resources;
            }
            Stack.parseMultipartResources = parseMultipartResources;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var check = Web.Utils.check;
            var Exception = Web.Utils.Exception;
            var HttpHeaders = Web.Utils.HttpHeaders;
            var ContentTypeHeader = Web.Utils.ContentTypeHeader;
            var rxCRLF2 = /(\r\n|\n){2}/;
            var rxCRLFL = /^(\r\n|\n)/;
            var rxCRLFR = /(\r\n|\n)$/;
            var rxEnding = /--\s*$/;
            /**
             * Parses a multipart/related response that has the following form:
             *
             *      HTTP/1.1 200 OK
             *      Content-Type: multipart/related; charset=utf-8; boundary=e6c28643-44ea-45c8-b62e-6a56bd22b3aa
             *
             *      --e6c28643-44ea-45c8-b62e-6a56bd22b3aa
             *      Content-Type: application/vnd.microsoft.com.ucwa+json; charset=utf-8
             *
             *      {"_links":{"self":{"href":"/ucwa/v1/applications/111415042852/events?ack=4"},"next...
             *      --e6c28643-44ea-45c8-b62e-6a56bd22b3aa
             *      Content-Type: application/sdp; charset=utf-8
             *      Content-ID: 0fced42f-b345-4294-95f0-9fc2f7882ade
             *
             *      v=0...
             *      --e6c28643-44ea-45c8-b62e-6a56bd22b3aa--
             */
            function parseMultipartRelatedResponse(response) {
                try {
                    var contentType = ContentTypeHeader(HttpHeaders(response.headers).get('Content-Type'));
                    check.equals(contentType.mimeType, 'multipart/related');
                    check.belongs('boundary', contentType.attributes);
                    var parts = response.responseText.split('--' + contentType.attributes['boundary']);
                    check(rxEnding.test(parts[parts.length - 1]));
                    check(parts.length >= 3);
                    return parts.slice(+1, -1).map(function (part, index) {
                        var crlf2 = rxCRLF2.exec(part);
                        if (!crlf2)
                            throw Exception('SingleHeaderExpected', { part: part, index: index });
                        var headers = part.substr(0, crlf2.index);
                        var content = part.substr(crlf2.index + crlf2[0].length);
                        return {
                            headers: headers.replace(rxCRLFL, ''),
                            responseText: content.replace(rxCRLFR, '')
                        };
                    });
                }
                catch (error) {
                    throw Exception('InvalidMultipartRelatedResponse', { response: response, reason: error });
                }
            }
            Stack.parseMultipartRelatedResponse = parseMultipartRelatedResponse;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var keys = Web.Utils.keys;
            var check = Web.Utils.check;
            var filter = Web.Utils.filter;
            var values = Web.Utils.values;
            var isObject = Web.Utils.isObject;
            /**
             * Parses the "application/vnd.microsoft.rtc.autodiscover+json;v=1" format
             * of the resource object. This format is used in a special auto-discovery
             * flow. An example of such a resource:
             *
             *      {
             *          "User": {
             *              "Links": [
             *                  { "href": "http://webdir1D.tip.lync.com/.../root", "token": "Redirect" },
             *                  { "href": "https://webdir0d.tip.lync.com/.../root/user", "token": "Self" },
             *                  { "href": "http://webdir1D.tip.lync.com/.../root/xframe", "token": "XFrame" }],
             *              "SipClientExternalAccess": null,
             *              "SipClientInternalAccess": null,
             *              "SipServerExternalAccess": null,
             *              "SipServerInternalAccess": null
             *          }
             *      }
             *
             * The Resource object created from this sample input will have rel=user
             * and will have links rel=redirect and rel=xframe. Rels are lowercased.
             */
            function parseAutodiscoverResource(json) {
                var roots = filter(json, isObject);
                check(values(roots).length == 1, 'single root expected');
                var rel = keys(roots)[0];
                var root = roots[rel];
                var selfs = filter(root.Links, function (link) { return link.token == 'Self'; });
                check(selfs.length == 1, 'single self href expected');
                var href = selfs[0].href;
                var res = new Stack.Resource(href, rel.toLowerCase());
                for (var _i = 0, _a = root.Links; _i < _a.length; _i++) {
                    var link = _a[_i];
                    if (link.href != href)
                        res.addLink(link.token.toLowerCase(), link.href);
                }
                return res;
            }
            Stack.parseAutodiscoverResource = parseAutodiscoverResource;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="parsers/multipart.ts" />
/// <reference path="parsers/multipart-related.ts" />
/// <reference path="parsers/autodiscover.ts" />
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var map = Web.Utils.map;
            var bind = Web.Utils.bind;
            var guid = Web.Utils.guid;
            var pick = Web.Utils.pick;
            var async = Web.Utils.async;
            var clone = Web.Utils.clone;
            var sleep = Web.Utils.sleep;
            var assert = Web.Utils.assert;
            var foreach = Web.Utils.foreach;
            var isObject = Web.Utils.isObject;
            var isString = Web.Utils.isString;
            var debounced = Web.Utils.debounced;
            var getOption = Web.Utils.getOption;
            var obscureAuthHeader = Web.Utils.obscureAuthHeader;
            var URI = Web.Utils.URI;
            var Http = Web.Utils.Http;
            var Task = Web.Utils.Task;
            var Event = Web.Utils.Event;
            var Property = Web.Utils.Property;
            var Exception = Web.Utils.Exception;
            var HttpHeaders = Web.Utils.HttpHeaders;
            function ERequestFailed(req, rsp) {
                var text = req.type + ' ' + req.url + ' failed: ' + (rsp.statusText || rsp.status);
                if (req) {
                    req = clone(req);
                    delete req.data; // may contain PII, such as user input
                    req = obscureAuthHeader(req);
                }
                return Exception.call(text, 'RequestFailed', { req: req, rsp: rsp });
            }
            Stack.ERequestFailed = ERequestFailed;
            /**
             * Endpoint exposes the "ajax" function that behaves like jQuery.ajax
             * and allows to send JSON requests to the UCWA server seamlessly passing
             * thru the authorization - Endpoint obtains the auth token.
             *
             */
            var Endpoint = (function () {
                function Endpoint(args) {
                    var renewed = new Event;
                    var transport = args.transport;
                    var batchRetryDelay = args.batchRetryDelay || 3.0;
                    var authorize = async(args.auth);
                    var restore = args.restore && debounced(args.restore);
                    var replace = args.replace && debounced(args.replace);
                    var enableInternalNS = getOption(args, 'enableInternalNS', true);
                    var tm = args.tm;
                    var user = args.user;
                    var anon = args.anon;
                    var lastActivityTimestamp = Web.Date.now();
                    user && user.isActive.changed(function () { return lastActivityTimestamp = Web.Date.now(); });
                    //#region suspend/resume
                    var resuming = false; // tells if POST /applications and GET /events are in progress
                    var resumed; // if present, all requests must wait for this
                    var tResumed; // the source of `resumed`
                    var suspended = Property({
                        value: false,
                        set: function (value, reason) {
                            if (value) {
                                tm && tm.record(Web.TelemetryEvent.EndpointSuspend, { reason: reason });
                                assert(!resumed); // the 410 response is suspending the stack
                                tResumed = new Task(reason + '');
                                resumed = tResumed.promise;
                                resumed.finally(function () {
                                    resumed = null;
                                    tResumed = null;
                                });
                                return true;
                            }
                            else {
                                tm && tm.record(Web.TelemetryEvent.EndpointResume, { reason: reason });
                                assert(resumed); // the user activity is resuming the stack
                                resumed = null; // no need to queue requests as the app is being resumed
                                resuming = true;
                                return tResumed.from(replace()).then(function () {
                                    resuming = false;
                                    return false;
                                });
                            }
                        }
                    });
                    //#endregion
                    /**
                     * Tests for user inactivity and suspends if required.
                     * if inactivityTimeout == -1, user is anon signed in, active or recently active
                     * the regular flow of resurrecting the app kicks in.
                     */
                    var restoreWhenUserRecentlyActive = debounced(function () {
                        var inactiveDuration = Web.Date.now() - lastActivityTimestamp;
                        if (anon || user && user.isActive() || user && inactiveDuration < user.inactivityTimeout || user && user.inactivityTimeout == -1)
                            return restore();
                        var suspensionId = guid();
                        suspended(true, Exception('UserInactive', {
                            inactiveDuration: inactiveDuration,
                            inactivityTimeout: user && user.inactivityTimeout,
                            suspensionId: suspensionId
                        }));
                        return resumed.then(function () {
                            tm && tm.record(Web.TelemetryEvent.Endpoint, {
                                action: 'restore',
                                reason: 'useractive',
                                suspensionId: suspensionId
                            });
                        });
                    });
                    //#region batch
                    /**
                     * Sends a batch request and parses the batch response.
                     *
                     * Under the hood it modifies each request, composes them
                     * into a single batch request, adds the authorization header
                     * to it and sends to the batch URL. When the batch response
                     * arrives, it decomposes it into separate responses, parses them
                     * and resolves the returned promise object with the array
                     * of responses.
                     *
                     * @param {Batch} composer - The composer of the batch requests.
                     * @param requests - The array of requests.
                     *
                     * @returns {Promise<Promise<Resource & { debug: any }>[]>}
                     *
                     *      The function returns a promise that resolves to an array of
                     *      promises. Each of these promises resolve to a resource.
                     */
                    function batch(composer, requests) {
                        foreach(requests, prepare);
                        var batchreq = composer.compose(requests);
                        return sendBatch(batchreq).then(function (batchrsp) {
                            // Batch requests often fail with HTTP 429 Too Many Requests
                            // and if this happens, resend the request in a few seconds.
                            // The batch request must be sent eventually, as it may contain
                            // requests that are crucial for normal operating of the web app,
                            // such as a POST .../makeMeAvailable request.
                            if (batchrsp.status == 429 /* TooManyRequests */) {
                                return sleep(batchRetryDelay).then(function () {
                                    return batch(composer, requests);
                                });
                            }
                            if (!Http.isSuccess(batchrsp.status))
                                throw ERequestFailed(batchreq, batchrsp);
                            return decompose(composer, requests, batchrsp);
                        });
                    }
                    //#endregion
                    //#region decompose
                    /**
                     * Decomposes a batch response into separate responses and
                     * parses them.
                     */
                    function decompose(composer, requests, batchrsp) {
                        var responses = composer.parse(batchrsp);
                        assert(requests.length == responses.length);
                        return map(requests, async(function (request, i) {
                            return process(requests[i], responses[i]);
                        }));
                    }
                    //#endregion
                    //#region prepare
                    function prepare(request) {
                        request.url = URI.mergeQuery(request.url, request.query);
                        if (!request.headers)
                            request.headers = {};
                        // the UCWA server always returns JSON
                        // except when it replies for the batch request
                        request.headers['Accept'] = 'application/json';
                        // TODO: the requested version is supported only if _links.self.revision
                        // is greater than or equal to it or the requested version is 1; at this
                        // point it's too late to check the revision, but somewhere above in the
                        // stack it should be possible
                        if (request.version > 1)
                            request.headers['X-MS-RequiresMinResourceVersion'] = request.version;
                        // specify the Content-Type header
                        if (isString(request.data)) {
                            // if plain text is sent and the content type is not set, assume "text/plain"
                            request.headers['Content-Type'] = request.headers['Content-Type'] || 'text/plain';
                        }
                        else if (isObject(request.data)) {
                            // for POST requests put the data into the body in the JSON format;
                            // for GET requests let jQuery put the data into the query string in the URL
                            if (request.type == 'POST' || request.type == 'PUT') {
                                if (request.type == 'PUT')
                                    request.headers['If-Match'] = '"' + request.data.etag + '"';
                                // if an object is sent, assume that this is a "application/json"
                                request.data = JSON.stringify(request.data);
                                request.headers['Content-Type'] = 'application/json';
                            }
                        }
                    }
                    //#endregion
                    function parseResponse(rsp) {
                        try {
                            // all responses from UCWA are in the JSON format
                            rsp.data = JSON.parse(rsp.responseText);
                        }
                        catch (_) {
                        }
                    }
                    //#region process
                    /**
                     * Handles a response for a request sent by "ajax".
                     *
                     * The response may be a "HTTP 401 Unauthorized" challenge, so
                     * the endpoint must seamlessly obtain an auth token from the server
                     * and send the same request with the auth token.
                     */
                    function process(request, response) {
                        assert(response);
                        var parsed, result, headers = HttpHeaders(response.headers);
                        parseResponse(response);
                        if (!Http.isSuccess(response.status)) {
                            // if the status code doesn't indicate the success,
                            // don't even try to parse the response text
                            throw ERequestFailed(request, response);
                        }
                        else if (!response.responseText) {
                            // in most cases the server responds with a resource,
                            // however when the client sends a POST request to the sendMessage
                            // resource, the server replies with "HTTP 201 Created" and with
                            // empty response body, but with the Location HTTP header that contains
                            // the href of the created message
                            return new Stack.Resource(headers.get('Location'), null);
                        }
                        else {
                            // if the UCWA server sends a successful response,
                            // its contents are expected to be a JSON string and
                            // the JSON string must represent a Resource
                            try {
                                parsed = response.data;
                                // TODO: What if the server returns the same mime type but with a different version, e.g. v=1.1?
                                result = headers.get('Content-Type') == 'application/vnd.microsoft.rtc.autodiscover+json; v=1' ?
                                    Stack.parseAutodiscoverResource(parsed) :
                                    new Stack.Resource(parsed);
                            }
                            catch (_) {
                                // If the response is not a regular resource,
                                // maybe it is a multipart resource?
                                parsed = Stack.parseMultipartRelatedResponse(response);
                                result = Stack.parseMultipartResources(parsed)[0];
                            }
                            Object.defineProperty(result, 'debug', {
                                value: {
                                    rsp: response && pick(response, ['status', 'statusText', 'headers'])
                                }
                            });
                            // Endpoint provides server responses as resources
                            return result;
                        }
                    }
                    //#endregion
                    //#region send
                    // batch requests are sent thru this layer
                    var sendBatch = new Web.Identity(async(transport.ajax)).map(function (send) {
                        return function (req) {
                            req.headers = req.headers || {};
                            if (enableInternalNS)
                                req.headers['X-Ms-Namespace'] = 'internal';
                            var corrid = (Web.Math.random() * 0x80000000 | 0) + '';
                            // It must be in the uint32 format: the webinfra is coded up this way.
                            // Later we may want to introduce some structure of the id, i.e. first
                            // few bits are the session id, next few bits are the request id and so on.                    
                            // Note, that there are cases when the webinfra drops the header by mistake.
                            req.headers['X-MS-Correlation-Id'] = corrid;
                            // This header can contain anything.
                            req.headers['Client-Request-Id'] = 'WebSDK/' + corrid;
                            return send(req);
                        };
                    }).map(function (send) {
                        // this layer adds seamless authorization:
                        // if the server requires authorization, the endpoint
                        // seamlessly obtains an auth token and resends the request
                        // again with the token
                        return function (req) {
                            return authorize(req, send).then(function (rsp) {
                                if (rsp['webTicketRenewed'])
                                    renewed.fire(req, rsp);
                                return rsp;
                            });
                        };
                    }).map(function (send) {
                        // this layer parses .responseText if it's in the JSON format
                        return function (req) {
                            return send(req).then(function (rsp) {
                                parseResponse(rsp);
                                return rsp;
                            });
                        };
                    }).map(function (send) {
                        // telemetry layer
                        if (!tm)
                            return send;
                        return function (req) {
                            return send(req).then(function (rsp) {
                                // in the anon p2p case the URL looks like /ucwa/anon/v1/applications
                                if (req.type == 'POST' && /\/applications$/.test(req.url))
                                    tm && tm.record(Web.TelemetryEvent.CreateApplicationCompleted, {
                                        status: rsp.status,
                                        reason: {
                                            rsp: rsp && pick(rsp, ['status', 'statusText', 'headers', 'data.endpointId', 'data.id', 'data.type', 'data._links.events.href'])
                                        }
                                    });
                                return rsp;
                            });
                        };
                    }).map(function (send) {
                        // this layer adds resiliency to the 404.ApplicationNotFound error
                        // that occurs whenever a UCWA instance crashes and gets recreated
                        // on another server machine
                        return function sendWhenResumed(req) {
                            return resumed ?
                                // if the tab has been suspended, all requests must be
                                // queued even if they aren't instanceId-specific
                                resumed.then(function () { return sendWhenResumed(req); }) :
                                send(req).then(function (rsp) {
                                    if (!Endpoint.is404(rsp))
                                        return rsp;
                                    // if there is a p-GET for the previous instance-id and we're sending a POST /applications
                                    // with a new instance-id, that p-GET will be dropped with a 404.ApplicationNotFound, however
                                    // that 404 needs to be ignored because the POST is followed by another p-GET with the new instance-id
                                    if (resuming && req.instanceId)
                                        return rsp;
                                    tm && tm.record('apps_404', { reason: { req: req, rsp: rsp } });
                                    // whenever this error occurs, it sends a POST to restore the app,
                                    // waits for the POST and then resends the request; if the request
                                    // fails again, it doesn't try to repeat the steps as it's likely
                                    // that the app has been permanently deleted
                                    return restoreWhenUserRecentlyActive().then(function (res) {
                                        // if it was GET /events that caused the 404, don't resend it
                                        // as it may cause the proper p-GET end with a 409 and sign
                                        // the app out
                                        if (req.instanceId && req.channel)
                                            return rsp;
                                        return send(req);
                                    }, function (err) {
                                        // In the multitab scenario UCWA may kick out a tab:
                                        //
                                        //      GET /events?ack=4&key=1
                                        //      404 subcode=ApplicationNotFound
                                        //      POST /applications (same instanceId)
                                        //      410 subcode=LimitExceeded
                                        //
                                        // If this happens, the SDK can restore the session by
                                        // POST /applications with a different instanceId.
                                        if (!Endpoint.is410Error(err))
                                            throw err;
                                        suspended(true, err);
                                        if (req.instanceId)
                                            throw err;
                                        return sendWhenResumed(req);
                                    });
                                });
                        };
                    }).value;
                    var send = new Web.Identity(sendBatch).map(function (send) {
                        // This layer sends JSON requests: it serializes args.data
                        // into a JSON string and sends it with "Content-Type: application/json"
                        // The response is always a Resource: this method parses the
                        // JSON string returned by the server and turns it into a Resource.
                        return function (req) {
                            prepare(req);
                            return send(req).then(bind(process, req));
                        };
                    }).map(function (send) {
                        // This layer resends a request if a response to it doesn't come back on time.
                        return function (req) {
                            var dfd = send(req);
                            if (!req.resend)
                                return dfd;
                            // Another approach would be to use Promise.race, but that has its own drawbacks.
                            var task = new Task();
                            var resent = false;
                            var timer = Web.setTimeout(function () {
                                resent = true;
                                req = clone(req);
                                req['resent'] = 1; // this is for telemetry
                                send(req).then(function (r) { return task.resolve(r); }, function (e) { return task.reject(e); }, function (s) { return task.status(s); });
                            }, req.resend * 1000 | 0);
                            dfd.finally(function () { return Web.clearTimeout(timer); }).then(function (r) { return !resent && task.resolve(r); }, function (e) { return !resent && task.reject(e); }, function (s) { return !resent && task.status(s); });
                            return task.promise;
                        };
                    }).value;
                    //#endregion
                    return {
                        suspended: suspended,
                        renewed: renewed.observer,
                        ajax: send,
                        batch: batch
                    };
                }
                return Endpoint;
            }());
            Stack.Endpoint = Endpoint;
            (function (Endpoint) {
                Endpoint.is404 = function (rsp) { return rsp
                    && rsp.status == 404
                    && rsp.data && rsp.data.subcode == 'ApplicationNotFound'; };
                Endpoint.is410 = function (rsp) { return rsp
                    && rsp.status == 410
                    && rsp.data && rsp.data.subcode == 'LimitExceeded'; };
                Endpoint.is410Error = function (err) { return err
                    && err.code == 'RequestFailed'
                    && Endpoint.is410(err.rsp); };
            })(Endpoint = Stack.Endpoint || (Stack.Endpoint = {}));
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var guid = Web.Utils.guid;
            var async = Web.Utils.async;
            var random = Web.Utils.random;
            var batched = Web.Utils.batched;
            var URI = Web.Utils.URI;
            var Task = Web.Utils.Task;
            var Promise = Web.Utils.Promise;
            var Exception = Web.Utils.Exception;
            var BoolProperty = Web.Utils.BoolProperty;
            var ConstProperty = Web.Utils.ConstProperty;
            /**
             * This class wraps the corresponding rel=application resource that
             * represents a signed in UCWA endpoint. The rel=application resource
             * has links to other resources, such as rel=me and rel=conversations,
             * that can be used to get the user name, the list of active conversations
             * and so on.
             *
             * The sign in process starts with the rel=root resource returned by the
             * auto discovery step and then sends a few requests to create a rel=application
             * resource. The diagram below shows the relationships between all these resources:
             *
             *      rel=root
             *          rel=xframe
             *          rel=user
             *              rel=xframe
             *              rel=applications
             *                  rel=application
             *                      rel=me
             *                      rel=batch
             *                      rel=events
             *                      rel=conversations
             *                      ...
             *
             * So to create a rel=application resource the stack sends two requests:
             *
             *      GET rel=user
             *      POST rel=applications
             *      GET rel=events
             *
             * In the case when rel=application already exists in the repository,
             * the client gets the current state of it instead of creating a new
             * rel=application:
             *
             *      GET rel=application
             *      GET rel=events
             *
             * Note, that getting rel=user is also skipped in this case.
             *
             */
            var Application = (function () {
                function Application(args) {
                    var repository = args.repository;
                    var xframe = args.xframe;
                    var endpoint = args.endpoint;
                    var connection = args.connection;
                    var maxBatchSize = args.maxBatchSize || 0;
                    var name = args.name; // guest name
                    var anon = args.anon;
                    var endpointId = name ? void 0 : args.id || guid(); // requires version=2 of POST /applications
                    var appType = args.appType;
                    var dwiid = args.dwiid;
                    // a forked app has the same endpoint id, but a unique instance id
                    var instanceId = appType == 'Desktop' ? dwiid && args.id && guid() : args.id && guid();
                    var version = args.version;
                    var culture = args.culture;
                    var supportsWebRtc = args.supportsWebRtc;
                    var root = args.root;
                    var tm = args.tm;
                    var batcher;
                    var href;
                    var isDeleted = false;
                    var initialized = false; // tells if init(...) has been invoked
                    var connecting = true; // it's set to false once rel=application is obtained
                    var lock = args.lock;
                    var imdn = args.imdn;
                    var ecws = args.ecws;
                    var cors = args.cors;
                    var appInvalidated = BoolProperty(false);
                    var signOutOnAppChange = args.soac == void 0 ? true : args.soac;
                    args = null; // reduce the visibility scope of this variable
                    //#region connect
                    /** Gets the rel=application and connects to the event channel.
                        This is the final step in the sign in process. */
                    function connect(root) {
                        return Task.wait(root).then(function (root) {
                            var syncLockedCreateApp = lock.synchronized(createApp);
                            // the regular flow: sign in, create a rel=application and subscribe to rel=events
                            if (root) {
                                repository.put(root);
                                return getUser(root).then(function () { return syncLockedCreateApp(); });
                            }
                            var app = repository.get('application')[0];
                            // the resurrection flow: fetch an existing rel=application and subscribe to rel=events
                            if (app) {
                                instanceId = app.get('instanceId', instanceId);
                                // Note, that if the GET rel=application returns a 404.ApplicationNotFound,
                                // the app will be restored with a call to restoreApp, which invokes init(...);
                                // to avoid invoking init(...) twice, it sets and checks the `initialized` flag.
                                return fetchApp();
                            }
                            // the partial sign in flow: when the rel=applications link is known, but rel=user isn't
                            return syncLockedCreateApp();
                        }).then(function (app) {
                            connecting = false;
                            // this flag prevents two p-GETs in the restore-from-snapshot scenario
                            !initialized && init(app);
                        });
                    }
                    //#endregion
                    //#region fixScheme
                    /**
                     * Changes the URI's scheme to https if the URI has a scheme.
                     * If it doesn't, returns the original URI.
                     */
                    function fixScheme(link) {
                        var uri = new URI(link);
                        return uri.scheme() == 'http' ?
                            uri.scheme('https') + '' :
                            link;
                    }
                    //#endregion
                    //#region getUser
                    /**
                     * This GET request is supposed to return a link to rel=applications.
                     * In certain cases, however, the rel=applications link is missing in
                     * the response. If this link is missing, the client may assume that
                     * it's observing a server bug for which there is a workaround:
                     *
                     *      1. The client needs to send the GET to rel=user again,
                     *         but this time with a special Accept header.
                     *
                     *      2. The response will contain a specially formatted resource
                     *         with rel=redirect and rel=xframe links that point to another pool.
                     *
                     *      3. The client needs to send a regular GET to the rel=redirect link
                     *         and the response will contain a link to rel=user on another pool.
                     *
                     * @returns {Promise<Resource>} - Returns the rel=user resource.
                     */
                    function getUser(root) {
                        return __awaiter(this, void 0, Promise, function () {
                            var user, ucwaLinkExists, redir;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, endpoint.ajax({
                                            type: 'GET',
                                            url: root.link('user').href
                                        })];
                                    case 1:
                                        user = _a.sent();
                                        ucwaLinkExists = name ?
                                            user.hasLink('anonApplications') :
                                            user.hasLink('applications');
                                        if (!!ucwaLinkExists)
                                            return [3 /*break*/, 7];
                                        return [4 /*yield*/, endpoint.ajax({
                                                type: 'GET',
                                                url: root.link('user').href,
                                                headers: { 'Accept': 'application/vnd.microsoft.rtc.autodiscover+json; v=1' }
                                            })];
                                    case 2:
                                        redir = _a.sent();
                                        redir.rel = redir.rel || 'user'; // the server may omit "rel" for this resource
                                        if (redir.hasLink('xframe'))
                                            // the server-side auto-d code is handcrafting URLs
                                            // and may mistakenly return an HTTP link here
                                            xframe.src(fixScheme(redir.link('xframe').href));
                                        _a.label = 3;
                                    case 3:
                                        if (!redir.hasLink('redirect'))
                                            return [3 /*break*/, 5];
                                        return [4 /*yield*/, endpoint.ajax({
                                                type: 'GET',
                                                // the server-side auto-d code is handcrafting URLs
                                                // and may mistakenly return an HTTP link here
                                                url: fixScheme(redir.link('redirect').href)
                                            })];
                                    case 4:
                                        redir = _a.sent();
                                        redir.rel = redir.rel || 'redirect'; // the server may omit "rel" for this resource
                                        if (redir.hasLink('xframe'))
                                            xframe.src(redir.link('xframe').href);
                                        return [3 /*break*/, 3];
                                    case 5: return [4 /*yield*/, endpoint.ajax({
                                            type: 'GET',
                                            url: redir.link('user').href
                                        })];
                                    case 6:
                                        user = _a.sent();
                                        _a.label = 7;
                                    case 7:
                                        user.rel = user.rel || 'user'; // the server may omit "rel" for this resource
                                        repository.put(user);
                                        if (user.hasLink('xframe'))
                                            xframe.src(user.link('xframe').href);
                                        return [2 /*return*/, user];
                                }
                            });
                        });
                    }
                    //#endregion
                    /**
                     * Compares the application href from repository to the newly created one to
                     * determine if the application has changed. If it has then we have no alternative but to sign out.
                     */
                    function ensureSameApp(app) {
                        if (repository.get('application').length > 0) {
                            var oldHref = new URI(repository.get('application')[0].href).path();
                            var newHref = new URI(app.href).path();
                            if (oldHref != newHref) {
                                var err = Exception('HrefChanged', {
                                    old: oldHref,
                                    new: newHref,
                                    rsp: app.debug && app.debug.rsp
                                });
                                tm && tm.record(Web.TelemetryEvent.ApplicationChanged, { reason: err });
                                appInvalidated(true, err);
                                throw err;
                            }
                        }
                    }
                    //#region createApp
                    /** Creates a rel=application resource. */
                    var createApp = function () {
                        if (isDeleted)
                            throw Exception('AppIsDeleted');
                        // GET rel=anonUser returns both links
                        var r = name ?
                            repository.get('anonApplications')[0] :
                            repository.get('applications')[0];
                        // if the server doesn't support forking an application, the client
                        // falls back to the regular POST /applications request that creates
                        // a new endpoint or resumes an existing one with the given id
                        var v = (instanceId || imdn) && r.revision >= 2 ? 2 : 1;
                        return Task.run(function () {
                            // Guess the xframe URL only in anon join or p2p modes.
                            // This could be done unconditionally, but there may
                            // be troubles with the internal OAuth2 flow in which
                            // the xframe.src value is changed to get the token:
                            //
                            // 1. GET /root -> a.lync.com/user
                            // 2. GET /user -> b.lync.com/apps
                            // 3. POST /apps
                            //
                            // After step 2 the xframe URL will be an OAuth URI with
                            // redirect_uri = a.lync.com/xframe because the #2 request
                            // went to a.lync.com. Then, if the xframe is blindly redirected
                            // to b.lync.com/xframe, the token in the current xframe will be lost.
                            // This is most like ok if /user and /apps are on different
                            // domains as tokens are bound to a specific FQDN, but if they
                            // are on the same domain, then the token will be dropped for no reason.
                            if (!anon)
                                return;
                            var _user = new URI(xframe.src());
                            var _apps = new URI(r.href);
                            // in the p2p anon flow rel=anonApplications and rel=anonUser
                            // are on different domains, but GET rel=anonUser doesn't return
                            // a new xframe; the workaround is to guess the new xframe URL
                            if (_user.host() != _apps.host())
                                return xframe.src(_apps.path('/xframe') + '');
                        }).then(function () {
                            var dfd = endpoint.ajax({
                                type: 'POST',
                                url: r.href,
                                version: v,
                                creds: cors && !anon,
                                data: {
                                    AnonymousDisplayName: name,
                                    RemoteEventChannel: ecws || undefined,
                                    UserAgent: version,
                                    Culture: culture,
                                    EndpointId: endpointId,
                                    InstanceId: v >= 2 ? instanceId : void 0,
                                    webRtcCapability: supportsWebRtc ? 'Supported' : void 0,
                                    EnableImdn: imdn,
                                    type: appType
                                }
                            });
                            tm && tm.monitor(dfd, Web.TelemetryEvent.ApplicationCreate, { anon: !!name, href: r.href, version: v }, { sendEndEventOnly: true });
                            return dfd;
                        }).then(function (app) {
                            href = app.href;
                            // do the check after setting href so that DELETE goes to the new application
                            if (!connecting && signOutOnAppChange)
                                ensureSameApp(app);
                            repository.put(app);
                            return app;
                        }).catch(function (err) {
                            if (Stack.Endpoint.is410Error(err))
                                removeInstanceSpecificResources();
                            throw err;
                        });
                    };
                    //#endregion
                    //#region deleteApp
                    function deleteApp() {
                        isDeleted = true;
                        var dfd = endpoint.ajax({
                            type: 'DELETE',
                            url: href,
                            nobatch: true
                        }).then(function () {
                            // drop the returned value
                        });
                        tm && tm.monitor(dfd, Web.TelemetryEvent.ApplicationDelete, { href: href }, { sendEndEventOnly: true });
                        return dfd;
                    }
                    //#endregion
                    //#region replaceApp
                    /** Creates a new fork of the endpoint by generating a new instanceId.
                        This invalidates the rel=application and rel=events hrefs. */
                    function replaceApp() {
                        // the current instanceId has been permanently deleted by UCWA
                        instanceId = guid();
                        removeInstanceSpecificResources();
                        // at this moment the event channel should have been suspended
                        // by the 410 response; this call is supposed to resume it
                        return restoreApp();
                    }
                    //#endregion
                    /** POST /applications, then GET /events */
                    function restoreApp() {
                        // POST /applications will drop the current p-GET with a 404,
                        // and since we're about to follow up with another p-GET,
                        // that 404, or any other error, needs to be ignored
                        connection && connection.channelId++;
                        return createApp().then(init);
                    }
                    /** Fetches the rel=application resource from UCWA. */
                    function fetchApp() {
                        return endpoint.ajax({
                            type: 'GET',
                            url: repository.get('application')[0].href,
                            creds: cors && !anon,
                            instanceId: instanceId,
                            headers: {
                                'X-Ms-Get-App': random(),
                                'If-None-Match': '"' + random() + '"' // forbid the browser to use a cached response
                            }
                        }).then(function (app) {
                            repository.put(app);
                            href = app.href;
                            return app;
                        });
                    }
                    //#region init
                    function init(app) {
                        initialized = true;
                        // if rel=batch is available, then batch requests are supported
                        if (app.hasLink('batch') && !batcher)
                            batcher = new Stack.Batch(app.link('batch').href);
                        // if rel=events available, start listening to events
                        if (app.hasLink('events'))
                            connection && connection.connect(app.link('events').href, instanceId);
                    }
                    //#endregion
                    // these are the only two hrefs that contain instanceId
                    function removeInstanceSpecificResources() {
                        var app = repository.get('application')[0];
                        app && repository.remove(app.href);
                        var events = repository.get('events')[0];
                        events && repository.remove(events.href);
                    }
                    //#region ajax
                    /**
                     * Sends an HTTP request to the given URL.
                     * The resource returned by the server is cached in the repository.
                     */
                    function ajax(request) {
                        return endpoint.ajax(request).then(function (resource) {
                            repository.put(resource);
                            // 204-like responses are represented by resources without href
                            // 201-like responses with Location header turn into resources without rel
                            return resource.href && repository.get(resource.href)[0] || resource;
                        });
                    }
                    //#endregion
                    //#region batch
                    /** Sends a few requests in one batch. */
                    function batch(requests) {
                        // if the batch contains only 1 request or batching is not enabled,
                        // send the requests separately
                        if (requests.length == 1 || !batcher || !maxBatchSize)
                            return Task.wait(requests.map(ajax));
                        return endpoint.batch(batcher, requests).then(function (results) {
                            for (var _i = 0, results_2 = results; _i < results_2.length; _i++) {
                                var r = results_2[_i];
                                Task.wait(r).then(repository.put);
                            }
                            return results;
                        });
                    }
                    //#endregion
                    //#region renewing cwt_ucwa cookie
                    // A response to the first "POST applications" request
                    // contains not only the "application" resource but also
                    // a Set-Cookie header that sets a cwt_ucwa cookie needed
                    // to get contact photos. This cookie looks like this:
                    //
                    //      POST .../applications HTTP/1.1
                    //      {"UserAgent":"...","Culture":"en-us","EndpointId":"..."}
                    //
                    //      HTTP/1.1 201 Created
                    //      Set-Cookie: cwt_ucwa=AAE...b3M; path=.../photos; secure; HttpOnly
                    //
                    // So whenever the client creates an <img> element pointing to
                    // a contact photo, the browser sends a GET request to that URL
                    // including the cwt_ucwa cookie in the Cookie header:
                    //
                    //      GET .../photos/johndoe HTTP/1.1
                    //      Cookie: cwt_ucwa=AAE...b3M
                    //
                    // However this cwt_ucwa cookie has a limited lifetime and eventually
                    // it expires. A right way to renew this cookie was suggested by
                    // the server team: whenever the primary web ticket expires, renew it
                    // and sends a "GET application" request - the response will contain
                    // a new value of the cwt_ucwa cookie:
                    //
                    //      GET .../applications/... HTTP/1.1
                    //      Authorization: Bearer cwt=AAE...1Vo
                    //
                    //      HTTP/1.1 200 OK
                    //      Set-Cookie: cwt_ucwa=AAE...b3M
                    //
                    // So the code snippet below sends this GET request whenever the primary
                    // web ticket expires.
                    endpoint.renewed(function () {
                        if (repository.get('application').length == 1)
                            fetchApp();
                    });
                    //#endregion
                    //#region send
                    var send = new Web.Identity(async(ajax)).map(function (send) {
                        // this is the batching layer that accumulates all requests
                        // without nobatch=true and sends them in one batch on the
                        // next event cycle
                        var sendInBatch = !maxBatchSize ? send :
                            batched(async(batch), maxBatchSize);
                        return function (req) {
                            req.priority = req.priority || 0;
                            return req.nobatch ? send(req) :
                                sendInBatch(req, req.priority);
                        };
                    }).map(function (send) {
                        // this is debouncing layer that merges identical GET requests
                        // into one; this is possible because GET requests do not modify
                        // the state on the server
                        var reqs = {};
                        return function (req) {
                            if (req.type != 'GET')
                                return send(req);
                            // JSON.stringify acts here as a hash function; since request
                            // objects are very small, JSON.stringify is just better than
                            // any other hash function
                            var uid = JSON.stringify(req);
                            reqs[uid] = reqs[uid] || send(req).finally(function () { return delete reqs[uid]; });
                            return reqs[uid];
                        };
                    }).value;
                    //#endregion
                    return {
                        ajax: send,
                        id: ConstProperty(endpointId),
                        restore: restoreApp,
                        replace: replaceApp,
                        remove: deleteApp,
                        ready: connect(root),
                        invalid: appInvalidated.asReadOnly()
                    };
                }
                return Application;
            }());
            Stack.Application = Application;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            var find = Web.Utils.find;
            var clone = Web.Utils.clone;
            var random = Web.Utils.random;
            var URI = Web.Utils.URI;
            var Exception = Web.Utils.Exception;
            var OAuth = Web.Auth.OAuth;
            var OAuthTokenRetriever = Web.Auth.OAuthTokenRetriever;
            var OAuthTokenIssuer = (function () {
                /**
                 * Handles the GET:TOKEN request in the xframe and XHR modes.
                 *
                 * This acts as a convenient location to fork auth requests to various auth providers.
                 * eg.
                 * oauth_cb is the sdk's external callback file that acts as a proxy for retrieving tokens.
                 * get_oauth_token is used when customers want to perform auth themselves and provide the sdk a token.
                 * in cors mode auth requests are handled by OAuth.ts
                 */
                function OAuthTokenIssuer(xframe, _a) {
                    var location = _a.location, window = _a.window, document = _a.document, xframector = _a.xframector, cors = _a.cors, tm = _a.tm, get_oauth_token = _a.get_oauth_token, oauth_cb = _a.oauth_cb, oauth_cb_timeout = _a.oauth_cb_timeout, hostProperty = _a.hostProperty;
                    var xframes = {}; // one xframe per token in the xframe mode
                    xframes[random()] = xframe; // this is the default xframe
                    var oauth_retriever = oauth_cb && new OAuthTokenRetriever(oauth_cb, oauth_cb_timeout, window, document);
                    return {
                        reset: function () {
                            oauth_retriever && oauth_retriever.reset();
                        },
                        send: function (req) {
                            if (req.type == 'GET:TOKEN') {
                                var uri = new URI(req.url);
                                if (oauth_cb) {
                                    return oauth_retriever.getToken(uri);
                                }
                                else if (get_oauth_token) {
                                    var resource_1 = uri.query.get('resource');
                                    return get_oauth_token(resource_1).then(function (token) {
                                        return {
                                            status: 200,
                                            responseText: token
                                        };
                                    }, function (err) {
                                        tm && tm.record('get_oauth_token', {
                                            result: 'failed',
                                            resource: resource_1,
                                            url: req.url,
                                            reason: err
                                        });
                                        throw Exception('GetOAuthTokenFailed', { reason: err });
                                    });
                                }
                                else if (cors) {
                                    return OAuth.getToken(uri, location, document).then(function (token) {
                                        return {
                                            status: 200,
                                            responseText: token
                                        };
                                    });
                                }
                                else {
                                    var aud_1 = OAuth.audfqdn(req.url);
                                    // 1. find an existing xframe with a token that has the same audience
                                    // 2. find an existing xframe with fqdn matching the requested audience
                                    // 3. if neither found, create a new xframe
                                    var x_1 = find(xframes, function (x) { return OAuth.audfqdn(x.src()) == aud_1; })
                                        || find(xframes, function (x) { return new URI(OAuth.baseurl(x.src())).host() == aud_1; })
                                        || new xframector(undefined, tm, undefined, hostProperty);
                                    return x_1.src.set(uri + '').then(function () {
                                        var headers = req.headers || {};
                                        headers['Authorization'] = null;
                                        headers['X-Ms-SDK-Host'] = hostProperty;
                                        // this is to check if the current origin is whitelisted
                                        if (new URI(OAuth.baseurl(x_1.src())).host() != aud_1)
                                            return x_1.send({ type: 'GET', url: '/ucwa/oauth', headers: headers });
                                    }).then(function () {
                                        var t = random();
                                        xframes[t] = x_1;
                                        return {
                                            status: 200,
                                            responseText: t
                                        };
                                    });
                                }
                            }
                            else {
                                // if the request has a token, find a matching xframe for it or use the default xframe
                                var x = find(xframes, function (x, t) { return req.headers && req.headers['Authorization'] == t; });
                                // the token id needs to be removed as the xframe has the actual token
                                // cloning the request object might not be necessary, but it's safer
                                // to do so as others may depend on the header that's removed here
                                if (x) {
                                    req = clone(req);
                                    delete req.headers['Authorization'];
                                }
                                return (x || xframe).send(req);
                            }
                        }
                    };
                }
                return OAuthTokenIssuer;
            }());
            Stack.OAuthTokenIssuer = OAuthTokenIssuer;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            var URI = Web.Utils.URI;
            var Task = Web.Utils.Task;
            var Http = Web.Utils.Http;
            var isString = Web.Utils.isString;
            var Exception = Web.Utils.Exception;
            /**
             * Supports querying both the Microsoft Graph as well as Azure Graph
             */
            var Graph = (function () {
                function Graph(args) {
                    var ms_graph_uri = args.ms_graph_uri;
                    var azure_graph_uri = args.azure_graph_uri;
                    var graph_oauth_uri = args.graph_oauth_uri;
                    var get_oauth_token = args.get_oauth_token;
                    var client_id = args.client_id;
                    var redirect_uri = args.redirect_uri;
                    var tm = args.tm;
                    var xframector = args.xframector;
                    var xframe_uri_for_graph = args.xframe_uri_for_graph;
                    var location = args.location;
                    var document = args.document;
                    var hostProperty = args.hostProperty;
                    // auth_request_uri requires resource but the resource depends on which graph api is called
                    // so resource is set later at the time of making the call
                    var auth_request_uri = new URI(graph_oauth_uri);
                    auth_request_uri.query.set('response_type', 'token');
                    auth_request_uri.query.set('client_id', client_id);
                    auth_request_uri.query.set('prompt', 'none');
                    var xframe;
                    var sipProxyAddress;
                    var tokens = {};
                    function search(graph_uri, type, relativePath, queryParams) {
                        if (queryParams === void 0) { queryParams = {}; }
                        if (!graph_uri)
                            throw Exception('NoGraphUri');
                        if (!graph_oauth_uri)
                            throw Exception('NoGraphOAuthUri');
                        var url = new URI(graph_uri);
                        url.path(url.path() + relativePath);
                        for (var param in queryParams)
                            url.query.set(param, queryParams[param]);
                        function sendReq(token) {
                            return Task.run(function () {
                                if (!xframe) {
                                    xframe = new xframector(void 0, tm, undefined, hostProperty);
                                    return xframe.src.set(xframe_uri_for_graph);
                                }
                            }).then(function () {
                                return xframe.send({
                                    type: type,
                                    headers: { Authorization: isString(token) ? token : void 0 },
                                    url: url + ''
                                });
                            });
                        }
                        var graphResource = new URI(graph_uri).path('').query('').hash('') + '';
                        return sendReq(tokens[graphResource]).then(function (rsp) {
                            if (rsp.status == 401) {
                                delete tokens[graphResource];
                                return getTokenForGraph(graphResource).then(function (token) {
                                    tokens[graphResource] = token;
                                    return sendReq(token);
                                });
                            }
                            else
                                return rsp;
                        });
                    }
                    /**
                     * Gets a token for a specified graph resource choosing the first available option from below:
                     * 1. get_oauth_token if provided - this assumes that the host of the sdk has a valid approach to retrieve tokens
                     * 2. if redirect_uri is provided - assumes we are running in cors mode so we should be able to pick up the token
                     *  ourselves from the redirect_uri which should be on the same domain
                     * 3. default is to use the xframe - if no xframe uri is specified then it uses the default xframe from
                     *  webdir.online.lync.com to obtain a token for graph and make graph requests
                     * Graph doesn't need to use the OAuthTokenRetriever (oauth_cb) since we have a way to send authenticated
                     * requests to graph in xframe or cors mode.
                     */
                    function getTokenForGraph(graphResource) {
                        auth_request_uri.query.set('resource', graphResource);
                        auth_request_uri.query.set('redirect_uri', redirect_uri || Web.Auth.OAuth.baseurl(xframe.src()));
                        if (get_oauth_token)
                            return get_oauth_token(graphResource);
                        else if (redirect_uri)
                            return Web.Auth.OAuth.getToken(auth_request_uri, location, document);
                        else {
                            return xframe.src.set(auth_request_uri + '').then(function () {
                                // First send any request that requires the X-Ms-Origin
                                // validation. The xframe will see from the response that
                                // the origin is trusted and can send requests to Graph.
                                return xframe.send({
                                    type: 'GET',
                                    url: '/ucwa/oauth',
                                    headers: {
                                        // Using the xframe's token for Graph will result
                                        // in a 403 Forbidden with the following diag code:
                                        //
                                        //   X-Ms-diagnostics: 28055;
                                        //      source="*.lync.com";
                                        //      reason="The OAuth token is invalid.";
                                        //      faultcode="wsse:FailedAuthentication"
                                        //
                                        // To pass the X-Ms-Origin check we need a 401 response.
                                        'Authorization': 'Bearer',
                                        'X-Ms-SDK-Host': hostProperty
                                    }
                                });
                            }).then(function () { return void 0; });
                        }
                    }
                    function getSipProxyAddress() {
                        return Task.run(function () {
                            // use cached one if available since it isn't expected to change
                            return sipProxyAddress || search(azure_graph_uri, 'GET', '/me').then(function (rsp) {
                                if (!Http.isSuccess(rsp.status))
                                    throw Stack.ERequestFailed({ url: '/me' }, rsp);
                                sipProxyAddress = JSON.parse(rsp.responseText).sipProxyAddress;
                                return sipProxyAddress;
                            });
                        }).catch(function (err) {
                            tm && tm.record(Web.TelemetryEvent.GraphFetchSip, { result: 'failed', reason: err });
                            throw err;
                        });
                    }
                    function getTopNContacts(n) {
                        return Task.run(function () {
                            return search(ms_graph_uri, 'GET', '/me/people', {
                                $top: n,
                                $select: 'displayName,emailAddresses,personType'
                            }).then(function (rsp) {
                                if (!Http.isSuccess(rsp.status))
                                    throw Stack.ERequestFailed({ url: '/me/people' }, rsp);
                                return JSON.parse(rsp.responseText).value;
                            });
                        }).catch(function (err) {
                            tm && tm.record(Web.TelemetryEvent.GraphFetchPeople, { result: 'failed', reason: err });
                            throw err;
                        });
                    }
                    function reset() {
                        xframe && xframe.reset();
                    }
                    return {
                        getSipProxyAddress: getSipProxyAddress,
                        getTopNContacts: getTopNContacts,
                        reset: reset
                    };
                }
                return Graph;
            }());
            Stack.Graph = Graph;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="Storage.ts" />
/// <reference path="Resource.ts" />
/// <reference path="ResourceEvent.ts" />
/// <reference path="Repository.ts" />
/// <reference path="EventBatch.ts" />
/// <reference path="EventChannel.ts" />
/// <reference path="RequestBatcher.ts" />
/// <reference path="XFrame.ts" />
/// <reference path="XHR.ts" />
/// <reference path="Transport.ts" />
/// <reference path="AutoDiscovery.ts" />
/// <reference path="Endpoint.ts" />
/// <reference path="Application.ts" />
/// <reference path="OAuthTokenIssuer.ts" />
/// <reference path="Graph.ts" />
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Settings;
        (function (Settings) {
            /** Dumps in the dev console all UCWA traffic. */
            Settings.logHttp = Web.ls.logs.get();
            /** If logging of the UCWA traffic is enabled, this setting
                makes the dump look like a unit test. For internal use only. */
            Settings.logMode = /\blm=ut\b/.test(Web.window.location && Web.window.location.hash) ? 'ut' : null;
            /** enables the prefix for text analysis tools, e.g. [EVENT] and [REQUEST] */
            Settings.logPrefix = Web.ls.pref.get() === undefined ? true : !!Web.ls.pref.get();
        })(Settings = Web.Settings || (Web.Settings = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            var ver = Web.version;
            var all = Web.Utils.all;
            var hash = Web.Utils.hash;
            var async = Web.Utils.async;
            var clone = Web.Utils.clone;
            var debug = Web.Utils.debug;
            var assert = Web.Utils.assert;
            var extend = Web.Utils.extend;
            var random = Web.Utils.random;
            var batched = Web.Utils.batched;
            var isObject = Web.Utils.isObject;
            var isString = Web.Utils.isString;
            var getOption = Web.Utils.getOption;
            var isFunction = Web.Utils.isFunction;
            var URI = Web.Utils.URI;
            var Task = Web.Utils.Task;
            var Event = Web.Utils.Event;
            var Symbol = Web.Utils.Symbol;
            var XmlDoc = Web.Utils.XmlDoc;
            var Property = Web.Utils.Property;
            var SyncLock = Web.Utils.SyncLock;
            var Exception = Web.Utils.Exception;
            var BoolProperty = Web.Utils.BoolProperty;
            var SourcedProperty = Web.Utils.SourcedProperty;
            /** This is a trick to avoid multiple GETs on the same resource object.
                A better solution would be to move this logic inside Resource. */
            var sGET = Symbol('GET');
            function getOptParamBound(params, name, upperBound) {
                var val = getOption(params, name, upperBound);
                return val <= upperBound ? val : upperBound;
            }
            /**
             * Encapsulates the UCWA stack.
             *
             * This object brings together various pieces of the stack,
             * such as Connection, XFrame, Transport and so on. The model
             * layer uses this stack as the data source.
             *
             */
            var UCWA = (function () {
                function UCWA(options) {
                    if (options === void 0) { options = {}; }
                    this.eEvent = new Event();
                    this.eRestored = new Event();
                    this.pConnected = BoolProperty(false);
                    this.pECStatus = Property();
                    /** An event from the UCWA server. Check event.type. */
                    this.event = this.eEvent.observer;
                    /** Tells that the connection with UCWA has been restored. */
                    this.restored = this.eRestored.observer;
                    /** Tells whether the UCWA endpoint is still alive. */
                    this.connected = this.pConnected.asReadOnly();
                    /** Tells the status of the p-GET. */
                    this.ecstatus = this.pECStatus.asReadOnly();
                    this.suspended = SourcedProperty();
                    this.nReq = 0;
                    this.tInit = new Task();
                    this.pAppDeleted = BoolProperty(false);
                    this.appDeleted = this.pAppDeleted.asReadOnly();
                    this.tm = options.tm;
                    if (Web.Settings.logMode == 'ut' || options.logs) {
                        this.logs = extend([], {
                            size: 0,
                            maxsize: Web.Settings.logMode == 'ut' ? Infinity : options.logs.size || Math.pow(2, 20) // 1 MB
                        });
                    }
                    if (Web.Settings.logHttp)
                        Stack.initConsoleFormatters();
                }
                Object.defineProperty(UCWA.prototype, "fqdn", {
                    /** Returns FQDN of rel=applications, aka the UCWA URL. */
                    get: function () {
                        var url = this._repository.get('applications')[0].href;
                        return new URI(url).host();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(UCWA.prototype, "app", {
                    /** Returns the base application resource that is received on POST /applications */
                    get: function () {
                        return this.get('application');
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Initializes the UCWA stack.
                 *
                 * If invoked without arguments, returns a promise that
                 * resolves after the client gets signed in.
                 */
                UCWA.prototype.init = function (options) {
                    if (options) {
                        if (this.tInit.state() != 'pending')
                            this.tInit = new Task();
                        assert(!this.pInit);
                        this.connect(options);
                    }
                    return this.tInit.promise;
                };
                /** Disconnects from the server and cleans up resources. */
                UCWA.prototype.uninit = function (reason) {
                    try {
                        if (this.pInit)
                            this.pInit.cancel(reason);
                        if (this._xframe)
                            this._xframe.reset();
                        this.pInit = null;
                        this.tInit = new Task();
                        this._xframe = null;
                        this._repository = null;
                        this._application = null;
                        this._uninit_reason = reason;
                    }
                    catch (err) {
                        this.tm && this.tm.record(Web.TelemetryEvent.UcwaUninitException, { reason: err });
                        throw err;
                    }
                };
                UCWA.prototype.deleteApp = function (reason) {
                    var _this = this;
                    return this._application.remove().then(function () {
                        _this.pAppDeleted(true, reason);
                        try {
                            _this.ssItem.remove();
                        }
                        catch (err) {
                        }
                    });
                };
                /** Sends an HTTP request and returns the resource object
                 *  given by the server in response. The options allow to
                 *  control the request priority, set headers, define whether
                 *  it should go to the batching queue and so on.
                 *
                 *      ucwa.send("POST", ".../audioVideoInvitations", {
                 *          nobatch: true,  // SDP offers cannot be batched
                 *          priority: 3,    // some random priority for the throttling queue
                 *          data: "v=0\r\nsession=1\r\n...",
                 *          query: { operationId: "12-342-232" },
                 *          headers: { "Content-Type": "application/sdp; charset=utf-8" }
                 *      });
                 *
                 *  `selector` can be either a URI/URL or an object of the form { rel: '...' }
                 *  to make the stack find the resource with the specified rel and send the
                 *  request to its href:
                 *
                 *      ucwa.send("GET", { rel: "me" });
                 */
                UCWA.prototype.send = function (method, selector, options) {
                    var _this = this;
                    var url = isString(selector) ? selector : this.get(selector).href;
                    var id = ++this.nReq;
                    var req = extend(clone(options || {}), {
                        type: method,
                        url: url
                    });
                    var url2 = Web.Settings.logHttp && URI.mergeQuery(url, req.query);
                    /* istanbul ignore next */
                    if (Web.Settings.logMode == 'ut') {
                        this.logRequest("req[" + id + "] = ucwa.request(\"" + method + " " + url2 + "\");");
                        if (req.data) {
                            var data = JSON.stringify(req.data, null, 4);
                            this.logRequest("assert.equal(req[" + id + "].data, " + data + ");");
                        }
                    }
                    else {
                        var args = [];
                        args.push(url2);
                        if (options && options.query)
                            args.push(options.query);
                        if (req.data)
                            args.push(JSON.stringify(req.data));
                        this.logRequest.apply(this, ['%c -> ' + id + ' ' + method,
                            'color:blue;font-weight:bold'].concat(args));
                    }
                    if (!this._application)
                        throw Exception('AppUninitialized');
                    var promise = this._application.ajax(req);
                    /* istanbul ignore next */
                    promise.then(function (rsp) {
                        if (Web.Settings.logMode == 'ut') {
                            _this.logRequest('//', method, url2);
                            _this.logRequest("req[" + id + "].resolve(" + (rsp.href ? rsp + '' : '') + ");");
                        }
                        else {
                            var args = [];
                            args.push(url2);
                            if (rsp.href) {
                                var s = JSON.parse(rsp + '');
                                delete s.userName;
                                delete s.password;
                                args.push(s);
                            }
                            _this.logRequest.apply(_this, ['%c <- ' + id + ' ' + method,
                                'color:green;font-weight:bold'].concat(args));
                        }
                    }, function (err) {
                        var rsp = err && err.rsp || {};
                        if (Web.Settings.logMode == 'ut') {
                            var data = JSON.stringify(rsp, null, 4);
                            _this.logRequest("req[" + id + "].reject(" + data + ");");
                        }
                        else {
                            _this.logRequest('%c <- ' + id + ' ' + method, 'color:red;font-weight:bold', url2, rsp.status, rsp.statusText);
                            _this.logRequest(err);
                        }
                        _this.tm && _this.tm.record(Web.TelemetryEvent.RequestFailed, { req: req, reason: err });
                    });
                    return promise;
                };
                /**
                 * Finds an existing resource object by href or rel in the repository.
                 * If there is no such resource or there are several such resources,
                 * the method throws an exception.
                 *
                 *     ucwa.get(".../messages/2"); // lookup the resource by its href
                 *     ucwa.get({ rel: "me" }); // lookup the resource by its rel
                 */
                UCWA.prototype.get = function (selector, defaults) {
                    var r = this.find(selector);
                    if (!r || r.length < 1) {
                        if (defaults === null)
                            return null;
                        throw Exception('ResourceNotFound', { selector: selector });
                    }
                    if (r.length > 1)
                        throw Exception('AmbiguousResource', { selector: selector });
                    return r[0];
                };
                /**
                 * Finds all resource objects in the repository matching the selector.
                 * The selector may contain the rel or the href of the resource.
                 */
                UCWA.prototype.find = function (selector) {
                    if (!this._repository)
                        throw Exception('Disconnected', { reason: this._uninit_reason });
                    return isFunction(selector) ? this._repository.find(selector) :
                        this._repository.get(isString(selector) ? selector : selector.rel);
                };
                /** Checks whether the resource object exists in the repository. */
                UCWA.prototype.exists = function (selector) {
                    return this.find(selector).length > 0;
                };
                /**
                 * Returns a snapshot of the repository.
                 *
                 * The snapshot is a mapping from a rel to an array of resource snapshots
                 * which are raw objects. This is how a snapshot can be used:
                 *
                 *     var snapshot = ucwa.getSnapshot();
                 *     var resource = Resource(snapshot.contact[0]);
                 */
                UCWA.prototype.getSnapshot = function (filter) {
                    var snapshot = this._repository.getSnapshot(filter);
                    // During auto discovery and sign in, UCWA may have redirected
                    // the client between pools a few times, each time giving a new
                    // xframe URL, so after sign in is completed, the repository may
                    // contain several rel=xframe resources and only one of them is used.      
                    var xframeUrl = new URI(snapshot.applications[0]._links.self.href).path('/xframe').query('').hash('').toString();
                    snapshot.xframe = [{ _links: { self: { href: xframeUrl } } }];
                    return snapshot;
                };
                /*
                 * Get value of the "revision" property associated with the given resource.
                 */
                UCWA.prototype.getRevisionOf = function (r) {
                    var _this = this;
                    // the resource may not contain revision info due to lazy-loading,
                    // so have to load again if initially not found
                    var link = r.link('self');
                    return Task.run(function () {
                        return +link.revision || r[sGET] || (r[sGET] = _this.send('GET', r.href));
                    }).then(function () {
                        return +link.revision || 1; // default revision is 1
                    });
                };
                /**
                 * Waits for a specific event from UCWA.
                 *
                 *      ucwa.wait({
                 *          type: 'completed',
                 *          target: { rel: 'message' }
                 *      }).then(function (event) {
                 *          console.log(event.target.href);
                 *      });
                 */
                UCWA.prototype.wait = function (pattern) {
                    var ucwa = this;
                    var pres = pattern.resource;
                    var ptar = pattern.target;
                    var ptyp = pattern.type;
                    var psts = pattern.status;
                    var psnd = pattern.sender;
                    function matches(event) {
                        var eres = event.resource;
                        var etar = event.target;
                        var etyp = event.type;
                        var ests = event.status;
                        var esnd = event.sender;
                        return !(etyp != ptyp ||
                            psts && psts != ests ||
                            etar.rel != ptar.rel ||
                            ptar.href && etar.href != ptar.href ||
                            isFunction(pres) && !pres(eres) ||
                            isObject(pres) && !all(pres, function (v, n) { return eres.has(n) && eres.get(n) == v; }) ||
                            isFunction(psnd) && !psnd(esnd) ||
                            psnd && psnd.rel && esnd.rel != psnd.rel ||
                            psnd && psnd.href && esnd.href != psnd.href);
                    }
                    var task = new Task(ptar.rel + ' ' + ptyp, {
                        mode: 'sync',
                        cancel: function (reason) {
                            ucwa.event.off(handler);
                            task.reject(reason);
                        }
                    });
                    function handler(event) {
                        if (matches(event)) {
                            ucwa.event.off(handler);
                            task.resolve(event);
                        }
                    }
                    ucwa.event(handler);
                    return task.promise;
                };
                /** Adds a listener to a specific event:
                    ucwa.observe("participant added", event => { ... }); */
                UCWA.prototype.observe = function (pattern, listener) {
                    var _a = /^(\w+) (\w+)$/.exec(pattern), rel = _a[1], type = _a[2];
                    return this.event(function (event) {
                        if (event.type == type && event.target.rel == rel)
                            listener(event);
                    });
                };
                UCWA.prototype.connect = function (options) {
                    var _this = this;
                    var events = options.events;
                    var auth = options.auth;
                    var id = options.id; // UCWA's endpoint id.
                    var ssKey = hash(JSON.stringify(options, function (k, v) { return /^(window|document|location)$/.test(k) ? undefined : v; }));
                    var client_id = options.client_id; // OAuth client_id
                    var redirect_uri = options.redirect_uri;
                    var oauth_uri = options.oauth_uri; // OAuth URI
                    var oauth_state = options.state; // OAuth state
                    var use_cwt = options.use_cwt;
                    var cwt_format = options.cwt_format;
                    var username = options.username;
                    var password = options.password;
                    var token = options.token;
                    var graph_uri = options.graph_uri || 'https://graph.microsoft.com/beta?api-version=1.6';
                    var azure_graph_uri = options.azure_graph_uri || 'https://graph.windows.net?api-version=1.6';
                    var graph_oauth_uri = options.graph_oauth_uri || 'https://login.microsoftonline.com/common/oauth2/authorize';
                    var xframe_uri_for_graph = options.xframe_uri_for_graph || 'https://webdir.online.lync.com/xframe';
                    var name = options.name;
                    var domain = options.domain; // auto d
                    var origins = options.origins; // auto d
                    var conf_uri = options.meeting; // conference URI
                    var conf_key = options.conf_key;
                    var join_url = options.join_url;
                    var join_url_mode = options.join_url_mode;
                    var xmscwt = options.xmscwt;
                    var root = options.root; // rel=root
                    var snapshot = options.snapshot; // if the snapshot is specified, it overrides the snapshot from the storage
                    var ssrels = new RegExp(options.ssrels || 'root|xframe|applications?');
                    var culture = options.culture || 'en-us';
                    var version = 'SkypeWeb/' + ver + (options.version ? ' ' + options.version : '');
                    var supportsWebRtc = options.supportsWebRtc;
                    var throttle = getOption(options, 'throttle', 5); // the number of requests in the throttling queue            
                    var enableInternalNS = !!options.enableInternalNS;
                    var cors = options.cors;
                    // Make a choice whether to use XHR or XFrame as the transport.
                    // Note, that determining whether the current agent supports CORS
                    // or not isn't that simple because some agents may be able to send
                    // cross-origin requests, but not able to read all the response
                    // headers because they do not support Access-Control-Expose-Headers.
                    var xframector = options.XFrame || (cors ? Stack.XHR : Stack.XFrame);
                    var windowMock = options.window;
                    var documentMock = options.document;
                    var locationMock = options.location;
                    var batchRetryDelay = getOption(options, 'batchRetryDelay', 5.0); // seconds
                    var maxBatchSize = getOptParamBound(options, 'maxBatchSize', 20); // UCWA limits batch size to 20 requests
                    var ssEnabled = !conf_uri && !join_url && !!id && snapshot !== null; // in the anon mode a snapshot cannot be reused
                    var session = random();
                    var lock = new SyncLock('CreateApp');
                    var user = options.user;
                    var retry = options.retry;
                    var ecws = options.ecws;
                    var appType = options.appType;
                    // ucwa does not set the cwt_ucwa photo cookie for type Desktop. 
                    // Because of this webinfra does not set the Access-Control-Allow-Credentials header in cors mode.
                    // Because of this we cannot set withCredentials to true on the xhr on any /applications query for type 'Desktop'
                    var creds = appType == 'Desktop' ? false : options.withCreds;
                    // This is a clumsy way to detect two anon modes: the p2p anon mode (aka the MSEG scenario) and
                    // the online anon join. The two modes have one thing in common: the GET /user request
                    // (aka the discover request) must not have the Authorization header. It would be better to introduce
                    // another sign-in param that would tell to not send the token in the discover request, but then
                    // changes would need to be made in MSEG code which was in prod already.
                    var psat = !!name && cors && !!root && !!token;
                    var get_oauth_token = !auth && options.get_oauth_token && isFunction(options.get_oauth_token) && async(options.get_oauth_token);
                    var hostProperty = options.hostProperty;
                    var soac = options.soac;
                    var dwiid = options.dwiid;
                    var enableOnPremDiscovery = options.eopd;
                    var oauth_cb = options.oauth_cb;
                    var oauth_cb_timeout = options.oauth_cb_t;
                    var imdn = options.imdn;
                    this.ssItem = new Stack.StorageItem(['Snapshot', ssKey]);
                    this.pAppDeleted(false);
                    // TODO: status = 0 is given not only to cancelled
                    // XHR requests, but also to failed cross-origin
                    // requests, on some SSL-specific failures and so on.
                    var delay000 = options.delay000 || (function () { return function () { return cors ? 100 : 3; }; });
                    var delay502 = options.delay502 || (function () {
                        var delay = 30; // fixed delay of 30 seconds
                        var maxdt = 15 * 60; // give up after 15 minutes
                        var n = 0;
                        return function () {
                            if (delay * n++ > maxdt)
                                throw Exception('MaxRetryDelayReached');
                            else
                                return delay;
                        };
                    });
                    var delay404 = options.delay404 || (function () {
                        var delay = 1;
                        return function () {
                            // exponential back off with the 1 hour upper limit
                            if (delay > 3600)
                                throw Exception('MaxRetryDelayReached');
                            else
                                return delay *= 2;
                        };
                    });
                    var delay503 = options.delay503 || (function () {
                        var delay = 1;
                        return function () {
                            // exponential back off with the 10 mins upper limit
                            if (delay > 600)
                                throw Exception('MaxRetryDelayReached');
                            else
                                return delay *= 1.5;
                        };
                    });
                    options = null; // reduce the visibility scope of this variable         
                    if (cors) {
                        // As of 2015, the UCWA's CORS works with OAuth tokens only:
                        // this is why the token->cwt exchange flag defaults to false.
                        if (use_cwt === void 0)
                            use_cwt = false;
                        // In most cases any URl on the same domain can be used. In IE,
                        // though, a full URL like /token/index.html is required, as
                        // otherwise it drops the access token from the URL's fragment part.
                        // This is why overriding the default redirect_uri may be useful.
                        if (redirect_uri === void 0)
                            redirect_uri = "/" + client_id + "/oauth2/token";
                    }
                    if (isString(origins)) {
                        if (!domain)
                            throw new Error('`domain` is required when `origins` is an env name');
                        origins = Stack.AutoD[origins](domain);
                        domain = null;
                    }
                    try {
                        if (ssEnabled && !snapshot)
                            snapshot = this.ssItem.json;
                    }
                    catch (err) {
                    }
                    /**
                     * Given an origin perform autod and sign in.
                     */
                    var processOrigin = function (origin) {
                        // this is either the XFrame ctor or the XHR ctor:
                        // they both have the 1st arg taking a mock for tests
                        // and the undefined value makes both ctors use
                        // the default value for the 1st arg
                        var xframe = new xframector(void 0, _this.tm, creds, hostProperty);
                        // the OAuth handler sends GET:TOKEN requests here
                        var xtissuer = new Stack.OAuthTokenIssuer(xframe, {
                            cors: cors,
                            tm: _this.tm,
                            xframector: xframector,
                            window: windowMock,
                            document: documentMock,
                            location: locationMock,
                            get_oauth_token: get_oauth_token,
                            oauth_cb: oauth_cb,
                            oauth_cb_timeout: oauth_cb_timeout,
                            hostProperty: hostProperty
                        });
                        // e.g. https://meet.contoso.com/johndoe/C4OY7GNO
                        function discoverConfURI(join_url, json) {
                            if (!cors) {
                                var uri = new URI(join_url);
                                // in on-prem the /xframe path doesn't host the xframe
                                uri.path('/autodiscover/xframe/xframe.html').query('').hash('');
                                xframe.src(uri + '');
                            }
                            return xframe.send({
                                type: 'GET',
                                url: join_url,
                                headers: { Accept: "Application/vnd.microsoft.lync.meeting+" + (json ? 'json' : 'xml') + ";ver=14" } // case sensitive
                            }).then(function (rsp) {
                                var data = json ? JSON.parse(rsp.responseText) : XmlDoc(rsp.responseText).root;
                                var read = function (name) { return json ? data[name.replace(/-/g, '')] : data.selectOne(name).text(); };
                                // in multi-pool on-prem topologies there may be a redirect to another fqdn
                                var redir = json && read('redirect');
                                if (redir)
                                    return discoverConfURI(redir, json);
                                conf_uri = read('conf-uri').trim();
                                conf_key = read('conf-key').trim();
                                var url;
                                try {
                                    // as of Sep 2016, the join launcher (aka JL) doesn't
                                    // return this URL; this is supposed to be an oauth
                                    // endpoint that supports the /oauthtoken flow
                                    url = read('ucwa-public-url').trim();
                                }
                                catch (_) {
                                    // this is not an oauth endpoint and one way to sign in
                                    // would be to use the /OAuth flow to get a cwt with
                                    // the conf claim; however this URL can be changed to
                                    // the oauth endpoint and then the /oauthtoken flow
                                    // can be used
                                    url = read('ucwa-url');
                                    // if xmscwt is set, the caller wants to use the /OAuth
                                    // way to get the cwt; in this case the non-oauth endpoint
                                    // should be used
                                    if (!xmscwt && url.indexOf('/ucwa/oauth/') < 0)
                                        url = url.replace('/ucwa/', '/ucwa/oauth/');
                                }
                                snapshot = {
                                    'applications': url,
                                    // simulating the ms:rtc:saas:discover flow when the GET
                                    // on that URL returns a conf URI: the model layer already
                                    // has code to create a conversation object from this URI
                                    'ms:rtc:saas:discover': {
                                        conferenceId: conf_uri,
                                        conferenceKey: conf_key,
                                        _links: {
                                            self: { href: join_url }
                                        }
                                    }
                                };
                            });
                        }
                        ;
                        var autodAndSignIn = function () {
                            if (snapshot) {
                                snapshot = Stack.Repository.expandSnapshot(snapshot);
                                // rel=xframe can be inferred from rel=applications or rel=user
                                if (!snapshot.xframe) {
                                    var href = (snapshot.applications || snapshot.user)[0]._links.self.href;
                                    snapshot.xframe = [{ _links: { self: { href: '' + new URI(href).path('/xframe').query('') } } }];
                                }
                            }
                            if (isString(origin)) {
                                // it's convenient to specify just the FQDN of the rel=root URL
                                if (origin.indexOf('://') < 0)
                                    origin = 'https://' + origin + '/Autodiscover/AutodiscoverService.svc/root';
                                origin = { origin: origin };
                            }
                            // in most cases the xframe URL can be inferred from the root URL
                            if (origin && !origin.xframe)
                                origin.xframe = new URI(origin.origin).path('/xframe').query('').hash('') + '';
                            var dfdroot;
                            if (snapshot) {
                                _this.tm && _this.tm.record(Web.TelemetryEvent.SigninUseSnapshot);
                                xframe.src(snapshot.xframe[0]._links.self.href);
                            }
                            else if (!root) {
                                if (!domain) {
                                    domain = username ? username.match(/@(.+?)$/)[1] :
                                        conf_uri ? conf_uri.match(/@(.+?);/)[1] : null;
                                    if (!domain && !origin)
                                        throw Exception('NoFQDN');
                                }
                                dfdroot = Stack.AutoDiscovery({
                                    XFrame: xframector,
                                    xframe: xframe,
                                    domain: domain,
                                    hostProperty: hostProperty,
                                    origins: origin && [origin]
                                }).root;
                            }
                            else {
                                // these parameters are provided by UI, so
                                // a meaningful error message is required
                                assert(root.user, 'root.user URL is missing');
                                // it's important to drop the query, otherwise the xframe won't be loaded
                                root.xframe = root.xframe || new URI(root.user).path('/xframe').query('') + '';
                                xframe.src(root.xframe);
                                dfdroot = new Stack.Resource('//root', 'root')
                                    .addLink('user', root.user)
                                    .addLink('xframe', root.xframe)
                                    .set('internal', !!root.internal);
                            }
                            var authfn;
                            if (isFunction(auth)) {
                                // the SF auth, and pretty much any other possible custom auth,
                                // needs to know the full URL of every request, but in most cases
                                // requests have URLs relative to the current UCWA domain; the .bind(...)
                                // trick gives access to the xframe.src property via the `this` variable
                                authfn = auth.bind(xframe);
                            }
                            else if (token) {
                                authfn = Web.Auth.Token(token, psat && root.user);
                            }
                            else if (password) {
                                authfn = Web.Auth.Basic(username, password);
                            }
                            else if (conf_uri) {
                                authfn = xmscwt ?
                                    Web.Auth.AnonMeetingInternal(conf_uri, conf_key) :
                                    Web.Auth.AnonMeeting(conf_uri, conf_key);
                            }
                            else if (client_id) {
                                authfn = Web.Auth.OAuth({
                                    xframe: xframe,
                                    client_id: client_id,
                                    oauth_uri: oauth_uri,
                                    state: oauth_state,
                                    use_cwt: use_cwt,
                                    cwt_format: cwt_format,
                                    tm: _this.tm,
                                    redirect_uri: oauth_cb || redirect_uri,
                                    hostProperty: hostProperty
                                });
                            }
                            else if (auth == 'passive' || use_cwt) {
                                authfn = Web.Auth.ADFS();
                            }
                            else {
                                authfn = Web.Auth.Integrated();
                            }
                            var send = xtissuer.send.bind(xtissuer);
                            var transport = new Stack.Transport({ send: send }, {
                                fmax: !Web.isUnitTested && 3.0,
                                tm: _this.tm,
                                buffer: throttle,
                                retry: retry,
                                version: version,
                                session: session,
                                hostProperty: hostProperty,
                                delay: { 0: delay000, 503: delay503, 502: delay502, 404: delay404 }
                            });
                            var endpoint = new Stack.Endpoint({
                                tm: _this.tm,
                                batchRetryDelay: batchRetryDelay,
                                transport: transport,
                                auth: authfn,
                                enableInternalNS: enableInternalNS,
                                user: user,
                                anon: !!name || !!conf_uri,
                                replace: function () { return application.replace(); },
                                restore: function () {
                                    // The handler of 404.ApplicationNotFound requests needs to be implemented
                                    // right on top of the auth layer, as its used by the batching layer and
                                    // by the event channel, and it's implementation needs to send the POST to
                                    // restore the app. The first requirement makes Endpoint as the natural
                                    // place for this handler, while the second requirement makes Application as
                                    // the proper place. The `restore` function, which is essentially an indirect
                                    // reference from endpoint to application, is the least hacky way to solve this.
                                    // A better solution would be to merge Transport, Endpoint and Application.
                                    return application.restore().then(function () {
                                        _this.eRestored.fire();
                                    });
                                }
                            });
                            var connection = events === false ? null : new Stack.EventChannel(endpoint, endpoint.suspended, _this.tm);
                            if (events && typeof events === 'object')
                                connection.timeout = events.timeout;
                            var repository = new Stack.Repository({
                                snapshot: snapshot,
                                connection: connection
                            });
                            var application = new Stack.Application({
                                tm: _this.tm,
                                maxBatchSize: maxBatchSize,
                                xframe: xframe,
                                endpoint: endpoint,
                                repository: repository,
                                connection: connection,
                                imdn: imdn,
                                root: dfdroot,
                                name: join_url ? undefined : name,
                                anon: !!name || !!conf_uri,
                                id: id,
                                ecws: ecws,
                                culture: culture,
                                version: version,
                                supportsWebRtc: supportsWebRtc,
                                lock: lock,
                                appType: appType,
                                cors: cors,
                                soac: soac,
                                dwiid: dwiid
                            });
                            return application.ready.then(function () {
                                // This subscription has to be synchronous because async delivery of Connection events to UCWA object 
                                // combined with sync delivery of these events to Repository results in incorrect events to the model layer.
                                //
                                // If two related events refer to that same resource but carry a different resource content and if these 
                                // events arrive in the same batch we will wind up with the following chain:
                                //
                                //  1. Event 1 is handed to Repository - resource is saved in Repository and event.resource is replaced 
                                //     by a reference to the resource in the repository.
                                //  2. Event 1 delivery to UCWA is postponed until the next event cycle.
                                //  3. Event 2  is handed to Repository - resource is updated in Repository and event.resource is replaced 
                                //     by a reference to the resource in the repository. Now both Event 1 and 2 refer to the same resource 
                                //     copy in Repository.
                                //  4. Event 2  delivery to UCWA is postponed until the next event cycle.
                                //
                                // When Event 1 and 2 reach UCWA they both have the reference to the same resource content received in  
                                // Event2, which is wrong.
                                //
                                connection && connection.event(function (event) {
                                    /* istanbul ignore next */
                                    var ctx = event['in'];
                                    var name = event.target.rel + ' ' + event.type + (ctx ? ' in ' + ctx.rel : '');
                                    if (Web.Settings.logMode == 'ut') {
                                        _this.logEvent('// ' + name);
                                        _this.logEvent("ucwa.fire(" + (event + '') + ");");
                                    }
                                    else {
                                        if (Web.Settings.customFmt)
                                            _this.logEvent(JSON.parse(event + ''));
                                        else
                                            _this.logEvent('%c ' + name, 'color:magenta;font-weight:bold', JSON.parse(event + ''));
                                    }
                                    _this.eEvent.fire(event);
                                });
                                if (connection) {
                                    connection.connected.changed(_this.pConnected);
                                    connection.status.changed(_this.pECStatus);
                                }
                                if (ssEnabled) {
                                    var save = batched(function () {
                                        try {
                                            var ss = _this.getSnapshot(function (rel) { return ssrels.test(rel); });
                                            if (!_this.pAppDeleted())
                                                _this.ssItem.json = ss;
                                        }
                                        catch (err) {
                                        }
                                    });
                                    repository.updated(save);
                                }
                                _this.suspended.setSource(endpoint.suspended);
                                _this._xframe = xframe;
                                _this._repository = repository;
                                _this._application = application;
                                _this._application.invalid.once(true, function (reason) {
                                    _this.deleteApp(reason);
                                });
                                _this.graph = new Stack.Graph({
                                    client_id: client_id,
                                    get_oauth_token: get_oauth_token,
                                    ms_graph_uri: origin && origin.graph_uri || graph_uri,
                                    azure_graph_uri: origin && origin.azure_graph_uri || azure_graph_uri,
                                    graph_oauth_uri: origin && origin.graph_oauth_uri || graph_oauth_uri,
                                    redirect_uri: redirect_uri,
                                    tm: _this.tm,
                                    xframector: xframector,
                                    xframe_uri_for_graph: xframe_uri_for_graph,
                                    location: locationMock,
                                    document: documentMock,
                                    hostProperty: hostProperty
                                });
                            });
                        };
                        return Task.run(function () {
                            if (join_url)
                                return discoverConfURI(join_url, join_url_mode == 'json');
                        }).then(autodAndSignIn).catch(function (err) {
                            xframe.reset();
                            xtissuer.reset(); // oauthtokenretriever inside OAuthTokenIssuer needs to remove its iframe
                            throw err;
                        });
                    };
                    /**
                     * Every origin can specify its own graph endpoint. Hence, for every origin lookup graph to get the sipProxyAddress.
                     * The first successful lookup to graph gets accepted as the default graph object in ucwa.
                     * Each origin that successfully looks up graph then adds two onprem routes to the list of routes.
                     */
                    var getOnPremRoutes = function (origin) {
                        if (!enableOnPremDiscovery || snapshot || root)
                            return;
                        if (isString(origin))
                            origin = { origin: origin };
                        if (origin && !origin.xframe)
                            origin.xframe = new URI(origin.origin).path('/xframe').query('').hash('') + '';
                        var graph = new Stack.Graph({
                            client_id: client_id,
                            get_oauth_token: get_oauth_token,
                            ms_graph_uri: origin && origin.graph_uri || graph_uri,
                            azure_graph_uri: origin && origin.azure_graph_uri || azure_graph_uri,
                            graph_oauth_uri: origin && origin.graph_oauth_uri || graph_oauth_uri,
                            redirect_uri: redirect_uri,
                            tm: _this.tm,
                            xframector: xframector,
                            xframe_uri_for_graph: origin && origin.xframe || xframe_uri_for_graph,
                            location: locationMock,
                            document: documentMock,
                            hostProperty: hostProperty
                        });
                        var dfdSip = graph.getSipProxyAddress();
                        dfdSip.finally(function () { return graph.reset(); });
                        var routes = [];
                        var _loop_1 = function (prefix) {
                            routes.push(dfdSip.then(function (sipProxyAddress) {
                                return processOrigin(prefix + sipProxyAddress.split('@')[1]);
                            }));
                        };
                        for (var _i = 0, _a = ['https://lyncdiscover.', 'https://lyncdiscoverinternal.']; _i < _a.length; _i++) {
                            var prefix = _a[_i];
                            _loop_1(prefix);
                        }
                        return routes;
                    };
                    /**
                     * Given a set of origins find onprem routes if available, and then online routes.
                     * Discover all in parallel. First one to create an application wins. The lock in
                     * Stack/Application ensures that only one successful route can create an application.
                     */
                    var getRoutes = function (origins) {
                        var routes = [];
                        for (var _i = 0, _a = (snapshot || !origins ? [null] : origins); _i < _a.length; _i++) {
                            var origin = _a[_i];
                            routes.push.apply(routes, getOnPremRoutes(origin));
                            routes.push(processOrigin(origin));
                        }
                        return routes;
                    };
                    this.pInit = Task.waitAny(getRoutes(origins)).catch(function (e) {
                        // Scenarios where deleting the snapshot and retrying autoD makes sense
                        // 1. upon 404 or 502 error from GET /application
                        // 2. If a 410-Gone-LimitExceeded error is hit during sign in it means we are using invalid data from the snapshot
                        if (snapshot && (Stack.Endpoint.is410Error(e) ||
                            origins && e && e.code == 'RequestFailed' && e.req.headers && e.req.headers['X-Ms-Get-App'] && /^(404|502)$/.test(e.rsp.status))) {
                            snapshot = null;
                            return Task.waitAny(getRoutes(origins));
                        }
                        throw e;
                    }).finally(function () {
                        _this.pInit = null;
                    });
                    this.pInit.then(function (res) { return _this.tInit.resolve(res); }, function (err) { return _this.tInit.reject(err); }, this.tInit.status);
                };
                UCWA.prototype.logEvent = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    if (Web.Settings.logPrefix)
                        debug.log.apply(debug, [Web.Settings.logHttp, '[EVENT] '].concat(args));
                    else
                        debug.log.apply(debug, [Web.Settings.logHttp].concat(args));
                };
                UCWA.prototype.logRequest = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    if (Web.Settings.logPrefix)
                        debug.log.apply(debug, [Web.Settings.logHttp, '[REQUEST] '].concat(args));
                    else
                        debug.log.apply(debug, [Web.Settings.logHttp].concat(args));
                };
                return UCWA;
            }());
            __decorate([
                async
            ], UCWA.prototype, "init", null);
            __decorate([
                async
            ], UCWA.prototype, "send", null);
            Stack.UCWA = UCWA;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Settings;
        (function (Settings) {
            Settings.customFmt = Web.ls.cfmt.get() === undefined ? true : Web.ls.cfmt.get(); // enabled by default
        })(Settings = Web.Settings || (Web.Settings = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
// Adds custom object formatters for Chrome's dev console:
// docs.google.com/document/d/1FTascZXT9cxfetuPRT2eXPQKXui4nWFivUnS_335T3U/preview
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            var isResource = function (x) { return x && x.rel && x._links; };
            var isEvent = function (x) { return x && x.type && x.sender && x.target; };
            // returns an array of JSON ML tags
            function getResourceProps(x) {
                var props = {};
                for (var key in x)
                    if (!/^(rel|_links|_embedded)$/.test(key))
                        props[key] = x[key];
                var jtags = [];
                for (var key in props) {
                    var val = props[key];
                    jtags.push(['span', {}, key]);
                    jtags.push(['span', {}, ': ']);
                    if (val === null || val === undefined)
                        jtags.push(['span', { style: 'color:lightgray' }, val]);
                    else
                        jtags.push(['span', {}, ['object', { object: val }]]);
                    jtags.push(['span', {}, ', ']);
                }
                jtags.pop();
                return jtags;
            }
            var initialized = false;
            // it's safe to invoke it multiple times; it can't be invoked right away
            // because ttt in the beginning sets its own `window` var that's switched
            // back to the original `window` var only in Application(...) constructor
            function initConsoleFormatters() {
                if (initialized)
                    return;
                initialized = true;
                var formatters = Web.window['devtoolsFormatters'] = Web.window['devtoolsFormatters'] || [];
                // formats UCWA resource objects
                formatters.push({
                    header: function (x) {
                        // allow to enable/disable custom formatters on the fly
                        if (!Web.Settings.customFmt || !isResource(x))
                            return;
                        var preview = getResourceProps(x);
                        return ['div', { style: 'font-style:italic' },
                            ['span', { style: 'font-weight:bold' }, x.rel],
                            ['span', {}, ' {']].concat(preview, [['span', {}, '}']]);
                    },
                    hasBody: function (x) {
                        return isResource(x);
                    },
                    body: function (x) {
                        return ['span', {}, JSON.stringify(x, null, 2)];
                    }
                });
                // formats UCWA event objects
                formatters.push({
                    header: function (event) {
                        // allow to enable/disable custom formatters on the fly
                        if (!Web.Settings.customFmt || !isEvent(event))
                            return;
                        var ctx = event['in'];
                        var name = event.target.rel + ' ' + event.type + (ctx ? ' in ' + ctx.rel : '');
                        var preview = getResourceProps(event.resource || {});
                        return ['div', { style: 'font-style:italic' },
                            ['span', { style: 'font-weight:bold;color:magenta' }, name],
                            ['span', {}, ' {']].concat(preview, [['span', {}, '}']]);
                    },
                    hasBody: function (x) {
                        return isEvent(x);
                    },
                    body: function (x) {
                        return ['span', {}, JSON.stringify(x, null, 2)];
                    }
                });
            }
            Stack.initConsoleFormatters = initConsoleFormatters;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="autod.ts" />
/// <reference path="auth.ts" />
/// <reference path="stack/UCWA.ts" />
/// <reference path="stack/DevFmt.ts" />
"use strict";
/**
 * The UCWA stack layer.
 *
 * This is the transport layer or the stack that lays between the UCWA server
 * and the model layer. The stack sends HTTP requests with
 * JSON payload to the UCWA server, processes responses with JSON
 * payload and provides the responses in a object-oriented way.
 *
 * The stack consists of four levels:
 *
 *      XFrame - the lowest level
 *
 *          Abstracts the functionality of the <iframe> HTML element.
 *          XFrame can send an HTTP request to the underlying <iframe>
 *          and receive a response from it. If this XFrame is replaced
 *          with a different XFrame that has the same interface but a different
 *          implementation (e.g. based on the Node's "http" or "https" module)
 *          then the whole stack will be able to run outside the browser.
 *
 *      Transport - built on top of XFrame
 *
 *          Adds resiliency on top of XFrame. Because the <iframe> given
 *          by the server cannot be considered as a reliable way to deliver
 *          messages, Transport takes care of of misbehaving iframes. It also
 *          contains the logic of matching responses with requests.
 *
 *          Transport maintains an xframe queue that queues requests until
 *          the underlying xframe becomes ready to redirect requests to the server.
 *          Almost at all times this queue is empty, because the xframe is ready.
 *
 *          Transport maintains a throttling queue to make sure that at all times
 *          no more than a given number of requests (usually it's 5 or 6) are
 *          pending. This queue is necessary because browsers do not allow
 *          web apps to send have too many pending requests. This queue is normally
 *          empty because the client sends almost all requests in batches. This
 *          queue is aware of that every request may have a priority and
 *          enqueues requests according to their priority.
 *
 *      Endpoint - built on top of Transport
 *
 *          Adds on top of Transport the ability to seamlessly bypass
 *          authentication. If the server responds with an "HTTP 401 Unauthorized"
 *          response, Endpoint obtains the auth token and sends the same
 *          request again with the token. Thus layers above the endpoint
 *          do not need to care about authentication.
 *
 *      Application - built on top of Endpoint
 *
 *          While lower layers of the stack send requests to raw URLs, Application
 *          sends requests to UCWA resources and saves responses to the resource
 *          repository (the cache).
 *
 *          Application has a persistent connection with the server over which it
 *          receives events from it. For example an IM invitation arrives from this
 *          channel.
 *
 *          Application maintains a batching queue that is used to merge requests
 *          of similar priority in chunks and send them as batch requests. The batching
 *          queue is aware of that every request may have a priority and can be
 *          non batchable. For example a request to send an IM has a very high
 *          priority; a request to download a photo is non batchable.
 *
 * In addition to the stack itself, there are a few supplementary  objects:
 *
 *      Repository
 *
 *          Contains all UCWA resources known to the stack. Repository enables
 *          resource lookup by its type (rel), URL (href) or by some other properties.
 *
 *      Connection
 *
 *          Is the persistent event channel connecting the client with the UCWA server
 *          during the lifetime of the JS application. Under the hood it sends
 *          HTTP GET requests to the event channel URL provided by the server,
 *          parses responses and returns responses as events. The caller of Connection
 *          attaches a handler to Connection to receive events. The pending GET requests
 *          to get events are sent with the highest priority, which is +Infinity.
 *
 */
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            /** unit tests refer to this ns */
            Stack.Internal = Stack;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Settings;
        (function (Settings) {
            Settings.logModel = false;
            Settings.mediaAgent = null;
        })(Settings = Web.Settings || (Web.Settings = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/**
 * Parts of the model layer common for both
 * media-dependent and media-independent models.
 */
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var debug = Web.Utils.debug;
                var extend = Web.Utils.extend;
                var Exception = Web.Utils.Exception;
                var Symbol = Web.Utils.Symbol;
                function EInvitationFailed(reason, debug) {
                    if (debug === void 0) { debug = {}; }
                    var text = reason && reason.message;
                    return Exception.call(text, 'InvitationFailed', extend({ reason: reason }, debug));
                }
                Internal.EInvitationFailed = EInvitationFailed;
                var Modality;
                (function (Modality) {
                    var State;
                    (function (State) {
                        State.Disconnected = 'Disconnected';
                        State.Disconnecting = 'Disconnecting';
                        State.Connecting = 'Connecting';
                        State.Ringing = 'Ringing';
                        State.Connected = 'Connected';
                        State.Notified = 'Notified';
                        State.Created = 'Created';
                    })(State = Modality.State || (Modality.State = {}));
                })(Modality = Internal.Modality || (Internal.Modality = {}));
                /** model[sHref] = href of the underlying resource */
                Internal.sHref = Symbol('href');
                /** model[sInternal] - an object exposing internal model properties and methods */
                Internal.sInternal = Symbol('internal');
                function log() {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    debug.log.apply(debug, [Web.Settings.logModel, '[MODEL] '].concat(args));
                }
                Internal.log = log;
                function watch(description, p) {
                    debug.watch(Web.Settings.logModel, '[MODEL] ' + description, p);
                }
                Internal.watch = watch;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Media;
        (function (Media) {
            'use strict';
            var singleton = Web.Utils.singleton;
            var Enum = Web.Utils.Enum;
            /**
             * A singleton object that aggregates platform and browser information from
             * window.navigator properties.
             *
             *  @method isIE - returns true if this is Internet Explorer(IE) browser, false otherwise
             *  @method isSupportedIE - returns true if this is a supported version of IE, false otherwise
             *  @method isWindows - return true if this is a Windows OS, false otherwise
             *  @method isMac - return true if this is a Mac OS, false otherwise
             *  @method is32bit - return true if this is a 32-bit browser, false otherwise
             *  @method is64bit - return true if this is a 64-bit browser, false otherwise
             *  @method reset - resets the state of UserAgent. Platform/browser info will be read anew when any
             *                  of the other methods are called again. This method is needed for unit testing only.
             *  @example
             *      if (UserAgent().isWindows() && UserAgent().is64bit())
             *         // do something specific to 64-bit Windows
             *
             */
            Media.UserAgent = singleton(function () {
                var OsType = Enum('Unknown', 'Windows', 'Mac', 'Linux', 'Mobile'), BrowserBitness = Enum('Unknown', 'Win32', 'Wow64', 'Win64'), BrowserName = Enum('IE', 'Other');
                var browserName = BrowserName.Other, browserBitness = BrowserBitness.Unknown, osType = OsType.Unknown;
                var isInitialized = false;
                function init() {
                    if (isInitialized)
                        return;
                    var userAgent = Web.window.navigator.userAgent.toLowerCase();
                    var platform = Web.window.navigator.platform ? Web.window.navigator.platform.toLowerCase() : '';
                    // detect IE
                    if (userAgent.match(/msie \d+\.\d+/)) {
                        browserName = BrowserName.IE;
                    }
                    else if (userAgent.match(/trident\/\d+\.\d+/) &&
                        userAgent.match(/\brv:\d+\.\d+/)) {
                        // IE11 dropped MSIE token, its user-agent string looks like: 
                        // "Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko"
                        browserName = BrowserName.IE;
                    }
                    // detect browser bitness on windows
                    if (userAgent.match(/wow64/))
                        browserBitness = BrowserBitness.Wow64;
                    else if (platform.match(/win64/) || userAgent.match(/win64/))
                        browserBitness = BrowserBitness.Win64;
                    else if (platform.match(/win32/))
                        browserBitness = BrowserBitness.Win32;
                    // detect OS
                    if (userAgent.match(/mobi/))
                        osType = OsType.Mobile;
                    else if (userAgent.match(/windows nt/) || browserBitness != BrowserBitness.Unknown)
                        osType = OsType.Windows;
                    else if (platform.match(/mac/) || userAgent.match(/macintosh/))
                        osType = OsType.Mac;
                    else if (platform.match(/linux/) || userAgent.match(/linux/))
                        osType = OsType.Linux;
                    isInitialized = true;
                }
                function isIE() {
                    init();
                    return browserName == BrowserName.IE;
                }
                function isSupportedIE() {
                    return (isIE() && document.documentMode); // IE8+
                }
                function isWindows() {
                    init();
                    return osType == OsType.Windows;
                }
                function isMac() {
                    init();
                    return osType == OsType.Mac;
                }
                function is64bit() {
                    init();
                    return browserBitness == BrowserBitness.Win64;
                }
                function is32bit() {
                    init();
                    return browserBitness == BrowserBitness.Win32 ||
                        browserBitness == BrowserBitness.Wow64;
                }
                function reset() {
                    browserName = BrowserName.Other;
                    browserBitness = BrowserBitness.Unknown;
                    osType = OsType.Unknown;
                    isInitialized = false;
                }
                init();
                return {
                    isIE: isIE,
                    isSupportedIE: isSupportedIE,
                    isWindows: isWindows,
                    isMac: isMac,
                    is64bit: is64bit,
                    is32bit: is32bit,
                    reset: reset
                };
            });
        })(Media = Web.Media || (Web.Media = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="UserAgent.ts" />
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Media;
        (function (Media) {
            'use strict';
            var assert = Web.Utils.assert;
            var isVoid = Web.Utils.isVoid;
            var Event = Web.Utils.Event;
            var Property = Web.Utils.Property;
            var Exception = Web.Utils.Exception;
            var StringEnum = Web.Utils.StringEnum;
            /**
             * A simple string formatter - replaces {ordinal} in the format string with the argument at
             * the ordinal position in the param list following the format string
             *
             * @param {string} format - the format string
             * @param variable list of parameters to be inserted into the format string
             *
             * @example
             *
             *      var s = formatString('Xbox {0} or {1}', 'One', 360);
             *      assert(s == 'Xbox One or 360');
             *
             */
            function formatString(format) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                if (arguments.length == 0)
                    throw new Error('Invalid arguments');
                return format.replace(/{(\d+)}/g, function (substr, index) {
                    // substr is the found substring, index is the first capture group
                    // ex: substr is '{0}', index is '0'
                    return (index in args) ? args[index] : substr;
                });
            }
            Media.formatString = formatString;
            /**
             * Wraps an LWA plugin object instance created by either <object> (ActiveX control) or
             * <embed> (NPAPI plugin) tag
             *
             * A wrapper around a platform-specific scriptable plugin object which is at the heart of each plugin component.
             * It is a COM object for IE and a scriptable plugin object for NPAPI browsers.
             *
             * @property {PluginObject.State} state - returns plugin object state
             *
             * @method innerObject - returns the DOM object representing the plugin object
             * @method {string} id - returns object id
             * @method createInnerObject - creates the plugin DOM object
             * @method destroyInnerObject - destroys the plugin DOM object
             * @method attach(parent, hookEvents) - attaches a visible plugin DOM object to the parent DOM element and
             *                                      optionally hooks up object events
             * @method onObjectLoaded - called by the wrapping PluginComponent after component is loaded
             * @method onObjectUnLoaded - called by the wrapping PluginComponent after component is unloaded
             * @event  event - raised by native plugin object
             *
             * @example
             *
             *    var po = PluginObject( {id: 'mainPluginObject', managerId: '_'} );
             *    po.event(onPOEvent);
             *    po.state.changed(onPOStateChanged);
             *    po.createInnerObject({ hide: true, hookEvents: true });
             *
             */
            function PluginObject(specs) {
                var state = Property({ value: PluginObject.State.None }), id = ((specs && specs.id) || '_plugin') + '_' + PluginObject.nextCount(), managerId = (specs && specs.managerId) ? specs.managerId : '_', event = new Event(), div, innerObject, isObjectLoaded = false, hookEvents = false, _self;
                function getInnerObject() {
                    return (state() == PluginObject.State.Attached) ? innerObject : null;
                }
                function isManager() {
                    return managerId == '_';
                }
                /**
                 * Creates the scriptable plugin object
                 */
                function createInnerObject(options) {
                    Media.log('PluginObject::createInnerObject ' + id);
                    assert(options);
                    assert(!isVoid(options.hide));
                    assert(!isVoid(options.hookEvents));
                    // we can start from uninitialized state only
                    assert(state() == PluginObject.State.None, 'invalid state');
                    // create html tag that embeds the plugin object
                    var tagHtml = getPluginObjectTag({
                        id: id,
                        managerId: managerId,
                        logLevel: Media.UserAgent().isIE() ? 1 : 0
                    });
                    // create a "div" element to host that object tag
                    div = options.hide ? createHiddenWrapper(tagHtml) :
                        createWrapper(tagHtml);
                    Media.log('PluginObject::createInnerObject ' + id + ' ' + div);
                    state.set(PluginObject.State.Created);
                    // if the object is hidden (i.e. the caller does not care where it is hosted) 
                    // attach our "div" element to the document.body
                    if (options.hide) {
                        attach(document.body, options.hookEvents);
                    }
                }
                /**
                 * Destroys the scriptable plugin object
                 */
                function destroyInnerObject() {
                    Media.log('PluginObject::destroyInnerObject ' + id);
                    cleanup();
                    state.set(PluginObject.State.Destroyed);
                }
                /**
                 * Removes the scriptable plugin object from the DOM tree
                 */
                function cleanup() {
                    Media.log('PluginObject::cleanup ' + id);
                    // window.setTimeout(function () {
                    try {
                        if (div)
                            div.parentNode.removeChild(div);
                    }
                    catch (error) {
                        Media.log(error.message);
                    }
                    div = null;
                    // }, 0);
                    innerObject = null;
                    isObjectLoaded = false;
                    hookEvents = false;
                }
                /**
                 * Attaches the "div" element containing the plugin object tag to the document body
                 */
                function attach(parent, fHookEvents) {
                    Media.log('PluginObject::attach ' + id);
                    assert(state() == PluginObject.State.Created);
                    assert(!isVoid(fHookEvents));
                    try {
                        parent.appendChild(div);
                        innerObject = div.firstChild;
                        if (isVoid(innerObject))
                            throw new Error('object missing');
                    }
                    catch (error) {
                        cleanup();
                        state.set(PluginObject.State.AttachFailed);
                        return;
                    }
                    hookEvents = fHookEvents;
                    // The manager plugin object is good to go upon creation, while plugin objects representing
                    // components should wait till components are actually loaded.
                    if (isManager()) {
                        isObjectLoaded = true;
                        validateAndAttachEvents();
                    }
                }
                /**
                 * Validates the created object and attaches events
                 * @remark this is the first place where we start calling methods of the native plugin object
                 */
                function validateAndAttachEvents() {
                    Media.log('PluginObject::validateAndAttachEvents ' + id);
                    // wait for the correct state
                    if (!innerObject || !isObjectLoaded)
                        return;
                    // check plugin object existence by making a plugin call
                    try {
                        if (!innerObject.CheckExistence()) {
                            cleanup();
                            state.set(PluginObject.State.ExistenceCheckFailed);
                            return;
                        }
                    }
                    catch (error) {
                        cleanup();
                        state.set(PluginObject.State.NotInstalled, error);
                        return;
                    }
                    // start listening to plugin object events
                    if (hookEvents) {
                        try {
                            // OnEvent and OnPing are LWA plugin callbacks
                            innerObject.OnEvent = eventHandler;
                            innerObject.OnPing = pingHandler;
                        }
                        catch (error) {
                            cleanup();
                            state.set(PluginObject.State.AttachFailed, error);
                            return;
                        }
                    }
                    state.set(PluginObject.State.Attached);
                }
                /**
                 * Called by the PluginComponent after it is loaded
                */
                function onObjectLoaded() {
                    Media.log('PluginObject::onObjectLoaded ' + id);
                    if (!isManager()) {
                        isObjectLoaded = true;
                        // need to delay the calling of this so that the entire
                        // path to the plugin is first freed and the loading is
                        // finalized before starting to call methods on the plugin
                        Web.window.setTimeout(validateAndAttachEvents, 0);
                    }
                }
                /**
                 * Called by the PluginComponent after it is unloaded
                 */
                function onObjectUnloaded() {
                    Media.log('PluginObject::onObjectUnloaded ' + id);
                    if (!isManager()) {
                        isObjectLoaded = false;
                        // need to delay the calling of this so that the entire
                        // path to the plugin is first freed and the loading is
                        // finalized before starting to call methods on the plugin
                        // window.setTimeout(destroyInnerObject, 0);
                        destroyInnerObject();
                    }
                }
                /**
                 * Handles native plugin object events
                 */
                function eventHandler(type, data) {
                    // if you want to see raw xml data add + ' ' + trim(data) to the output
                    // log('PluginObject::eventHandler - ' + id + ' ' + type); 
                    event.fire(type, data);
                }
                /**
                 * Handles native plugin object pings
                */
                function pingHandler() {
                    try {
                        innerObject.PingResponse();
                        event.fire('__FxPing', '');
                    }
                    catch (error) {
                        destroyInnerObject();
                        return false;
                    }
                    return true;
                }
                /**
                 * Creates an <embed> tag for the NPAPI plugin or an <object> tag for the ActiveX control
                 */
                function getPluginObjectTag(params) {
                    assert(params);
                    var format;
                    // we can quickly check whether the plugin is installed
                    if (!Media.PluginManager().isPluginInstalled()) {
                        state.set(PluginObject.State.NotInstalled);
                        throw Exception('PluginNotInstalled');
                    }
                    if (Media.UserAgent().isIE()) {
                        assert(Media.UserAgent().isWindows());
                        format = PluginObject.IE_HTML_TEMPLATE;
                    }
                    else {
                        assert(Media.UserAgent().isWindows() || Media.UserAgent().isMac());
                        format = PluginObject.FF_HTML_TEMPLATE;
                    }
                    return formatString(format, params.id, Media.PluginManager().installedPlugin().MIME_TYPE, params.managerId, params.logLevel, true, true);
                }
                /**
                 * Creates a hidden "div" element containing the passed-in html fragment
                 */
                function createHiddenWrapper(html) {
                    var div = document.createElement('div');
                    div.style.position = 'absolute';
                    div.style.width = '1px';
                    div.style.height = '1px';
                    div.style.left = '-100px';
                    div.style.top = '0px';
                    div.style.overflow = 'hidden';
                    div.style.visibility = 'hidden';
                    div.innerHTML = html;
                    return div;
                }
                /**
                 * Creates a visible "div" element containing the passed-in html fragment
                 */
                function createWrapper(html) {
                    var div = document.createElement('div');
                    div.style.width = '100%';
                    div.style.height = '100%';
                    div.innerHTML = html;
                    return div;
                }
                _self = {
                    id: function () { return id; },
                    state: state.asReadOnly(),
                    innerObject: getInnerObject,
                    createInnerObject: createInnerObject,
                    destroyInnerObject: destroyInnerObject,
                    attach: attach,
                    event: event.observer,
                    onObjectLoaded: onObjectLoaded,
                    onObjectUnloaded: onObjectUnloaded
                };
                return _self;
            }
            Media.PluginObject = PluginObject;
            (function (PluginObject) {
                PluginObject.nextCount = (function () {
                    var count = 0;
                    return function () {
                        return count++;
                    };
                })();
                PluginObject.State = StringEnum('None', 'ConfigNotSupported', 'NotInstalled', 'CreateFailed', 'ExistenceCheckFailed', 'AttachFailed', 'Created', 'Attached', 'Destroyed');
                PluginObject.IE_HTML_TEMPLATE = '<object id=\"{0}\" type=\"{1}\" width=\"100%\" height=\"100%\"><param name=\"managerID\" value=\"{2}\" /><param name=\"componentID\" value=\"{0}\" /><param name=\"logLevel\" value=\"{3}\" /><param name=\"structuredArguments\" value=\"{4}\" /><param name=\"windowless\" value=\"{5}\" /></object>';
                PluginObject.FF_HTML_TEMPLATE = '<embed id=\"{0}\" type=\"{1}\" width=\"100%\" height=\"100%\" managerID=\"{2}\" componentID=\"{0}\" logLevel=\"{3}\" structuredArguments=\"{4}\" windowless=\"{5}\"></embed>';
            })(PluginObject = Media.PluginObject || (Media.PluginObject = {}));
        })(Media = Web.Media || (Web.Media = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="PluginObject.ts" />
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Media;
        (function (Media) {
            'use strict';
            var check = Web.Utils.check;
            var assert = Web.Utils.assert;
            var isVoid = Web.Utils.isVoid;
            var isNumber = Web.Utils.isNumber;
            var isNotEmptyString = Web.Utils.isNotEmptyString;
            var Enum = Web.Utils.Enum;
            var Task = Web.Utils.Task;
            var Event = Web.Utils.Event;
            var Property = Web.Utils.Property;
            var Exception = Web.Utils.Exception;
            // matches enum values in the native plugin
            Media.PluginLoadResult = Enum('LoadSuccessful', 'NoInstanceManager', 'ComponentNotFound', 'ComponentLoadFailed', 'ComponentInitFailed', 'ComponentLoadCancelled');
            /** Represents plugin method result */
            function PluginMethodResult(res) {
                var i, s = '0x', hr = res[0];
                for (i = 7; i >= 0; i--)
                    s += ((hr >> (i * 4)) & 15).toString(16);
                res.hresultstr = s;
                res.succeeded = res[0] >= 0;
                res.failed = res[0] < 0;
                res.hresult = res[0];
                return res;
            }
            Media.PluginMethodResult = PluginMethodResult;
            /**
             * Wraps an individual native plugin component like MediaPlatformConfig or AVComponent
             *
             * Each component implements a certain subset of plugin functionality, for example:
             * Media configuration, Tuning Wizard, Audio/Video Call, App sharing, etc.
             *
             * @method {string} id() - returns component id
             * @method load() - loads component
             * @method unload() - unloads component
             * @property {PluginComponent.State} state - component state
             * @event event - raised by a contained plugin object
             *
             */
            function PluginComponent(specs) {
                assert(specs.type == 'MediaPlatformConfig' || specs.type == 'AVComponent' ||
                    specs.type == 'VideoUI' || specs.type == 'TuningWizard' ||
                    specs.type == 'AppShareCore' || specs.type == 'AppShareViewerUI');
                var state = Property({ value: PluginComponent.State.Unloaded }), event = new Event(), pluginMgr, // plugin manager
                pluginObj, // scriptable plugin object
                tm, // telemetry recorder
                parent, // parent DOM element
                loadParams = [], // parameters passed to load method
                task, isCanceled = false;
                pluginMgr = specs.pluginManager;
                tm = specs.tm;
                pluginObj = Media.PluginObject({
                    id: '_' + specs.type,
                    managerId: pluginMgr.id()
                });
                pluginObj.event(onPluginObjectEvent, 'async');
                pluginObj.state.changed(onPluginObjectState);
                /**
                 * Returns component id
                 */
                function id() {
                    return (pluginObj && pluginObj.id()) || "";
                }
                /**
                 * Starts loading plugin component
                 */
                function load() {
                    Media.log('PluginComponent::load ' + id());
                    assert(state() == PluginComponent.State.Unloaded, 'invalid component state');
                    assert(pluginMgr.state() == Media.PluginManager.State.Initialized);
                    assert(!task || task.state() != 'pending');
                    state.set(PluginComponent.State.Loading);
                    task = new Task('Loading ' + specs.type + '.', {
                        cancel: function (reason) {
                            Media.log('PluginComponent::load canceled ' + id());
                            isCanceled = true;
                            unload();
                            task.reject(reason);
                        }
                    });
                    // TODO: figure why LWA merges options passed to this method with ctor options
                    // extend the array 
                    loadParams = [].slice.call(arguments, 0);
                    try {
                        pluginObj.createInnerObject({
                            hide: specs.hide,
                            hookEvents: true
                        });
                    }
                    catch (err) {
                        tm && tm.record(Web.TelemetryEvent.PluginComponent, {
                            action: 'loadPluginComponent',
                            id: id(),
                            state: state(),
                            result: 'failed',
                            reason: err
                        });
                        if (task.state() == 'pending')
                            task.reject(err);
                    }
                    return task.promise;
                }
                /**
                 * Unloads component
                 */
                function unload() {
                    Media.log('PluginComponent::unload ' + id());
                    if (state() == PluginComponent.State.Loading ||
                        state() == PluginComponent.State.Loaded) {
                        state.set(PluginComponent.State.Unloading);
                        try {
                            pluginObj.innerObject().UnLoad();
                        }
                        catch (error) {
                            // debugger;
                            cleanupPluginObject(error);
                            state.set(PluginComponent.State.Unloaded);
                        }
                    }
                }
                /**
                 * Called by PluginManager upon receiving the __FxComponentLoadComplete event
                 */
                function onLoaded() {
                    Media.log('PluginComponent::onLoaded ' + id());
                    assert(pluginObj);
                    pluginObj.onObjectLoaded();
                }
                /**
                 * Called by PluginManager upon receiving the __FxComponentUnLoadComplete event
                 */
                function onUnloaded() {
                    Media.log('PluginComponent::onUnloaded ' + id());
                    assert(pluginObj);
                    pluginObj.onObjectUnloaded();
                }
                /**
                 * Sets the hosting DOM element for a visible component
                 */
                function setContainer(parentElem) {
                    check(!specs.hide, 'setContainer called for a hidden component');
                    check(state() != PluginComponent.State.Loaded, 'setContainer called after component is already loaded');
                    parent = parentElem;
                    if (state() == PluginComponent.State.Loading &&
                        pluginObj.state() == Media.PluginObject.State.Created)
                        pluginObj.attach(parent, true);
                }
                /**
                 * Handles native plugin object events
                 */
                function onPluginObjectEvent(type, args) {
                    var arg0;
                    Media.log('%c' + id() + ' ' + type, 'color:blue', args);
                    switch (type) {
                        case '__FxLoadComplete':
                            assert(args.length == 1);
                            arg0 = args[0];
                            assert(isNumber(arg0));
                            if (arg0 == Media.PluginLoadResult.LoadSuccessful &&
                                state() == PluginComponent.State.Loading) {
                                if (!isCanceled)
                                    task.resolve();
                                state.set(PluginComponent.State.Loaded);
                                setLogLevel(1 /* Error */ |
                                    2 /* Info */);
                            }
                            else {
                                // TODO: examine arg0 to determine the failure reason
                                cleanupPluginObject(arg0);
                                if (!isCanceled)
                                    task.reject(arg0);
                                state.set(PluginComponent.State.Unloaded);
                            }
                            break;
                        case '__FxUnLoadComplete':
                            assert(args.length == 0);
                            cleanupPluginObject();
                            state.set(PluginComponent.State.Unloaded);
                            break;
                        default:
                            event.fire({ type: type, args: args });
                            break;
                    }
                }
                /**
                 * Plugin object state change event handler
                 */
                function onPluginObjectState(value) {
                    Media.log('PluginComponent::onPluginObjectState ' + id() + ' ' + value);
                    tm && tm.record(Web.TelemetryEvent.PluginComponent, {
                        action: 'onPluginObjectState',
                        id: id(),
                        reason: value
                    });
                    switch (value) {
                        case Media.PluginObject.State.None:
                            // initial state - ignore
                            break;
                        case Media.PluginObject.State.Created:
                            // attach the div element hosting the visible component to the parent DOM element
                            if (!specs.hide && !isVoid(parent))
                                pluginObj.attach(parent, true);
                            break;
                        case Media.PluginObject.State.Attached:
                            // load component
                            Web.window.setTimeout(loadComponent, 0);
                            break;
                        case Media.PluginObject.State.Destroyed:
                            state.set(PluginComponent.State.Unloaded);
                            break;
                        default:
                            cleanupPluginObject(value);
                            state.set(PluginComponent.State.Unloaded);
                    }
                }
                /**
                 * Loads component for real
                 */
                function loadComponent() {
                    Media.log('PluginComponent::loadComponent ' + id());
                    assert(state() == PluginComponent.State.Loading);
                    assert(pluginObj.state() == Media.PluginObject.State.Attached);
                    try {
                        pluginObj.innerObject().Load(specs.type, loadParams);
                    }
                    catch (error) {
                        // debugger;
                        cleanupPluginObject(error);
                        state.set(PluginComponent.State.Unloaded);
                    }
                }
                /**
                 * plugin object cleanup
                 */
                function cleanupPluginObject(reason) {
                    Media.log('PluginComponent::cleanupPluginObject ' + id());
                    tm && tm.record(Web.TelemetryEvent.PluginComponent, {
                        action: 'cleanupPluginObjectInComponent',
                        id: id(),
                        state: state(),
                        reason: reason
                    });
                    if (pluginObj) {
                        pluginObj.event.off(onPluginObjectEvent);
                        pluginObj.state.changed.off(onPluginObjectState);
                        pluginObj.destroyInnerObject();
                        pluginObj = null;
                    }
                }
                /**
                 * Invokes component method
                 *
                 * @param {string} method - method name
                 * @param {arguments} - list of method parameters
                 *
                 * @returns [] - results array
                 */
                function invoke(method) {
                    assert(pluginObj);
                    assert(isNotEmptyString(method));
                    assert(state() == PluginComponent.State.Loaded);
                    var args = [].slice.call(arguments, 1), res, ret;
                    Media.log('PluginComponent::invoke %c' + method, 'color:red', args, id());
                    tm && tm.record(Web.TelemetryEvent.PluginComponent, {
                        action: method,
                        args: args && args.join(),
                        id: id(),
                        state: state(),
                        result: 'started'
                    });
                    try {
                        res = pluginObj.innerObject().ProcessMethod(method, args);
                        ret = PluginMethodResult(res);
                    }
                    catch (error) {
                        Media.log(id() + ' error executing ' + method + ' ' + error.message);
                        tm && tm.record(Web.TelemetryEvent.PluginComponent, {
                            action: method,
                            state: state(),
                            result: 'failed',
                            reason: error
                        });
                        throw Exception('PCInvoke', {
                            method: method,
                            args: args && args.join()
                        });
                    }
                    if (ret && ret.failed) {
                        tm && tm.record(Web.TelemetryEvent.PluginComponent, {
                            action: method,
                            state: state(),
                            result: 'ret.failed',
                            reason: ret.hresultstr
                        });
                        throw Exception.call(method + ':' + ret.hresultstr, 'PCInvoke', {
                            method: method,
                            args: args && args.join()
                        });
                    }
                    else {
                        tm && tm.record(Web.TelemetryEvent.PluginComponent, {
                            action: method,
                            state: state(),
                            result: 'succeeded',
                            reason: ret && ret.hresultstr
                        });
                    }
                    return ret;
                }
                /**
                 * Sets logger level
                 * @param {Number} level - logger level, may be a combo of any levels defined by
                 *                         PluginComponent.LogLevel enumeration
                 */
                function setLogLevel(level) {
                    check(level > 0 && level <= 7 /* All */, 'Invalid level');
                    if (pluginObj)
                        try {
                            pluginObj.innerObject().SetLogLevel(level);
                        }
                        catch (error) {
                            Media.log('SetLogLevel(' + level + ') failed: ', error);
                        }
                }
                return {
                    id: id,
                    state: state.asReadOnly(),
                    load: load,
                    unload: unload,
                    onLoaded: onLoaded,
                    onUnloaded: onUnloaded,
                    event: event.observer,
                    setContainer: setContainer,
                    setLogLevel: setLogLevel,
                    invoke: invoke
                };
            }
            Media.PluginComponent = PluginComponent;
            (function (PluginComponent) {
                PluginComponent.State = Enum('Unloaded', 'Unloading', 'Loading', 'Loaded');
                PluginComponent.UnloadReason = Enum('None', 'CreateFailed', 'LoadFailed', 'UserInitiated', 'PluginInitiated', 'PluginClosedUnexpectedly');
            })(PluginComponent = Media.PluginComponent || (Media.PluginComponent = {}));
        })(Media = Web.Media || (Web.Media = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Media;
        (function (Media) {
            'use strict';
            var assert = Web.Utils.assert;
            var isString = Web.Utils.isString;
            var isNumber = Web.Utils.isNumber;
            var isBoolean = Web.Utils.isBoolean;
            /**
             * JavaScript supports signed integers |x| < 2^53. BigInt represents a signed 64-bit
             * integer (__int64 or "long long" in C++) as high and low 32-bit parts (+ sign)
             *
             * @constructor BigInt(string) - initialize the object from a string
             * @constructor BigInt(long) - initialize the object from a long
             * @constructor BigInt(high, low, [sign]) - initialize the object from high and low parts and an optional sign
             *
             * @method empty() - reset the object
             * @method fromString(string) - reset the object from a string
             * @method toString(string) - serialize the object to string
             *
             * @example
             *
             *   var bigInt = BigInt(1024, 2048);
             *   assert(bigInt.toString() == '1024,2048,false');
             *
             */
            function BigInt(_lo, _hi, _sign) {
                var high = 0, low = 0, isNegative = false;
                if (arguments.length == 1) {
                    if (isString(arguments[0]))
                        fromString(arguments[0]);
                    else if (isNumber(arguments[0]))
                        fromLong(arguments[0]);
                    else
                        throw new Error('invalid argument');
                }
                else if (arguments.length >= 2) {
                    assert(isNumber(arguments[0]));
                    assert(isNumber(arguments[1]));
                    assert(!arguments[2] || isBoolean(arguments[2]));
                    high = arguments[0];
                    low = arguments[1];
                    isNegative = arguments[2] || false;
                }
                function empty() {
                    high = 0;
                    low = 0;
                    isNegative = false;
                }
                function toString() {
                    return high + ',' + low + ',' + isNegative;
                }
                function fromString(str) {
                    assert(isString(str));
                    var args = str.split(',');
                    if (args.length < 2)
                        throw new Error('invalid argument format');
                    empty();
                    high = parseInt(args[0]);
                    low = parseInt(args[1]);
                    isNegative = sign(args[2]);
                }
                function sign(arg) {
                    var negative = false;
                    if (arg === undefined)
                        return false;
                    assert(isString(arg));
                    switch (arg) {
                        case 'true':
                            negative = true;
                            break;
                        case 'false':
                            negative = false;
                            break;
                        default:
                            throw new Error('invalid argument format');
                    }
                    return negative;
                }
                function fromLong(value) {
                    assert(isNumber(value));
                    if (value > 0x80000000 || value <= -0x80000000) {
                        throw new RangeError('out of range');
                    }
                    high = 0;
                    isNegative = false;
                    if (value < 0) {
                        value = -value;
                        isNegative = true;
                    }
                    low = value & 0xFFFFFFFF;
                }
                return {
                    toString: toString,
                    fromString: fromString,
                    empty: empty
                };
            }
            Media.BigInt = BigInt;
        })(Media = Web.Media || (Web.Media = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="PluginComponent.ts" />
/// <reference path="BigInt.ts" />
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Media;
        (function (Media) {
            'use strict';
            var guid = Web.Utils.guid;
            var async = Web.Utils.async;
            var assert = Web.Utils.assert;
            var extend = Web.Utils.extend;
            var isNumber = Web.Utils.isNumber;
            var isString = Web.Utils.isString;
            var isBoolean = Web.Utils.isBoolean;
            var singleton = Web.Utils.singleton;
            var StringEnum = Web.Utils.StringEnum;
            var Task = Web.Utils.Task;
            var Property = Web.Utils.Property;
            var Exception = Web.Utils.Exception;
            var Collection = Web.Utils.Collection;
            /**
             * Encapsulates the native LWA media plugin.
             *
             * Loads/unloads the plugin into the browser,
             * controls the plugin lifetime and allows the application to
             * load individual plugin components.
             *
             */
            Media.PluginManager = singleton(function () {
                var components = {}, // Plugin components controlled by PluginManager
                pluginObj = null, // PluginManager plugin object
                state = Property({ value: Media.PluginManager.State.Uninitialized }), language, isRtl, tm, loadTimerId = 0, loadTimeout = 5000, pingTimerId = 0, pingTimeout = 6000, task;
                var installedPlugin = Property();
                // no need to initialize pluginObj to check whether plugin is installed,
                // which means a get of this property may not result in plugin version
                // being populated
                var isPluginInstalled = Property({
                    get: getPluginInstallState
                });
                // default plugin download links
                var pluginDownloadLinks = Collection({
                    get: getPluginDownloadLinks
                });
                // need to initialize pluginObj to check installed plugin version,
                // which means a get of this property always results in isPluginInstalled
                // being populated
                var installedVersion = Property({
                    // TODO: currently init is always called with the default 'language'
                    // and 'rtl'. If that changes in DevicesManager/SharedResources in the
                    // future, we need to make it consistent here.
                    get: function () { return init().then(getPluginVersion); }
                });
                Media.watch('PluginManager::state', state);
                /**
                 * Initializes PluginManager by creating PluginManager plugin object
                 *
                 * @param {string} specs.language - language, i.e. "en-us", "ru-ru"
                 * @param {bool}   specs.rtl - is a right-to-left script?
                 *
                 * @returns {Promise}
                 */
                function init(specs) {
                    tm && tm.record(Web.TelemetryEvent.PluginManager, {
                        action: 'init',
                        state: state()
                    });
                    if (state() == Media.PluginManager.State.Uninitialized) {
                        var id = '__mainPluginManager_' + guid().replace(/-/g, '_');
                        Media.log('PluginManager::init - id = ' + id);
                        language = (specs && specs.language) || "en-us";
                        isRtl = (specs && specs.rtl) || false;
                        var PluginObjectCtor_1 = (specs && specs.PluginObject) || Media.PluginObject;
                        tm = specs && specs.tm;
                        assert(!task || task.state() != 'pending');
                        task = new Task('Loading the media plugin.', {
                            cancel: function (reason) {
                                Media.log('PluginManager::init canceled ' + id);
                                stopLoadTimer();
                                reset(reason);
                                task.reject(reason);
                            }
                        });
                        tm && tm.monitor(task.promise, Web.TelemetryEvent.PluginManager, {
                            action: 'initPluginMgr',
                            state: state(),
                            id: id
                        });
                        state.set(Media.PluginManager.State.Initializing);
                        isPluginInstalled.get().then(function (installed) {
                            if (!installed)
                                throw Exception('PluginNotInstalled');
                            pluginObj = PluginObjectCtor_1({
                                id: id,
                                managerId: '_'
                            });
                            pluginObj.event(onPluginObjectEvent, 'async');
                            pluginObj.state.changed(onPluginObjectState);
                            Media.watch('pluginObject(' + id + ')::state', state);
                            Media.log('PluginManager::init - creating inner object');
                            try {
                                pluginObj.createInnerObject({
                                    hide: true,
                                    hookEvents: true
                                });
                            }
                            catch (err) {
                                state.set(Media.PluginManager.State.Uninitialized);
                                if (task.state() == 'pending')
                                    task.reject(err);
                            }
                        }).catch(function (err) {
                            state.set(Media.PluginManager.State.Uninitialized);
                            if (task.state() == 'pending')
                                task.reject(err);
                        });
                    }
                    else {
                        // init has already been called and the plugin is either 
                        // initializing or is already initialized; in either case
                        // we will return an existing promise
                        assert(task);
                    }
                    return task.promise;
                }
                /**
                 * Uninitializes PluginManager by unloading all loaded components and
                 * the main plugin object
                 */
                function uninit() {
                    Media.log('PluginManager::uninit');
                    assert(!task || task.state() != 'pending');
                    task = new Task('Unloading the media plugin.');
                    try {
                        tm && tm.monitor(task.promise, Web.TelemetryEvent.PluginManager, {
                            action: 'uninit',
                            state: state(),
                            id: id
                        });
                        // unload components
                        for (var id in components)
                            components[id].unload();
                        if (pluginObj) {
                            state.set(Media.PluginManager.State.Uninitializing);
                            pluginObj.innerObject().UnLoad();
                        }
                        reset();
                        task.resolve();
                    }
                    catch (error) {
                        reset(error);
                        task.reject(error);
                    }
                    stopLoadTimer();
                    stopPingTimer();
                    return task.promise;
                }
                function reset(reason) {
                    resetPluginInstallState();
                    cleanupPluginObject(reason);
                    state.set(Media.PluginManager.State.Uninitialized);
                }
                /**
                 * main plugin object cleanup
                 */
                function cleanupPluginObject(reason) {
                    Media.log('PluginManager::cleanupPluginObject', reason || '');
                    if (!pluginObj)
                        return;
                    tm && tm.record(Web.TelemetryEvent.PluginManager, {
                        action: 'cleanupPluginObject',
                        reason: reason
                    });
                    pluginObj.event.off(onPluginObjectEvent);
                    pluginObj.state.changed.off(onPluginObjectState);
                    pluginObj.destroyInnerObject();
                    pluginObj = null;
                }
                function setPingTimeout(timeout) {
                    pingTimeout = timeout;
                }
                /**
                 * returns the identifier of the main plugin object
                 */
                function id() {
                    assert(pluginObj);
                    return pluginObj.id();
                }
                /**
                 * Creates a plugin component
                 */
                function createComponent(specs) {
                    assert(specs);
                    assert(isString(specs.type));
                    assert(isBoolean(specs.hide));
                    assert(state() == Media.PluginManager.State.Initialized);
                    Media.log('PluginManager::createComponent ' + specs.type);
                    tm && tm.record(Web.TelemetryEvent.PluginManager, {
                        action: 'createComponent',
                        specs: JSON.stringify(specs)
                    });
                    extend(specs, { pluginManager: Media.PluginManager(), tm: tm });
                    var component = Media.PluginComponent(specs);
                    var thisId = component.id();
                    var onComponentState = function (stateValue) {
                        Media.log('PluginManager::onComponentState ' + stateValue);
                        if (stateValue == Media.PluginComponent.State.Unloaded) {
                            if (components[thisId]) {
                                components[thisId].state.changed.off(onComponentState);
                                delete components[thisId];
                            }
                        }
                        else if (stateValue == Media.PluginComponent.State.Loaded) {
                        }
                    };
                    // do not change the order of the next two statements - if you do, the immediate execution  
                    // of the component state event handler while component is 'Unloaded' will orphan the component 
                    component.state.changed(onComponentState);
                    components[thisId] = component;
                    return component;
                }
                /**
                 * main plugin object event handler
                 */
                function onPluginObjectEvent(type, args) {
                    var arg0;
                    switch (type) {
                        case '__FxLoadComplete':
                            assert(args.length == 1);
                            arg0 = args[0];
                            assert(isNumber(arg0));
                            Media.log('PluginManager::onPluginObjectEvent ' + type + ' ' + arg0);
                            stopLoadTimer();
                            if (arg0 == Media.PluginLoadResult.LoadSuccessful &&
                                state() == Media.PluginManager.State.Initializing) {
                                tm && tm.record(Web.TelemetryEvent.PluginManager, {
                                    action: 'pluginObjectLoadSuccessful'
                                });
                                state.set(Media.PluginManager.State.Initialized);
                                startPingTimer();
                                getPluginVersion(); // populate installedVersion
                                task.resolve();
                            }
                            else {
                                tm && tm.record(Web.TelemetryEvent.PluginManager, {
                                    action: 'pluginObjectLoadError',
                                    reason: arg0
                                });
                                cleanupPluginObject(Error(arg0));
                                state.set(Media.PluginManager.State.Uninitialized);
                                if (task.state() == 'pending')
                                    task.reject(Exception.call('onPluginObjectEvent failed with result ' + arg0, Web.Utils.enumName(Media.PluginLoadResult, arg0)));
                            }
                            break;
                        case '__FxUnLoadComplete':
                            Media.log('PluginManager::onPluginObjectEvent ' + type);
                            tm && tm.record(Web.TelemetryEvent.PluginManager, {
                                action: 'pluginObjectUnloadComplete'
                            });
                            stopLoadTimer();
                            stopPingTimer();
                            reset();
                            task.resolve();
                            break;
                        case '__FxComponentLoadComplete':
                            tm && tm.record(Web.TelemetryEvent.PluginManager, {
                                action: 'pluginObjectComponentLoadComplete',
                                reason: args[0]
                            });
                            assert(args.length == 1);
                            arg0 = args[0];
                            assert(isString(arg0));
                            Media.log('PluginManager::onPluginObjectEvent ' + type + ' ' + arg0);
                            if (components[arg0]) {
                                components[arg0].onLoaded();
                            }
                            break;
                        case '__FxComponentUnLoadComplete':
                            tm && tm.record(Web.TelemetryEvent.PluginManager, {
                                action: 'pluginObjectComponentUnloadComplete',
                                reason: args[0]
                            });
                            assert(args.length == 1);
                            arg0 = args[0];
                            assert(isString(arg0));
                            Media.log('PluginManager::onPluginObjectEvent ' + type + ' ' + arg0);
                            if (components[arg0])
                                components[arg0].onUnloaded();
                            break;
                        case '__FxPing':
                            startPingTimer();
                            break;
                    }
                }
                /**
                 * main plugin object state change event handler
                 */
                function onPluginObjectState(value) {
                    Media.log('PluginManager::onPluginObjectState ' + value);
                    tm && tm.record(Web.TelemetryEvent.PluginManager, {
                        action: 'onPluginObjectState',
                        id: id(),
                        state: value
                    });
                    switch (value) {
                        case Media.PluginObject.State.None:
                            // initial state - ignore
                            break;
                        case Media.PluginObject.State.Created:
                            // nothing interesting - ignore
                            break;
                        case Media.PluginObject.State.Attached:
                            Web.window.setTimeout(loadManager, 0);
                            break;
                        case Media.PluginObject.State.NotInstalled:
                            var err = Exception('PluginNotInstalled');
                            cleanupPluginObject(err);
                            state.set(Media.PluginManager.State.Uninitialized);
                            if (task.state() == 'pending')
                                task.reject(err);
                            break;
                        default:
                            stopLoadTimer();
                            cleanupPluginObject();
                            state.set(Media.PluginManager.State.Uninitialized);
                    }
                }
                /**
                 * Loads plugin component manager
                 */
                function loadManager() {
                    Media.log('PluginManager::loadManager');
                    if (state() != Media.PluginManager.State.Initializing ||
                        pluginObj.state() != Media.PluginObject.State.Attached)
                        return;
                    try {
                        startLoadTimer();
                        pluginObj.innerObject().Load('__pluginFx', [language, isRtl]);
                    }
                    catch (error) {
                        stopLoadTimer();
                        cleanupPluginObject(error);
                        state.set(Media.PluginManager.State.Uninitialized);
                    }
                }
                /**
                 * Checks the existence of the main plugin object
                 */
                function pluginObjectExists() {
                    var exists = false;
                    try {
                        exists = pluginObj.innerObject().CheckExistence();
                    }
                    catch (error) {
                        tm && tm.record(Web.TelemetryEvent.PluginManager, {
                            action: 'CheckExistence',
                            state: state(),
                            result: 'failed',
                            reason: error,
                            id: id()
                        });
                    }
                    return exists;
                }
                function startLoadTimer() {
                    stopLoadTimer();
                    loadTimerId = Web.window.setTimeout(onLoadTimeout, loadTimeout);
                }
                function stopLoadTimer() {
                    if (loadTimerId != 0) {
                        Web.window.clearTimeout(loadTimerId);
                        loadTimerId = 0;
                    }
                }
                function onLoadTimeout() {
                    if (pluginObjectExists()) {
                        startLoadTimer();
                    }
                    else {
                        stopLoadTimer();
                        cleanupPluginObject(Error('TimedOut'));
                        state.set(Media.PluginManager.State.Uninitialized);
                    }
                }
                function startPingTimer() {
                    stopPingTimer();
                    pingTimerId = Web.window.setTimeout(onPingTimeout, pingTimeout);
                }
                function stopPingTimer() {
                    if (pingTimerId != 0) {
                        Web.window.clearTimeout(pingTimerId);
                        pingTimerId = 0;
                    }
                }
                function onPingTimeout() {
                    if (Media.UserAgent().isMac()) {
                        // On mac there is no native timeout, so we use this timer to track the existence of the plugin
                        startPingTimer();
                    }
                    else {
                        // On windows this will get hit if the plugin loaded/pinged once but not again for 5 seconds.
                        stopPingTimer();
                    }
                    if (!pluginObjectExists()) {
                        uninit();
                        Media.log('PluginManager::onPingTimeout - uninit due to missed ping');
                        tm && tm.record(Web.TelemetryEvent.PluginManager, {
                            action: 'uninitPluginMgr',
                            reason: 'pingMissed'
                        });
                    }
                }
                function queryActiveXPlugin(plugins) {
                    for (var _i = 0, plugins_1 = plugins; _i < plugins_1.length; _i++) {
                        var p = plugins_1[_i];
                        try {
                            var obj = new ActiveXObject(p.VERSION_QUERY);
                            installedPlugin(p);
                            return obj;
                        }
                        catch (err) {
                        }
                    }
                }
                function queryNpapiPlugin(plugins) {
                    Web.window.navigator.plugins.refresh(); // check for newly installed plugins but don't reload page
                    for (var _i = 0, plugins_2 = plugins; _i < plugins_2.length; _i++) {
                        var p = plugins_2[_i];
                        if (p.MIME_TYPE in Web.window.navigator.mimeTypes) {
                            installedPlugin(p);
                            return true;
                        }
                    }
                    return false;
                }
                /**
                 * Update and return plugin installation status.
                 */
                function getPluginInstallState() {
                    var isInstalled = false, reason, obj;
                    var latest = [Media.PluginManager.LYNC_PLUGINS.LATEST];
                    var compat = Media.PluginManager.LYNC_PLUGINS.COMPATIBLE;
                    var obsolete = Media.PluginManager.LYNC_PLUGINS.OBSOLETE;
                    if (Media.UserAgent().isIE()) {
                        if (obj = queryActiveXPlugin(latest)) {
                            // latest version
                            isInstalled = true;
                        }
                        else if (obj = queryActiveXPlugin(compat)) {
                            // compatible version
                            isInstalled = true;
                            reason = 'CompatiblePluginInstalled';
                        }
                        else if (obj = queryActiveXPlugin(obsolete)) {
                            // obsolete version
                            reason = 'ObsoletePluginInstalled';
                        }
                        else {
                            reason = 'NoPluginInstalled';
                        }
                    }
                    else if (Web.window.navigator.mimeTypes) {
                        if (queryNpapiPlugin(latest)) {
                            isInstalled = true;
                        }
                        else if (queryNpapiPlugin(compat)) {
                            isInstalled = true;
                            reason = 'CompatiblePluginInstalled';
                        }
                        else if (queryNpapiPlugin(obsolete)) {
                            reason = 'ObsoletePluginInstalled';
                        }
                        else {
                            reason = 'NoPluginInstalled';
                        }
                    }
                    else {
                        reason = 'NoPluginInstalled';
                    }
                    getPluginVersion(obj);
                    getPluginDownloadLinks();
                    isPluginInstalled(isInstalled, reason);
                    return isInstalled;
                }
                /**
                 * Reset plugin installation status.
                 */
                function resetPluginInstallState() {
                    isPluginInstalled(void 0);
                    installedPlugin(void 0);
                    pluginDownloadLinks.removeAll(function () { return true; });
                    installedVersion(void 0);
                }
                /**
                 * Populate plugin version.
                 */
                function getPluginVersion(obj) {
                    var version;
                    if (pluginObj && pluginObj.innerObject()) {
                        // plugin already loaded
                        try {
                            version = pluginObj.innerObject().GetVersion();
                        }
                        catch (err) {
                        }
                    }
                    if (!version && obj) {
                        try {
                            // plugin not loaded yet, version may be available in ActiveXObject
                            version = obj.GetVersion();
                        }
                        catch (err) {
                        }
                    }
                    if (version) {
                        version = version.replace(/@/g, '.');
                        installedVersion(version);
                    }
                    return version;
                }
                /**
                 * Populate default plugin download links.
                 */
                function getPluginDownloadLinks() {
                    var latest = Media.PluginManager.LYNC_PLUGINS.LATEST;
                    if (latest.DOWNLOAD.MSI && !(pluginDownloadLinks.index('msi') >= 0))
                        pluginDownloadLinks.add(latest.DOWNLOAD.MSI, 'msi');
                    if (latest.DOWNLOAD.PKG && !(pluginDownloadLinks.index('pkg') > 0))
                        pluginDownloadLinks.add(latest.DOWNLOAD.PKG, 'pkg');
                    if (latest.DOWNLOAD.DMG && !(pluginDownloadLinks.index('dmg') > 0))
                        pluginDownloadLinks.add(latest.DOWNLOAD.DMG, 'dmg');
                    return pluginDownloadLinks();
                }
                return {
                    init: async(init),
                    uninit: async(uninit),
                    createComponent: createComponent,
                    isPluginInstalled: isPluginInstalled.asReadOnly(),
                    installedPlugin: installedPlugin,
                    pluginDownloadLinks: pluginDownloadLinks.asReadOnly(),
                    installedVersion: installedVersion.asReadOnly(),
                    state: state.asReadOnly(),
                    id: id,
                    setPingTimeout: setPingTimeout
                };
            });
            Media.PluginManager.State = StringEnum('Uninitialized', 'Uninitializing', 'Initializing', 'Initialized');
            // These are provided by each plugin build (inside the <build-name>.js or the
            // cs file). Update it when the plugin is changed.
            Media.PluginManager.LYNC_PLUGINS = {
                LATEST: {
                    MIME_TYPE: "application/x-skypeforbusiness-plugin-16.2",
                    MIME_TYPE_VERSION: "application/x-skypeforbusiness-version-16.2",
                    SHELLAPP_URL_SCHEME: "sfb",
                    SHELLAPP_ID: "com.microsoft.skypeforbusiness.shellapp",
                    VERSION_QUERY: "Microsoft.SkypeForBusinessPlugin16.2.VersionQuery",
                    // download links may be provided as app level settings such as
                    // 'plugin.download.msi' and 'plugin.download.pkg'; and populated
                    // inside DevicesManager. If these settings are not provided, the
                    // default download links can be specified here.
                    DOWNLOAD: {
                        MSI: "to-be-filled: latest msi plugin download link in CDN",
                        PKG: "to-be-filled: latest pkg plugin download link in CDN",
                        DMG: "to-be-filled: latest dmg plugin download link in CDN"
                    }
                },
                COMPATIBLE: [
                    {
                        MIME_TYPE: "application/x-skypeforbusiness-plugin-16.1",
                        MIME_TYPE_VERSION: "application/x-skypeforbusiness-version-16.1",
                        SHELLAPP_URL_SCHEME: "sfb-16.1",
                        SHELLAPP_ID: "com.microsoft.skypeforbusiness.shellapp.16.1",
                        VERSION_QUERY: "Microsoft.SkypeForBusinessPlugin16.1.VersionQuery"
                    },
                    {
                        MIME_TYPE: "application/x-skypeforbusiness-plugin-16.0",
                        MIME_TYPE_VERSION: "application/x-skypeforbusiness-version-16.0",
                        SHELLAPP_URL_SCHEME: "sfb-16.0",
                        SHELLAPP_ID: "com.microsoft.skypeforbusiness.shellapp.16.0",
                        VERSION_QUERY: "Microsoft.SkypeForBusinessPlugin16.0.VersionQuery"
                    }
                ],
                OBSOLETE: [
                    {
                        MIME_TYPE: "application/x-lwa-nativeplugin15.8",
                        MIME_TYPE_VERSION: "application/x-lwa-nativeplugin-version15.8",
                        SHELLAPP_URL_SCHEME: "sfb-w16-v2",
                        SHELLAPP_ID: "com.microsoft.skypeforbusiness.shellapp",
                        VERSION_QUERY: "Microsoft.LWA64Plugin15.8.VersionQuery"
                    }
                ]
            };
        })(Media = Web.Media || (Web.Media = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="utils.ts" />
/// <reference path="media/plugin/PluginManager.ts" />
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Settings;
        (function (Settings) {
            /** Dumps to the dev console all media logs */
            Settings.logMedia = false;
            /** Setting this to true to debug plugin-based scenarios in WebRTC/ORTC capable browsers */
            Settings.dbgPlugin = false;
        })(Settings = Web.Settings || (Web.Settings = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
(function (Skype) {
    var Web;
    (function (Web) {
        var Media;
        (function (Media) {
            'use strict';
            var debug = Web.Utils.debug;
            function log() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                debug.log.apply(debug, [Web.Settings.logMedia, '[MEDIA] '].concat(args));
            }
            Media.log = log;
            function watch(description, p) {
                debug.watch(Web.Settings.logMedia, '[MEDIA] ' + description, p);
            }
            Media.watch = watch;
            function useBrowserMedia() {
                return !Web.Settings.dbgPlugin && Media.MediaAgent.isPlatformSupported();
            }
            Media.useBrowserMedia = useBrowserMedia;
            function isOrtc() {
                return typeof RTCIceGatherer != 'undefined' && !Web.Settings.mediaAgent;
            }
            Media.isOrtc = isOrtc;
            function isWebRtc() {
                return typeof RTCPeerConnection != 'undefined' && typeof RTCIceGatherer == 'undefined' && !Web.Settings.mediaAgent;
            }
            Media.isWebRtc = isWebRtc;
        })(Media = Web.Media || (Web.Media = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                /**
                 * Wraps the rel=mediaPolicies resource into an observable model.
                 *
                 * rel=mediaPolicies represents a resource that allows clients to fetch
                 * all media-related settings that cannot be modeled as capability links
                 * or properties of individual resources. Most of them are directly consumed
                 * by media stack manager on the client side.
                 *
                 */
                var MediaPolicies = (function () {
                    //#endregion
                    function MediaPolicies(ucwa) {
                        function tryParseInt(src) {
                            var num = +src | 0;
                            return num == src ? num : src;
                        }
                        return Internal.ObservableResource(ucwa, { rel: 'mediaPolicies' }, function ($) {
                            $.property('bandwidthControl');
                            $.property('fipsCompliantMedia');
                            $.property('poorDeviceWarnings');
                            $.property('poorNetworkWarnings');
                            $.property('portRange');
                            $.property('qualityOfService');
                            $.property('audioVideoEncryption');
                            $.property('audioBitRate', tryParseInt);
                            $.property('audioBypass');
                            $.property('audioBypassId');
                            $.property('internalAudioBypassMode');
                            $.property('externalAudioBypassMode');
                            $.property('minimumAudioPort', tryParseInt);
                            $.property('maximumAudioPort', tryParseInt);
                            $.property('minimumVideoPort', tryParseInt);
                            $.property('maximumVideoPort', tryParseInt);
                            $.property('maximumVideoRateAllowed');
                            $.property('multiViewJoin');
                            $.property('totalReceivedVideoBitRateKB', tryParseInt);
                            $.property('video');
                            $.property('videoBitRate', tryParseInt);
                            $.property('applicationSharingBitRate', tryParseInt);
                            $.property('applicationSharingEncryption');
                            $.property('minimumApplicationSharingPort', tryParseInt);
                            $.property('maximumApplicationSharingPort', tryParseInt);
                            $.property('highPerformanceApplicationSharingInOnlineMeeting');
                        });
                    }
                    return MediaPolicies;
                }());
                Internal.MediaPolicies = MediaPolicies;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var async = Web.Utils.async;
                var check = Web.Utils.check;
                var Promise = Web.Utils.Promise;
                var PluginManager = Web.Media.PluginManager;
                /**
                 * Encapsulates media plugin functionality.
                 * The AV modality takes a reference to this object and
                 * uses it to communicate with the media plugin.
                 * Unit tests create a mock of this object.
                 */
                var MediaPlugin = (function () {
                    //#endregion
                    function MediaPlugin(ucwa, tm, settings) {
                        var mediaConfig, appSharing, pluginStateSub;
                        function getMediaConfig() {
                            var promise;
                            if (!mediaConfig) {
                                promise = initMedia().then(function () { return ucwa.init(); }).then(function () {
                                    mediaConfig = Internal.MediaConfig({
                                        ucwa: ucwa,
                                        mediaPlugin: self,
                                        tm: tm
                                    });
                                    return mediaConfig.init();
                                });
                            }
                            else if (mediaConfig.mrasTokenExpired()) {
                                promise = mediaConfig.renewMrasToken();
                            }
                            else
                                promise = Promise.resolve();
                            return promise.then(function () { return mediaConfig; });
                        }
                        function getAppSharing(language) {
                            return appSharing ||
                                initMedia(language).then(getMediaConfig).then(function () {
                                    appSharing = Internal.AppSharing({
                                        mediaConfig: mediaConfig,
                                        component: createComponent({
                                            type: 'AppShareCore',
                                            hide: true
                                        })
                                    });
                                    return appSharing.init();
                                }).then(function () {
                                    return appSharing;
                                });
                        }
                        function initMedia(language) {
                            if (language === void 0) { language = 'en-us'; }
                            check(PluginManager, 'NoMedia');
                            pluginStateSub = pluginStateSub || PluginManager().state.changed(function (newVal, reason, oldVal) {
                                if (newVal == PluginManager.State.Uninitialized) {
                                    uninitMediaConfig();
                                    uninitAppSharing();
                                }
                            });
                            if (settings && settings.pluginPingTimeout) {
                                PluginManager().setPingTimeout(settings.pluginPingTimeout);
                            }
                            // TODO: deduce rtl from language
                            var rtl = false;
                            return PluginManager().init({
                                language: language,
                                rtl: rtl,
                                tm: tm
                            });
                        }
                        function uninitMedia() {
                            uninitMediaConfig();
                            uninitAppSharing();
                            if (pluginStateSub) {
                                pluginStateSub.dispose();
                                pluginStateSub = null;
                            }
                            return PluginManager().uninit();
                        }
                        function uninitMediaConfig() {
                            if (mediaConfig) {
                                mediaConfig.uninit();
                                mediaConfig = null;
                            }
                        }
                        function uninitAppSharing() {
                            if (appSharing) {
                                appSharing.uninit();
                                appSharing = null;
                            }
                        }
                        function createComponent(options) {
                            return PluginManager().createComponent(options);
                        }
                        var self = {
                            getMediaConfig: async(getMediaConfig),
                            getAppSharing: async(getAppSharing),
                            initMedia: async(initMedia),
                            uninitMedia: async(uninitMedia),
                            uninitAppSharing: async(uninitAppSharing),
                            createComponent: createComponent
                        };
                        return self;
                    }
                    return MediaPlugin;
                }());
                Internal.MediaPlugin = MediaPlugin;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var async = Web.Utils.async;
                var assert = Web.Utils.assert;
                var Task = Web.Utils.Task;
                var Property = Web.Utils.Property;
                var EWrongType = Web.Utils.EWrongType;
                var StringEnum = Web.Utils.StringEnum;
                var log = Web.Media.log;
                /**
                 * Media configuration model.
                 *
                 * @param {UCWA} ucwa
                 * @param {MediaPlugin} mediaPlugin
                 *
                 * @method {Promise} init - initialized media configuration
                 * @method uninit - uninitializes media configuration
                 * @method {Boolean} isInternal - indicates whether this client is signed in on the internal or external network
                 * @method {MediaEnum.SecurityLevel} audioVideoSecurityLevel - returns audio/video security level
                 * @method {MediaEnum.SecurityLevel}applicationSharingSecurityLevel - returns app sharing security level
                 * @method {Number} maxVideoChannelCount - returns the max number of video channels
                 * @method  setDefaultDevices - sets default media devices
                 * @property {MediaConfig.ProxyDetection} proxyDetection - proxy detection state
                 *
                 */
                function MediaConfig(options) {
                    var ucwa = options.ucwa, mediaPlugin = options.mediaPlugin, isInternal = ucwa.get({ rel: 'root' }, null) ? !!ucwa.get({ rel: 'root' }).get('internal', false) : false, pcMediaConfig, proxyDetection = Property({ value: MediaConfig.ProxyDetection.None }), proxies = {}, tm = options.tm, mrasTokenExpiration = 0, EnforcementPolicy = StringEnum('Enforced', 'Supported', 'NotSupported');
                    options = null;
                    /**
                     * Initializes media configuration by loading MediaPlatformConfig plugin component,
                     * fetching media config from UCWA server and passing it to the plugin component
                     */
                    function init() {
                        pcMediaConfig = mediaPlugin.createComponent({
                            type: 'MediaPlatformConfig',
                            hide: true
                        });
                        pcMediaConfig.event(onPluginComponentEvent);
                        pcMediaConfig.state.changed(function (state) {
                            log('pcMediaConfig.state = ' + state);
                        });
                        var p = pcMediaConfig.load().then(setMediaConfig).catch(function (error) {
                            log('MediaConfig::init rejected');
                            uninit();
                            throw error;
                        });
                        return p;
                    }
                    /**
                     * Uninitializes media configuration
                     */
                    function uninit() {
                        if (pcMediaConfig) {
                            pcMediaConfig.event.off(onPluginComponentEvent);
                            pcMediaConfig = null;
                        }
                    }
                    /**
                     * MediaPlatformConfig component event listener
                     */
                    function onPluginComponentEvent(ev) {
                        if (ev.type == 'ProxyDetectionCompleted') {
                            // args0 (string) - the host name, args1 (boolean) - was the proxy detected or not
                            proxies[ev.args[0]] = (ev.args[1] == 'true') ?
                                MediaConfig.ProxyDetection.Succeeded :
                                MediaConfig.ProxyDetection.Failed;
                            // we signal that proxy detection is completed once we received the plugin event
                            // for all tested proxies.
                            var done = true, res = MediaConfig.ProxyDetection.Failed;
                            for (var p in proxies) {
                                switch (p) {
                                    case MediaConfig.ProxyDetection.None:
                                    case MediaConfig.ProxyDetection.Started:
                                        done = false;
                                        break;
                                    case MediaConfig.ProxyDetection.Succeeded:
                                        res = MediaConfig.ProxyDetection.Succeeded;
                                        break;
                                }
                            }
                            if (done)
                                proxyDetection(res);
                        }
                    }
                    /**
                     * Fetches media configuration from UCWA server and sets it in the plugin.
                     */
                    function setMediaConfig() {
                        return Task.waitAll([
                            ucwa.send('GET', { rel: 'mediaPolicies' }).then(function () {
                                return setMediaPolicies();
                            }).catch(function (err) {
                                // swallow the exception since media plugin may still work
                                // without media policies
                                log('MediaConfig::getMediaPolicies error: ', err);
                                tm && tm.record(Web.TelemetryEvent.Call, {
                                    action: 'getMediaPolicies',
                                    mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                    result: 'failed',
                                    reason: err
                                });
                            }),
                            renewMrasToken()
                        ]);
                    }
                    function renewMrasToken() {
                        var dfd = ucwa.send('GET', { rel: 'mediaRelayAccessToken' }).then(function () {
                            return setMras();
                        }).catch(function (err) {
                            // swallow the exception since media plugin may still work
                            // without media relay
                            log('MediaConfig::getMediaRelayAccessToken error: ', err);
                            tm && tm.record(Web.TelemetryEvent.Call, {
                                action: 'getMediaRelayAccessToken',
                                mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                result: 'failed',
                                reason: err
                            });
                        });
                        tm && tm.monitor(dfd, Web.TelemetryEvent.Call, {
                            action: 'renewMrasToken',
                            mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin'
                        });
                        return dfd;
                    }
                    /**
                     * Set media policies in the plugin
                     */
                    function setMediaPolicies() {
                        tm && tm.record(Web.TelemetryEvent.Call, {
                            action: 'setMediaPolicies',
                            mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                            result: 'started'
                        });
                        var comm = ucwa.get(ucwa.app.relatedHref('communication')), mp = ucwa.get(comm.link('mediaPolicies').href);
                        if (mp.properties.portRange == 'Enabled') {
                            pcMediaConfig.invoke('SetPortRanges', mp.properties['minimumAudioPort'], mp.properties['maximumAudioPort'], mp.properties['minimumVideoPort'], mp.properties['maximumVideoPort'], mp.properties['minimumApplicationSharingPort'], mp.properties['maximumApplicationSharingPort']);
                        }
                        pcMediaConfig.invoke('SetMediaPlatformConfig', mp.properties['qualityOfService'] == 'Enabled', isInternal);
                        pcMediaConfig.invoke('SetMediaSettings', true, // fEnableBWCheck
                        true, // EnableBWPolicyOverride
                        parseInt(mp.properties['audioBitRate']) || -1, parseInt(mp.properties['videoBitRate']) || -1, parseInt(mp.properties['applicationSharingBitRate']) || -1, -1, // file transfer bit rate ignored
                        parseInt(mp.properties['totalReceivedVideoBitRateKB']) || -1, mp.properties['fipsCompliantMedia'] == 'Required');
                        // TODO: param from some user options ??
                        pcMediaConfig.invoke('SetStereoAudioRendering', false);
                        tm && tm.record(Web.TelemetryEvent.Call, {
                            action: 'setMediaPolicies',
                            mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                            result: 'succeeded'
                        });
                    }
                    /**
                     * Set media relay configuration in the plugin
                     */
                    function setMras() {
                        tm && tm.record(Web.TelemetryEvent.Call, {
                            action: 'setMras',
                            mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                            result: 'started'
                        });
                        var comm = ucwa.get(ucwa.app.relatedHref('communication')), mras = ucwa.get(comm.link('mediaRelayAccessToken').href);
                        var username = mras.properties['userName'];
                        var password = mras.properties['password'];
                        var mr, tcpPort, udpPort, hostName, realm = '*';
                        pcMediaConfig.invoke('ClearIceServers');
                        for (var i = 0, len = mras.related.mediaRelay.length; i < len; i++) {
                            mr = ucwa.get(mras.related.mediaRelay[i].href);
                            if ((isInternal && mr.properties['location'] == 'Internet') ||
                                (!isInternal && mr.properties['location'] == 'Intranet'))
                                continue;
                            hostName = mr.properties['host'];
                            tcpPort = mr.properties['tcpPort'] || -1;
                            udpPort = mr.properties['udpPort'] || -1;
                            pcMediaConfig.invoke('AddProxyServer', hostName);
                            proxies[hostName] = MediaConfig.ProxyDetection.Started;
                            if (proxyDetection() == MediaConfig.ProxyDetection.None)
                                proxyDetection(MediaConfig.ProxyDetection.Started);
                            if (udpPort != -1) {
                                try {
                                    pcMediaConfig.invoke('AddIceServer', 1 /* TurnUDP */, hostName, udpPort, username, realm, password);
                                }
                                catch (err) {
                                    log(err.message + ' : UDP ' + hostName + ':' + udpPort);
                                }
                            }
                            if (tcpPort != -1) {
                                try {
                                    pcMediaConfig.invoke('AddIceServer', 2 /* TurnTCP */, hostName, tcpPort, username, realm, password);
                                }
                                catch (err) {
                                    log(err.message + ' : TCP ' + hostName + ':' + tcpPort);
                                }
                            }
                        }
                        var duration = mras.properties['duration'] || 0;
                        duration = duration > 2 ? duration - 2 : 0;
                        mrasTokenExpiration = Web.Date.now() + duration * 60000;
                        tm && tm.record(Web.TelemetryEvent.Call, {
                            action: 'setMras',
                            mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                            result: 'succeeded'
                        });
                    }
                    /**
                     * Sets default audio and video devices
                     */
                    function setDefaultDevices() {
                        assert(pcMediaConfig);
                        pcMediaConfig.invoke('SetDefaultDevices');
                    }
                    /**
                     * Returns AV security level
                     */
                    function getAudioVideoSecurityLevel() {
                        var comm = ucwa.get(ucwa.app.relatedHref('communication')), mp = ucwa.get(comm.link('mediaPolicies').href), encr, level;
                        if (mp) {
                            encr = mp.properties['audioVideoEncryption'];
                            switch (encr) {
                                case EnforcementPolicy.Enforced:
                                    level = 3 /* Required */;
                                    break;
                                case void 0:
                                // anonymous user will not get this media policy from the
                                // server - when undefined we default to 'Supported'.
                                case EnforcementPolicy.Supported:
                                    level = 2 /* Supported */;
                                    break;
                                case EnforcementPolicy.NotSupported:
                                    level = 1 /* Unsupported */;
                                    break;
                                default:
                                    throw EWrongType(encr, 'EnforcementPolicy');
                            }
                        }
                        return level;
                    }
                    /**
                     * Returns AS security level
                     */
                    function getApplicationSharingSecurityLevel() {
                        var comm = ucwa.get(ucwa.app.relatedHref('communication')), mp = ucwa.get(comm.link('mediaPolicies').href), encr, level;
                        if (mp) {
                            encr = mp.properties['applicationSharingEncryption'];
                            switch (encr) {
                                case EnforcementPolicy.Enforced:
                                    level = 3 /* Required */;
                                    break;
                                case void 0:
                                // anonymous user will not get this media policy from the
                                // server - when undefined we default to 'Supported'.
                                case EnforcementPolicy.Supported:
                                    level = 2 /* Supported */;
                                    break;
                                case EnforcementPolicy.NotSupported:
                                    level = 1 /* Unsupported */;
                                    break;
                                default:
                                    throw EWrongType(encr, 'EnforcementPolicy');
                            }
                        }
                        return level;
                    }
                    /**
                     * Returns the number of video channels
                     */
                    function getMaxVideoChannelCount() {
                        var res = pcMediaConfig.invoke('GetMaxVideoChannelCount');
                        return res[1] < 6 ? res[1] : 6;
                    }
                    return {
                        init: async(init),
                        uninit: uninit,
                        isInternal: function () { return isInternal; },
                        audioVideoSecurityLevel: getAudioVideoSecurityLevel,
                        applicationSharingSecurityLevel: getApplicationSharingSecurityLevel,
                        maxVideoChannelCount: getMaxVideoChannelCount,
                        proxyDetection: proxyDetection.asReadOnly(),
                        setDefaultDevices: setDefaultDevices,
                        mrasTokenExpired: function () { return Web.Date.now() > mrasTokenExpiration; },
                        renewMrasToken: renewMrasToken
                    };
                }
                Internal.MediaConfig = MediaConfig;
                (function (MediaConfig) {
                    ;
                    MediaConfig.ProxyDetection = StringEnum('None', 'Started', 'Succeeded', 'Failed');
                })(MediaConfig = Internal.MediaConfig || (Internal.MediaConfig = {}));
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_1) {
            var Internal;
            (function (Internal) {
                'use strict';
                var assert = Web.Utils.assert;
                var DataUri = Web.Utils.DataUri;
                var async = Web.Utils.async;
                var extend = Web.Utils.extend;
                var indexOf = Web.Utils.indexOf;
                var guid = Web.Utils.guid;
                var Property = Web.Utils.Property;
                var check = Web.Utils.check;
                var Exception = Web.Utils.Exception;
                var Task = Web.Utils.Task;
                var Command = Web.Utils.Command;
                var Model = Web.Utils.Model;
                var log = Web.Media.log;
                /**
                 * Starts outgoing app sharing and receives incoming app sharing.
                 * Uses the native media plugin for that.
                 *
                 * @param {UCWA} ucwa
                 * @param {MediaPlugin} mediaPlugin
                 * @param {SharedResources} sharedResources
                 * @param {String} [threadId] - Required for outgoing app sharing.
                 * @param {AppSharingInvitation} [invitation] - Required for incoming app sharing.
                 * @param {Resource} [resource] - Required for incoming app sharing.
                 * @param {Collection} participants
                 * @param {Resource} [rConversation] - The parent rel=conversation resource.
                 *
                 *      If the AS modality gets added to an existing conversation, the AS call
                 *      is started with sending a POST request to rel=conversation/rel=applicationSharing/rel=addScreenSharing.
                 *
                 *      If the AS modality is the first modality in the conversation, then the
                 *      AS call is started with sending the same request to the global rel=startScreenSharing link.
                 *
                 * @property {Modality.State} state
                 * @property {ShareableWindow|ShareableMonitor} shared - the currently shared content
                 *
                 * @member {Participant} from
                 *
                 * @command {Promise} start - Starts an outgoing call.
                 * @command {Promise} accept - Accepts an incoming call.
                 * @command {Promise} decline - Declines an incoming call.
                 * @command {Promise} stop - Stops an ongoing call.
                 *
                 */
                function AppSharingModality(options) {
                    //#region Locals
                    var self = Model(), ucwa = options.ucwa, invitation = options.invitation, rConversation = options.rConversation, // rel=conversation resource
                    participants = options.participants, state = Property({
                        value: invitation ? Internal.Modality.State.Notified :
                            Internal.Modality.State.Created
                    }), threadId = options.threadId, mediaPlugin = options.mediaPlugin, sharedResources = options.sharedResources, mediaConfig, // MediaConfig  - a wrapper around "MediaPlatformConfig" plugin component
                    appSharing, // MediaPlugin wrapper around PluginComponent of type "AppShareCore"
                    pcASUI, // PluginComponent of type "AppShareViewerUI"
                    shareable, // local reference to shareable object (used by start(...))
                    dfdAccept, // a task returned by the accept method
                    dfdStart, // a task returned by the start method
                    to, // SIP URI of the remote party
                    asSession, // applicationSharingSession UCWA resource
                    asRenegotiation, // applicationSharingRenegotiation UCWA resource
                    asInvitation = options.resource, // applicationSharingInvitation UCWA resource
                    outAsRenegoOpIds = {}, // list of outgoing applicationSharingRenegotiation operationId values
                    container, // container object for viewing  shared content
                    wHandle; // handle to App sharing viewer
                    options = null;
                    //#endregion
                    var shared = Property({
                        value: null,
                        get: function () {
                            return shareable;
                        },
                        set: function (val) {
                            return changeShared(val).then(function () {
                                return val;
                            });
                        }
                    });
                    //#region Initialization
                    extend(self, {
                        state: state.asReadOnly(),
                        shared: shared
                    });
                    if (invitation)
                        self.from = invitation.from;
                    state.changed(function (newState, reason, oldState) {
                        log('AppSharingModality::state: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                    });
                    ucwa.event(onServerEvent);
                    //#endregion
                    //#region defineAsyncCommand
                    function defineAsyncCommand(name, states, method) {
                        var enabled = Property();
                        state.changed(function (value) {
                            enabled(indexOf(states, value) >= 0);
                        });
                        self[name] = Command(async(method), enabled);
                    }
                    //#endregion
                    //#region onServerEvent
                    function onServerEvent(event) {
                        var id = event.target.rel + ' ' + event.type;
                        var handler = ucwaEventHandlers[id];
                        if (handler) {
                            // debugger; // this is to let debug the handler of the event
                            handler(event.status, event.resource, event);
                        }
                    }
                    var ucwaEventHandlers = {
                        'applicationSharingInvitation started': function (status, resource) {
                            // @todo: "POST startApplicationSharing" returns a URL of the applicationSharingInvitation resource
                            if (resource.properties.direction == 'Outgoing' &&
                                resource.properties.threadId == threadId) {
                                // assert(!asInvitation);
                                asInvitation = resource;
                                dfdStart.status('awaiting "applicationSharingNegotiation started" event from UCWA');
                            }
                        },
                        'applicationSharingNegotiation started': function (status, resource) {
                            var sdp, remoteEndpoint;
                            if (resource.relatedHref('applicationSharingInvitation') == asInvitation.href) {
                                sdp = DataUri(resource.relatedHref('mediaProvisionalAnswer')).data;
                                remoteEndpoint = resource.get('remoteEndpoint');
                                appSharing.setProvisionalAnswer(true, true, remoteEndpoint, sdp);
                                dfdStart.status('awaiting "applicationSharingNegotiation completed" event from UCWA');
                            }
                        },
                        'applicationSharingNegotiation completed': function (status, resource, event) {
                            if (event.sender.href == asInvitation.href) {
                                switch (status) {
                                    case 'Success':
                                        setFinalAnswer(resource, resource.get('remoteEndpoint'));
                                        dfdStart.status('awaiting "applicationSharingInvitation completed" event from UCWA');
                                        break;
                                    case 'Failure':
                                        dfdStart.status(event.reason && event.reason.message);
                                        break;
                                }
                            }
                        },
                        'applicationSharingSession added': function (status, resource) {
                            if (asInvitation.relatedHref('conversation') == resource.relatedHref('conversation'))
                                asSession = resource;
                        },
                        // handle { type:"completed", status:"Failure", reason:{...}, target:{rel:"applicationSharingInvitation"} }
                        // it may arrive before the "applicationSharingInvitation started" event, which this code does not expect
                        'applicationSharingInvitation completed': function (status, resource) {
                            if (asInvitation && asInvitation.href == resource.href) {
                                if (asInvitation.get('direction', '') == 'Outgoing') {
                                }
                                else if (asInvitation.get('direction', '') == 'Incoming') {
                                    if (status == 'Success') {
                                        try {
                                            // an "applicationSharingRenegotiation started" event may arrive later
                                            completeNegotiation(status);
                                            dfdAccept.resolve();
                                            state(Internal.Modality.State.Connected);
                                        }
                                        catch (error) {
                                            dfdAccept.reject(error);
                                            state(Internal.Modality.State.Disconnected, error);
                                        }
                                    }
                                }
                            }
                        },
                        'applicationSharingRenegotiation started': function (status, resource) {
                            // LWA uses the empty string as the Content-ID for the SDP in the case of renegotiation
                            var sdp, id = '';
                            if (resource.properties.direction == 'Incoming' &&
                                resource.relatedHref('conversation') == asInvitation.relatedHref('conversation')) {
                                sdp = DataUri(resource.relatedHref('mediaOffer')).data;
                                log('Incoming SDP offer:\n' + sdp);
                                Task.wait(null).then(function () {
                                    if (state() === 'Connected' && shareable)
                                        return changeShared(null);
                                }).then(function () {
                                    appSharing.setOffer(false, 1, sdp, id);
                                });
                                // now expect one more ANSWER_READY event from the plugin
                                asRenegotiation = resource;
                            }
                        },
                        'applicationSharingRenegotiation completed': function (status, resource) {
                            if (resource.relatedHref('conversation') == asInvitation.relatedHref('conversation')) {
                                if (resource.get('direction') == 'Outgoing')
                                    setFinalAnswer(resource, asSession.get('remoteEndpoint'));
                                completeNegotiation(status);
                            }
                        },
                        'applicationSharing updated': function (status, resource) {
                            if (asInvitation && resource.href == asInvitation.relatedHref('applicationSharing') &&
                                resource.get('state') == 'Disconnected') {
                                if (resource.hasLink('applicationSharer')) {
                                    asSession = null;
                                    changeShared(null);
                                }
                                else {
                                    cleanup();
                                    state(Internal.Modality.State.Disconnected);
                                }
                            }
                        },
                        'conversation updated': function (status, resource) {
                            if (asInvitation && resource.href == asInvitation.relatedHref('conversation') &&
                                (resource.get('state') == 'Connected' || resource.get('state') == 'Conferenced')) {
                                var appSharing = indexOf(resource.get('activeModalities'), 'ApplicationSharing') >= 0;
                                if (appSharing) {
                                }
                            }
                        }
                    };
                    //#endregion
                    //#region onPluginComponentEvent
                    function onPluginComponentEvent(event) {
                        log('pcAS.event %c ' + event.type, 'color:blue', event.args);
                        var handler = pluginEventHandlers[event.type];
                        if (handler) {
                            // debugger; // this is to let debug the handler of the event
                            handler.apply(null, event.args !== "" ? event.args : null);
                        }
                    }
                    var pluginEventHandlers = {
                        'OFFER_READY': function (hasOffer, diagCode, sdpCount) {
                            var i, offers = [];
                            try {
                                for (i = 0; i < sdpCount; i++) {
                                    offers.push({
                                        sdp: arguments[3 + i * 2],
                                        id: arguments[3 + i * 2 + 1]
                                    });
                                }
                                if (offers.length == 0)
                                    throw Exception('NoSdpOffers', { diagCode: diagCode });
                                if (asSession) {
                                    // expect an "applicationSharingRenegotiation completed" event from UCWA
                                    sendRenegotiationOffer(offers[0].sdp);
                                }
                                else {
                                    // expect an "applicationSharingInvitation started" event from UCWA
                                    sendOffer(offers).then(function () {
                                        dfdStart.resolve();
                                        state(Internal.Modality.State.Connected);
                                    }, function (error) {
                                        dfdStart.reject(error);
                                        state(Internal.Modality.State.Disconnected, error);
                                        cleanup();
                                    }, dfdStart.status);
                                }
                            }
                            catch (error) {
                                if (dfdStart)
                                    dfdStart.reject(error);
                            }
                        },
                        'ANSWER_READY': function (_arg0, sdp) {
                            if (asRenegotiation) {
                                // expect an "applicationSharingRenegotiation completed" after this call
                                ucwa.send('POST', asRenegotiation.link('answer').href, {
                                    headers: { 'Content-Type': 'application/sdp' },
                                    data: sdp,
                                    nobatch: true
                                });
                            }
                            else {
                                dfdAccept.status('sending answer to UCWA');
                                // expect an "applicationSharingRenegotiation started" after this call
                                invitation.acceptWithAnswer(sdp).then(function () {
                                    dfdAccept.status('awaiting a "applicationSharingInvitation completed" event from UCWA');
                                }, function (error) {
                                    state(Internal.Modality.State.Disconnected, error);
                                    dfdAccept.reject(error);
                                }, dfdAccept.status);
                            }
                        },
                        'StopSharing': function () {
                            self.stop();
                        }
                    };
                    //#endregion
                    //#region initMedia
                    function initMedia() {
                        return mediaConfig ?
                            Task.wait(mediaConfig) :
                            mediaPlugin.getMediaConfig() // otherwise load it and return when it becomes available
                                .then(function (mc) {
                                mediaConfig = mc;
                                return mediaConfig;
                            });
                    }
                    //#endregion
                    //#region setupAppShareViewerUI
                    function setupAppShareViewerUI() {
                        assert(!pcASUI);
                        pcASUI = mediaPlugin.createComponent({
                            type: 'AppShareViewerUI',
                            hide: false
                        });
                        pcASUI.setContainer(container);
                        pcASUI.event(onViewerEvent, 'async');
                        return pcASUI.load();
                    }
                    //#endregion
                    //#region prepareAppSharing
                    // Based on supplied role (MediaEnum.AppSharingRole) this function will configure the
                    // needed plugins (AppShareCore/AppShareViewerUI) to allow sharing or viewing content.
                    function prepareAppSharing(role) {
                        function reinitSharing() {
                            return sharedResources.init().then(mediaPlugin.getAppSharing).then(function (as) {
                                appSharing = as;
                                appSharing.event(onPluginComponentEvent, 'async');
                            });
                        }
                        function setupSharer() {
                            return Task.wait(null).then(function () {
                                sharedResources.windows.each(function (item) {
                                    sharedResources.setShared(item.id(), false);
                                });
                                sharedResources.monitors.each(function (item) {
                                    sharedResources.setShared(item.id(), false);
                                    item.selected(false);
                                });
                                sharedResources.setShared(shareable.id(), true);
                                appSharing.setCallConfig();
                                appSharing.setMediaConfig(3 /* BOTH */, 2 /* Sharer */);
                            });
                        }
                        function setupViewer() {
                            return Task.wait(null).then(function () {
                                if (!pcASUI)
                                    return setupAppShareViewerUI();
                            }).then(function () {
                                pcASUI.invoke('CreateAppShareViewerUI');
                                var result = pcASUI.invoke('GetViewerWindow');
                                if (result.length === 2 && result[1])
                                    wHandle = result[1];
                                appSharing.setCallConfig();
                                appSharing.initializeViewer(wHandle);
                                appSharing.connectViewer('connectString');
                                appSharing.setSmartSizingViewer(true);
                                appSharing.setViewerWindowSize(container.offsetWidth, container.offsetHeight);
                                if (isConferencing()) {
                                    appSharing.setMediaConfig(3 /* BOTH */, 1 /* Viewer */);
                                }
                                else {
                                    appSharing.createViewerStream();
                                }
                            });
                        }
                        if (role === 2 /* Sharer */) {
                            if (appSharing) {
                                return setupSharer();
                            }
                            else {
                                return reinitSharing().then(setupSharer);
                            }
                        }
                        else {
                            return Task.wait(null).then(function () {
                                if (appSharing) {
                                    return setupViewer();
                                }
                                else {
                                    return reinitSharing().then(setupViewer);
                                }
                            });
                        }
                    }
                    //#endregion
                    //#region onViewerEvent
                    function onViewerEvent(event) {
                        log('pcASUI.event %c ' + event.type, 'color:blue', event.args);
                        if (event.type == 'SIZE_CHANGED' && appSharing)
                            appSharing.setViewerWindowSize(event.args[0], event.args[1]);
                    }
                    //#endregion
                    //#region isConferencing
                    function isConferencing() {
                        return rConversation && (rConversation.get('state', '') == 'Conferenced' || rConversation.get('state', '') == 'Conferencing');
                    }
                    //#endregion
                    //#region start
                    /**
                     * Starts an outgoing app-sharing call. Under the hood it does the following:
                     *
                     *      - Get an AppSharingComponent from the media plugin.
                     *      - Attaches an event handle for plugin events.
                     *      - Marks all currently shared resources as not shared and shares the new resource.
                     *      - Invokes AppSharingComponent::SetCallConfig.
                     *      - Invokes AppSharingComponent::SetMediaConfig.
                     *      - Gets an OFFER_READY event from the AppSharingComponent.
                     *      - Sends a POST request to startApplicationSharing link with the SDP offer.
                     *      - Gets an "applicationSharingInvitation started" event from UCWA.
                     *      - Gets an "applicationSharingNegotiation started" event from UCWA with a provisional SDP answer.
                     *      - Invokes AppSharingComponent::SetProvisionalAnswer.
                     *      - Gets an "applicationSharingSession added" event.
                     *      - Gets an "applicationSharingNegotiation completed" event with a final SDP answer.
                     *      - Invokes AppSharingComponent::SetFinalAnswer.
                     *      - Gets a "applicationSharingInvitation completed" event from UCWA.
                     *      - Invokes AppSharingComponent::CompleteNegotiation.
                     *      - Gets a "applicationSharingRenegotiation started" event from UCWA.
                     *      - Gets a OFFER_READY event from AppSharingComponent with a new SDP answer.
                     *      - Sends a POST request to applicationSharingSession/renegotiations link.
                     *      - Gets a "applicationSharingRenegotiation completed" event from UCWA with a new SDP answer.
                     *      - Invokes AppSharingComponent::SetFinalAnswer.
                     *      - Invokes AppSharingComponent::CompleteNegotiation.
                     *
                     * @param {String} to - SIP URI of the remote participant.
                     * @param {ShareableWindow} window - Window resource to be shared
                     * @param {ShareableMonitor} monitor - Monitor resource to be shared
                     *
                     * @returns {Promise}
                     *
                     *      This promise gets resolved after the client receives an "applicationSharingInvitation completed" event.
                     *      The "status" property of the promise lets track the progress of the operation.
                     *      Since the promise gets resolved before the renegotiation starts, the progress
                     *      of the renegotiation cannot be monitored with it.
                     */
                    defineAsyncCommand('start', [Internal.Modality.State.Created], function (options) {
                        state(Internal.Modality.State.Connecting);
                        options = options || {};
                        container = options.container;
                        if (!isConferencing()) {
                            to = to || options.to;
                            if (!to) {
                                // find some remote participant
                                participants.each(function (p) {
                                    if (!p.local())
                                        to = p.uri();
                                });
                            }
                            check(to, 'the remote participant URI is not specified');
                        }
                        shareable = options.window || options.monitor;
                        return initMedia().then(function () {
                            return mediaPlugin.getAppSharing().then(function (as) {
                                appSharing = as;
                                appSharing.event(onPluginComponentEvent, 'async');
                                prepareAppSharing(shareable ? 2 /* Sharer */ : 1 /* Viewer */);
                                // expect an OFFER_READY event from the media plugin
                                assert(!dfdStart);
                                dfdStart = new Task('awaiting an OFFER_READY event from the media plugin');
                                return dfdStart.promise;
                            }).then(null, function (error) {
                                if (asInvitation && asInvitation.hasLink('cancel') &&
                                    (asInvitation.get('state', '') == 'Connecting' || asInvitation.get('state', '') == 'Alerting'))
                                    ucwa.send('POST', asInvitation.link('cancel').href, { nobatch: true });
                                state(Internal.Modality.State.Disconnected, error);
                                throw error;
                            });
                        });
                    });
                    //#endregion
                    //#region cleanup
                    function cleanup() {
                        ucwa.event.off(onServerEvent);
                        if (appSharing) {
                            appSharing.event.off(onPluginComponentEvent);
                            if (shareable)
                                sharedResources.setShared(shareable.id(), false);
                            appSharing.disposeSharer();
                            // TODO: See if this makes the most sense for cleanup of old plugin / loading of new...
                            sharedResources.uninit();
                        }
                        if (pcASUI) {
                            appSharing.disposeViewer();
                            pcASUI.event.off(onViewerEvent);
                            pcASUI.unload();
                        }
                        pcASUI = null;
                        mediaPlugin.uninitAppSharing().then(function () {
                            appSharing = null;
                            return sharedResources.init();
                        });
                    }
                    //#endregion
                    //#region stop
                    defineAsyncCommand('stop', [Internal.Modality.State.Connected], function () {
                        cleanup();
                        return ucwa.send('GET', asInvitation.link('applicationSharing').href).then(function (rAS) {
                            return ucwa.send('POST', rAS.link('stopScreenSharing').href);
                        }).then(function () {
                            state(Internal.Modality.State.Disconnected);
                            asInvitation = null;
                            asSession = null;
                        });
                    });
                    //#endregion
                    //#region accept
                    /**
                     * Accepts an incoming app-sharing invitation.
                     *
                     * If the AS modality was created to handle a applicationSharingInvitation event,
                     * the accept method will configure the media plugin and connect it with
                     * the remote party via UCWA.
                     *
                     * Under the hood the accept method does the following:
                     *
                     *      - Get an AppSharingComponent from the media plugin.
                     *      - Attaches an event handle for plugin events.
                     *      - Create an AppSharingViewerComponent with the media plugin.
                     *      - Invokes AppSharingViewerComponent::CreateAppShareViewerUI.
                     *      - Invokes AppSharingViewerComponent::GetViewerWindow.
                     *      - Invokes AppSharingComponent::SetCallConfig.
                     *      - Invokes AppSharingComponent::InitializeViewer.
                     *      - Invokes AppSharingComponent::ConnectViewer.
                     *      - Invokes AppSharingComponent::SetOffer with the SDPs received from the remote party.
                     *      - Invokes AppSharingComponent::PublishFullScreenState.
                     *      - Handles the ANSWER_READY event from the media plugin: the event contains an SDP.
                     *      - Sends a POST applicationSharingInvitation/acceptWithAnswer with the SDP from the media plugin.
                     *      - Receives an "applicationSharinginvitation completed" event from UCWA
                     *      - Receives an "applicationSharingRenegotiation started" event with a new SDP from the remote party.
                     *      - Invokes AppSharingComponent::SetOffer with the new SDP given in the renegotiation event.
                     *      - Handles another ANSWER_READY event from the media plugin with an SDP answer.
                     *      - Sends a POST applicationSharingRenegotiation/answer with the SDP answer.
                     *      - Receives a "applicationSharingRenegotiation completed" event from UCWA.
                     *      - Invokes AppSharingComponent::CompleteNegotiation
                     *
                     * @returns {Promise}
                     *
                     *      This promise gets resolved after the POST request to applicationSharingInvitation/acceptWithAnswer
                     *      succeeds. The renegotiation is considered to be optional and its progress is not tracked
                     *      by the promise returned from the accept method.
                     */
                    defineAsyncCommand('accept', [Internal.Modality.State.Notified], function (options) {
                        assert(options && options.container);
                        state(Internal.Modality.State.Connecting);
                        container = options.container;
                        return initMedia().then(function () {
                            return mediaPlugin.getAppSharing().then(function (as) {
                                appSharing = as;
                                appSharing.event(onPluginComponentEvent, 'async');
                                return prepareAppSharing(1 /* Viewer */).then(function () {
                                    // expect the ANSWER_READY event from the plugin after this call
                                    setOffer(invitation.offers);
                                });
                            });
                        }).then(function () {
                            assert(!dfdAccept);
                            dfdAccept = new Task();
                            dfdAccept.status('awaiting an ANSWER_READY event from the media plugin');
                            return dfdAccept.promise;
                        }).then(null, function (error) {
                            state(Internal.Modality.State.Disconnected, error);
                            cleanup();
                            throw error;
                        });
                    });
                    //#endregion
                    //#region changeShared
                    /**
                     * Changes the shared content and/or presentation role in the conversation.  Presentation roles can switch
                     * depending on what is currently active in the conversation and if the optional shareable resource was
                     * provided.
                     *
                     * @param {ShareableWindow|ShareableMonitor} resource - resource to be shared (not required)
                     *
                     * @returns {Promise}
                     */
                    function changeShared(resource) {
                        check.state(state(), Internal.Modality.State.Connected);
                        function sharing() {
                            if (!isConferencing()) {
                                appSharing.setCallConfig();
                                appSharing.setMediaConfig(3 /* BOTH */, 2 /* Sharer */);
                            }
                            appSharing.disposeViewer();
                            pcASUI.event.off(onViewerEvent);
                            pcASUI.unload();
                            pcASUI = null;
                            if (isConferencing()) {
                                return mediaPlugin.uninitAppSharing().then(function () {
                                    appSharing = null;
                                    sharedResources.uninit();
                                }).then(function () {
                                    shareable = resource;
                                    return prepareAppSharing(2 /* Sharer */);
                                });
                            }
                            else {
                                sharedResources.setShared(resource.id(), true);
                                shareable = resource;
                            }
                        }
                        function viewing() {
                            appSharing.disposeSharer();
                            return mediaPlugin.uninitAppSharing().then(function () {
                                appSharing = null;
                                sharedResources.uninit();
                            }).then(function () {
                                return prepareAppSharing(1 /* Viewer */);
                            });
                        }
                        if (shareable) {
                            sharedResources.setShared(shareable.id(), false);
                        }
                        if (pcASUI) {
                            return sharing();
                        }
                        else if (resource) {
                            sharedResources.setShared(resource.id(), true);
                            shareable = resource;
                        }
                        else {
                            return viewing();
                        }
                    }
                    //#endregion
                    //#region decline
                    defineAsyncCommand('decline', [Internal.Modality.State.Notified], function () {
                        return invitation.decline().then(function () {
                            state(Internal.Modality.State.Disconnected);
                        });
                    });
                    //#endregion
                    //#region setOffer
                    /**
                     * Invokes appSharing.setOffer(...) with the given set of SDPs,
                     * e.g. pcAS.invoke("SetOffer", false, 2, sdp1, id1, sdp2, id2).
                     *
                     * @param {Object[]} offers
                     * @returns Whatever pcAS returns.
                     */
                    function setOffer(offers) {
                        assert(offers.length >= 0);
                        var i, offer, args = [false, offers.length];
                        for (i = 0; i < offers.length; i++) {
                            offer = offers[i];
                            assert('sdp' in offer);
                            assert('id' in offer);
                            args.push(offer.sdp);
                            args.push(offer.id);
                        }
                        appSharing.setOffer.apply(appSharing, args);
                    }
                    //#endregion
                    //#region setFinalAnswer
                    /**
                     * Sets the final SDP answer from the remote party
                     */
                    function setFinalAnswer(resource, remoteEndpoint) {
                        var mediaAnswer = resource.relatedHref('mediaAnswer'), sdp = DataUri(mediaAnswer).data;
                        log('Final answer from the remote party:\n' + sdp);
                        appSharing.setFinalAnswer(remoteEndpoint, sdp);
                    }
                    //#endregion
                    //#region completeNegotiation
                    function completeNegotiation(eventStatus) {
                        // TODO: this is entirely my fantasy - figure out what are other values
                        // that ucwa can return here
                        var statusCode = (eventStatus == 'Success') ?
                            Internal.MediaEnum.NegotiationStatus.NS_SUCCESS :
                            Internal.MediaEnum.NegotiationStatus.NS_LOCAL_INTERNAL_ERROR;
                        appSharing.completeNegotiation(statusCode);
                    }
                    //#endregion
                    //#region getScreenSharingLink
                    /**
                     * The first SDP offer is sent to a URI given by this function.
                     */
                    function getScreenSharingLink() {
                        // if the AS modality is the 1-st modality in the conversation,
                        // send a request to the global startScreenSharing link
                        if (!rConversation) {
                            var link = ucwa.get(ucwa.app.relatedHref('communication')).link('startScreenSharing');
                            link.rel = 'startScreenSharing';
                            return link;
                        }
                        // if the AS modality gets added to an existing conversation,
                        // send the request to its addScreenSharing link
                        var link = rConversation.link('applicationSharing');
                        return ucwa.send('GET', link.href).then(function (rAS) {
                            var link = rAS.link('addScreenSharing');
                            link.rel = 'addScreenSharing';
                            return link;
                        });
                    }
                    //#endregion
                    //#region sendOffer
                    /**
                     * Composes an SDP offer from the OFFER_READY media plugin event data and
                     * sends it to the server to start an AS session.
                     */
                    function sendOffer(offers) {
                        assert(offers.length > 0);
                        // for now it takes only one SDP offer from all offers given by the media plugin
                        var mediaOffer = 'data:application/sdp;charset=utf-8,' +
                            DataUri.encodeData(offers[0].sdp);
                        return async(getScreenSharingLink).call(null).then(function (link) {
                            var dfdPost, dfdCompleted, operationId = guid(), data;
                            if (isConferencing()) {
                                data = {
                                    operationId: operationId,
                                    threadId: threadId,
                                    mediaOffer: mediaOffer
                                };
                            }
                            else {
                                data = {
                                    to: link.rel == 'addScreenSharing' ? void 0 : to,
                                    operationId: operationId,
                                    sessionContext: guid(),
                                    threadId: threadId,
                                    mediaOffer: mediaOffer
                                };
                            }
                            dfdPost = ucwa.send('POST', link.href, {
                                data: data
                            }).then(function (r) {
                                asInvitation = r;
                            });
                            // wait for the "applicationSharingInvitation completed" event that corresponds to the given conversation
                            dfdCompleted = ucwa.wait({
                                type: 'completed',
                                target: { rel: 'applicationSharingInvitation' },
                                resource: function (r) {
                                    return r.get('direction') == 'Outgoing' && (r.get('threadId') == threadId || r.get('operationId') == operationId);
                                }
                            }).then(function (event) {
                                if (event.status == 'Failure')
                                    throw Internal.EInvitationFailed(event.reason);
                                completeNegotiation(event.status);
                            });
                            return Task.waitAll([dfdPost, dfdCompleted]);
                        });
                    }
                    //#endregion
                    //#region sendRenegotiationOffer
                    /**
                     * Composes an SDP offer from the OFFER_READY media plugin event data and
                     * sends it to the server to renegotiate the AV session.
                     */
                    function sendRenegotiationOffer(sdp) {
                        var url = asSession.relatedHref('renegotiations');
                        assert(url, '"renegotiations" link is missing');
                        // cache operation id
                        var operationId = guid();
                        outAsRenegoOpIds[operationId] = "";
                        return ucwa.send('POST', url, {
                            headers: { 'Content-Type': 'application/sdp' },
                            query: { operationId: operationId },
                            data: sdp,
                            nobatch: true
                        });
                    }
                    //#endregion
                    return self;
                }
                Internal.AppSharingModality = AppSharingModality;
            })(Internal = Model_1.Internal || (Model_1.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_2) {
            var Internal;
            (function (Internal) {
                'use strict';
                var async = Web.Utils.async;
                var ConstProperty = Web.Utils.ConstProperty;
                var Model = Web.Utils.Model;
                /**
                 * Encapsulates logic for a shareable window
                 *
                 * @param {MediaPlugin} mediaPlugin
                 * @param {JSON} resource
                 * @param {Property} shared
                 *
                 * @property {Number} id - read only
                 * @property {String} title - read only
                 * @property {Boolean} shared - Gets the shared state of the resource
                 *
                 * @method {String} preview - returns the data URL of the image
                 *
                 */
                function ShareableWindow(_a) {
                    var mediaPlugin = _a.mediaPlugin, resource = _a.resource, shared = _a.shared;
                    resource.filter = 2 /* ApplicationFilter */;
                    function preview(dimensions) {
                        return mediaPlugin.getAppSharing().then(function (as) {
                            return as.getResourcePreview(resource, dimensions);
                        });
                    }
                    return Model({
                        id: ConstProperty(resource.id),
                        title: ConstProperty(resource.name),
                        shared: shared,
                        preview: async(preview)
                    });
                }
                Internal.ShareableWindow = ShareableWindow;
            })(Internal = Model_2.Internal || (Model_2.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_3) {
            var Internal;
            (function (Internal) {
                'use strict';
                var ConstProperty = Web.Utils.ConstProperty;
                var Property = Web.Utils.Property;
                var Model = Web.Utils.Model;
                /**
                 * Encapsulates logic for a shareable monitor
                 *
                 * @param {MediaPlugin} mediaPlugin
                 * @param {JSON} resource
                 * @param {Property} shared
                 *
                 * @property {Number} id - read only
                 * @property {String} title - read only
                 * @property {Boolean} shared - Gets the shared state of the resource
                 * @property {Boolean} selected - Draws/Removes tracking chrome based on selection
                 *
                 */
                function ShareableMonitor(_a) {
                    var mediaPlugin = _a.mediaPlugin, resource = _a.resource, shared = _a.shared;
                    if (resource.id !== -1)
                        resource.name = 'Monitor #' + resource.id;
                    else
                        resource.name = 'Desktop Sharing';
                    resource.filter = 1 /* DesktopFilter */;
                    // draws or removes tracking chrome based on selection state
                    var selected = Property({
                        value: false,
                        set: function (val) {
                            return mediaPlugin.getAppSharing().then(function (as) {
                                if (val)
                                    as.drawTrackingChrome(resource.id);
                                else
                                    as.removeTrackingChrome(resource.id);
                                return val;
                            });
                        }
                    });
                    return Model({
                        id: ConstProperty(resource.id),
                        title: ConstProperty(resource.name),
                        shared: shared,
                        selected: selected
                    });
                }
                Internal.ShareableMonitor = ShareableMonitor;
            })(Internal = Model_3.Internal || (Model_3.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_4) {
            var Internal;
            (function (Internal) {
                'use strict';
                var assert = Web.Utils.assert;
                var async = Web.Utils.async;
                var foreach = Web.Utils.foreach;
                var Property = Web.Utils.Property;
                var Collection = Web.Utils.Collection;
                var Model = Web.Utils.Model;
                var UserAgent = Web.Media.UserAgent;
                /**
                 * Encapsulates AppSharing component to be shared across Models
                 *
                 * @collection {ShareableWindow} windows - available shareable windows
                 * @collection {ShareableMonitor} monitors - available shareable monitors
                 *
                 * @method {Promise} init - initializes/loads shareable resources
                 * @method uninit
                 * @method setShared(id, value) - Sets the shared state value of a resource based on supplied id
                 *
                 */
                function SharedResources(mediaPlugin) {
                    var appSharing, dfdInit, // `init` returns this promise
                    windows = Collection({ get: init, subscribed: init }), monitors = Collection({ get: init, subscribed: init }), sharedProperties = {};
                    /**
                     * Note, that `init` may be called multiple times: the first call
                     * must start initializing the AS component, while subsequent calls
                     * must await the first call. This is achieved by keeping the promise
                     * returned by the first call in a variable `dfdInit` and returning
                     * this `dfdInit` from subsequent calls.
                     */
                    function init() {
                        return dfdInit ? dfdInit : dfdInit = mediaPlugin.initMedia().then(function () {
                            return mediaPlugin.getAppSharing();
                        }).then(function (as) {
                            assert(!appSharing);
                            appSharing = as;
                            appSharing.event(onPluginComponentEvent, 'async');
                            // Skip resource discovery for Mac for now
                            if (!UserAgent().isMac()) {
                                var windowItems = [], monitorItems = [], resources = appSharing.getShareableResources();
                                foreach(resources, function (item) {
                                    if (item.type === 1) {
                                        monitorItems.push(item);
                                    }
                                    else if (item.type === 3) {
                                        windowItems.push(item);
                                    }
                                });
                                updateItems(windowItems, windows);
                                updateItems(monitorItems, monitors);
                            }
                            handleDesktopSharing();
                        });
                    }
                    function uninit() {
                        if (appSharing)
                            appSharing.event.off(onPluginComponentEvent);
                        appSharing = null;
                        dfdInit = null;
                    }
                    /**
                     * Listen for 'ResourceUpdate' component events to determine when resources are added/removed
                     */
                    function onPluginComponentEvent(event) {
                        if (event.type == 'ResourceUpdated') {
                            var action = event.args.splice(7, 1)[0], type = event.args[0], item, resource = {
                                type: event.args[0],
                                id: event.args[1],
                                appId: event.args[2],
                                name: event.args[3],
                                isShared: event.args[4],
                                flags: event.args[5],
                                isResourceAsIsShareable: event.args[6],
                                fIsImmersiveModeApp: event.args[7]
                            }, shared;
                            if (type === 1) {
                                // This is a monitor resource
                                item = GetResourceKey(resource, monitors);
                                if (action === 1) {
                                    // Add
                                    if (!item) {
                                        shared = createSharedProperty(resource);
                                        sharedProperties[resource.id] = shared;
                                        monitors.add(Internal.ShareableMonitor({
                                            resource: resource,
                                            mediaPlugin: mediaPlugin,
                                            shared: shared.asReadOnly()
                                        }));
                                    }
                                }
                                else if (action === 2) {
                                    // Delete
                                    if (item) {
                                        monitors.remove(item);
                                        delete sharedProperties[resource.id];
                                    }
                                }
                                handleDesktopSharing();
                            }
                            else if (type === 3) {
                                // This is a window resource
                                item = GetResourceKey(resource, windows);
                                if (action === 1) {
                                    // Add
                                    if (!item && resource.isResourceAsIsShareable) {
                                        shared = createSharedProperty(resource);
                                        sharedProperties[resource.id] = shared;
                                        windows.add(Internal.ShareableWindow({
                                            resource: resource,
                                            mediaPlugin: mediaPlugin,
                                            shared: shared.asReadOnly()
                                        }));
                                    }
                                }
                                else if (action === 2) {
                                    // Delete
                                    if (item) {
                                        windows.remove(item);
                                        delete sharedProperties[resource.id];
                                    }
                                }
                            }
                        }
                    }
                    /**
                     * Adds or removes option for sharing entire desktop based on number of monitors
                     */
                    function handleDesktopSharing() {
                        var desktopSharingKey, resource = {
                            type: 4,
                            id: -1,
                            appId: -1
                        }, shared;
                        monitors.each(function (item, key) {
                            if (item.title() === 'Desktop Sharing') {
                                desktopSharingKey = key;
                            }
                        });
                        if (desktopSharingKey) {
                            monitors.remove(desktopSharingKey);
                            delete sharedProperties[resource.id];
                        }
                        shared = createSharedProperty(resource);
                        sharedProperties[resource.id] = shared;
                        monitors.add(Internal.ShareableMonitor({
                            resource: resource,
                            mediaPlugin: mediaPlugin,
                            shared: shared.asReadOnly()
                        }));
                    }
                    /**
                     * Find the specific resource key for a value potentially in the collection
                     */
                    function GetResourceKey(value, collection) {
                        var resourceKey;
                        collection.each(function (item, key) {
                            if (item.id() === value.id) {
                                resourceKey = key;
                                return;
                            }
                        });
                        return resourceKey;
                    }
                    /**
                     * Add/Remove resources of a collection
                     */
                    function updateItems(resources, collection) {
                        foreach(resources, function (item) {
                            var skip = false;
                            collection.each(function (obj) {
                                if (item.id === obj.id()) {
                                    skip = true;
                                }
                            });
                            if (!skip) {
                                var shared = createSharedProperty(item);
                                sharedProperties[item.id] = shared;
                                if (item.type === 1) {
                                    collection.add(Internal.ShareableMonitor({
                                        resource: item,
                                        mediaPlugin: mediaPlugin,
                                        shared: shared.asReadOnly()
                                    }));
                                }
                                else {
                                    collection.add(Internal.ShareableWindow({
                                        resource: item,
                                        mediaPlugin: mediaPlugin,
                                        shared: shared.asReadOnly()
                                    }));
                                }
                            }
                        });
                    }
                    function createSharedProperty(resource) {
                        return Property({
                            value: false,
                            set: function (val) {
                                return mediaPlugin.getAppSharing().then(function (appSharing) {
                                    var obj = {
                                        type: resource.type,
                                        id: resource.id,
                                        appId: resource.appId,
                                        filter: resource.filter
                                    };
                                    if (val)
                                        appSharing.shareResource(obj);
                                    else
                                        appSharing.unshareResource(obj);
                                    return val;
                                });
                            }
                        });
                    }
                    function setShared(id, value) {
                        if (sharedProperties[id]) {
                            sharedProperties[id](value);
                        }
                    }
                    return Model({
                        init: async(init),
                        uninit: uninit,
                        windows: windows.asReadOnly(),
                        monitors: monitors.asReadOnly(),
                        setShared: setShared
                    });
                }
                Internal.SharedResources = SharedResources;
            })(Internal = Model_4.Internal || (Model_4.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var DataUri = Web.Utils.DataUri;
                var async = Web.Utils.async;
                var extend = Web.Utils.extend;
                var guid = Web.Utils.guid;
                var map = Web.Utils.map;
                var check = Web.Utils.check;
                var HttpHeaders = Web.Utils.HttpHeaders;
                var parseMultipartRelatedResponse = Web.Stack.parseMultipartRelatedResponse;
                /**
                 * This model represents a applicationSharingInvitation resource.
                 *
                 * @param {Resource} resource - A resource with rel=applicationSharingInvitation.
                 * @param {Function} createParticipant - Takes a rel=participant resource and creates a Participant model.
                 * @param {UCWA} ucwa
                 *
                 * @member {Participant} from
                 * @member {Object[]} offers - An array of media offers.
                 *
                 *     - offers[i].sdp - SDP of the i-th offer.
                 *     - offers[i].id - Content ID of the i-th offer.
                 *
                 * @method {Promise} decline
                 * @method {Promise} acceptWithAnswer(sdp)
                 *
                 */
                function AppSharingInvitation(_a) {
                    var ucwa = _a.ucwa, resource = _a.resource, createParticipant = _a.createParticipant;
                    check.equals(resource.rel, 'applicationSharingInvitation');
                    /*  An applicationSharingInvitation resource may have the following form:
            
                        {
                            "rel": "applicationSharingInvitation",
                            "direction": "Incoming",
                            "importance": "Normal",
                            "threadId": "...",
                            "state": "Connecting",
                            "operationId": "...",
                            "telemetryId": "...",
                            "sessionContext": "...",
                            "_links": {
                                "self": ...,
                                "from": ...,
                                "cancel": ...,
                                "conversation": ...,
                                "applicationSharing": ...
                            }
                        }
                    */
                    var self = {
                        acceptWithAnswer: async(acceptWithAnswer),
                        decline: async(decline),
                        offers: getMediaOffers(),
                        from: getSender()
                    };
                    extend(self, resource.properties);
                    // if the server has not provided the sessionContext of
                    // the app sharing invitation, generate some unique value
                    self.sessionContext = self.sessionContext || guid();
                    /**
                     * Reads the "mediaOffer" link and converts it to a collection SDPs.
                     */
                    function getMediaOffers() {
                        /* The "mediaOffer" link may have the following form:
                         *
                         *  data:multipart/alternative;charset=utf-8;boundary=e47d80f2,
                         *  --e47d80f2
                         *  Content-Type:+application/sdp
                         *  Content-ID:+<9544aa8a8ac9dfe08fad74893bd1095e@contoso.com>
                         *  Content-Disposition:+session;+handling=optional;+proxy-fallback
                         *
                         *  v=0
                         *  o=-+0+0+IN+IP4+127.0.0.1
                         *  s=session
                         *  ...
                         *
                         *  --e47d80f2
                         *  Content-Type:+application/sdp
                         *  Content-ID:+<cdfd6188fd977372c577873b03dd580d@contoso.com>
                         *  Content-Disposition:+session;+handling=optional
                         *
                         *  v=0
                         *  o=-+0+1+IN+IP4+127.0.0.1
                         *  s=session
                         *  c=IN+IP4+127.0.0.1
                         *  ...
                         *
                         *  --e47d80f2
                         */
                        var href, dataUri, responses;
                        href = resource.relatedHref('mediaOffer');
                        if (!href)
                            return [];
                        dataUri = DataUri(href);
                        try {
                            responses = parseMultipartRelatedResponse({
                                status: null,
                                responseText: dataUri.data,
                                headers: { 'Content-Type': 'multipart/related;boundary=' + dataUri.attributes.boundary }
                            });
                            return map(responses, function (response) {
                                var headers = HttpHeaders(response.headers);
                                return {
                                    sdp: response.responseText,
                                    id: headers.get('Content-ID')
                                };
                            });
                        }
                        catch (error) {
                            // if the media offer is not a multipart/alternate-encoded
                            // set of SDPs, consider it as a single SDP
                            return [{
                                    sdp: dataUri.data,
                                    id: ''
                                }];
                        }
                    }
                    function getSender() {
                        var href = resource.relatedHref('from');
                        return href && createParticipant(resource.embedded[href]);
                    }
                    function acceptWithAnswer(sdp) {
                        var url = resource.link('acceptWithAnswer').href;
                        return ucwa.send('POST', url, {
                            headers: { 'Content-Type': 'application/sdp' },
                            query: { sessionContext: self.sessionContext },
                            data: sdp,
                            nobatch: true
                        });
                    }
                    function decline() {
                        return ucwa.send('POST', resource.link('decline').href, {
                            data: { reason: 'Local' }
                        });
                    }
                    return self;
                }
                Internal.AppSharingInvitation = AppSharingInvitation;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var async = Web.Utils.async;
                var guid = Web.Utils.guid;
                var Exception = Web.Utils.Exception;
                var EInvalidArgument = Web.Utils.EInvalidArgument;
                /**
                 * Encapsulates AppSharing component to be shared across Models
                 *
                 * @param {MediaPlugin} mediaPlugin
                 * @param {PluginComponent} component
                 *
                 * @method {Promise} init - initializes/loads AppSharing component
                 * @method uninit - unloads AppSharing component
                 * @method setCallConfig - wraps call to component's SetCallConfig
                 * @method setMediaConfig - wraps call to component's SetMediaConfig
                 * @method initializeViewer - wraps call to component's InitializeViewer
                 * @method connectViewer - wraps call to component's ConnectViewer
                 * @method createViewerStream - wraps call to component's ConnectViewerStream
                 * @method setViewerWindowSize - wraps call to component's SIZE_CHANGED
                 * @method setSmartSizingViewer - wraps call to component's SetSmartSizingViewer
                 * @method publishFullScreenState - wraps call to component's PublishFullScreenState
                 * @method setOffer - wraps call to component's SetOffer
                 * @method setFinalAnswer - wraps call to component's SetFinalAnswer
                 * @method setProvisionalAnswer - wraps call to component's SetProvisionalAnswer
                 * @method completeNegotiation - wraps call to component's CompleteNegotiation
                 * @method {Array} getShareableResources - queries component for shareable resources (windows/monitors)
                 * @method drawTrackingChrome - draws a tracking chrome around a specified monitor
                 * @method removeTrackingChrome - removes a tracking chrome around a specified monitor
                 * @method {String} getResourcePreview - returns the data URL of the image
                 * @method shareResource - Shares a resource (window/monitor) with AppSharing component
                 * @method unshareResource - Unshares a resource (window/monitor) with AppSharing component
                 * @method disposeSharer - wraps call to component's DisposeSharer
                 * @method disposeViewer - wraps call to component's DisposeViewer
                 * @method on - attaches handler to component's events
                 * @method off - detaches handler from component's events
                 *
                 */
                function AppSharing(_a) {
                    var mediaConfig = _a.mediaConfig, pcAS = _a.component;
                    var isInitialized = false;
                    function init() {
                        return pcAS.load('', // local uri
                        '', // remote uri
                        guid(), // threadId
                        false, // isConference
                        mediaConfig.maxVideoChannelCount(), mediaConfig.applicationSharingSecurityLevel()).then(function () {
                            pcAS.invoke('InitializeSharer');
                            pcAS.setLogLevel(3);
                            isInitialized = true;
                        });
                    }
                    function uninit() {
                        if (pcAS) {
                            pcAS.unload();
                            pcAS = null;
                            isInitialized = false;
                        }
                    }
                    function checkState() {
                        if (!isInitialized)
                            throw Exception.call('Not Initialized', 'NotInitialized');
                    }
                    function setCallConfig() {
                        checkState();
                        pcAS.invoke('SetCallConfig', mediaConfig.isInternal() ?
                            Internal.MediaEnum.PreferredMediaAddressType.Direct :
                            Internal.MediaEnum.PreferredMediaAddressType.Relay);
                    }
                    function setMediaConfig(direction, type) {
                        checkState();
                        pcAS.invoke('SetMediaConfig', direction, type);
                    }
                    function initializeViewer(wHandle) {
                        checkState();
                        pcAS.invoke('InitializeViewer', wHandle);
                    }
                    function connectViewer(connectionString) {
                        checkState();
                        pcAS.invoke('ConnectViewer', connectionString);
                    }
                    function createViewerStream() {
                        checkState();
                        pcAS.invoke('CreateViewerStream', 3 /* BOTH */);
                    }
                    function setViewerWindowSize(width, height) {
                        checkState();
                        pcAS.invoke('SIZE_CHANGED', width, height);
                    }
                    function setSmartSizingViewer(val) {
                        checkState();
                        pcAS.invoke('SetSmartSizingViewer', val);
                    }
                    function publishFullScreenState(state) {
                        checkState();
                        pcAS.invoke('PublishFullScreenState', state);
                    }
                    function setOffer(isProvisionalAnsReq, count) {
                        checkState();
                        if (count < 1)
                            throw EInvalidArgument('count', 'No Offers Provided');
                        var args = ['SetOffer', isProvisionalAnsReq, count].concat([].slice.call(arguments, 2));
                        pcAS.invoke.apply(pcAS, args);
                    }
                    function setFinalAnswer(remoteEndpoint, sdp) {
                        checkState();
                        pcAS.invoke('SetFinalAnswer', remoteEndpoint, sdp);
                    }
                    function setProvisionalAnswer(isOfferForked, acceptEarlyMedia, remoteEndpoint, sdp) {
                        checkState();
                        pcAS.invoke('SetProvisionalAnswer', isOfferForked, acceptEarlyMedia, remoteEndpoint, sdp);
                    }
                    function completeNegotiation(statusCode) {
                        checkState();
                        pcAS.invoke('CompleteNegotiation', statusCode);
                    }
                    function getShareableResources() {
                        checkState();
                        var items = [], resources, count, index = 0;
                        pcAS.invoke('LockFetchResources');
                        resources = pcAS.invoke('GetResources');
                        pcAS.invoke('UnlockFetchResources');
                        if (resources) {
                            count = resources[resources.length - 1];
                            resources = resources.slice(1, -1);
                            for (var i = 0; i < count; i++) {
                                // Check if resource is shareable before adding to list and not already shared
                                if (resources[index + 4] !== 1 && (resources[index] === 1 || (resources[index] === 3 && resources[index + 6] !== 0))) {
                                    items.push({
                                        type: resources[index],
                                        id: resources[index + 1],
                                        appId: resources[index + 2],
                                        name: resources[index + 3],
                                        isShared: resources[index + 4],
                                        flags: resources[index + 5],
                                        isResourceAsIsShareable: resources[index + 6],
                                        fIsImmersiveModeApp: resources[index + 7]
                                    });
                                }
                                index += 8;
                            }
                        }
                        return items;
                    }
                    function drawTrackingChrome(id) {
                        checkState();
                        pcAS.invoke('DrawMonitorTrackingChrome', id);
                    }
                    function removeTrackingChrome(id) {
                        checkState();
                        pcAS.invoke('RemoveMonitorTrackingChrome', id);
                    }
                    function getResourcePreview(resource, dimensions) {
                        checkState();
                        var result;
                        // TODO: Consider reusing filter...
                        if (resource.type === 1) {
                        }
                        else {
                            var temp = pcAS.invoke('GetApplicationPreview', resource.appId, resource.id, dimensions.width, dimensions.height);
                            result = 'data:image/png;base64,' + temp[1];
                        }
                        return result;
                    }
                    function shareResource(resource) {
                        checkState();
                        // Probably a try/catch here...
                        // Figure out if we can move control related to another method or extend signature...
                        pcAS.invoke('SetControlAllowed', 1, true, true);
                        if (resource.id !== -1) {
                            pcAS.invoke('SetResourceFilter', resource.filter, 1);
                            pcAS.invoke('SetResourceSharedState', resource.type, resource.id, resource.appId, 1);
                        }
                        else {
                            pcAS.invoke('DisableFilters');
                        }
                        // Figure out if we should allow control over allowing sharing to stop..?
                        pcAS.invoke('CanStopSharing', true);
                    }
                    function unshareResource(resource) {
                        checkState();
                        pcAS.invoke('SetResourceSharedState', resource.type, resource.id, resource.appId, 0);
                    }
                    function disposeSharer() {
                        checkState();
                        pcAS.invoke('DisposeSharer');
                    }
                    function disposeViewer() {
                        checkState();
                        pcAS.invoke('DisposeViewerCore');
                    }
                    return {
                        init: async(init),
                        uninit: uninit,
                        setCallConfig: setCallConfig,
                        setMediaConfig: setMediaConfig,
                        initializeViewer: initializeViewer,
                        connectViewer: connectViewer,
                        createViewerStream: createViewerStream,
                        setViewerWindowSize: setViewerWindowSize,
                        setSmartSizingViewer: setSmartSizingViewer,
                        publishFullScreenState: publishFullScreenState,
                        setOffer: setOffer,
                        setFinalAnswer: setFinalAnswer,
                        setProvisionalAnswer: setProvisionalAnswer,
                        completeNegotiation: completeNegotiation,
                        getShareableResources: getShareableResources,
                        drawTrackingChrome: drawTrackingChrome,
                        removeTrackingChrome: removeTrackingChrome,
                        getResourcePreview: getResourcePreview,
                        shareResource: shareResource,
                        unshareResource: unshareResource,
                        disposeSharer: disposeSharer,
                        disposeViewer: disposeViewer,
                        event: pcAS.event
                    };
                }
                Internal.AppSharing = AppSharing;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var find = Web.Utils.find;
                var guid = Web.Utils.guid;
                var check = Web.Utils.check;
                var async = Web.Utils.async;
                var assert = Web.Utils.assert;
                var extend = Web.Utils.extend;
                var random = Web.Utils.random;
                var values = Web.Utils.values;
                var filter = Web.Utils.filter;
                var foreach = Web.Utils.foreach;
                var isEmptyObject = Web.Utils.isEmptyObject;
                var isNotEmptyString = Web.Utils.isNotEmptyString;
                var currentUTCms = Web.Utils.currentUTCms;
                var Task = Web.Utils.Task;
                var Event = Web.Utils.Event;
                var Symbol = Web.Utils.Symbol;
                var DataUri = Web.Utils.DataUri;
                var Promise = Web.Utils.Promise;
                var Property = Web.Utils.Property;
                var Exception = Web.Utils.Exception;
                var Collection = Web.Utils.Collection;
                var StringEnum = Web.Utils.StringEnum;
                var EDoesNotExist = Web.Utils.EDoesNotExist;
                var EInvalidState = Web.Utils.EInvalidState;
                var ENotSupported = Web.Utils.ENotSupported;
                var EInvalidArgument = Web.Utils.EInvalidArgument;
                var setHiddenProperty = Web.Utils.setHiddenProperty;
                var log = Web.Media.log;
                var watch = Web.Media.watch;
                var PluginManager = Web.Media.PluginManager;
                var PluginComponent = Web.Media.PluginComponent;
                /** denotes escalation as a reason for internal property change */
                Internal.sEscalation = Symbol('escalation');
                /**
                 * Created by AudioVideoModality to represent an AudioVideo session (call). Can be either
                 * peer-to-peer or multi-party (conference). Only one such session exists when the call is
                 * established. When a P2P conversation is escalated to a conference, a second session
                 * linking this client to the conference is created. Once escalation succeeds, the second
                 * session replaces the original P2P session.
                 *
                 */
                var AudioVideoSession = (function () {
                    //#endregion
                    function AudioVideoSession(options) {
                        var changed = new Event(), escalated = new Event(), errorOccured = new Event(), self = {}, pcAV, mediaConfig, mediaPlugin = options.mediaPlugin, devices = options.devices, ucwa = options.ucwa, tm = options.tm, context = options.context, contextType = options.contextType, settings = options.settings, participants = options.participants, selfParticipant = options.selfParticipant, conversation = options.conversation, rConversation = options.rConversation, rAVInvitation = options.rAVInvitation, rAVRenegotiation, 
                        // During an outgoing call the server may set up more than one audioVideoSession, because
                        // the remote sip uri that we are calling may be signed in on more than one endpoint.
                        // Therefore we may see multiple pairs of audioVideoNegotiation - audioVideoSession events.
                        // Eventually, one of these sessions will be connected, others will be deleted. We keep
                        // track of these sessions in a dictionary of objects indexed by audioVideoSession hrefs,
                        // where these session objects may have properties:
                        //    resource:  audioVideoSession resource;
                        //    negotiated:  boolean (true if this session was successfully negotiated);
                        //    resumeAudioVideoUri:  present if this is an escalated conference session.
                        avSessions = {}, invitation = options.invitation, rInvitation = options.rInvitation, operationId = options.operationId || guid(), // provided by unittest or generated on the fly
                        sessionContext = options.sessionContext || guid(), // provided by unittest or generated on the fly
                        outAvRenegoOpIds = {}, // list of outgoing audioVideoRenegotiation operationId values
                        localUri = options.localUri, remoteUri, state = Property({
                            value: invitation || (rInvitation && rInvitation.rel == 'onlineMeetingInvitation') ?
                                Internal.Modality.State.Notified :
                                Internal.Modality.State.Disconnected
                        }), 
                        // TODO: if we receive a video invitation we force the client to accept/decline on the video
                        // service. Figure out how to deal with answering with audio to a video invitation.
                        audioState = Property({
                            value: isAudioInvitation() || isVideoInvitation() ?
                                Internal.Modality.State.Notified :
                                Internal.Modality.State.Disconnected
                        }), videoState = Property({
                            value: isVideoInvitation() ?
                                Internal.Modality.State.Notified :
                                Internal.Modality.State.Disconnected
                        }), activeSourceId, recentActiveSpeakers = {}, activeModalities = { audio: false, video: false }, audioChannel, mainVideoStream = new Internal.MediaStream({
                            mediaPlugin: mediaPlugin,
                            type: Internal.MediaEnum.StreamType.MainRender
                        }), selfVideoStream = new Internal.MediaStream({
                            mediaPlugin: mediaPlugin,
                            type: Internal.MediaEnum.StreamType.Preview
                        }), 
                        // remote video streams
                        videoStreams = Collection(), dfdStart, // promise returned by the start method
                        dfdAccept, // promise returned by the accept method
                        dfdSelfVideo, // promise returned by the [show|remove]ParticipantVideo methods
                        dfdHold, // promise returned by the hold/resume methods
                        holdValue, 
                        // promise used to monitor the progress of an outgoing audioVideoRenegotiation, which
                        // can be triggered by methods such as start, mute/unmute, hold/resume, showParticipantVideo/removeParticipantVideo
                        dfdOutRenego = new Task(), isPendingInRenego = false, renegoError = Exception('skipping outgoing renegotiation because of pending incoming renegotiation'), 
                        // the collection of participants whose video was renedered before a video call
                        // was put on hold; used for auto-restoring video when the call is resumed;
                        // participants who left the call or stopped streaming video while the call 
                        // was on hold are removed from this collection
                        participantsWithVideoToRender = {}, 
                        // video config of the main media manager channel requested by either start or accept;
                        // is needed for setting the initial value of video channel's isStarted property for the
                        // self participant when start/accept is finished.
                        mainVideoConfig = 0 /* NOT_PRESENT */, 
                        // a unique id of this session - handy for debugging this session's
                        // server event subscription
                        callId = options.callId || random(), RemoteHoldState = {
                            Unknown: 0,
                            HoldOffered: 1,
                            HoldAnswered: 2,
                            HoldCompleted: 3,
                            ResumeOffered: 4,
                            ResumeAnswered: 5,
                            ResumeCompleted: 6
                        }, AudioVideoDirection = StringEnum('Inactive', // hold
                        'ReceiveOnly', 'SendOnly', 'SendReceive', // resume
                        'Unknown'), 
                        // A flag to track the renegotiation progress when a remote
                        // participant hold/resume the call in P2P mode.
                        //
                        // Steps to identify when remote participant hold/resume in P2P:
                        // 1. wait for audioVideo renegotiation offer.
                        // 2. if the offer has "a=inactive" field (for m=audio or m=video),
                        //    it is a HOLD request, mark it and expect ANSWER READY.
                        //    Otherwise, it MIGHT be a RESUME request (but not necessarily),
                        //    so mark it that way.
                        // 3. if answer has "a=inactive" field, it is a HOLD request, mark it
                        //    and expect "audioVideoRenegotiation completed".
                        //    Otherwise, it MIGHT be a RESUME request (but not necessarily),
                        //    so mark it that way.
                        // 4. when "audioVideoRenegotiation completed" event is received
                        //    with "Incoming" direction, progress the marker set in previous
                        //    steps; and expect CHANNEL_DIRECTION_CHANGED event.
                        // 5. if CHANNEL_DIRECTION_CHANGED event is received with direction
                        //    equal to NO_ACTIVE_MEDIA, and the HOLD marker was set in last
                        //    step, it completes a HOLD renegotiation, so we can set:
                        //    p.audioOnHold(true) for the remote participant.
                        // 6. if CHANNEL_DIRECTION_CHANGED event is received with direction
                        //    equal to other values (likely BOTH), and the RESUME marker was
                        //    set in last step, it completes a RESUME renegotiation, so set:
                        //    p.audioOnHold(false) for the remote participant.
                        remoteHoldState = RemoteHoldState.Unknown, escalateAudioVideoUri = options.escalateAudioVideoUri, 
                        // Track if an audio/video session is involved in a P2P to group escalation:
                        //  - None: this session is currently not involved in escalation
                        //  - From: this is the session for the old P2P call that is being escalated
                        //          (it will be set to this state by AVM#startEscalation)
                        //  - To:   this is the session newly created to manage the escalated group call
                        escalationState = Property({
                            value: escalateAudioVideoUri ? 2 /* To */ : 0 /* None */
                        }), 
                        // Keep track of video configuration before escalation so that it can be configured
                        // the same post-escalation
                        preEscalationVideoConfig = Property(), 
                        // A subscription to the devicesManager.selectedCamera changed event
                        selectedCameraChangedSubscription, 
                        // A subscription to the devicesManager.selectedMicrophone changed event
                        selectedMicrophoneChangedSubscription, 
                        // A subscription to the devicesManager.selectedSpeaker changed event
                        selectedSpeakerChangedSubscription, pluginStateSub, reportMediaDiagnosticsUrl, publishCallQualityFeedbackUrl, isUnmuteRequested = selfParticipant.audio.isUnmuteRequested, isClean = Property({ value: false }); // whether this session has been cleaned up
                        assert(conversation);
                        dfdOutRenego.resolve();
                        //#region mute
                        // Used for P2P self mute/unmute and in conference mode to prevent being 
                        // unmuted by remote without confirmation
                        // NOTE: this would cause the other participant to receive
                        // MEDIA_CHANGED event. However, those events are not
                        // reliable triggers to update participant mute states since
                        // they can also appear when the remote participant is not
                        // on mute but there is no sound input for a while. Also
                        // confirmed with Lync Client that there is no way for one
                        // endpoint to know whether the other endpoint is on mute or
                        // not. So you will always see participant.audio.isMuted to
                        // be 'false' in P2P mode.
                        function hardMuteUnmute(val) {
                            pcAV.invoke('MuteOrUnMute', Internal.MediaEnum.MediaDeviceType.MIC, val, // mute
                            false); // isDeviceSystemProperty
                        }
                        // mutes/unmutes the audio channel or returns the mute status
                        var muted = Property({
                            value: false,
                            get: function () {
                                // if this throws, the cached value won't be changed
                                check.state(pcAV.state(), PluginComponent.State.Loaded);
                                // TODO: race condition with getting while underlying value is being set
                                if (isConferencing())
                                    return muted();
                                var res = pcAV.invoke('GetMuteStatus', Internal.MediaEnum.MediaDeviceType.MIC, false); // isDeviceSystemProperty
                                // the output param is a flag telling us if our audio is muted or not
                                return res[1];
                            },
                            set: function (val) {
                                // if this throws, the cached value won't be changed
                                check.state(pcAV.state(), PluginComponent.State.Loaded);
                                var dfd;
                                // soft mute is applicable in conference mode
                                if (isConferencing()) {
                                    var rel = val ? 'muteAudio' : 'unmuteAudio', rAudio = ucwa.get(selfParticipant[Internal.sInternal].audioLink);
                                    // Triggered when accepting unmute request from remote - undo hard mute
                                    if (!val && isUnmuteRequested()) {
                                        isUnmuteRequested(false);
                                        hardMuteUnmute(val);
                                        dfd = Promise.resolve(val);
                                    }
                                    else {
                                        // Regular self mute/unmute 
                                        dfd = Task.run(function () {
                                            if (!rAudio || !rAudio.hasLink(rel))
                                                return ucwa.send('GET', selfParticipant[Internal.sInternal].audioLink);
                                            else
                                                return rAudio;
                                        }).then(function (rAudio) {
                                            return ucwa.send('POST', rAudio.link(rel).href);
                                        }).then(function () {
                                            if (!val && isUnmuteRequested())
                                                isUnmuteRequested(false);
                                            return val;
                                        });
                                    }
                                }
                                else {
                                    // P2P self mute
                                    hardMuteUnmute(val);
                                    dfd = Promise.resolve(val);
                                }
                                return dfd;
                            }
                        });
                        //#endregion mute
                        //#region onHold
                        // holds/resumes audio/video or returns the onHold status
                        var onHold = Property({
                            value: false,
                            get: function () {
                                check.state(pcAV.state(), PluginComponent.State.Loaded);
                                return onHold();
                            },
                            set: function (val) {
                                // if this throws, the cached value won't be changed
                                check.state(pcAV.state(), PluginComponent.State.Loaded);
                                if (!isConferencing() && participants.size() > 0) {
                                    // the call is on hold when the remote puts on hold; so when
                                    // the local participant requests hold, the plugin will not
                                    // renegotiate, and no need to wait for renegotiation result
                                    if (participants(0).audio.isOnHold() && !onHold())
                                        return val;
                                }
                                var audioConfig = val ? 4 /* NO_ACTIVE_MEDIA */ : 3 /* BOTH */;
                                var moreChannels = activeModalities.video && isConferencing();
                                return dfdOutRenego.promise.then(function () {
                                    // give up if there is pending incoming renegotiation
                                    if (isPendingInRenego)
                                        throw renegoError;
                                    dfdOutRenego = new Task();
                                    // TODO: do we need to consider remote video in this like in setting renegotiation offer?
                                    mainVideoConfig = activeModalities.video ?
                                        (val ?
                                            4 /* NO_ACTIVE_MEDIA */ :
                                            (selfParticipant[Internal.sInternal].videoStartedBeforeHold() ?
                                                3 /* BOTH */ :
                                                2 /* RECEIVE */) // Self video was off before hold
                                        ) :
                                        0 /* NOT_PRESENT */; // No video
                                    pcAV.invoke('SetMediaConfig', audioConfig, // audio configuration
                                    mainVideoConfig, // main video configuration
                                    moreChannels ?
                                        mediaConfig.maxVideoChannelCount() - 1 : 0, moreChannels ?
                                        (val ?
                                            4 /* NO_ACTIVE_MEDIA */ :
                                            2 /* RECEIVE */) :
                                        0 /* NOT_PRESENT */, 0 /* NOT_PRESENT */); // panoVideoConfig
                                    holdValue = val;
                                    // save or reset video channel's isStarted property value prior to putting call on hold
                                    selfParticipant[Internal.sInternal].videoStartedBeforeHold(val ?
                                        selfParticipant.video.channels(0).isStarted() : undefined);
                                    selfParticipant[Internal.sInternal].audioOnHold(val);
                                    // expect an OFFER_READY event from the media plugin
                                    return startTrackingHoldResume();
                                })
                                    .then(function () { return handleMeetingVideoOnHoldResume(val); })
                                    .then(function () { return val; })
                                    .catch(function (err) {
                                    log(err);
                                    stopTrackingHoldResume('reject', err);
                                    if (dfdOutRenego.state() == 'pending')
                                        dfdOutRenego.resolve();
                                    throw err;
                                });
                            }
                        });
                        //#endregion onHold
                        options = null;
                        ucwa.event(onServerEvent);
                        pluginStateSub = PluginManager().state.changed(function (newVal, reason, oldVal) {
                            if (newVal == PluginManager.State.Uninitialized && oldVal != void 0) {
                                var err = 'PluginUninited';
                                if (dfdStart && dfdStart.state() == 'pending')
                                    dfdStart.reject(err);
                                else if (dfdAccept && dfdAccept.state() == 'pending')
                                    dfdAccept.reject(err);
                                else {
                                    cleanup(err);
                                    state(Internal.Modality.State.Disconnected);
                                }
                            }
                        });
                        watch('AudioVideoSession(' + callId + ')::state:', state);
                        watch('AudioVideoSession(' + callId + ')::audioState:', audioState);
                        watch('AudioVideoSession(' + callId + ')::videoState:', videoState);
                        state.when(Internal.Modality.State.Disconnected, function () {
                            audioState(Internal.Modality.State.Disconnected);
                            videoState(Internal.Modality.State.Disconnected);
                        });
                        // note that the reset method will be called with the "reason" parameter if the
                        // reason was set when property values were changed.
                        // also note the reset of participant.[audio|video].state is done inside AVM.
                        videoState.when(Internal.Modality.State.Disconnected, resetVideo);
                        participants.removed(function (p) {
                            var id = p[Internal.sInternal].audioSourceId();
                            delete recentActiveSpeakers[id];
                            if (activeSourceId == id)
                                activeSourceId = -1;
                            removeParticipantWithVideoToRender(p);
                        });
                        setVideoRendering(selfVideoStream, true);
                        if (!isConferencing())
                            setVideoRendering(mainVideoStream, false);
                        //#region self
                        extend(self, {
                            state: state.asReadOnly(),
                            audioState: audioState.asReadOnly(),
                            videoState: videoState.asReadOnly(),
                            start: async(start),
                            stop: async(stop),
                            cleanup: cleanup,
                            sendDtmf: sendDtmf,
                            changed: changed.observer,
                            escalated: escalated.observer,
                            errorOccured: errorOccured.observer,
                            muted: muted,
                            onHold: onHold,
                            selfVideoStream: selfVideoStream,
                            showParticipantVideo: showParticipantVideo,
                            removeParticipantVideo: removeParticipantVideo,
                            removeVideo: async(removeAllVideo),
                            escalationState: escalationState,
                            preEscalationVideoConfig: preEscalationVideoConfig,
                            isClean: isClean.asReadOnly()
                        });
                        if (invitation) {
                            // incoming call
                            extend(self, {
                                from: invitation.from,
                                accept: async(accept)
                            });
                        }
                        //#endregion
                        //#region private utilities
                        function initMedia() {
                            return mediaConfig ?
                                Task.wait(mediaConfig) :
                                mediaPlugin.getMediaConfig() // otherwise load it and return when it becomes available
                                    .then(function (mc) {
                                    mediaConfig = mc;
                                    return mediaConfig;
                                });
                        }
                        function isConferencing() {
                            rConversation = rConversation || getConversationResource();
                            var convState = rConversation && rConversation.get('state', '');
                            // TODO: move Conversation.State to model.common.js and use enum here
                            return convState == 'Conferencing' || convState == 'Conferenced';
                        }
                        function getConversationResource() {
                            // sHref is an internal id available in this file
                            var href = conversation && conversation[Internal.sHref];
                            return href ? ucwa.get(href) : null;
                        }
                        function getRenegotiationsHref() {
                            var renegoHref, negoSession, negotiated = filter(values(avSessions), function (session) {
                                return session.negotiated;
                            });
                            if (negotiated.length > 0) {
                                assert(negotiated.length == 1);
                                negoSession = negotiated[0];
                                renegoHref = negoSession.resumeAudioVideoUri || negoSession.resource.link('renegotiations').href;
                                assert(renegoHref);
                            }
                            return renegoHref;
                        }
                        function setNegotiatedSession(sctx) {
                            foreach(avSessions, function (session) {
                                if (session.resource.get('sessionContext') == sctx)
                                    session.negotiated = true;
                            });
                        }
                        // switches video rendering on/off for 1:1 conversations when video starts/stops streaming 
                        // and when video container is set/changed/nulled
                        function setVideoRendering(videoStream, isPreview) {
                            videoStream._isFlowing.changed(function (newVal, reason, oldVal) {
                                log('AudioVideoSession(' + callId + ')::isFlowing changed:isPreview=' + isPreview, oldVal + '=>' + newVal, reason);
                                if (newVal)
                                    showVideo(videoStream, isPreview);
                                else
                                    removeVideo(videoStream, isPreview);
                            });
                            videoStream.source.sink.container.changed(function (newVal, reason, oldVal) {
                                log('AudioVideoSession(' + callId + ')::container changed:isPreview=' + isPreview, oldVal + '=>' + newVal, reason);
                                if (videoStream._isFlowing()) {
                                    if (oldVal)
                                        removeVideo(videoStream, isPreview);
                                    if (newVal)
                                        showVideo(videoStream, isPreview);
                                }
                            });
                            videoStream.source.sink.format.changed(function (newVal, reason, oldVal) {
                                var sink = videoStream.source.sink;
                                log('AudioVideoSession(' + callId + ')::format changed:isPreview=' + isPreview, oldVal + '=>' + newVal, reason);
                                if (newVal && videoStream._id() && sink._videoWindow() && videoStream._isFlowing()) {
                                    pcAV.invoke('SetVideoDisplayOptions', isPreview ? Internal.MediaEnum.MediaDeviceType.PREVIEW : Internal.MediaEnum.MediaDeviceType.RENDER, sink._videoWindow(), sink._format(), 1 /* SmartCrop */);
                                    tm && tm.record(Web.TelemetryEvent.Call, {
                                        action: 'SetVideoDisplayOptions',
                                        type: isConferencing() ? 'conf' : 'p2p',
                                        modalities: activeModalities.video ? 'av' : 'audio',
                                        mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                        state: state(),
                                        oldFormat: oldVal,
                                        newFormat: newVal,
                                        reason: reason,
                                        mediaDeviceType: isPreview ? 'preview' : 'render',
                                        callId: callId
                                    });
                                }
                            });
                        }
                        function handleMeetingVideoOnHoldResume(val) {
                            var promises = [];
                            if (val) {
                                var _loop_2 = function (id) {
                                    var p = participantsWithVideoToRender[id];
                                    var dfd = removeParticipantVideo(p, true).then(function () {
                                        return p[Internal.sInternal].setVideoStarted(false);
                                    });
                                    promises.push(dfd);
                                };
                                for (var id in participantsWithVideoToRender) {
                                    _loop_2(id);
                                }
                            }
                            else {
                                var _loop_3 = function (id) {
                                    var p = participantsWithVideoToRender[id];
                                    var dfd = showParticipantVideo(p, true).then(function () {
                                        return p[Internal.sInternal].setVideoStarted(true);
                                    });
                                    promises.push(dfd);
                                };
                                for (var id in participantsWithVideoToRender) {
                                    _loop_3(id);
                                }
                            }
                            return Task.waitAll(promises);
                        }
                        function addParticipantWithVideoToRender(participant) {
                            assert(participant);
                            participantsWithVideoToRender[participant[Internal.sHref]] = participant;
                        }
                        function removeParticipantWithVideoToRender(participant) {
                            assert(participant);
                            delete participantsWithVideoToRender[participant[Internal.sHref]];
                        }
                        // called when we stop 1:1 video (including escalation to a meeting)
                        function removeAllVideo(reason) {
                            log('AudioVideoSession(' + callId + ')::removeAllVideo', reason);
                            removeVideo(mainVideoStream, false);
                            removeVideo(selfVideoStream, true);
                            mainVideoStream._isFlowing(false);
                            selfVideoStream._isFlowing(false);
                            if (reason !== Internal.sEscalation) {
                                selfParticipant[Internal.sInternal].setVideoStream(null);
                            }
                            if (participants.size() > 0) {
                                participants(0)[Internal.sInternal].setVideoStream(null);
                                participants(0)[Internal.sInternal].setVideoStarted(false);
                            }
                        }
                        function resetVideo(reason) {
                            log('AudioVideoSession(' + callId + ')::resetVideo', reason);
                            participants.each(function (p) {
                                // reset the participant video stream source to an empty stream
                                p[Internal.sInternal].setVideoStream(null);
                            });
                            mainVideoStream._isFlowing(false);
                            selfVideoStream._isFlowing(false);
                            videoStreams.empty();
                            if (reason !== Internal.sEscalation) {
                                selfParticipant[Internal.sInternal].setVideoStream(null);
                                selfParticipant[Internal.sInternal].videoState(Internal.Modality.State.Disconnected);
                            }
                        }
                        // Check if the SDP offer/answer contains a=inactive field,
                        // which indicates it is a renegotiation triggered when a
                        // participant holds a call.
                        function isHoldRequest(sdp) {
                            return /\ba=inactive\b/gmi.test(sdp);
                        }
                        function isAudioInvitation() {
                            return invitation && !invitation.hasVideo() ||
                                rInvitation && rInvitation.rel == 'onlineMeetingInvitation' &&
                                    conversation.meeting.availableModalities.audio() &&
                                    !conversation.meeting.availableModalities.video();
                        }
                        function isVideoInvitation() {
                            return invitation && invitation.hasVideo() ||
                                rInvitation && rInvitation.rel == 'onlineMeetingInvitation' &&
                                    conversation.meeting.availableModalities.video();
                        }
                        function getDiagnosticsBlob() {
                            var blob;
                            try {
                                if (pcAV)
                                    blob = pcAV.invoke('GetDiagnosticsBlob');
                                if (blob && blob[0] === 0)
                                    return blob[1];
                            }
                            catch (err) {
                                log('GetDiagnosticsBlob FAILURE', err);
                            }
                        }
                        function getPluginVersion() {
                            return !Web.Media.useBrowserMedia() ? devices && devices.mediaCapabilities.installedVersion() : void 0;
                        }
                        // This POST will fail until we upgrade to v16.1 of the plugin since the 
                        // diagnostics blob format has been fixed by media libraries for that version.
                        // Until then the exception is continuable.
                        function postMediaDiagnosticsData(reason) {
                            if (!reportMediaDiagnosticsUrl)
                                return;
                            log('AudioVideoSession(' + callId + ')::postMediaDiagnostics', reason);
                            var blob = getDiagnosticsBlob();
                            if (blob) {
                                // at minimum empty data is a must, else ucwa fails input validation
                                var content = { data: {}, nobatch: true };
                                content.headers = { 'X-MS-MediaDiagnostics': blob };
                                content.data.callId = callId;
                                if (reason) {
                                    if (reason.code)
                                        content.data.errorCode = reason.code;
                                    if (reason.subcode)
                                        content.data.errorSubcode = reason.subcode;
                                }
                                var dfd = ucwa.send('POST', reportMediaDiagnosticsUrl, content);
                                tm && tm.monitor(dfd, Web.TelemetryEvent.Call, {
                                    action: 'postMediaDiagnostics',
                                    type: isConferencing() ? 'conf' : 'p2p',
                                    modalities: activeModalities.video ? 'av' : 'audio',
                                    mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                    pluginVersion: getPluginVersion(),
                                    callId: callId
                                });
                                // reset so it doesn't get sent again for this session
                                reportMediaDiagnosticsUrl = null;
                            }
                        }
                        function postCallQualityFeedback() {
                            if (!publishCallQualityFeedbackUrl)
                                return;
                            var qoe;
                            try {
                                qoe = pcAV.invoke('GetQoeXml');
                            }
                            catch (err) {
                                log('GetQoeXml FAILURE', err);
                            }
                            if (qoe && qoe[0] === 0) {
                                if (qoe.length < 3) {
                                    log('Unexpected GetQoeXml result', qoe);
                                    return;
                                }
                                var dfd = ucwa.send('POST', publishCallQualityFeedbackUrl, {
                                    data: {
                                        mediaEndpoint: qoe[1],
                                        mediaQualityOfExperience: qoe[2]
                                    },
                                    nobatch: true
                                });
                                tm && tm.monitor(dfd, Web.TelemetryEvent.Call, {
                                    action: 'publishCallQualityFeedback',
                                    type: isConferencing() ? 'conf' : 'p2p',
                                    modalities: activeModalities.video ? 'av' : 'audio',
                                    mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                    pluginVersion: getPluginVersion(),
                                    callId: callId
                                });
                                // reset so it doesn't get sent again for this session
                                publishCallQualityFeedbackUrl = null;
                            }
                        }
                        // The publishTelemetry link only appears for meeting join scenarios, not even during escalations
                        function postPublishTelemetry(avResourceWhenConnected) {
                            if (avResourceWhenConnected.hasLink('publishTelemetry')) {
                                ucwa.send('POST', avResourceWhenConnected.link('publishTelemetry').href, {
                                    nobatch: true,
                                    headers: { 'Content-Type': 'application/json' },
                                    // Search online for 'ASP.NET AJAX: Inside JSON date and time string'
                                    // By JSON rules, "\/Date(ticks)\/" is technically equivalent to "/Date(ticks)/" but 
                                    // the JavaScriptSerializer (in UCWA) will deserialize the former as a DateTime and the latter as a String.
                                    // Hence, forced to build content as a string to prevent JSON.stringify in our Endpoint from removing the '\'
                                    // Also:
                                    // endTime should be greater than startTime else UCWA will fail
                                    data: '{startTime:"\\/Date(' + currentUTCms() + ')\\/", '
                                        + 'endTime:"\\/Date(' + (currentUTCms() + 1) + ')\\/"}'
                                });
                            }
                        }
                        //#endregion
                        //#region public methods
                        //#region start
                        /**
                         * Starts an outgoing Audio/Video call
                         *
                         *  @param {String} remoteUri
                         *  @param {MediaEnum.MediaConfig} audioConfig
                         *  @param {MediaEnum.MediaConfig} mainVideoConfig
                         *  @param {Object} [video]
                         *
                         *  @returns {Promise}
                         *
                         *  Starting a P2P audio call
                         *  - Creates an AVComponent in the media plugin.
                         *  - Invokes AVComponent::SetCallConfig.
                         *  - Invokes AVComponent::SetMediaConfig.
                         *  - Gets an OFFER_READY event from the AVComponent.
                         *  - Sends a POST request to startAudioVideo link with the SDP offer.
                         *  - Gets an "audioVideoInvitation started" event from UCWA.
                         *  - Gets an "audioVideoNegotiation started" event from UCWA with a provisional SDP answer.
                         *  - Invokes AVComponent::SetProvisionalAnswer.
                         *  -  Gets an "audioVideoSession added" event.
                         *  -  Gets an "audioVideoNegotiation completed" event with a final SDP answer.
                         *  -  Invokes AVComponent::SetFinalAnswer.
                         *  -  Gets a "audioVideoInvitation completed" event from UCWA.
                         *  -  Invokes AVComponent::CompleteNegotiation.
                         *  -  Gets a "audioVideoRenegotiation started" event from UCWA.
                         *  -  Gets a OFFER_READY event from AVComponent with a new SDP answer.
                         *  -  Sends a POST request to audioVideoSession/renegotiations link.
                         *  -  Gets a "audioVideoRenegotiation completed" event from UCWA with a new SDP answer.
                         *  -  Invokes AVComponent::SetFinalAnswer.
                         *  -  Invokes AVComponent::CompleteNegotiation.
                         *
                         *  Joining an audio conference call the client follows the same sequence with one exception:
                         *  there is no initial negotiation - all "audioVideoNegotiation" events are absent.
                         *
                         *  If the client calls an invalid sip uri, it receives a single "audioVideoInvitation
                         *  completed" event with failure status and appropriate error code.
                         */
                        function start(options) {
                            // prohibit start of audio or video when that modality is already started
                            if ((options.mainVideoConfig != 0 /* NOT_PRESENT */ && activeModalities.video) ||
                                (options.mainVideoConfig == 0 /* NOT_PRESENT */ &&
                                    options.audioConfig == 3 /* BOTH */ && activeModalities.audio))
                                return Task.wait('already started');
                            log('AudioVideoSession(' + callId + ')::start', options);
                            check.state(onHold(), false);
                            dfdStart = new Task('starting a call');
                            var audioConfig = options.audioConfig, previewContainer = options.video && options.video.previewContainer, videoContainer = options.video && options.video.container, startsVideo = options.mainVideoConfig != 0 /* NOT_PRESENT */, oldMainVideoConfig = mainVideoConfig;
                            mainVideoConfig = options.mainVideoConfig;
                            // start is allowed to be called twice only when the first call starts audio,
                            // and the second call adds video. So a different options.remoteUri for adding
                            // video does not make sense
                            remoteUri = remoteUri || options.remoteUri;
                            options = null;
                            check.state(state(), [
                                Internal.Modality.State.Disconnected,
                                Internal.Modality.State.Notified,
                                Internal.Modality.State.Connected
                            ]);
                            if (state() == Internal.Modality.State.Disconnected ||
                                state() == Internal.Modality.State.Notified) {
                                state(Internal.Modality.State.Connecting);
                            }
                            // to keep parity with Skype not only we need to set the local participant AV state
                            // in a 1:1 call but also to fake the remote participant AV state; and we always check
                            // for the remote participant existence because the call can be started with the
                            // empty participants collection by specifying the remote sip uri.
                            if (audioState() == Internal.Modality.State.Disconnected ||
                                audioState() == Internal.Modality.State.Notified) {
                                audioState(Internal.Modality.State.Connecting);
                                if (!isConferencing() && participants.size() > 0)
                                    participants(0)[Internal.sInternal].audioState(Internal.Modality.State.Connecting);
                            }
                            // reset videoState if user does not want to start video
                            if (!startsVideo)
                                videoState(Internal.Modality.State.Disconnected);
                            if (videoState() == Internal.Modality.State.Disconnected && startsVideo ||
                                videoState() == Internal.Modality.State.Notified) {
                                videoState(Internal.Modality.State.Connecting);
                                if (!isConferencing() && participants.size() > 0)
                                    participants(0)[Internal.sInternal].videoState(Internal.Modality.State.Connecting);
                            }
                            var promise = initMedia().then(function () {
                                if (!pcAV) {
                                    pcAV = mediaPlugin.createComponent({
                                        type: 'AVComponent',
                                        hide: true
                                    });
                                    pcAV.event(onPluginComponentEvent, 'async');
                                    return pcAV.load(localUri, isConferencing() ? guid() : remoteUri, conversation.threadId(), isConferencing(), 
                                    // max num of video channels - use 1 for P2P, otherwise the media
                                    // manager will fail the call constructed by the media plugin.
                                    isConferencing() ? mediaConfig.maxVideoChannelCount() : 1, mediaConfig.audioVideoSecurityLevel());
                                }
                            }).then(function () {
                                // This path occurs when the audio call is connecting and video is started immediately;
                                // audio renegotiation is in progress and the plugin will fail to start video until it is completed.
                                return dfdOutRenego.promise.then(function () {
                                    // give up if there is pending incoming renegotiation and
                                    // this is to start video on top of connected audio; because
                                    // it would otherwise cause renegotiation conflict
                                    if (startsVideo && audioState() == 'Connected') {
                                        if (isPendingInRenego)
                                            throw renegoError;
                                        else
                                            dfdOutRenego = new Task();
                                    }
                                });
                            }).then(function () {
                                var moreChannels = mainVideoConfig != 0 /* NOT_PRESENT */ && isConferencing();
                                // select default devices if we have not selected a device explicitly
                                if (devices && !devices.selectedMicrophone())
                                    mediaConfig.setDefaultDevices();
                                pcAV.invoke('SetCallConfig', mediaConfig.isInternal() ?
                                    Internal.MediaEnum.PreferredMediaAddressType.Direct :
                                    Internal.MediaEnum.PreferredMediaAddressType.Relay);
                                // hook up the preview video stream - this will retain the video container if it was set for
                                // self participant.
                                // NB: we need to do it even if it's just an audio call. If the video is added later we won't
                                // receive another invitation (it's a renegotiation of an established AV connection), so
                                // we won't have a chance to call accept method again.
                                selfParticipant[Internal.sInternal].setVideoStream(selfVideoStream);
                                if (videoContainer)
                                    mainVideoStream.source.sink.container(videoContainer);
                                if (previewContainer)
                                    selfVideoStream.source.sink.container(previewContainer);
                                pcAV.invoke('SetMediaConfig', audioConfig, // audio configuration
                                mainVideoConfig, // main video configuration
                                moreChannels ? mediaConfig.maxVideoChannelCount() - 1 : 0, // additional video channel count
                                moreChannels ? 2 /* RECEIVE */ : 0 /* NOT_PRESENT */, // additional video config
                                0 /* NOT_PRESENT */); // panoVideoConfig
                                if (audioState() == Internal.Modality.State.Connecting && !isConferencing() && participants.size() > 0)
                                    participants(0)[Internal.sInternal].audioState(Internal.Modality.State.Ringing);
                                if (startsVideo && audioState() == 'Connected')
                                    startTrackingSelfVideoToggle();
                                // expect an OFFER_READY event from the media plugin
                                dfdStart.status('waiting for an OFFER_READY event from the media plugin');
                            });
                            return Task.waitAll([promise, dfdStart.promise]).catch(function (error) {
                                log('AudioVideoSession(' + callId + ')::start failed', error);
                                if (error == renegoError && startsVideo && audioState() == 'Connected') {
                                    // this was an attempt to start video on top of audio, make sure
                                    // audio connection does not get cleaned up
                                    mainVideoConfig = oldMainVideoConfig;
                                    videoState(Internal.Modality.State.Disconnected);
                                    if (!isConferencing() && participants.size() > 0 &&
                                        participants(0)[Internal.sInternal].videoState() == Internal.Modality.State.Connecting)
                                        participants(0)[Internal.sInternal].videoState(Internal.Modality.State.Disconnected);
                                    if (dfdStart.state() == 'pending')
                                        dfdStart.reject(error);
                                    throw error;
                                }
                                postMediaDiagnosticsData();
                                if (!rAVInvitation) {
                                    // if the AV invitation was not sent (rAVInvitation is undefined) release the plugin component.
                                    cleanup(error);
                                }
                                else if (rAVInvitation.hasLink('cancel')) {
                                    // if the AV invitation was sent and the "audioVideoInvitation started" event was received we have
                                    // the cancel link and we can terminate the call here.
                                    ucwa.send('POST', rAVInvitation.link('cancel').href, { nobatch: true });
                                }
                                else {
                                }
                                if (dfdStart.state() == 'pending')
                                    dfdStart.reject(error);
                                if (dfdOutRenego.state() == 'pending')
                                    dfdOutRenego.resolve();
                                state(Internal.Modality.State.Disconnected);
                                audioState(Internal.Modality.State.Disconnected);
                                videoState(Internal.Modality.State.Disconnected);
                                throw error;
                            });
                        }
                        //#endregion
                        //#region accept
                        /**
                         * Accepts an incoming Audio/Video invitation.
                         *
                         * @param {Dictionary} [video] - The video window container holder.
                         * @param {HTMLElement} [video.container] - A DOM element that serves as the video window container for remote video.
                         *
                         * @returns {Promise}
                         *
                         * Accepting an incoming call invitation:
                         *
                         *  - Creates an AVComponent with the media plugin.
                         *  - Invokes AVComponent::Load and waits until it gets loaded.
                         *  - Invokes AVComponent::SetCallConfig.
                         *  - Invokes AVComponent::SetAcceptedMedia and specifies that no video is needed.
                         *  - Invokes AVComponent::SetOffer with the SDPs received from the remote party.
                         *  - Handles the ANSWER_READY event from the media plugin: the event contains an SDP.
                         *  - Sends a POST audioVideoInvitation/acceptWithAnswer with the SDP from the media plugin.
                         *  - Receives an "audioVideoinvitation completed" event from UCWA
                         *  - Receives an "audioVideoRenegotiation started" event with a new SDP from the remote party.
                         *  - Invokes AVComponent::SetAcceptedMedia.
                         *  - Invokes AVComponent::SetOffer with the new SDP given in the renegotiation event.
                         *  - Handles another ANSWER_READY event from the media plugin with an SDP answer.
                         *  - Sends a POST audioVideoRenegotiation/answer with the SDP answer.
                         *  - Receives a "audioVideoRenegotiation completed" event from UCWA.
                         *  - Invokes AVComponent::CompleteNegotiation
                         */
                        function accept(options) {
                            assert(invitation, 'This is an outgoing call, so it cannot be "accepted"');
                            assert(!isConferencing(), 'This is a conference'); // accept is used in P2P only
                            assert(participants.size() == 1, 'The caller is not in participants');
                            log('AudioVideoSession(' + callId + ')::accept', options);
                            dfdAccept = new Task('accepting a call');
                            var video = options && options.video, videoContainer = video && video.container, previewContainer = video && video.previewContainer;
                            mainVideoConfig = video ? Internal.MediaEnum.enumcastDirection(video.direction) :
                                settings && settings.supportsVideo == false ? 0 /* NOT_PRESENT */ : 2 /* RECEIVE */;
                            state(Internal.Modality.State.Connecting);
                            audioState(Internal.Modality.State.Connecting);
                            participants(0)[Internal.sInternal].audioState(Internal.Modality.State.Connecting);
                            if (invitation.hasVideo()) {
                                videoState(Internal.Modality.State.Connecting);
                                participants(0)[Internal.sInternal].videoState(Internal.Modality.State.Connecting);
                            }
                            var promise = initMedia().then(function () {
                                // the caller has already hung up
                                if (state() == Internal.Modality.State.Disconnected)
                                    throw Internal.EInvitationFailed(state.reason);
                                assert(!pcAV);
                                pcAV = mediaPlugin.createComponent({
                                    type: 'AVComponent',
                                    hide: true
                                });
                                pcAV.event(onPluginComponentEvent, 'async');
                                return pcAV.load(localUri, invitation.from.uri(), invitation.resource.get('threadId'), false, // isConference - accept is used in P2P only
                                1, // max num of video channels - only the main video channel is used in P2P (don't change,
                                // otherwise the media manager will fail the call constructed by the media plugin)
                                mediaConfig.audioVideoSecurityLevel());
                            }).then(function () {
                                // the caller has already hung up
                                if (state() == Internal.Modality.State.Disconnected)
                                    throw Internal.EInvitationFailed(state.reason);
                                // select default devices if we have not selected a device explicitly
                                if (devices && !devices.selectedMicrophone())
                                    mediaConfig.setDefaultDevices();
                                // hook up the preview video stream - this will retain the video container if it was set for
                                // self participant.
                                // NB: we need to do it even if it's just an audio call. If the video is added later we won't
                                // receive another invitation (it's a renegotiation of an established AV connection), so
                                // we won't have a chance to call accept method again.
                                selfParticipant[Internal.sInternal].setVideoStream(selfVideoStream);
                                if (videoContainer)
                                    mainVideoStream.source.sink.container(videoContainer);
                                if (previewContainer)
                                    selfVideoStream.source.sink.container(previewContainer);
                                pcAV.invoke('SetCallConfig', mediaConfig.isInternal() ?
                                    Internal.MediaEnum.PreferredMediaAddressType.Direct :
                                    Internal.MediaEnum.PreferredMediaAddressType.Relay);
                                pcAV.invoke('SetAcceptedMedia', 3 /* BOTH */, // audio
                                mainVideoConfig); // video
                                // expect the ANSWER_READY event from the plugin after this call
                                setOffer(invitation.offers);
                                dfdAccept.status('awaiting an ANSWER_READY event from the media plugin');
                            });
                            return Task.waitAll([promise, dfdAccept.promise]).catch(function (error) {
                                log('AudioVideoSession(' + callId + ')::accept failed', error);
                                postMediaDiagnosticsData();
                                state(Internal.Modality.State.Disconnected);
                                audioState(Internal.Modality.State.Disconnected);
                                videoState(Internal.Modality.State.Disconnected);
                                cleanup();
                                if (dfdAccept.state() == 'pending')
                                    dfdAccept.reject(error);
                                throw error;
                            });
                        }
                        //#endregion
                        //#region stop
                        /**
                         * Stops Audio/Video session
                         *
                         * @param {String} [reason] - if equals 'video', only video is stopped, if omitted both audio and video are stopped.
                         */
                        function stop(reason) {
                            log('AudioVideoSession(' + callId + ')::stop', reason);
                            // cancel start/accept if stop is called during connecting
                            if (state() == Internal.Modality.State.Connecting) {
                                var dfd = dfdStart || dfdAccept;
                                if (dfd) {
                                    dfd.promise.cancel();
                                    return Promise.resolve();
                                }
                                else {
                                    log('AudioVideoSession(' + callId + '):: stop cannot be called in Connecting state without a pending start or accept');
                                    return Promise.reject(ENotSupported('stop cannot be called in Connecting state without a pending start or accept'));
                                }
                            }
                            var task = new Task;
                            if (reason == 'video') {
                                if (isConferencing()) {
                                    participants.each(function (p) {
                                        p.video.channels(0).isStarted(false);
                                    });
                                }
                                var audioConfig = onHold() ?
                                    4 /* NO_ACTIVE_MEDIA */ : 3 /* BOTH */;
                                mainVideoConfig = 0 /* NOT_PRESENT */;
                                pcAV.invoke('SetMediaConfig', audioConfig, // audio configuration
                                mainVideoConfig, // main video configuration
                                isConferencing() ? mediaConfig.maxVideoChannelCount() - 1 : 0, // video channel count
                                0 /* NOT_PRESENT */, // videoConfig
                                0 /* NOT_PRESENT */); // panoVideoConfig
                                task.resolve();
                            }
                            else if (reason === Internal.sEscalation || (reason && reason.code == 'NotFound')) {
                                // if escalation or server error, do only cleanup
                                cleanup(reason);
                                task.resolve();
                            }
                            else {
                                postCallQualityFeedback();
                                // if not escalation then it is a call getting stopped.
                                // In this case call stopAudioVideo on ucwa and then cleanup
                                task.from(ucwa.send('GET', rConversation.link('audioVideo').href).then(function (rAudioVideo) {
                                    var content = { query: { reason: 'UserInitiatedAction' } };
                                    var blob = getDiagnosticsBlob();
                                    if (blob)
                                        extend(content, { headers: { 'X-MS-MediaDiagnostics': blob } });
                                    return ucwa.send('POST', rAudioVideo.link('stopAudioVideo').href, content);
                                }).catch(function (err) {
                                    // any error during stopAudioVideo (e.g., no audioVideo link or POST failed
                                    // with 404 NotFound) should not be considered a failure of stop action, but
                                    // should be recorded in telemetry
                                    tm && tm.record(Web.TelemetryEvent.Call, {
                                        action: 'stopAudioVideo',
                                        type: isConferencing() ? 'conf' : 'p2p',
                                        modalities: activeModalities.video ? 'av' : 'audio',
                                        mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                        state: state(),
                                        reason: err,
                                        callId: callId
                                    });
                                }).finally(function () { return cleanup(reason); }));
                            }
                            return task.promise.then(function () { }); // the 'then' clause is to satisfy the Promise<void> return type contract
                        }
                        //#endregion
                        //#region sendDtmf
                        /**
                         * Sends a DTMF tone
                         *
                         * @param {String} tone - A DTMF tone from MediaEnum.DtmfTone enumeration
                         * @returns {Promise}
                         */
                        function sendDtmf(tone) {
                            if (isNotEmptyString(tone)) {
                                tone = tone.trim().toLowerCase();
                                tone = tone.substr(0, 1).toUpperCase() + tone.substr(1);
                                switch (tone) {
                                    case '*':
                                        tone = 'Star';
                                        break;
                                    case '#':
                                        tone = 'Pound';
                                        break;
                                }
                                if (Internal.MediaEnum.DtmfTone[tone] !== undefined) {
                                    pcAV.invoke('SendDTMF', Internal.MediaEnum.DtmfTone[tone]);
                                    return Promise.resolve(tone);
                                }
                            }
                            throw EInvalidArgument('tone', 'out of range');
                        }
                        //#endregion
                        //#region showParticipantVideo
                        function showParticipantVideo(participant, whileOnHold) {
                            var p = new Promise(function (resolve) {
                                if (videoState() == Internal.Modality.State.Connecting) {
                                    var sub_1 = videoState.changed(function (newValue, reason, oldValue) {
                                        if (newValue != Internal.Modality.State.Connecting) {
                                            sub_1.dispose();
                                            resolve();
                                        }
                                    });
                                }
                                else
                                    resolve();
                            });
                            return p.then(function () {
                                var videoStream, dfd;
                                if (videoState() != Internal.Modality.State.Connected)
                                    throw EInvalidState(videoState(), Internal.Modality.State.Connected);
                                if (onHold() && !whileOnHold)
                                    throw Exception('OnHold');
                                log('AudioVideoSession(' + callId + ')::showParticipantVideo', participant);
                                if (participant[Internal.sInternal].isLocal()) {
                                    // undefined means that we just started video, no need to renegotiate
                                    // TODO: this condition may be redundant - the undefined code path
                                    // is unreachable because when video initially gets Connected, the
                                    // '_set' setter is used to change isStarted to true, which will not
                                    // go through the custom setter to arrive here.
                                    if (participant.video.channels(0).isStarted() === false) {
                                        // check to see if there is ongoing renegotiation
                                        return dfdOutRenego.promise.then(function () {
                                            // give up if there is pending incoming renegotiation
                                            if (isPendingInRenego)
                                                throw renegoError;
                                            dfdOutRenego = new Task();
                                            mainVideoConfig = 3 /* BOTH */;
                                            pcAV.invoke('SetMediaConfig', 3 /* BOTH */, // audio configuration
                                            mainVideoConfig, // main video configuration
                                            isConferencing() ? mediaConfig.maxVideoChannelCount() - 1 : 0, // additional video channel count
                                            isConferencing() ? 2 /* RECEIVE */ : 0 /* NOT_PRESENT */, // additional video config
                                            0 /* NOT_PRESENT */); // panoVideoConfig
                                            // expect an OFFER_READY event from the media plugin
                                            return startTrackingSelfVideoToggle();
                                        }).catch(function (err) {
                                            log(err);
                                            stopTrackingSelfVideoToggle('reject', err);
                                            if (dfdOutRenego.state() == 'pending')
                                                dfdOutRenego.resolve();
                                            throw err;
                                        });
                                    }
                                    return new Task().resolve().promise;
                                }
                                else if (isConferencing()) {
                                    // find available stream
                                    if (!mainVideoStream._isAttached()) {
                                        videoStream = mainVideoStream;
                                    }
                                    else {
                                        for (var _i = 0, _a = videoStreams(); _i < _a.length; _i++) {
                                            var vs = _a[_i];
                                            if (!vs._isAttached()) {
                                                videoStream = vs;
                                                break;
                                            }
                                        }
                                        ;
                                    }
                                    if (!videoStream) {
                                        log('Cannot find available stream');
                                        throw EDoesNotExist('No available stream');
                                    }
                                    participant[Internal.sInternal].setVideoStream(videoStream);
                                    videoStream._isAttached(true);
                                    dfd = showVideo(videoStream, false).then(function () {
                                        try {
                                            pcAV.invoke('Subscribe', videoStream._id(), participant[Internal.sInternal].videoSourceId());
                                        }
                                        catch (err) {
                                            log('SUBSCRIBE ERROR: ' + err);
                                            throw err;
                                        }
                                    }).then(function () {
                                        var sink = videoStream.source.sink;
                                        sink._c(sink.container.changed(function (newVal, reason, oldVal) {
                                            if (oldVal)
                                                removeVideo(videoStream, false);
                                            if (newVal)
                                                showVideo(videoStream, false);
                                        }));
                                        sink._f(sink.format.changed(function (newVal, reason, oldVal) {
                                            if (newVal && videoStream._id() && sink._videoWindow()) {
                                                pcAV.invoke('SetVideoDisplayOptions', Internal.MediaEnum.MediaDeviceType.RENDER, sink._videoWindow(), sink._format(), 1 /* SmartCrop */);
                                                tm && tm.record(Web.TelemetryEvent.Call, {
                                                    action: 'SetVideoDisplayOptions',
                                                    type: isConferencing() ? 'conf' : 'p2p',
                                                    modalities: activeModalities.video ? 'av' : 'audio',
                                                    mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                                    state: state(),
                                                    oldFormat: oldVal,
                                                    newFormat: newVal,
                                                    reason: reason,
                                                    mediaDeviceType: 'render',
                                                    callId: callId
                                                });
                                            }
                                        }));
                                        addParticipantWithVideoToRender(participant);
                                    });
                                }
                                else {
                                    dfd = new Task().reject(ENotSupported('cannot start remote video in 1:1 conversation')).promise;
                                }
                                return dfd;
                            });
                        }
                        //#endregion showParticipantVideo
                        //#region removeParticipantVideo
                        function removeParticipantVideo(participant, whileOnHold) {
                            var dfd;
                            log('AudioVideoSession(' + callId + ')::removeParticipantVideo', participant);
                            if (participant[Internal.sInternal].isLocal()) {
                                // check to see if there is ongoing renegotiation
                                dfd = dfdOutRenego.promise.then(function () {
                                    // give up if there is pending incoming renegotiation
                                    if (isPendingInRenego)
                                        throw renegoError;
                                    dfdOutRenego = new Task();
                                    // need to respect the current videoConfig of the remote party
                                    var v = participants(0).video.channels(0);
                                    if (!isConferencing() && !v.isVideoOn())
                                        mainVideoConfig = 4 /* NO_ACTIVE_MEDIA */;
                                    else
                                        mainVideoConfig = 2 /* RECEIVE */;
                                    pcAV.invoke('SetMediaConfig', 3 /* BOTH */, // audio configuration
                                    mainVideoConfig, // main video configuration
                                    isConferencing() ? mediaConfig.maxVideoChannelCount() - 1 : 0, // additional video channel count
                                    isConferencing() ? 2 /* RECEIVE */ : 0 /* NOT_PRESENT */, // additional video config
                                    0 /* NOT_PRESENT */); // panoVideoConfig
                                    // expect an OFFER_READY event from the media plugin
                                    return startTrackingSelfVideoToggle();
                                }).catch(function (err) {
                                    log(err);
                                    stopTrackingSelfVideoToggle('reject', err);
                                    if (dfdOutRenego.state() == 'pending')
                                        dfdOutRenego.resolve();
                                    throw err;
                                });
                            }
                            else if (isConferencing()) {
                                dfd = Task.wait(null, 'sync').then(function () {
                                    // NB: this is a sourced stream
                                    var videoStream = participant.video.channels(0).stream;
                                    var sink = videoStream.source.sink;
                                    if (sink._c())
                                        sink._c().dispose();
                                    if (sink._f())
                                        sink._f().dispose();
                                    if (!whileOnHold)
                                        removeParticipantWithVideoToRender(participant);
                                    if (videoStream._isAttached()) {
                                        try {
                                            pcAV.invoke('Unsubscribe', videoStream._id());
                                        }
                                        catch (err) {
                                            log('UNSUBSCRIBE ERROR: ' + err);
                                        }
                                        removeVideo(videoStream, false);
                                        videoStream._isAttached(false);
                                        participant[Internal.sInternal].setVideoStream(null);
                                    }
                                });
                            }
                            else {
                                // in 1:1 we can't remove remote video without stopping video altogether
                                dfd = new Task().reject(ENotSupported('cannot remove remote video in 1:1 conversation')).promise;
                            }
                            return dfd;
                        }
                        //#endregion removeParticipantVideo
                        //#endregion public methods
                        //#region cleanup
                        // Unsubscribes from server and plugin component events and unloads the plugin component
                        function cleanup(reason) {
                            if (isClean()) {
                                log('AudioVideoSession(' + callId + ')::already cleaned up', reason);
                                return;
                            }
                            tm && tm.record(Web.TelemetryEvent.Call, {
                                action: 'cleanup',
                                type: isConferencing() ? 'conf' : 'p2p',
                                modalities: activeModalities.video ? 'av' : 'audio',
                                mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                state: state(),
                                reason: reason,
                                callId: callId
                            });
                            var cDisconnected = Internal.Modality.State.Disconnected;
                            log('AudioVideoSession(' + callId + ')::cleanup', reason);
                            // Before unloading plugin component, reset some avs state
                            if (isConferencing())
                                muted._set(false);
                            else
                                muted.set(false);
                            onHold._set(false);
                            // These are both 'bottom-up' property changes; ie. selfParticipant.audio.isMuted 
                            // inherits from avm.muted which inherits from avs.muted.
                            // To reflect change in isMuted and isOnHold() must do a get() explicitly
                            selfParticipant.audio.isMuted.get();
                            selfParticipant.audio.isOnHold.get();
                            // clean up the internal properties associated with call hold
                            selfParticipant[Internal.sInternal].audioOnHold(false);
                            selfParticipant[Internal.sInternal].videoStartedBeforeHold(undefined);
                            ucwa.event.off(onServerEvent);
                            if (pcAV) {
                                pcAV.event.off(onPluginComponentEvent);
                                try {
                                    removeAllVideo(reason);
                                    pcAV.invoke('Terminate');
                                    pcAV.unload();
                                }
                                catch (err) {
                                    // a plugin component may be unloaded by the plugin uninit when plugin manager detects
                                    // that the plugin is not responding
                                    if (pcAV.state() != PluginComponent.State.Unloaded)
                                        log('AudioVideoSession(' + callId + '):: AV component cleanup failed', err);
                                }
                                pcAV = null;
                            }
                            if (pluginStateSub) {
                                pluginStateSub.dispose();
                                pluginStateSub = null;
                            }
                            participants.each(function (p) {
                                // reset the participant video stream source to an empty stream
                                p[Internal.sInternal].setVideoStream(null);
                                // note the reset of participant.[audio|video].state is done inside AVM.
                                if (reason !== Internal.sEscalation) {
                                    p.video.channels(0)[Internal.sInternal].isVideoOn(false);
                                    p[Internal.sInternal].setVideoStarted(false);
                                }
                            });
                            if (reason !== Internal.sEscalation) {
                                selfParticipant.video.channels(0)[Internal.sInternal].isVideoOn(false);
                                selfParticipant[Internal.sInternal].setVideoStarted(false);
                            }
                            audioState(cDisconnected /*, reason*/);
                            videoState(cDisconnected, reason);
                            if (selectedCameraChangedSubscription) {
                                selectedCameraChangedSubscription.dispose();
                                selectedCameraChangedSubscription = null;
                            }
                            if (selectedMicrophoneChangedSubscription) {
                                selectedMicrophoneChangedSubscription.dispose();
                                selectedMicrophoneChangedSubscription = null;
                            }
                            if (selectedSpeakerChangedSubscription) {
                                selectedSpeakerChangedSubscription.dispose();
                                selectedSpeakerChangedSubscription = null;
                            }
                            reportMediaDiagnosticsUrl = null;
                            publishCallQualityFeedbackUrl = null;
                            isPendingInRenego = false;
                            isClean(true);
                        }
                        //#endregion
                        //#region videoWindow
                        /**
                         * Creates a video window and anchors it in the parent DOM element
                         *
                         * The whole area of the parent element will be occupied by the video. Video preview window sized to
                         * 1/3rd of the remote window and is placed in the lower-right corner. Currently, its flicker makes
                         * the preview unusable
                         */
                        function showVideo(vs, isPreview) {
                            var sink = vs.source.sink;
                            log('AudioVideoSession(' + callId + ')::showVideo:isPreview=' + isPreview);
                            if (vs._id() && sink.container()) {
                                // TODO: this is a temporary check to avoid repeated window creation
                                // when this method is called more than once ('participantVideo updated')
                                if (sink._state() == PluginComponent.State.Unloaded) {
                                    return sink._init().then(function () {
                                        pcAV.invoke('SetVideoWindow', vs._id(), isPreview ? Internal.MediaEnum.MediaDeviceType.PREVIEW : Internal.MediaEnum.MediaDeviceType.RENDER, sink._videoWindow(), sink._format(), 1 /* SmartCrop */);
                                    });
                                }
                                else {
                                    log('AudioVideoSession(' + callId + ')::showVideo:sink state:', sink._state());
                                }
                            }
                            else {
                                log('AudioVideoSession(' + callId + ')::showVideo:stream id:', vs._id(), sink.container());
                            }
                            return Promise.resolve();
                        }
                        /**
                         * Removes the video window from the parent DOM element
                         */
                        function removeVideo(vs, isPreview) {
                            var sink = vs.source.sink;
                            log('AudioVideoSession(' + callId + ')::removeVideo', isPreview);
                            if (vs._id() && sink._videoWindow()) {
                                pcAV.invoke('RemoveVideoWindow', vs._id(), isPreview ? Internal.MediaEnum.MediaDeviceType.PREVIEW : Internal.MediaEnum.MediaDeviceType.RENDER, sink._videoWindow());
                                sink._uninit();
                            }
                            else {
                                log('AudioVideoSession(' + callId + ')::removeVideo:stream id:', vs._id(), sink.container());
                            }
                        }
                        //#endregion videoWindow
                        function startTrackingSelfVideoToggle() {
                            dfdSelfVideo = new Task('selfVideo');
                            return dfdSelfVideo.promise;
                        }
                        function stopTrackingSelfVideoToggle(val, reason) {
                            if (dfdSelfVideo && dfdSelfVideo.state() == 'pending') {
                                if (val == 'resolve')
                                    dfdSelfVideo.resolve();
                                else if (val == 'reject')
                                    dfdSelfVideo.reject(reason);
                            }
                        }
                        function startTrackingHoldResume() {
                            dfdHold = new Task(holdValue ? 'hold' : 'resume');
                            return dfdHold.promise.then(function () { return holdValue; });
                        }
                        function stopTrackingHoldResume(val, reason) {
                            if (dfdHold && dfdHold.state() == 'pending') {
                                if (val == 'resolve')
                                    dfdHold.resolve(holdValue);
                                else if (val == 'reject')
                                    dfdHold.reject(reason);
                            }
                        }
                        //#region server events
                        function onServerEvent(event) {
                            var id = event.target.rel + ' ' + event.type;
                            var handler = ucwaEventHandlers[id];
                            if (handler /*&& !toBeEscalated */) {
                                // old p2p av session should ignore events once escalation started
                                // debugger; // this is to let debug the handler of the event
                                // use callId to check if events are picked up by old AVS event handlers
                                log('AudioVideoSession(' + callId + ')::onServerEvent:', event);
                                handler(event.status, event.resource, event);
                            }
                        }
                        var ucwaEventHandlers = {
                            // this is the first event received in any AV call setup (except calling an invalid SIP uri,
                            // in which case UCWA sends the 'audioVideoInvitation completed' event only).
                            'audioVideoInvitation started': function (status, resource) {
                                // set the invitation resource for the outgoing AV session (for the incoming call
                                // audioVideoSession is initialized with the received invitation resource)
                                if (resource.get('direction') == 'Outgoing' &&
                                    resource.get('sessionContext') == sessionContext) {
                                    // if the user canceled the call before we received this event terminate the call
                                    // on the server and unload the AV component.
                                    if (state() == Internal.Modality.State.Disconnected) {
                                        if (resource.hasLink('cancel')) {
                                            var dfd = ucwa.send('POST', resource.link('cancel').href, { nobatch: true });
                                            tm && tm.monitor(dfd, Web.TelemetryEvent.Call, {
                                                action: 'cancel',
                                                type: isConferencing() ? 'conf' : 'p2p',
                                                modalities: activeModalities.video ? 'av' : 'audio',
                                                mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                                state: state(),
                                                callId: callId
                                            });
                                        }
                                        cleanup();
                                    }
                                    else {
                                        rAVInvitation = resource;
                                        // when we make the outgoing invite we get a reportMediaDiagnostics link, save it.
                                        // if the call is declined by the remote party or timed out use this link to post media diag
                                        if (resource.hasLink('reportMediaDiagnostics'))
                                            reportMediaDiagnosticsUrl = resource.link('reportMediaDiagnostics').href;
                                        dfdStart.status('awaiting "audioVideoNegotiation started or completed" event from UCWA');
                                    }
                                }
                            },
                            // this event is received if we started an outgoing AV call as the first conversation modality
                            // using the global startAudioVideo link
                            'conversation added': function (status, resource) {
                                if (resource.get('threadId') == conversation.threadId())
                                    rConversation = resource;
                            },
                            // this event is received during outgoing P2P AV call setup (early media?)
                            'audioVideoNegotiation started': function (status, resource, event) {
                                if (rAVInvitation && event.sender.href == rAVInvitation.href) {
                                    tm && tm.record(Web.TelemetryEvent.Call, {
                                        action: 'audioVideoNegotiationStarted',
                                        type: isConferencing() ? 'conf' : 'p2p',
                                        modalities: activeModalities.video ? 'av' : 'audio',
                                        mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                        state: state(),
                                        hasAnswer: resource.hasLink('mediaProvisionalAnswer'),
                                        callId: callId
                                    });
                                    if (resource.hasLink('mediaProvisionalAnswer')) {
                                        setProvisionalAnswer(resource.link('mediaProvisionalAnswer').href, resource.get('remoteEndpoint'));
                                        dfdStart.status('awaiting "audioVideoNegotiation completed" event from UCWA');
                                    }
                                }
                            },
                            // this event is received during outgoing P2P or conference call setup.
                            // If the negotiation completed successfully the event resource contains session context,
                            // a link to matching audioVideoSession and the remoteEndpoint of that session.
                            // If the call was declined or not answered we have negotiation href only.
                            'audioVideoNegotiation completed': function (status, resource, event) {
                                var href;
                                if (rAVInvitation && event.sender.href == rAVInvitation.href) {
                                    tm && tm.record(Web.TelemetryEvent.Call, {
                                        action: 'audioVideoNegotiationCompleted',
                                        type: isConferencing() ? 'conf' : 'p2p',
                                        modalities: activeModalities.video ? 'av' : 'audio',
                                        mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                        state: state(),
                                        status: status,
                                        reason: event.reason,
                                        hasAnswer: resource && resource.hasLink('mediaAnswer'),
                                        callId: callId
                                    });
                                    switch (status) {
                                        case 'Success':
                                            // "audioVideoNegotiation completed" may arrive before the corresponding
                                            // "audioVideoSession added" event when the call is forwarded to voice mail.
                                            // in this case we create an entry in avSessions and expect to fill it out
                                            // after the session added event arrives.
                                            href = resource.link('audioVideoSession').href;
                                            avSessions[href] = avSessions[href] || {};
                                            avSessions[href].negotiated = true;
                                            setFinalAnswer(resource.link('mediaAnswer').href, resource.get('remoteEndpoint'));
                                            dfdStart.status('awaiting "audioVideoInvitation completed" event from UCWA');
                                            break;
                                        case 'Failure':
                                            if (event.reason.subcode != 'Ended' && event.reason.subcode != 'ConnectedElsewhere' && dfdStart)
                                                dfdStart.status(event.reason && event.reason.message);
                                            break;
                                    }
                                }
                            },
                            // during an outgoing call the server may set up more than one audioVideoSession, because
                            // the remote sip uri that we are calling may be signed in on more than one endpoint.
                            // Also, if the remote party does not accept the call the UCWA server may redirect the
                            // client to a media server so that the client may leave a voice mail; during this process
                            // the UCWA server will create another audioVideoSession and delete the original session.
                            // The next two handlers keep track of audioVideoSessions.
                            'audioVideoSession added': function (status, resource) {
                                var href = resource.href;
                                if (resource.get('sessionContext') == sessionContext) {
                                    avSessions[href] = avSessions[href] || {};
                                    avSessions[href].resource = resource;
                                    if (resource.hasLink('publishCallQualityFeedback'))
                                        publishCallQualityFeedbackUrl = resource.link('publishCallQualityFeedback').href;
                                    tm && tm.record(Web.TelemetryEvent.Call, {
                                        action: 'audioVideoSessionAdded',
                                        type: isConferencing() ? 'conf' : 'p2p',
                                        mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                        callId: callId,
                                        href: href
                                    });
                                }
                            },
                            'audioVideoSession updated': function (status, resource) {
                                if (resource.get('sessionContext') == sessionContext) {
                                    if (resource.hasLink('publishCallQualityFeedback'))
                                        publishCallQualityFeedbackUrl = resource.link('publishCallQualityFeedback').href;
                                }
                            },
                            'audioVideoSession deleted': function (status, resource, event) {
                                // this event is the only indication of a failed escalation; we need to notify
                                // AudioVideoModality so it can force the cleanup of this session (technically there
                                // a "participantInvitation completed" event with code == ServiceFailure and
                                // subcode == EscalationFailed but it is received by the client that issued the
                                // invitation only).
                                //
                                // Note: for the client (which did not issue the escalation invitation), it can
                                // receive the 'audioVideoSession deleted' event (for the old session) before it
                                // receives the 'audioVideoSession added' event (for the new session); and that
                                // should not be treated as a failed escalation.
                                if (event.target.href in avSessions) {
                                    tm && tm.record(Web.TelemetryEvent.Call, {
                                        action: 'audioVideoSessionDeleted',
                                        type: isConferencing() ? 'conf' : 'p2p',
                                        modalities: activeModalities.video ? 'av' : 'audio',
                                        mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                        state: state(),
                                        status: status,
                                        reason: event.reason,
                                        callId: callId
                                    });
                                    delete avSessions[event.target.href];
                                    if (escalationState() == 2 /* To */ && isEmptyObject(avSessions)) {
                                        escalated.fire('failure');
                                        escalationState(0 /* None */);
                                    }
                                }
                            },
                            // this event is received during any AV call setup
                            'audioVideoInvitation completed': function (status, resource, event) {
                                // check for rAVInvitation is needed because this event may arrive before we
                                // even get a response to startAudioVideo post if we call an invalid SIP uri,
                                // so rAVInvitation may be undefined.
                                // Note that completion of an outgoing invitation is handled by sendOffer method
                                if (rAVInvitation && rAVInvitation.href == resource.href &&
                                    resource.get('direction') == 'Incoming') {
                                    tm && tm.record(Web.TelemetryEvent.Call, {
                                        action: 'audioVideoInvitationCompleted',
                                        type: isConferencing() ? 'conf' : 'p2p',
                                        modalities: activeModalities.video ? 'av' : 'audio',
                                        mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                        state: state(),
                                        status: status,
                                        reason: event.reason,
                                        sessionContext: resource.get('sessionContext', void 0),
                                        direction: 'Incoming',
                                        callId: callId
                                    });
                                    if (status == 'Success') {
                                        try {
                                            // there are no audioVideoNegotiation events in the incoming P2P call setup,
                                            // so we set negotiated flag for the cached audioVideoSession here
                                            setNegotiatedSession(resource.get('sessionContext'));
                                            completeNegotiation(status, event.reason);
                                            // if AV is added by a remote participant in a 1:1 conversation which already
                                            // has another modality (messaging) then "participantAudio/Video added" events
                                            // arrive before "audioVideoInvitation started" event, i.e. before this
                                            // AudioVideoSession object exists. So we need to set the AV properties of the
                                            // remote participant here:
                                            // TODO: check if they were not set before : Accepting the AV invitation that created the call
                                            assert(!isConferencing());
                                            var p = participants(0);
                                            if (p) {
                                                p[Internal.sInternal].audioState(Internal.Modality.State.Connected);
                                                if (videoState() == Internal.Modality.State.Connected) {
                                                    p[Internal.sInternal].setVideoStream(mainVideoStream);
                                                    p[Internal.sInternal].videoState(Internal.Modality.State.Connected);
                                                }
                                            }
                                            dfdAccept.resolve();
                                            state(Internal.Modality.State.Connected);
                                        }
                                        catch (error) {
                                            dfdAccept.reject(error);
                                            state(Internal.Modality.State.Disconnected);
                                        }
                                    }
                                    else {
                                        // the caller (remote party) hung up while the call setup was not completed.
                                        if (dfdAccept)
                                            dfdAccept.reject(event.reason);
                                        state(Internal.Modality.State.Disconnected, event.reason);
                                    }
                                }
                            },
                            'audioVideoRenegotiation started': function (status, resource) {
                                if (resource.link('audioVideoSession').href in avSessions) {
                                    tm && tm.record(Web.TelemetryEvent.Call, {
                                        action: 'audioVideoRenegotiationStarted',
                                        type: isConferencing() ? 'conf' : 'p2p',
                                        modalities: activeModalities.video ? 'av' : 'audio',
                                        mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                        state: state(),
                                        status: status,
                                        hasOffer: resource.hasLink('mediaOffer'),
                                        direction: resource.get('direction', void 0),
                                        callId: callId
                                    });
                                    if (resource.get('direction') == 'Incoming') {
                                        var sdp = DataUri(resource.link('mediaOffer').href).data;
                                        if (!isConferencing() && participants.size() > 0) {
                                            remoteHoldState = isHoldRequest(sdp) ?
                                                RemoteHoldState.HoldOffered : RemoteHoldState.ResumeOffered;
                                        }
                                        rAVRenegotiation = resource;
                                        isPendingInRenego = true;
                                        dfdOutRenego.promise.then(function () {
                                            setRenegotiationOffer(sdp);
                                        }).catch(function (err) {
                                            log(err);
                                            cleanup(err);
                                            state(Internal.Modality.State.Disconnected, err);
                                            isPendingInRenego = false;
                                        });
                                    }
                                    else if (dfdStart && dfdStart.state() == 'pending') {
                                        // this is an outgoing renegotiation caused by the second start() call
                                        // to add video to an audio conversation
                                        dfdStart.status('Waiting for audioVideoRenegotiation completed event');
                                    }
                                    else if (dfdSelfVideo && dfdSelfVideo.state() == 'pending') {
                                        // this is an outgoing renegotiation caused by [show|remove]ParticipantVideo
                                        dfdSelfVideo.status('Waiting for audioVideoRenegotiation completed event');
                                    }
                                    else if (dfdHold && dfdHold.state() == 'pending') {
                                        // this is an outgoing renegotiation caused by hold/resume
                                        dfdHold.status('Waiting for audioVideoRenegotiation completed event');
                                    }
                                }
                            },
                            'audioVideoRenegotiation completed': function (status, resource, event) {
                                var href = resource.link('audioVideoSession').href;
                                if (href in avSessions) {
                                    tm && tm.record(Web.TelemetryEvent.Call, {
                                        action: 'audioVideoRenegotiationCompleted',
                                        type: isConferencing() ? 'conf' : 'p2p',
                                        modalities: activeModalities.video ? 'av' : 'audio',
                                        mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                        state: state(),
                                        status: status,
                                        reason: event.reason,
                                        hasAnswer: resource.hasLink('mediaAnswer'),
                                        operationId: resource.get('operationId', void 0),
                                        direction: resource.get('direction', void 0),
                                        callId: callId
                                    });
                                    var error;
                                    if (resource.get('direction') == 'Outgoing') {
                                        assert(resource.get('operationId') in outAvRenegoOpIds);
                                        delete outAvRenegoOpIds[resource.get('operationId')];
                                        try {
                                            if (status == 'Success') {
                                                avSessions[href].renegotiated = true;
                                                setFinalAnswer(resource.link('mediaAnswer').href, avSessions[href].resource.get('remoteEndpoint'));
                                            }
                                            completeNegotiation(status, event.reason);
                                        }
                                        catch (err) {
                                            status = 'Failure';
                                            error = err;
                                        }
                                        if (status == 'Success') {
                                            stopTrackingSelfVideoToggle('resolve');
                                            stopTrackingHoldResume('resolve');
                                        }
                                        else {
                                            stopTrackingSelfVideoToggle('reject', error || event.reason);
                                            stopTrackingHoldResume('reject', error || event.reason);
                                        }
                                        if (dfdStart && dfdStart.state() == 'pending') {
                                            // this is an outgoing renegotiation caused by the second start() call
                                            // to add video to an audio conversation
                                            if (status == 'Success')
                                                dfdStart.resolve();
                                            else
                                                dfdStart.reject(error || event.reason);
                                        }
                                        dfdOutRenego.resolve();
                                    }
                                    else {
                                        // the renegotiation may be in response to remote participant hold/resume
                                        if (!isConferencing()) {
                                            if (remoteHoldState == RemoteHoldState.HoldAnswered)
                                                remoteHoldState = RemoteHoldState.HoldCompleted;
                                            else if (remoteHoldState == RemoteHoldState.ResumeAnswered)
                                                remoteHoldState = RemoteHoldState.ResumeCompleted;
                                        }
                                        completeNegotiation(status, event.reason);
                                        isPendingInRenego = false;
                                    }
                                }
                            },
                            'audioVideo updated': function (status, resource, event) {
                                if (rAVInvitation && rAVInvitation.hasLink('audioVideo') &&
                                    resource.href == rAVInvitation.link('audioVideo').href) {
                                    // Initially in an outbound call rAVInvitation is assigned an empty resource constructed 
                                    // from the POST invitation response. 'audioVideo updated' may arrive before 
                                    // 'audioVideoInvitation started', so to avoid an exception about the missing audioVideo link
                                    // we need to check for 'audioVideo' link above. Skipping the event processing is not a
                                    // a problem, because it is a 'Connecting' event, which we need not handle. 
                                    tm && tm.record(Web.TelemetryEvent.Call, {
                                        action: 'audioVideoUpdated',
                                        type: isConferencing() ? 'conf' : 'p2p',
                                        modalities: activeModalities.video ? 'av' : 'audio',
                                        mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                        state: resource.get('state', void 0),
                                        status: status,
                                        reason: event.reason,
                                        callId: callId
                                    });
                                    if (resource.get('state') == 'Disconnected') {
                                        postMediaDiagnosticsData(event.reason);
                                        postCallQualityFeedback();
                                        if (rAVInvitation.get('state') == 'Connected') {
                                            // This is our chance to clean up the established call that is terminated by
                                            // the remote party. The local party terminates the established call via modality.stop()
                                            // and hang-ups by either party during call setup are processed by audioVideoInvitation
                                            // started/completed event handlers.
                                            //
                                            // Note: after cleanup, the event handlers are detached so events such as
                                            // "participantVideo deleted" are no longer handled; so some reset work
                                            // handled there may need to be done inside cleanup.
                                            cleanup();
                                            // setting this modality state to disconnected will cause its removal from
                                            // the conversation
                                            state(Internal.Modality.State.Disconnected);
                                        }
                                    }
                                    else if (resource.get('state') == 'Connected') {
                                        // when audiovideo is connected pick up the reportMediaDiagnostics url and save it
                                        // when audiovideo gets disconnected use the saved link to send media diagnostics
                                        if (resource.hasLink('reportMediaDiagnostics'))
                                            reportMediaDiagnosticsUrl = resource.link('reportMediaDiagnostics').href;
                                        if (isConferencing())
                                            postPublishTelemetry(resource);
                                        if (event.reason && event.reason.subcode == 'SessionSwitched' &&
                                            resource.link('audioVideoSession').href in avSessions) {
                                            // this is the escalation confirmation, i.e. this AV session replaced the
                                            // original P2P AV session
                                            escalated.fire('success');
                                            escalationState(0 /* None */);
                                        }
                                    }
                                }
                            },
                            // participantAudio/Video added/deleted events for a localParticipant are used to
                            // track active modalities of this client
                            'participantAudio added': onParticipantAudio,
                            'participantAudio updated': onParticipantAudio,
                            'participantAudio deleted': onParticipantAudio,
                            'participantVideo added': onParticipantVideo,
                            'participantVideo updated': onParticipantVideo,
                            'participantVideo deleted': onParticipantVideo,
                            'escalateAudio deleted': function (status, resource, event) {
                                if (event.target.href == escalateAudioVideoUri)
                                    escalateAudioVideoUri = null;
                            },
                            // these events are fired in the later phase of the escalation when the setup of our inactive AV call
                            // to a conference is finished and we may activate (resume) it.
                            'resumeAudio added': onResumeAudioVideoAdded,
                            'resumeAudioVideo added': onResumeAudioVideoAdded,
                            'resumeAudio deleted': onResumeAudioVideoDeleted,
                            'resumeAudioVideo deleted': onResumeAudioVideoDeleted
                        };
                        // returns a participant object from a participants collection
                        function getParticipant(href) {
                            var participant = find(participants(), function (p) { return p[Internal.sHref] == href; });
                            if (participant)
                                return participant;
                            // shortcut for a 1:1 conversation with a participant added to the conversation beforehand
                            //
                            // The check for participant size is needed because if the AV conversation is started not with the
                            // participant from a person model but using the sip uri as a parameter, we would have to rely on
                            // "participant added" event for the remote guy to become a member of participants collection.
                            // If miraculously this event arrives after "participantAudio/Video added" we would have an empty
                            // participants collection here.
                            if (!isConferencing() && participants.size() == 1)
                                return participants(0);
                            // "participantAudio/Video added" event arrives right after "participant added" event. If the
                            // participant was added to the conversation's participant collection using its contact href,
                            // the "participant added" event handler is doing another server lookup to match that contact href
                            // to the participant href. So we can't find that participant here either and we need to do the
                            // same lookup.
                            return ucwa.send('GET', href).then(function (r) {
                                return getParticipant(r.link('contact').href);
                            });
                        }
                        function isInMediaRoster(participant) {
                            var p = participant[Internal.sInternal];
                            return pcAV && p.isInMediaRoster[pcAV.id()];
                        }
                        function updateMediaRoster(participant, type) {
                            try {
                                var method = type == 'add' ? 'AddParticipantInfo' :
                                    type == 'remove' ? 'RemoveParticipantInfo' :
                                        type == 'update' ? 'UpdateParticipantInfo' :
                                            assert(false);
                                var p = participant[Internal.sInternal];
                                // pcAV may not exist yet when we join the meeting which participants are already on the AV call.
                                // In this case 'participantVideo added' events for such participants may come before we finish
                                // joining the meeting so we have not loaded the plugin AVComponent.
                                // This may also happen during escalation on the 'almost obsolete' avs object (i.e., the pcAV
                                // object has just been deleted but the avs event handler has picked up the "participantVideo updated"
                                // event and arrived here.
                                if (!pcAV)
                                    return false;
                                pcAV.invoke(method, p.audioSourceId(), p.videoSourceId(), -1);
                                p.isInMediaRoster[pcAV.id()] = type != 'remove';
                                return true;
                            }
                            catch (err) {
                                log('Media Roster ERROR: ' + err);
                                return false;
                            }
                        }
                        // event handler for "participantAudio added/updated/deleted in participant|localParticipant" events
                        //  - tracks session audio state (on/off) and participant audio state.
                        function onParticipantAudio(status, resource, event) {
                            var scope = event['in'];
                            if (rConversation && event.sender.href == rConversation.href && scope) {
                                if (scope.rel == 'localParticipant') {
                                    switch (event.type) {
                                        case 'added': // signal for the initial AV session
                                        case 'updated':
                                            if (isConferencing() && escalationState() != 1 /* From */) {
                                                selfParticipant[Internal.sInternal].setMediaSourceId(event);
                                                if (resource.has('audioDirection')) {
                                                }
                                                if (resource.has('audioMuted')) {
                                                    var mute = resource.get('audioMuted');
                                                    muted.get().then(function () {
                                                        // Remote requests mute after requesting unmute
                                                        if (mute && muted() && isUnmuteRequested()) {
                                                            isUnmuteRequested(false);
                                                            // Undo force mute now that conference mute is true
                                                            hardMuteUnmute(false);
                                                        }
                                                        // Mute requested by remote
                                                        if (mute && !muted()) {
                                                            muted._set(mute);
                                                        }
                                                        // Unmute requested by remote
                                                        if (!mute && muted()) {
                                                            isUnmuteRequested(true);
                                                            // Force mute self since we're automatically unmuted according to ucwa resource
                                                            hardMuteUnmute(true);
                                                        }
                                                        // to reflect change at api layer must do a get() explicitly
                                                        // harmless since this get() just reads muted() in the case of conference.
                                                        selfParticipant.audio.isMuted.get();
                                                    });
                                                }
                                                // check participants that are already in the conference - we need their msis
                                                // because we won't receive "participantAudio added" events for them.
                                                for (var _i = 0, _a = participants(); _i < _a.length; _i++) {
                                                    var p = _a[_i];
                                                    if (p[Internal.sInternal].audioSourceId() == -1)
                                                        getAudioSourceId(p);
                                                }
                                            }
                                            activeModalities.audio = true;
                                            audioState(Internal.Modality.State.Connected);
                                            break;
                                        case 'deleted':
                                            activeModalities.audio = false;
                                            audioState(Internal.Modality.State.Disconnected);
                                            break;
                                        default:
                                            assert(false, 'unexpected event type');
                                    }
                                }
                                else if (scope.rel == 'participant') {
                                    Task.wait(getParticipant(scope.href)).then(function (participant) {
                                        switch (event.type) {
                                            case 'added':
                                            case 'updated':
                                                if (isConferencing()) {
                                                    participant[Internal.sInternal].setMediaSourceId(event);
                                                    // In conference mode, the indication of a remote
                                                    // participant hold/resume or mute/unmute is
                                                    // "participantAudio added/updated" event. We need to
                                                    // reload "participantAudio" resource and set the
                                                    // properties accordingly
                                                    ucwa.send('GET', event.target.href).then(function (r) {
                                                        if (r.has('audioDirection')) {
                                                            participant[Internal.sInternal].audioOnHold(r.get('audioDirection') ==
                                                                AudioVideoDirection.Inactive);
                                                        }
                                                        if (r.has('audioMuted'))
                                                            participant[Internal.sInternal].audioMuted(r.get('audioMuted'));
                                                        if (r.has('audioSourceId'))
                                                            participant[Internal.sInternal].audioSourceId(+r.get('audioSourceId'));
                                                    });
                                                }
                                                participant[Internal.sInternal].audioState(Internal.Modality.State.Connected);
                                                break;
                                            case 'deleted':
                                                participant[Internal.sInternal].audioState(Internal.Modality.State.Disconnected);
                                                break;
                                            default:
                                                assert(false, 'unexpected event type');
                                        }
                                    });
                                }
                            }
                        }
                        // event handler for "participantVideo added/updated/deleted in participant|localParticipant" events
                        //  - tracks session video state (on/off), participant video state and shows/removes video
                        //    when video modality is activated/deactivated.
                        function onParticipantVideo(status, resource, event) {
                            var scope = event['in'];
                            if (rConversation && event.sender.href == rConversation.href && scope) {
                                if (scope.rel == 'localParticipant') {
                                    switch (event.type) {
                                        case 'added':
                                        case 'updated':
                                            activeModalities.video = true;
                                            if (isConferencing()) {
                                                selfParticipant[Internal.sInternal].setMediaSourceId(event);
                                                updateMediaRoster(selfParticipant, isInMediaRoster(selfParticipant) ? 'update' : 'add');
                                                var _loop_4 = function (p) {
                                                    if (!isInMediaRoster(p)) {
                                                        getAudioSourceId(p).then(function (id) {
                                                            if (id != -1) {
                                                                if (!p.video.channels(0)[Internal.sInternal].isVideoOn()) {
                                                                    getAudioVideoHref(p, 'Video').then(function (href) {
                                                                        href && ucwa.send('GET', href).then(function (rVideo) {
                                                                            updateVideoState(p, { resource: rVideo }, false);
                                                                        });
                                                                    });
                                                                }
                                                                updateMediaRoster(p, 'add');
                                                            }
                                                        });
                                                    }
                                                };
                                                // check participants that are already in the conference - we need their msis
                                                // because we won't receive "participantVideo added" events for them. We also
                                                // need to turn on isVideoOn if the participant is already streaming video
                                                for (var _i = 0, _a = participants(); _i < _a.length; _i++) {
                                                    var p = _a[_i];
                                                    _loop_4(p);
                                                }
                                                updateVideoState(selfParticipant, event, true);
                                            }
                                            else {
                                                videoState(Internal.Modality.State.Connected);
                                                selfParticipant[Internal.sInternal].videoState(Internal.Modality.State.Connected);
                                            }
                                            break;
                                        case 'deleted':
                                            removeVideo(selfVideoStream, true);
                                            activeModalities.video = false;
                                            if (isConferencing()) {
                                                if (isInMediaRoster(selfParticipant))
                                                    updateMediaRoster(selfParticipant, 'remove');
                                                selfParticipant[Internal.sInternal].setMediaSourceId(event);
                                            }
                                            selfParticipant.video.channels(0)[Internal.sInternal].isVideoOn(false);
                                            selfParticipant[Internal.sInternal].setVideoStarted(false);
                                            videoState(Internal.Modality.State.Disconnected);
                                            selfParticipant[Internal.sInternal].videoState(Internal.Modality.State.Disconnected);
                                            break;
                                        default:
                                            assert(false, 'unexpected event type');
                                    }
                                }
                                else if (scope.rel == 'participant') {
                                    Task.wait(getParticipant(scope.href)).then(function (participant) {
                                        switch (event.type) {
                                            case 'added':
                                            case 'updated':
                                                if (isConferencing()) {
                                                    participant[Internal.sInternal].setMediaSourceId(event);
                                                    updateMediaRoster(participant, isInMediaRoster(participant) ? 'update' : 'add');
                                                    updateVideoState(participant, event).then(function () {
                                                        if (onHold() && !participant.video.channels(0).isVideoOn())
                                                            removeParticipantWithVideoToRender(participant);
                                                    });
                                                }
                                                else {
                                                    participant[Internal.sInternal].setVideoStream(mainVideoStream);
                                                    participant[Internal.sInternal].videoState(Internal.Modality.State.Connected);
                                                }
                                                break;
                                            case 'deleted':
                                                if (isConferencing()) {
                                                    if (isInMediaRoster(participant))
                                                        updateMediaRoster(participant, 'remove');
                                                    participant[Internal.sInternal].setMediaSourceId(event);
                                                    removeParticipantVideo(participant);
                                                }
                                                else {
                                                    participant[Internal.sInternal].setVideoStream(null);
                                                }
                                                // if participant video is deleted not because we stopped video
                                                // subscription explicitly (via isStarted(false)) but because 
                                                // participant left the AV call then we need to reset isStarted.
                                                participant.video.channels(0)[Internal.sInternal].isVideoOn(false);
                                                participant[Internal.sInternal].setVideoStarted(false);
                                                participant[Internal.sInternal].videoState(Internal.Modality.State.Disconnected);
                                                break;
                                            default:
                                                assert(false, 'unexpected event type');
                                        }
                                    });
                                }
                            }
                        }
                        // event handler for "participant deleted" events
                        // - if video is on, a 'participant deleted' event should be handled to take this
                        //   participant out of the media roster
                        function onParticipantDeleted(event) {
                            var target = event.target;
                            if (rConversation && event.sender.href == rConversation.href &&
                                target.rel == 'participant' && event.type == 'deleted' && !event['in']) {
                                return Task.wait(getParticipant(target.href)).then(function (participant) {
                                    if (isConferencing()) {
                                        if (isInMediaRoster(participant))
                                            updateMediaRoster(participant, 'remove');
                                        participant[Internal.sInternal].setMediaSourceId(event);
                                        participant.video.channels(0)[Internal.sInternal].isVideoOn(false);
                                        participant[Internal.sInternal].setVideoStarted(false);
                                        participant[Internal.sInternal].videoState(Internal.Modality.State.Disconnected);
                                        return removeParticipantVideo(participant);
                                    }
                                    else {
                                        participant[Internal.sInternal].setVideoStream(null);
                                    }
                                });
                            }
                        }
                        // get Href of participantAudio/participantVideo
                        // m is 'Audio' or 'Video'
                        function getAudioVideoHref(p, m) {
                            // 'audioLink' or 'videoLink'
                            var mLink = m.toLowerCase() + 'Link';
                            if (p[Internal.sInternal][mLink])
                                return Promise.resolve(p[Internal.sInternal][mLink]);
                            if (p[Internal.sHref]) {
                                return ucwa.send('GET', p[Internal.sHref]).then(function (res) {
                                    // participantAudio or participantVideo
                                    var pMod = 'participant' + m;
                                    if (res.hasLink(pMod))
                                        return res.link(pMod).href;
                                });
                            }
                            else {
                                tm && tm.record(Web.TelemetryEvent.Call, {
                                    action: 'getAudioVideoHref',
                                    type: isConferencing() ? 'conf' : 'p2p',
                                    modalities: activeModalities.video ? 'av' : 'audio',
                                    mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                    state: state(),
                                    result: 'failed',
                                    reason: 'no href for participant',
                                    callId: callId
                                });
                                return Promise.resolve();
                            }
                        }
                        function getAudioSourceId(p) {
                            var dfd = p[Internal.sInternal].audioSourceId() != -1 ? Promise.resolve() : getAudioVideoHref(p, 'Audio').then(function (href) {
                                return href && ucwa.send('GET', href);
                            }).then(function (res) {
                                return res && res.has('audioSourceId') && p[Internal.sInternal].audioSourceId.set(+res.get('audioSourceId'));
                            });
                            return dfd.then(function () { return p[Internal.sInternal].audioSourceId(); });
                        }
                        /**
                         * Do a GET on participantVideo and connect the video state if the
                         * resource has active videoDirection.
                         */
                        function updateVideoState(participant, event, isSelf) {
                            if (isSelf === void 0) { isSelf = false; }
                            var resource = event.resource;
                            var target = event.target;
                            return Task.run(function () {
                                return resource && resource.has('videoDirection') ? resource : target && ucwa.send('GET', target.href);
                            }).then(function (res) {
                                if (res && res.has('videoSourceId'))
                                    participant[Internal.sInternal].videoSourceId(+res.get('videoSourceId'));
                                if (res && res.has('videoDirection')) {
                                    var rVideoDirection = res.get('videoDirection');
                                    participant.video.channels(0)[Internal.sInternal].isVideoOn(rVideoDirection === AudioVideoDirection.SendOnly
                                        || rVideoDirection === AudioVideoDirection.SendReceive);
                                    if (!(rVideoDirection == AudioVideoDirection.Inactive || rVideoDirection == AudioVideoDirection.Unknown)) {
                                        if (isSelf)
                                            videoState(Internal.Modality.State.Connected);
                                        participant[Internal.sInternal].videoState(Internal.Modality.State.Connected);
                                        participant[Internal.sInternal].audioState(Internal.Modality.State.Connected);
                                    }
                                }
                            });
                        }
                        // event handler for 'resumeAudio/resumeAudioVideo added' event
                        //   - activates the inactive conference session created during escalation
                        function onResumeAudioVideoAdded(status, resource, event) {
                            var scope = event['in'], href;
                            if (scope && scope.rel == 'audioVideoSession' && scope.href in avSessions) {
                                href = scope.href;
                                // Currently UCWA returns the 'renegotiations' link of the audioVideoSession as resumeAudio uri,
                                // i.e. avSessions[event.in.href].resource.link('renegotiations').href == event.target.href,
                                // but we cache it separately just in case
                                avSessions[href].resumeAudioVideoUri = event.target.href;
                                Task.wait(null).then(function () {
                                    if (!avSessions[href].renegotiated) {
                                        return ucwa.wait({
                                            type: 'completed',
                                            target: { rel: 'audioVideoRenegotiation' },
                                            resource: function (r) {
                                                // r.get('operationId') in outAvRenegoOpIds;
                                                return r.get('direction') == 'Outgoing' && r.link('audioVideoSession').href in avSessions;
                                            }
                                        });
                                    }
                                }).then(function () {
                                    resumeAudioVideo();
                                });
                            }
                        }
                        function onResumeAudioVideoDeleted(status, resource, event) {
                            var scope = event['in'];
                            if (scope && scope.rel == 'audioVideoSession' && scope.href in avSessions &&
                                event.target.href == avSessions[scope.href].resumeAudioVideoUri) {
                                delete avSessions[scope.href].resumeAudioVideoUri;
                            }
                        }
                        //#endregion server events
                        //#region plugin events
                        function onPluginComponentEvent(event) {
                            var handler = pluginEventHandlers[event.type];
                            if (handler) {
                                // debugger; // this is to let debug the handler of the event
                                // use callId to check if events are picked up by old AVS event handlers
                                log('AudioVideoSession(' + callId + ')::onPluginComponentEvent:', event);
                                handler.apply(null, event.args);
                            }
                        }
                        var pluginEventHandlers = {
                            'CHANNEL_CREATED': function (channelType, channelId, isMain) {
                                switch (channelType) {
                                    case 1 /* AUDIO */:
                                        audioChannel = { channelType: channelType, channelId: channelId };
                                        break;
                                    case 2 /* VIDEO */:
                                        if (isMain) {
                                            mainVideoStream._id(channelId);
                                            selfVideoStream._id(channelId);
                                        }
                                        else {
                                            // in the incoming P2P to conference escalation case,
                                            // isConferencing may not be true until a later time
                                            videoStreams.add(new Internal.MediaStream({
                                                mediaPlugin: mediaPlugin,
                                                type: Internal.MediaEnum.StreamType.Render,
                                                id: channelId
                                            }));
                                            // max number of remote participant video streams in a meeting
                                            // = max num of plugin channels excluding the main channel
                                            assert(videoStreams.size() < mediaConfig.maxVideoChannelCount());
                                            log('Num streams created: ' + videoStreams.size());
                                        }
                                        break;
                                    default:
                                        log('Created a channel of unknown type ' + channelType);
                                        // debugger;
                                        break;
                                }
                            },
                            'CHANNEL_DISCONNECTED': function (channelType, channelId, reason) {
                                if (channelType === 2 /* VIDEO */
                                    && mainVideoStream._id() === channelId
                                    && !isConferencing()) {
                                    selfParticipant.video.channels(0)[Internal.sInternal].isVideoOn(false);
                                    participants(0).video.channels(0)[Internal.sInternal].isVideoOn(false);
                                    // For an outgoing p2p video call if remote user accepts with audio only
                                    // we need to disconnect video.
                                    // We don't get any localparticipant video events from ucwa so without below
                                    // the videoState remains connecting.
                                    videoState(Internal.Modality.State.Disconnected);
                                }
                            },
                            'CHANNEL_DIRECTION_CHANGED': function (channelType, channelId, direction) {
                                // wire participant.audio.isOnHold to direction:
                                //   - MediaEnum.MediaConfig.NO_ACTIVE_MEDIA: hold
                                //   - otherwise (likely MediaEnum.MediaConfig.BOTH): resume
                                if (remoteHoldState == RemoteHoldState.HoldCompleted) {
                                    if (direction == 4 /* NO_ACTIVE_MEDIA */ && !isConferencing())
                                        participants(0)[Internal.sInternal].audioOnHold(true);
                                    remoteHoldState = RemoteHoldState.Unknown;
                                }
                                else if (remoteHoldState == RemoteHoldState.ResumeCompleted) {
                                    if (!isConferencing()) {
                                        // note: direction can be MediaConfig.NO_ACTIVE_MEDIA
                                        // if local participant is on hold
                                        participants(0)[Internal.sInternal].audioOnHold(false);
                                    }
                                    remoteHoldState = RemoteHoldState.Unknown;
                                }
                                // CHANNEL_DIRECTION_CHANGED is a good hint for detecting...
                                if (channelType == 2 /* VIDEO */ &&
                                    selfVideoStream._id() == channelId) {
                                    // ... if self participant is streaming video
                                    switch (direction) {
                                        case 1 /* SEND */:
                                        case 3 /* BOTH */:
                                            selfParticipant[Internal.sInternal].setVideoStarted(true);
                                            selfVideoStream._isFlowing(true);
                                            selfParticipant.video.channels(0)[Internal.sInternal].isVideoOn(true);
                                            break;
                                        // We need to explicitly call _isFlowing(false) for Safari, as at the point when the sender turns self video on,
                                        // the _isFlowing.change event needs to be fired for reconstruction of video window which had unloaded automatically on Safari
                                        // On IE the reconstruction was not needed as it never got unloaded in the first place
                                        case 2 /* RECEIVE */:
                                        case 4 /* NO_ACTIVE_MEDIA */:
                                            selfParticipant[Internal.sInternal].setVideoStarted(false);
                                            selfVideoStream._isFlowing(false);
                                            selfParticipant.video.channels(0)[Internal.sInternal].isVideoOn(false);
                                            break;
                                        default:
                                            selfParticipant[Internal.sInternal].setVideoStarted(false);
                                            selfParticipant.video.channels(0)[Internal.sInternal].isVideoOn(false);
                                            break;
                                    }
                                    // ... and if remote participant in a 1:1 conversation is streaming video
                                    if (!isConferencing()) {
                                        assert(mainVideoStream._id() == channelId);
                                        preEscalationVideoConfig(direction);
                                        switch (direction) {
                                            case 1 /* SEND */:
                                            case 4 /* NO_ACTIVE_MEDIA */:
                                                participants(0)[Internal.sInternal].setVideoStarted(false);
                                                mainVideoStream._isFlowing(false);
                                                participants(0).video.channels(0)[Internal.sInternal].isVideoOn(false);
                                                break;
                                            case 2 /* RECEIVE */:
                                            case 3 /* BOTH */:
                                                participants(0)[Internal.sInternal].setVideoStarted(true);
                                                mainVideoStream._isFlowing(true);
                                                participants(0).video.channels(0)[Internal.sInternal].isVideoOn(true);
                                                break;
                                            default:
                                                participants(0)[Internal.sInternal].setVideoStarted(false);
                                                participants(0).video.channels(0)[Internal.sInternal].isVideoOn(false);
                                                break;
                                        }
                                    }
                                }
                            },
                            'MEDIA_CHANGED': function (channelType, channelId, direction, mediaEvent) {
                                var streamState;
                                if (channelType == 2 /* VIDEO */) {
                                    streamState = Internal.MediaEnum.enumcastStreamState(mediaEvent);
                                    if (mainVideoStream._id() == channelId && direction == 2 /* RENDER */)
                                        mainVideoStream._state(streamState);
                                    else if (selfVideoStream._id() == channelId && direction == 1 /* CAPTURE */) {
                                        // Workaround for a plugin bug where stream state comes in as 'Inactive' even though it's active
                                        if (streamState === Internal.MediaEnum.StreamState.Inactive &&
                                            isConferencing() &&
                                            participants().map(function (x) { return x.audio.state(); }).filter(function (x) { return x === Internal.Modality.State.Connected; }).length === 0 &&
                                            selfParticipant.video.channels(0).isVideoOn()) {
                                            selfVideoStream._state(Internal.MediaEnum.StreamState.Active);
                                        }
                                        else {
                                            selfVideoStream._state(streamState);
                                        }
                                        if (1 /* STREAM_STARTED */ === mediaEvent) {
                                            selectedCameraChangedSubscription = devices.selectedCamera.changed(function (camera) {
                                                try {
                                                    if (camera && pcAV)
                                                        pcAV.invoke('SetCameraDevice', camera.name());
                                                }
                                                catch (err) {
                                                    log('AudioVideoSession(' + callId + ') error handling selectedCamera changed ' + err);
                                                }
                                            }, 'async');
                                        }
                                        else if (4 /* STREAM_STOPPED */ === mediaEvent && selectedCameraChangedSubscription) {
                                            selectedCameraChangedSubscription.dispose();
                                            selectedCameraChangedSubscription = null;
                                        }
                                    }
                                    else {
                                        videoStreams.each(function (vs) {
                                            if (vs._id() == channelId)
                                                vs._state(streamState);
                                        });
                                    }
                                }
                                else if (channelType == 1 /* AUDIO */ && audioChannel && channelId == audioChannel.channelId &&
                                    mediaEvent === 2 /* STREAM_ACTIVE */) {
                                    // selectedSpeaker and selectedMicrophone change events fire immediately when the subscription is created, causing the plugin component
                                    // to invoke setAudioDevice. This method should be called when audio stream is already active, otherwise it will fail harmlessly, but
                                    // log a bunch of unnecessary errors in the tm. The check for the stream state appears to be insufficient, so the setTimeout is added
                                    Web.setTimeout(function () {
                                        if (direction == 2 /* RENDER */) {
                                            selectedSpeakerChangedSubscription = selectedSpeakerChangedSubscription || devices.selectedSpeaker.changed(function (speaker) {
                                                try {
                                                    if (speaker && pcAV)
                                                        pcAV.invoke('SetAudioDevice', Internal.MediaEnum.MediaDeviceType.SPEAKER, speaker.name());
                                                }
                                                catch (err) {
                                                    log('AudioVideoSession(' + callId + ') error handling selectedSpeaker changed ' + err);
                                                }
                                            }, 'async');
                                        }
                                        else if (direction == 1 /* CAPTURE */) {
                                            selectedMicrophoneChangedSubscription = selectedMicrophoneChangedSubscription || devices.selectedMicrophone.changed(function (microphone) {
                                                try {
                                                    if (microphone && pcAV)
                                                        pcAV.invoke('SetAudioDevice', Internal.MediaEnum.MediaDeviceType.MIC, microphone.name());
                                                }
                                                catch (err) {
                                                    log('AudioVideoSession(' + callId + ') error handling selectedMicrophone changed ' + err);
                                                }
                                            }, 'async');
                                        }
                                    }, 500);
                                }
                            },
                            // yes, it's not a typo but a plugin bug
                            'DOMINANT_SPEKAER_CHANGED': function () {
                                // args - num of speakers, msi0, msi1, ...
                                //   the most recent speaker is the first in the list; 
                                //   if msi0 == -1, nobody is speaking
                                var args = [];
                                for (var _i = 0; _i < arguments.length; _i++) {
                                    args[_i] = arguments[_i];
                                }
                                var msi = args[1], cur, prev = recentActiveSpeakers[activeSourceId];
                                if (prev)
                                    prev[Internal.sInternal].isSpeaking(false);
                                if (msi == -1) {
                                    activeSourceId = msi;
                                    return;
                                }
                                cur = recentActiveSpeakers[msi];
                                if (!cur) {
                                    // we have a new speaker who has not talked before
                                    if (selfParticipant[Internal.sInternal].audioSourceId() == msi) {
                                        cur = selfParticipant;
                                    }
                                    else {
                                        participants.each(function (p) {
                                            if (p[Internal.sInternal].audioSourceId() == msi)
                                                cur = p;
                                        });
                                    }
                                    if (cur)
                                        recentActiveSpeakers[msi] = cur;
                                }
                                if (cur) {
                                    cur[Internal.sInternal].isSpeaking(true);
                                    activeSourceId = msi;
                                }
                            },
                            'OFFER_READY': function (hasOffer, diagCode, sdpCount) {
                                var rest = [];
                                for (var _i = 3; _i < arguments.length; _i++) {
                                    rest[_i - 3] = arguments[_i];
                                }
                                tm && tm.record(Web.TelemetryEvent.Call, {
                                    action: 'OFFER_READY',
                                    type: isConferencing() ? 'conf' : 'p2p',
                                    modalities: activeModalities.video ? 'av' : 'audio',
                                    mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                    state: state(),
                                    hasOffer: hasOffer,
                                    diagCode: diagCode,
                                    sdpCount: sdpCount,
                                    isRenegotiation: !!getRenegotiationsHref(),
                                    callId: callId
                                });
                                var i, offers = [], renegoHref;
                                try {
                                    for (i = 0; i < sdpCount; i++) {
                                        offers.push({
                                            sdp: rest[i * 2],
                                            id: rest[i * 2 + 1]
                                        });
                                    }
                                    if (offers.length == 0)
                                        throw Exception('NoSdpOffers', { diagCode: diagCode });
                                    renegoHref = getRenegotiationsHref();
                                    if (renegoHref) {
                                        // A negotiated AudioVideoSession already exists, the client starts renegotiation -
                                        // expect an "audioVideoRenegotiation completed" event from UCWA after
                                        // sending renegotiation offer
                                        if (!dfdOutRenego || dfdOutRenego.state() != 'pending')
                                            dfdOutRenego = new Task();
                                        return Promise.resolve().then(function () {
                                            // give up if there is pending incoming renegotiation
                                            if (isPendingInRenego)
                                                throw renegoError;
                                            // may result in 409 conflict
                                            return sendRenegotiationOffer(offers[0].sdp, renegoHref);
                                        }).catch(function (err) {
                                            log(err);
                                            stopTrackingSelfVideoToggle('reject', err);
                                            stopTrackingHoldResume('reject', err);
                                            completeNegotiation('Failure', err && err.code);
                                            dfdOutRenego.resolve();
                                        });
                                    }
                                    else {
                                        // The client starts AV session - expect an "audioVideoInvitation completed"
                                        // event from UCWA after sending the invitation
                                        dfdStart.status('Waiting for audioVideoInvitation completed');
                                        sendOffer(offers).then(function () {
                                            dfdStart.resolve();
                                            state(Internal.Modality.State.Connected);
                                        }).catch(function (error) {
                                            // if the caller hangs up by canceling this promise explicitly we wind up
                                            // here with the rejected promise
                                            if (dfdStart.state() == 'pending')
                                                dfdStart.reject(error);
                                            cleanup();
                                        });
                                    }
                                }
                                catch (error) {
                                    log(error);
                                    if (dfdStart && dfdStart.state() == 'pending')
                                        dfdStart.reject(error);
                                }
                            },
                            'ANSWER_READY': function (_arg0, sdp) {
                                log('SDP Answer:\n' + sdp);
                                tm && tm.record(Web.TelemetryEvent.Call, {
                                    action: 'ANSWER_READY',
                                    type: isConferencing() ? 'conf' : 'p2p',
                                    modalities: activeModalities.video ? 'av' : 'audio',
                                    mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                    state: state(),
                                    isRenegotiation: !!rAVRenegotiation,
                                    callId: callId
                                });
                                if (rAVRenegotiation) {
                                    if (!isConferencing()) {
                                        if (remoteHoldState == RemoteHoldState.HoldOffered)
                                            remoteHoldState = RemoteHoldState.HoldAnswered;
                                        else if (remoteHoldState == RemoteHoldState.ResumeOffered)
                                            remoteHoldState = RemoteHoldState.ResumeAnswered;
                                    }
                                    // the client answers the incoming renegotiation request
                                    // expect an "audioVideoRenegotiation completed" after this call
                                    ucwa.send('POST', rAVRenegotiation.link('answer').href, {
                                        headers: { 'Content-Type': 'application/sdp' },
                                        data: sdp,
                                        nobatch: true
                                    });
                                }
                                else {
                                    // the client answers the incoming invitation
                                    dfdAccept.status('sending answer to UCWA');
                                    invitation.acceptWithAnswer(sdp, sessionContext).then(function () {
                                        dfdAccept.status('awaiting an "audioVideoInvitation completed" event from UCWA');
                                    }).catch(function (error) {
                                        return dfdAccept.reject(error);
                                    });
                                }
                            },
                            'VIDEO_SIZE_CHANGED': function (hwnd, w, h /*, cropw, croph*/) {
                                if (mainVideoStream.source.sink._videoWindow() == hwnd) {
                                    mainVideoStream._setResolution(w, h);
                                }
                                else if (selfVideoStream.source.sink._videoWindow() == hwnd) {
                                    selfVideoStream._setResolution(w, h);
                                }
                                else {
                                    for (var _i = 0, _a = videoStreams(); _i < _a.length; _i++) {
                                        var v = _a[_i];
                                        if (v.source.sink._videoWindow() == hwnd)
                                            v._setResolution(w, h);
                                    }
                                }
                            }
                        };
                        //#endregion plugin events
                        //#region sendOffer
                        /**
                        * Composes an SDP offer from the OFFER_READY media plugin event data and
                        * sends it to the server to start an AV session.
                        *
                        * The returned promise is resolved only when we get a reply to the post and
                        * and audioVideoInvitation completed event
                        */
                        function sendOffer(offers) {
                            assert(offers.length > 0);
                            // construct content that contains all offers given by the media plugin
                            function createOfferOptions(context, contextType, isAddingAVToExistingConv) {
                                var boundary = '9BCE36B8-2C70-44CA-AAA6-D3D332ADBD3F', mediaOffer, options = { nobatch: true };
                                if (isConferencing()) {
                                    if (escalateAudioVideoUri) {
                                        mediaOffer = Internal.multipartSDP(offers, boundary);
                                        options = {
                                            headers: {
                                                'Content-Type': 'multipart/alternative;boundary=' + boundary +
                                                    ';type="application/sdp"',
                                                'Content-Length': '' + mediaOffer.length
                                            },
                                            query: {
                                                operationId: operationId,
                                                sessionContext: sessionContext
                                            },
                                            data: mediaOffer,
                                            nobatch: true
                                        };
                                    }
                                    else {
                                        options.data = Internal.multipartJsonAndSDP({
                                            offers: offers,
                                            boundary: boundary,
                                            operationId: operationId,
                                            sessionContext: sessionContext,
                                            threadId: conversation.threadId(),
                                            context: context,
                                            contextType: contextType
                                        });
                                        options.headers = {
                                            'Content-Type': 'multipart/related;boundary=' + boundary +
                                                ';type="application/vnd.microsoft.com.ucwa+json"'
                                        };
                                    }
                                }
                                else {
                                    // P2P mode
                                    options.data = Internal.multipartJsonAndSDP({
                                        to: isAddingAVToExistingConv ? void 0 : remoteUri,
                                        offers: offers,
                                        boundary: boundary,
                                        subject: conversation.topic(),
                                        importance: conversation.priority(),
                                        operationId: operationId,
                                        sessionContext: sessionContext,
                                        threadId: conversation.threadId(),
                                        context: context,
                                        contextType: contextType
                                    });
                                    options.headers = {
                                        'Content-Type': 'multipart/related;boundary=' + boundary +
                                            ';type="application/vnd.microsoft.com.ucwa+json"'
                                    };
                                }
                                if (context !== void 0)
                                    extend(options.headers, { 'X-MS-RequiresMinResourceVersion': 2 });
                                return options;
                            }
                            return async(getStartAudioVideoLink).call(null).then(function (link) {
                                var options = createOfferOptions(link.revision >= 2 ? context : void 0, contextType, link.rel == 'addAudioVideo'), dfdPost, dfdCompleted;
                                dfdPost = ucwa.send('POST', link.href, options).then(function (r) {
                                    // POST to startAudioVideo/addAudioVideo returns an empty response with an AV invitation
                                    // URI in the Location header. The UCWA stack constructs and returns an empty resource
                                    // with href set to that URI.
                                    if (!rAVInvitation)
                                        rAVInvitation = r;
                                }).catch(function (err) {
                                    log('AudioVideoSession(' + callId + '):sendOffer: startAudioVideo failed', err);
                                    // If threadId is too long, UCWA will reject it with a 400 'badRequest.' 
                                    // In this case, reset the threadId and resend the request.
                                    if (conversation.isThreadIdRejectedError(err)) {
                                        conversation.resetThreadId();
                                        options = createOfferOptions(link.revision >= 2 ? context : void 0, contextType, link.rel == 'addAudioVideo');
                                        return ucwa.send('POST', link.href, options);
                                    }
                                    throw err;
                                });
                                // wait for the "audioVideoInvitation completed" event that corresponds to the given conversation
                                dfdCompleted = ucwa.wait({
                                    type: 'completed',
                                    target: { rel: 'audioVideoInvitation' },
                                    resource: { direction: 'Outgoing', threadId: conversation.threadId(), operationId: operationId, sessionContext: sessionContext }
                                }).then(function (event) {
                                    log('AudioVideoSession(' + callId + '):sendOffer: audioVideoInvitation completed', event);
                                    tm && tm.record(Web.TelemetryEvent.Call, {
                                        action: 'audioVideoInvitationCompleted',
                                        type: isConferencing() ? 'conf' : 'p2p',
                                        modalities: activeModalities.video ? 'av' : 'audio',
                                        mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                        state: state(),
                                        status: event.status,
                                        reason: event.reason,
                                        direction: 'Outgoing',
                                        callId: callId
                                    });
                                    if (event.status == 'Failure') {
                                        // if remote SIP uri is invalid we won't receive "audioVideoInvitation started" event,
                                        // thus we won't have a full rAVInvitation resource cached. It will be either undefined or
                                        // just an empty resource with an href returned by a response to startAudioVideo POST (if
                                        // that response arrived before this event). So we cache the invitation resource here,
                                        // since it may be used by other event handlers.
                                        rAVInvitation = event.resource;
                                        // Technically we may need to complete the negotiation if it was started (i.e. if the call
                                        // reached the remote party and was declined).
                                        completeNegotiation(event.status, event.reason);
                                        throw Internal.EInvitationFailed(event.reason);
                                    }
                                    completeNegotiation(event.status, event.reason);
                                });
                                return Task.waitAll([dfdPost, dfdCompleted]);
                            });
                        }
                        //#endregion
                        //#region sendRenegotiationOffer
                        /**
                         * Composes an SDP offer from the OFFER_READY media plugin event data and
                         * sends it to the server to renegotiate the AV session.
                         */
                        function sendRenegotiationOffer(sdp, url) {
                            log('Renegotiation SDP offer:\n', sdp);
                            // cache operation id
                            var operationId = guid();
                            outAvRenegoOpIds[operationId] = "";
                            return ucwa.send('POST', url, {
                                headers: { 'Content-Type': 'application/sdp' },
                                query: { operationId: operationId },
                                data: sdp,
                                nobatch: true
                            });
                        }
                        //#endregion
                        //#region setOffer
                        /**
                         * Invokes pcAV.invoke("SetOffer", ...) with the given set of SDPs,
                         * e.g. pcAV.invoke("SetOffer", false, 2, sdp1, id1, sdp2, id2).
                         *
                         * @param {Object[]} offers
                         * @returns Whatever pcAV returns.
                         */
                        function setOffer(offers) {
                            assert(offers.length >= 0);
                            var i, offer, args = ['SetOffer', false, offers.length];
                            for (i = 0; i < offers.length; i++) {
                                offer = offers[i];
                                assert('sdp' in offer);
                                assert('id' in offer);
                                args.push(offer.sdp);
                                args.push(offer.id);
                            }
                            return pcAV.invoke.apply(pcAV, args);
                        }
                        //#endregion
                        //#region resumeAudioVideo
                        /**
                         * Activates (resumes) the AV conference call created in inactive state
                         * when a p2p call is escalated to a conference.
                         */
                        function resumeAudioVideo() {
                            // TODO: I don't see how onHold can ever be true here
                            var audioConfig = onHold() ? 4 /* NO_ACTIVE_MEDIA */ : 3 /* BOTH */;
                            // can't configure inactive when resuming. If it was inactive before escalation, just do recvonly.
                            var pevc = preEscalationVideoConfig() == 4 /* NO_ACTIVE_MEDIA */ ?
                                2 /* RECEIVE */ : preEscalationVideoConfig();
                            mainVideoConfig = activeModalities.video ?
                                (onHold() ? 4 /* NO_ACTIVE_MEDIA */ :
                                    (pevc != null ? pevc : 2 /* RECEIVE */)) :
                                0 /* NOT_PRESENT */;
                            var moreChannels = mainVideoConfig != 0 /* NOT_PRESENT */;
                            pcAV.invoke('SetMediaConfig', audioConfig, // audio configuration
                            mainVideoConfig, // main video configuration
                            moreChannels ? mediaConfig.maxVideoChannelCount() - 1 : 0, // additional video channel count
                            moreChannels ? 2 /* RECEIVE */ : 0 /* NOT_PRESENT */, // additional video config
                            0 /* NOT_PRESENT */); // panoVideoConfig
                        }
                        //#endregion
                        //#region setRenegotiationOffer
                        function setRenegotiationOffer(sdp) {
                            // LWA uses the empty string as the Content-ID for the SDP in the case of renegotiation
                            var id = '';
                            var audioConfig = onHold() ? 4 /* NO_ACTIVE_MEDIA */ :
                                3 /* BOTH */;
                            var videoConfig;
                            // TODO: what about video not active? Shouldn't this be NONE?
                            if (onHold() || !/\bm=video\b/gmi.test(sdp)) {
                                // call onHold or no video in offer
                                videoConfig = 4 /* NO_ACTIVE_MEDIA */;
                            }
                            else if (videoState() == Internal.Modality.State.Connected &&
                                (mainVideoConfig == 1 /* SEND */ ||
                                    mainVideoConfig == 3 /* BOTH */)) {
                                // remote participant starts/stops video: isStarted(true|false):
                                // videoConfig will default to RECEIVE plus existing config
                                // about whether to send video or not. In other words, if self
                                // is already sending video, then videoConfig will be BOTH;
                                // otherwise it will be RECEIVE. Subsequent 'SetOffer' call will
                                // determine the proper value in ANSWER based on this videoConfig
                                // setting and the actual OFFER from the remote participant.
                                videoConfig = 3 /* BOTH */;
                            }
                            else {
                                // adding video to an audio conversation (video was not Connected),
                                // we auto-accept incoming video only. The local participant can turn
                                // their video on later via video.channels(0).isStarted(true).
                                videoConfig = settings && settings.supportsVideo == false ?
                                    0 /* NOT_PRESENT */ :
                                    2 /* RECEIVE */;
                            }
                            log('Incoming SDP offer:\n' + sdp);
                            pcAV.invoke('SetAcceptedMedia', audioConfig, videoConfig);
                            pcAV.invoke('SetOffer', false, 1, sdp, id);
                        }
                        //#endregion
                        //#region setProvisionalAnswer
                        /**
                         * Sets the provisional SDP answer from the remote party
                         */
                        function setProvisionalAnswer(mediaAnswer, remoteEndpoint) {
                            var sdp = DataUri(mediaAnswer).data;
                            log('Provisional answer from the remote party:\n' + sdp);
                            pcAV.invoke('SetProvisionalAnswer', true, true, remoteEndpoint, sdp);
                        }
                        //#endregion
                        //#region setFinalAnswer
                        /**
                         * Sets the final SDP answer from the remote party
                         */
                        function setFinalAnswer(mediaAnswer, remoteEndpoint) {
                            var sdp = DataUri(mediaAnswer).data;
                            log('Final answer from the remote party:\n' + sdp);
                            pcAV.invoke('SetFinalAnswer', remoteEndpoint, sdp);
                        }
                        //#endregion
                        //#region completeNegotiation
                        /**
                         * Completes SDP negotiation
                         */
                        function completeNegotiation(eventStatus, reason) {
                            var errCode;
                            // the component may have already been cleaned up (the caller canceled the call
                            // while it was connecting)
                            if (pcAV) {
                                errCode = eventStatus == 'Success' ?
                                    Internal.MediaEnum.NegotiationStatus.NS_SUCCESS :
                                    (reason && reason.code == 'RemoteFailure') ?
                                        Internal.MediaEnum.NegotiationStatus.NS_REMOTE_INTERNAL_ERROR :
                                        Internal.MediaEnum.NegotiationStatus.NS_LOCAL_INTERNAL_ERROR;
                                pcAV.invoke('CompleteNegotiation', errCode);
                            }
                        }
                        //#endregion
                        //#region getStartAudioVideoUri
                        /**
                         * The first SDP offer is sent to the link given by this function.
                         */
                        function getStartAudioVideoLink() {
                            // if the AV modality is the 1-st modality in the conversation,
                            // send a request to the global startAudioVideo link
                            if (!rConversation) {
                                var link = ucwa.get(ucwa.app.relatedHref('communication')).link('startAudioVideo');
                                link.rel = 'startAudioVideo';
                                return link;
                            }
                            // if this is an escalation from P2P to a conference, send the
                            // request to the escalation link
                            if (escalateAudioVideoUri)
                                return ucwa.get(escalateAudioVideoUri); // TODO: .link('self')?
                            // if the AV modality gets added to an existing conversation,
                            // send the request to its addAudioVideo link
                            return ucwa.send('GET', rConversation.link('audioVideo').href).then(function (rAV) {
                                var link = rAV.link('addAudioVideo');
                                link.rel = 'addAudioVideo';
                                return link;
                            });
                        }
                        //#endregion
                        setHiddenProperty(self, Internal.sInternal, {
                            callId: callId,
                            onParticipantDeleted: onParticipantDeleted
                        });
                        log('AudioVideoSession(' + callId + ') created');
                        return self;
                    }
                    return AudioVideoSession;
                }());
                Internal.AudioVideoSession = AudioVideoSession;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var map = Web.Utils.map;
                var async = Web.Utils.async;
                var check = Web.Utils.check;
                var contains = Web.Utils.contains;
                var DataUri = Web.Utils.DataUri;
                var HttpHeaders = Web.Utils.HttpHeaders;
                var parseMultipartRelatedResponse = Web.Stack.parseMultipartRelatedResponse;
                /**
                 * This model represents an audioVideoInvitation resource.
                 *
                 * An audioVideoInvitation resource may have the following form:
                 *
                 *      {
                 *          "rel": "audioVideoInvitation",
                 *          "bandwidthControlId": "...",
                 *          "direction": "Incoming",
                 *          "importance": "Normal",
                 *          "threadId": "...",
                 *          "state": "Connecting",
                 *          "privateLine": false,
                 *          "subject": "...",
                 *          "_links": {
                 *              "self": ...,
                 *              "to":
                 *              "conversation": ...,
                 *              "acceptWithAnswer": ...,
                 *              "sendProvisionalAnswer": ...,
                 *              "decline": ...,
                 *              "audioVideo": ...,
                 *              "mediaOffer": ...
                 *          },
                 *          "_embedded": {
                 *              "from": {
                 *                  "rel": "participant",
                 *                  ...
                 *              }
                 *          }
                 *      }
                 *
                 * @param {Resource} resource - A resource with rel=audioVideoInvitation.
                 * @param {UCWA} ucwa
                 *
                 * @member {Participant} from
                 * @member {Object[]} offers - An array of media offers.
                 *
                 *     - offers[i].sdp - SDP of the i-th offer.
                 *     - offers[i].id - Content ID of the i-th offer.
                 *
                 * @method {Promise} decline
                 * @method {Promise} acceptWithAnswer(sdp, sessionContext)
                 *
                 */
                function AudioVideoInvitation(options) {
                    var resource = options.resource, ucwa = options.ucwa, from = options.from;
                    check.equals(resource.rel, 'audioVideoInvitation');
                    var offers = getMediaOffers();
                    var self = {
                        resource: resource,
                        acceptWithAnswer: async(acceptWithAnswer),
                        decline: async(decline),
                        offers: offers,
                        from: from,
                        hasVideo: function () {
                            return contains(offers, function (offer) {
                                return /\bm=video\b/gmi.test(offer.sdp);
                            });
                        }
                    };
                    /**
                     * Reads the "mediaOffer" link and converts it to a collection SDPs.
                     *
                     * The "mediaOffer" link may have the following form:
                     *
                     *  data:multipart/alternative;charset=utf-8;boundary=e47d80f2,
                     *  --e47d80f2
                     *  Content-Type:+application/sdp
                     *  Content-ID:+<9544aa8a8ac9dfe08fad74893bd1095e@contoso.com>
                     *  Content-Disposition:+session;+handling=optional;+proxy-fallback
                     *
                     *  v=0
                     *  o=-+0+0+IN+IP4+127.0.0.1
                     *  s=session
                     *  ...
                     *
                     *  --e47d80f2
                     *  Content-Type:+application/sdp
                     *  Content-ID:+<cdfd6188fd977372c577873b03dd580d@contoso.com>
                     *  Content-Disposition:+session;+handling=optional
                     *
                     *  v=0
                     *  o=-+0+1+IN+IP4+127.0.0.1
                     *  s=session
                     *  c=IN+IP4+127.0.0.1
                     *  ...
                     *
                     *  --e47d80f2
                     */
                    function getMediaOffers() {
                        var href, dataUri, responses;
                        href = resource.relatedHref('mediaOffer');
                        if (!href)
                            return [];
                        dataUri = DataUri(href);
                        try {
                            responses = parseMultipartRelatedResponse({
                                status: null,
                                responseText: dataUri.data,
                                headers: { 'Content-Type': 'multipart/related;boundary=' + dataUri.attributes.boundary }
                            });
                            return map(responses, function (response) {
                                var headers = HttpHeaders(response.headers);
                                return {
                                    sdp: response.responseText,
                                    id: headers.get('Content-ID')
                                };
                            });
                        }
                        catch (error) {
                            // if the media offer is not a multipart/alternate-encoded
                            // set of SDPs, consider it as a single SDP
                            return [{
                                    sdp: dataUri.data,
                                    id: ''
                                }];
                        }
                    }
                    function acceptWithAnswer(sdp, sessionContext) {
                        var url = resource.link('acceptWithAnswer').href;
                        return ucwa.send('POST', url, {
                            headers: { 'Content-Type': 'application/sdp' },
                            query: { sessionContext: sessionContext },
                            data: sdp,
                            nobatch: true
                        });
                    }
                    function decline(reason) {
                        // We don't send media diagnostics header here because the plugin isn't loaded
                        // and its overkill to load the plugin just to retrieve media diag for a call that isn't connected
                        return ucwa.send('POST', resource.link('decline').href, {
                            data: { reason: reason },
                            nobatch: true
                        });
                    }
                    return self;
                }
                Internal.AudioVideoInvitation = AudioVideoInvitation;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Media;
        (function (Media) {
            var module, requireEx, _setTimeOut = window.setTimeout;
            window.setTimeout = function (cb) { return cb(); };
            /**
             * Available via the MIT or new BSD license.
             * see: http://github.com/jrburke/almond for details
             */
            //Going sloppy to avoid 'use strict' string cost, but strict practices should
            //be followed.
            /*jslint sloppy: true */
            /*global setTimeout: false */
            var requirejs, require, define;
            (function (undef) {
                var main, req, makeMap, handlers, defined = {}, waiting = {}, config = {}, defining = {}, hasOwn = Object.prototype.hasOwnProperty, aps = [].slice, jsSuffixRegExp = /\.js$/;
                function hasProp(obj, prop) {
                    return hasOwn.call(obj, prop);
                }
                /**
                 * Given a relative module name, like ./something, normalize it to
                 * a real name that can be mapped to a path.
                 * @param {String} name the relative name
                 * @param {String} baseName a real name that the name arg is relative
                 * to.
                 * @returns {String} normalized name
                 */
                function normalize(name, baseName) {
                    var nameParts, nameSegment, mapValue, foundMap, lastIndex, foundI, foundStarMap, starI, i, j, part, baseParts = baseName && baseName.split("/"), map = config.map, starMap = (map && map['*']) || {};
                    //Adjust any relative paths.
                    if (name && name.charAt(0) === ".") {
                        //If have a base name, try to normalize against it,
                        //otherwise, assume it is a top-level require that will
                        //be relative to baseUrl in the end.
                        if (baseName) {
                            //Convert baseName to array, and lop off the last part,
                            //so that . matches that "directory" and not name of the baseName's
                            //module. For instance, baseName of "one/two/three", maps to
                            //"one/two/three.js", but we want the directory, "one/two" for
                            //this normalization.
                            baseParts = baseParts.slice(0, baseParts.length - 1);
                            name = name.split('/');
                            lastIndex = name.length - 1;
                            // Node .js allowance:
                            if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                                name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                            }
                            name = baseParts.concat(name);
                            //start trimDots
                            for (i = 0; i < name.length; i += 1) {
                                part = name[i];
                                if (part === ".") {
                                    name.splice(i, 1);
                                    i -= 1;
                                }
                                else if (part === "..") {
                                    if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                                        //End of the line. Keep at least one non-dot
                                        //path segment at the front so it can be mapped
                                        //correctly to disk. Otherwise, there is likely
                                        //no path mapping for a path starting with '..'.
                                        //This can still fail, but catches the most reasonable
                                        //uses of ..
                                        break;
                                    }
                                    else if (i > 0) {
                                        name.splice(i - 1, 2);
                                        i -= 2;
                                    }
                                }
                            }
                            //end trimDots
                            name = name.join("/");
                        }
                        else if (name.indexOf('./') === 0) {
                            // No baseName, so this is ID is resolved relative
                            // to baseUrl, pull off the leading dot.
                            name = name.substring(2);
                        }
                    }
                    //Apply map config if available.
                    if ((baseParts || starMap) && map) {
                        nameParts = name.split('/');
                        for (i = nameParts.length; i > 0; i -= 1) {
                            nameSegment = nameParts.slice(0, i).join("/");
                            if (baseParts) {
                                //Find the longest baseName segment match in the config.
                                //So, do joins on the biggest to smallest lengths of baseParts.
                                for (j = baseParts.length; j > 0; j -= 1) {
                                    mapValue = map[baseParts.slice(0, j).join('/')];
                                    //baseName segment has  config, find if it has one for
                                    //this name.
                                    if (mapValue) {
                                        mapValue = mapValue[nameSegment];
                                        if (mapValue) {
                                            //Match, update name to the new value.
                                            foundMap = mapValue;
                                            foundI = i;
                                            break;
                                        }
                                    }
                                }
                            }
                            if (foundMap) {
                                break;
                            }
                            //Check for a star map match, but just hold on to it,
                            //if there is a shorter segment match later in a matching
                            //config, then favor over this star map.
                            if (!foundStarMap && starMap && starMap[nameSegment]) {
                                foundStarMap = starMap[nameSegment];
                                starI = i;
                            }
                        }
                        if (!foundMap && foundStarMap) {
                            foundMap = foundStarMap;
                            foundI = starI;
                        }
                        if (foundMap) {
                            nameParts.splice(0, foundI, foundMap);
                            name = nameParts.join('/');
                        }
                    }
                    return name;
                }
                function makeRequire(relName, forceSync) {
                    return function () {
                        //A version of a require function that passes a moduleName
                        //value for items that may need to
                        //look up paths relative to the moduleName
                        return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
                    };
                }
                function makeNormalize(relName) {
                    return function (name) {
                        return normalize(name, relName);
                    };
                }
                function makeLoad(depName) {
                    return function (value) {
                        defined[depName] = value;
                    };
                }
                function callDep(name) {
                    if (hasProp(waiting, name)) {
                        var args = waiting[name];
                        delete waiting[name];
                        defining[name] = true;
                        main.apply(undef, args);
                    }
                    if (!hasProp(defined, name) && !hasProp(defining, name)) {
                        throw new Error('No ' + name);
                    }
                    return defined[name];
                }
                //Turns a plugin!resource to [plugin, resource]
                //with the plugin being undefined if the name
                //did not have a plugin prefix.
                function splitPrefix(name) {
                    var prefix, index = name ? name.indexOf('!') : -1;
                    if (index > -1) {
                        prefix = name.substring(0, index);
                        name = name.substring(index + 1, name.length);
                    }
                    return [prefix, name];
                }
                /**
                 * Makes a name map, normalizing the name, and using a plugin
                 * for normalization if necessary. Grabs a ref to plugin
                 * too, as an optimization.
                 */
                makeMap = function (name, relName) {
                    var plugin, parts = splitPrefix(name), prefix = parts[0];
                    name = parts[1];
                    if (prefix) {
                        prefix = normalize(prefix, relName);
                        plugin = callDep(prefix);
                    }
                    //Normalize according
                    if (prefix) {
                        if (plugin && plugin.normalize) {
                            name = plugin.normalize(name, makeNormalize(relName));
                        }
                        else {
                            name = normalize(name, relName);
                        }
                    }
                    else {
                        name = normalize(name, relName);
                        parts = splitPrefix(name);
                        prefix = parts[0];
                        name = parts[1];
                        if (prefix) {
                            plugin = callDep(prefix);
                        }
                    }
                    //Using ridiculous property names for space reasons
                    return {
                        f: prefix ? prefix + '!' + name : name,
                        n: name,
                        pr: prefix,
                        p: plugin
                    };
                };
                function makeConfig(name) {
                    return function () {
                        return (config && config.config && config.config[name]) || {};
                    };
                }
                handlers = {
                    require: function (name) {
                        return makeRequire(name);
                    },
                    exports: function (name) {
                        var e = defined[name];
                        if (typeof e !== 'undefined') {
                            return e;
                        }
                        else {
                            return (defined[name] = {});
                        }
                    },
                    module: function (name) {
                        return {
                            id: name,
                            uri: '',
                            exports: defined[name],
                            config: makeConfig(name)
                        };
                    }
                };
                main = function (name, deps, callback, relName) {
                    var cjsModule, depName, ret, map, i, args = [], callbackType = typeof callback, usingExports;
                    //Use name if no relName
                    relName = relName || name;
                    //Call the callback to define the module, if necessary.
                    if (callbackType === 'undefined' || callbackType === 'function') {
                        //Pull out the defined dependencies and pass the ordered
                        //values to the callback.
                        //Default to [require, exports, module] if no deps
                        deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
                        for (i = 0; i < deps.length; i += 1) {
                            map = makeMap(deps[i], relName);
                            depName = map.f;
                            //Fast path CommonJS standard dependencies.
                            if (depName === "require") {
                                args[i] = handlers.require(name);
                            }
                            else if (depName === "exports") {
                                //CommonJS module spec 1.1
                                args[i] = handlers.exports(name);
                                usingExports = true;
                            }
                            else if (depName === "module") {
                                //CommonJS module spec 1.1
                                cjsModule = args[i] = handlers.module(name);
                            }
                            else if (hasProp(defined, depName) ||
                                hasProp(waiting, depName) ||
                                hasProp(defining, depName)) {
                                args[i] = callDep(depName);
                            }
                            else if (map.p) {
                                map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                                args[i] = defined[depName];
                            }
                            else {
                                throw new Error(name + ' missing ' + depName);
                            }
                        }
                        ret = callback ? callback.apply(defined[name], args) : undefined;
                        if (name) {
                            //If setting exports via "module" is in play,
                            //favor that over return value and exports. After that,
                            //favor a non-undefined return value over exports use.
                            if (cjsModule && cjsModule.exports !== undef &&
                                cjsModule.exports !== defined[name]) {
                                defined[name] = cjsModule.exports;
                            }
                            else if (ret !== undef || !usingExports) {
                                //Use the return value from the function.
                                defined[name] = ret;
                            }
                        }
                    }
                    else if (name) {
                        //May just be an object definition for the module. Only
                        //worry about defining if have a module name.
                        defined[name] = callback;
                    }
                };
                requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
                    if (typeof deps === "string") {
                        if (handlers[deps]) {
                            //callback in this case is really relName
                            return handlers[deps](callback);
                        }
                        //Just return the module wanted. In this scenario, the
                        //deps arg is the module name, and second arg (if passed)
                        //is just the relName.
                        //Normalize module name, if it contains . or ..
                        return callDep(makeMap(deps, callback).f);
                    }
                    else if (!deps.splice) {
                        //deps is a config object, not an array.
                        config = deps;
                        if (config.deps) {
                            req(config.deps, config.callback);
                        }
                        if (!callback) {
                            return;
                        }
                        if (callback.splice) {
                            //callback is an array, which means it is a dependency list.
                            //Adjust args if there are dependencies
                            deps = callback;
                            callback = relName;
                            relName = null;
                        }
                        else {
                            deps = undef;
                        }
                    }
                    //Support require(['a'])
                    callback = callback || function () { };
                    //If relName is a function, it is an errback handler,
                    //so remove it.
                    if (typeof relName === 'function') {
                        relName = forceSync;
                        forceSync = alt;
                    }
                    //Simulate async callback;
                    if (forceSync) {
                        main(undef, deps, callback, relName);
                    }
                    else {
                        //Using a non-zero value because of concern for what old browsers
                        //do, and latest browsers "upgrade" to 4 if lower value is used:
                        //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
                        //If want a value immediately, use require('id') instead -- something
                        //that works in almond on the global level, but not guaranteed and
                        //unlikely to work in other AMD implementations.
                        setTimeout(function () {
                            main(undef, deps, callback, relName);
                        }, 4);
                    }
                    return req;
                };
                /**
                 * Just drops the config on the floor, but returns req in case
                 * the config return value is used.
                 */
                req.config = function (cfg) {
                    return req(cfg);
                };
                /**
                 * Expose module registry for debugging and tooling
                 */
                requirejs._defined = defined;
                define = function (name, deps, callback) {
                    //This module may not have dependencies
                    if (!deps.splice) {
                        //deps is not an array, so probably means
                        //an object literal or factory function for
                        //the value. Adjust args.
                        callback = deps;
                        deps = [];
                    }
                    if (!hasProp(defined, name) && !hasProp(waiting, name)) {
                        waiting[name] = [name, deps, callback];
                    }
                };
                define.amd = {
                    jQuery: true
                };
            }());
            define("../vendor/almond", function () { });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/constants', ["require", "exports"], factory);
                }
            })(function (require, exports) {
                exports.__esModule = true;
                exports["default"] = {
                    MEDIA_STATE: {
                        send: 'sendonly',
                        receive: 'recvonly',
                        sendReceive: 'sendrecv',
                        inactive: 'inactive'
                    },
                    MEDIA_DEVICE: {
                        camera: 'camera',
                        microphone: 'microphone',
                        speaker: 'speaker',
                        defaultId: 'default'
                    },
                    MEDIA_ERROR: {
                        constraintNotSatisfiedError: 'ConstraintNotSatisfiedError',
                        iceConnectionError: 'iceConnectionError',
                        srtpError: 'srtpError',
                        permissionDeniedError: 'permissionDeniedError',
                        internalError: 'internalError',
                        sourceUnavailableError: 'SourceUnavailableError'
                    },
                    RENEGOTIATION_ERROR: {
                        local: 'local',
                        glare: 'glare',
                        signaling: 'signaling',
                        media: 'media',
                        escalation: 'escalation' // when trying to escalate from audio-only to audio-video
                    },
                    MSI: {
                        unsubscribe: -1,
                        subscribeAny: -2
                    },
                    MEDIA_LABEL: {
                        audio: 'main-audio',
                        video: 'main-video',
                        screensharing: 'applicationsharing-video'
                    },
                    MEDIA_TYPE: {
                        audio: 'audio',
                        video: 'video'
                    },
                    MODALITY: {
                        audio: 'audio',
                        video: 'video',
                        screensharing: 'screensharing'
                    },
                    ICE_TRANSPORT_POLICY: {
                        all: 'all',
                        relay: 'relay'
                    },
                    EXTENSION_TYPE: {
                        dominantSpeakerHistory: 'dominantSpeakerHistory'
                    },
                    RENDERER_TYPE: {
                        video: 'video',
                        screensharing: 'screensharing'
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/common/utils', ["require", "exports"], factory);
                }
            })(function (require, exports) {
                function forOwn(obj, func) {
                    for (var key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            func(obj[key], key);
                        }
                    }
                }
                function find(arr, callback) {
                    var match;
                    arr.some(function (el, index) {
                        if (callback(el, index, arr)) {
                            match = el;
                            return true;
                        }
                        return false;
                    });
                    return match;
                }
                function findIndex(arr, callback) {
                    var match;
                    arr.some(function (el, index) {
                        if (callback(el, index, arr)) {
                            match = index;
                            return true;
                        }
                        return false;
                    });
                    return match;
                }
                function remove(arr, callback) {
                    var found = false;
                    for (var index = arr.length; index-- > 0;) {
                        if (callback(arr[index], index, arr)) {
                            arr.splice(index, 1);
                            found = true;
                        }
                    }
                    return found;
                }
                function values(obj) {
                    var res = [];
                    for (var key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            res.push(obj[key]);
                        }
                    }
                    return res;
                }
                function isEmpty(obj) {
                    return !Object.keys(obj).length;
                }
                function shallowClone(obj) {
                    var copy = {};
                    forOwn(obj, function (value, key) {
                        copy[key] = value;
                    });
                    return copy;
                }
                function deepClone(obj) {
                    var copy;
                    // Handle the 3 simple types, and null or undefined
                    if (!obj || typeof obj !== "object") {
                        return obj;
                    }
                    // Handle Date
                    if (obj instanceof Date) {
                        copy = new Date();
                        copy.setTime(obj.getTime());
                        return copy;
                    }
                    // Handle Array
                    if (obj instanceof Array) {
                        copy = [];
                        for (var i = 0, len = obj.length; i < len; i++) {
                            copy[i] = deepClone(obj[i]);
                        }
                        return copy;
                    }
                    // Handle Object
                    if (obj instanceof Object) {
                        copy = {};
                        forOwn(obj, function (value, key) {
                            copy[key] = deepClone(value);
                        });
                        return copy;
                    }
                    throw new Error("Unable to copy: " + obj);
                }
                /**
                 * Returns a pseudo-randomly generated UUID, 32 hex digits long, without section separators, all lowercase
                 */
                function uniqueId() {
                    function segment() {
                        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
                    }
                    return segment() + segment() + segment() + '4' + segment().substring(1) + 'b' + segment().substring(1) + segment() + segment() + segment();
                }
                function deepEqual(obj1, obj2) {
                    var prop, t1 = typeof obj1, t2 = typeof obj2;
                    // strict comparison (this will cover primitive types, including
                    // undefined and null)
                    if (obj1 === obj2)
                        return true;
                    // both have to be object or function before continue
                    if (t1 !== t2 || t1 !== 'object' && t1 !== 'function')
                        return false;
                    if (obj1 === null || obj2 === null)
                        return obj1 === obj2;
                    if (obj1 instanceof Date && obj2 instanceof Date)
                        return +obj1 == +obj2;
                    // each property in obj1 must exist in obj2
                    for (prop in obj1) {
                        if (!(prop in obj2) || !deepEqual(obj1[prop], obj2[prop]))
                            return false;
                    }
                    // each property in obj2 must exist in obj1
                    for (prop in obj2) {
                        if (!(prop in obj1) || !deepEqual(obj1[prop], obj2[prop]))
                            return false;
                    }
                    return true;
                }
                exports.__esModule = true;
                exports["default"] = {
                    forOwn: forOwn,
                    find: find,
                    findIndex: findIndex,
                    remove: remove,
                    values: values,
                    isEmpty: isEmpty,
                    shallowClone: shallowClone,
                    deepClone: deepClone,
                    uniqueId: uniqueId,
                    deepEqual: deepEqual
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/helper', ["require", "exports", './constants', './common/utils'], factory);
                }
            })(function (require, exports) {
                var constants_1 = require('./constants');
                var utils_1 = require('./common/utils');
                function invertDirectionality(directionality) {
                    switch (directionality) {
                        case constants_1["default"].MEDIA_STATE.send:
                            return constants_1["default"].MEDIA_STATE.receive;
                        case constants_1["default"].MEDIA_STATE.receive:
                            return constants_1["default"].MEDIA_STATE.send;
                        default:
                            return directionality;
                    }
                }
                function invertModalities(modalities) {
                    var ret = {};
                    var audio = invertDirectionality(modalities.audio);
                    if (audio) {
                        ret.audio = audio;
                    }
                    var video = invertDirectionality(modalities.video);
                    if (video) {
                        ret.video = video;
                    }
                    var screensharing = invertDirectionality(modalities.screensharing);
                    if (screensharing) {
                        ret.screensharing = screensharing;
                    }
                    return ret;
                }
                function removeSendDirectionality(directionality) {
                    return directionality === constants_1["default"].MEDIA_STATE.sendReceive ? constants_1["default"].MEDIA_STATE.receive : void 0;
                }
                function hasSendDirectionality(directionality) {
                    return directionality === constants_1["default"].MEDIA_STATE.send || directionality === constants_1["default"].MEDIA_STATE.sendReceive;
                }
                function hasReceiveDirectionality(directionality) {
                    return directionality === constants_1["default"].MEDIA_STATE.receive || directionality === constants_1["default"].MEDIA_STATE.sendReceive;
                }
                function isOnHold(modalities) {
                    //check implementation as webrtc might require that if any of the direction is inactive then all directions must be inactive
                    return modalities.audio === constants_1["default"].MEDIA_STATE.inactive || modalities.video === constants_1["default"].MEDIA_STATE.inactive || modalities.screensharing === constants_1["default"].MEDIA_STATE.inactive;
                }
                function createUniformModalities(direction) {
                    var modalities = {};
                    for (var key in constants_1["default"].MEDIA_TYPE) {
                        if (constants_1["default"].MEDIA_TYPE.hasOwnProperty(key)) {
                            modalities[constants_1["default"].MEDIA_TYPE[key]] = direction;
                        }
                    }
                    return modalities;
                }
                function negotiateDirectionality(acceptable, local) {
                    //computes subset of what acceptable (remote) can do and what local can do
                    //local send direction can be seen as what i want to do and local receive direction what i can do
                    //acceptable send direction means i can receive and acceptable receive direction that i want to send
                    //thus acceptable directions are assumed to be "inverted" if compared to the local direction direction on remote itself
                    var canSend = hasSendDirectionality(acceptable) && hasSendDirectionality(local), canReceive = hasReceiveDirectionality(acceptable) && hasReceiveDirectionality(local);
                    if (canSend && canReceive) {
                        return constants_1["default"].MEDIA_STATE.sendReceive;
                    }
                    else if (canSend) {
                        return constants_1["default"].MEDIA_STATE.send;
                    }
                    else if (canReceive) {
                        return constants_1["default"].MEDIA_STATE.receive;
                    }
                    else if (acceptable === constants_1["default"].MEDIA_STATE.inactive && local) {
                        //call on hold
                        return constants_1["default"].MEDIA_STATE.inactive;
                    }
                    return void 0; //rejecting
                }
                function negotiateModalities(acceptableModalities, localModalities) {
                    //returns subset (downgraded) modalities that are acceptable (remote offers) and local accepts
                    //returned modalities are "valid" modalities in the sdp answer
                    var ret = {};
                    var audio = negotiateDirectionality(acceptableModalities.audio, localModalities.audio);
                    if (audio) {
                        ret.audio = audio;
                    }
                    var video = negotiateDirectionality(acceptableModalities.video, localModalities.video);
                    if (video) {
                        ret.video = video;
                    }
                    var screensharing = negotiateDirectionality(acceptableModalities.screensharing, localModalities.screensharing);
                    if (screensharing) {
                        ret.screensharing = screensharing;
                    }
                    return ret;
                }
                function areModalitiesEqual(a, b) {
                    return !(!a || !b || a.audio !== b.audio || a.video !== b.video); //iff both are undefined then they are not equal
                }
                function areNegotiatedDirectionsAcceptable(modalities, negotiatingModalities, negotiatedModalities) {
                    //modalities - most recent modalities user wants to have, negotiatingModalities - modalities user had configured when negotiation had to generate offer
                    function isNegotiatedDirectionAcceptable(direction, negotiatingDirection, negotiatedDirection) {
                        //check user has not turned send or receive direction on during negotiation
                        //check that if we don't want to send or receive that we really don't send or receive (for case user has turned send direction off during negotiation)
                        var isSendDirectionAcceptable = (hasSendDirectionality(direction) && hasSendDirectionality(negotiatingDirection)) ||
                            (!hasSendDirectionality(direction) && !hasSendDirectionality(negotiatedDirection)), isReceiveDirectionAcceptable = (hasReceiveDirectionality(direction) && hasReceiveDirectionality(negotiatingDirection)) ||
                            (!hasReceiveDirectionality(direction) && !hasReceiveDirectionality(negotiatedDirection));
                        return isSendDirectionAcceptable && isReceiveDirectionAcceptable;
                    }
                    return isNegotiatedDirectionAcceptable(modalities.audio, negotiatingModalities.audio, negotiatedModalities.audio) &&
                        isNegotiatedDirectionAcceptable(modalities.video, negotiatingModalities.video, negotiatedModalities.video) &&
                        isNegotiatedDirectionAcceptable(modalities.screensharing, negotiatingModalities.screensharing, negotiatedModalities.screensharing);
                }
                function areNegotiatedDirectionsFulfilled(modalities, negotiatedModalities) {
                    function isNegotiatedDirectionFulfilled(direction, negotiatedDirection) {
                        var isSendDirectionFulfilled = (hasSendDirectionality(direction) === hasSendDirectionality(negotiatedDirection)), isReceiveDirectionFulfilled = (hasReceiveDirectionality(direction) === hasReceiveDirectionality(negotiatedDirection));
                        return isSendDirectionFulfilled && isReceiveDirectionFulfilled;
                    }
                    return isNegotiatedDirectionFulfilled(modalities.audio, negotiatedModalities.audio) &&
                        isNegotiatedDirectionFulfilled(modalities.video, negotiatedModalities.video) &&
                        isNegotiatedDirectionFulfilled(modalities.screensharing, negotiatedModalities.screensharing);
                }
                function isMsBrowser() {
                    return (typeof RTCIceGatherer !== 'undefined');
                }
                function defer() {
                    var resolve, reject, isPending = true, promise = new Promise(function (resolve_, reject_) {
                        resolve = resolve_;
                        reject = reject_;
                    });
                    return {
                        isPending: function () { return isPending; },
                        promise: promise,
                        resolve: function () {
                            if (isPending) {
                                resolve.apply(null, arguments);
                                isPending = false;
                            }
                        },
                        reject: function (args) {
                            if (isPending) {
                                reject.apply(null, arguments);
                                isPending = false;
                            }
                        }
                    };
                }
                function delay(time) {
                    return new Promise(function (fulfill) {
                        setTimeout(fulfill, time);
                    });
                }
                function timeout(promise, time, promiseName) {
                    var timeoutRacer = new Promise(function (resolve, reject) {
                        setTimeout(reject.bind(null, new Error('Promise timed out' + (promiseName ? ': ' + promiseName : '') + 'after ' + time + 'ms')), time);
                    });
                    return Promise.race([promise, timeoutRacer]);
                }
                function getSrtpInfo(model) {
                    var srtpInfo = {
                        dtls: false,
                        sdes: false
                    };
                    srtpInfo.dtls = !!model.fingerprint;
                    model.media.forEach(function (media) {
                        srtpInfo.dtls = srtpInfo.dtls || !!media.fingerprint;
                        srtpInfo.sdes = srtpInfo.sdes || !!media.crypto;
                    });
                    return srtpInfo;
                }
                function excludePassiveModalities(configuredModalities, passiveModalities, offeredModalities) {
                    if (!passiveModalities || utils_1["default"].isEmpty(passiveModalities)) {
                        return configuredModalities;
                    }
                    var shouldAddModality = function (modality, direction) {
                        if (!passiveModalities[modality]) {
                            return true;
                        }
                        if (offeredModalities) {
                            if (!hasSendDirectionality(direction) &&
                                (!offeredModalities[modality] || offeredModalities[modality] !== direction)) {
                                return false;
                            }
                        }
                        else if (passiveModalities[modality] === direction) {
                            return false;
                        }
                        return true;
                    };
                    var newModalities = {};
                    utils_1["default"].forOwn(configuredModalities, function (direction, modality) {
                        if (shouldAddModality(modality, direction)) {
                            newModalities[modality] = configuredModalities[modality];
                        }
                    });
                    return newModalities;
                }
                exports.__esModule = true;
                exports["default"] = {
                    invertDirectionality: invertDirectionality,
                    invertModalities: invertModalities,
                    removeSendDirectionality: removeSendDirectionality,
                    hasSendDirectionality: hasSendDirectionality,
                    hasReceiveDirectionality: hasReceiveDirectionality,
                    negotiateDirectionality: negotiateDirectionality,
                    negotiateModalities: negotiateModalities,
                    areModalitiesEqual: areModalitiesEqual,
                    isOnHold: isOnHold,
                    createUniformModalities: createUniformModalities,
                    areNegotiatedDirectionsFulfilled: areNegotiatedDirectionsFulfilled,
                    areNegotiatedDirectionsAcceptable: areNegotiatedDirectionsAcceptable,
                    isMsBrowser: isMsBrowser,
                    defer: defer,
                    delay: delay,
                    timeout: timeout,
                    getSrtpInfo: getSrtpInfo,
                    excludePassiveModalities: excludePassiveModalities
                };
            });
            /// <disable>EnableStrictMode,DoNotReferenceBannedTerms,DoNotUseEval</disable>
            (function (f) { if (typeof exports === "object" && typeof module !== "undefined") {
                module.exports = f();
            }
            else if (typeof define === "function" && define.amd) {
                define('microsoft-sdp-transform/lib/sdp-transform', [], f);
            }
            else {
                var g;
                if (typeof window !== "undefined") {
                    g = window;
                }
                else if (typeof global !== "undefined") {
                    g = global;
                }
                else if (typeof self !== "undefined") {
                    g = self;
                }
                else {
                    g = this;
                }
                g.sdpTransform = f();
            } })(function () {
                var define, module, exports;
                return (function e(t, n, r) { function s(o, u) { if (!n[o]) {
                    if (!t[o]) {
                        var a = typeof require == "function" && require;
                        if (!u && a)
                            return a(o, !0);
                        if (i)
                            return i(o, !0);
                        var f = new Error("Cannot find module '" + o + "'");
                        throw f.code = "MODULE_NOT_FOUND", f;
                    }
                    var l = n[o] = { exports: {} };
                    t[o][0].call(l.exports, function (e) { var n = t[o][1][e]; return s(n ? n : e); }, l, l.exports, e, t, n, r);
                } return n[o].exports; } var i = typeof require == "function" && require; for (var o = 0; o < r.length; o++)
                    s(r[o]); return s; })({ 1: [function (_dereq_, module, exports) {
                            var grammar = module.exports = {
                                v: [{
                                        name: 'version',
                                        reg: /^(\d*)$/
                                    }],
                                o: [{
                                        // NB: sessionId will be a String in most cases because it is huge
                                        name: 'origin',
                                        reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
                                        names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],
                                        format: "%s %s %d %s IP%d %s"
                                    }],
                                // default parsing of these only (though some of these feel outdated)
                                s: [{ name: 'name' }],
                                i: [{ name: 'description' }],
                                u: [{ name: 'uri' }],
                                e: [{ name: 'email' }],
                                p: [{ name: 'phone' }],
                                z: [{ name: 'timezones' }],
                                r: [{ name: 'repeats' }],
                                //k: [{}], // outdated thing ignored
                                t: [{
                                        name: 'timing',
                                        reg: /^(\d*) (\d*)/,
                                        names: ['start', 'stop'],
                                        format: "%d %d"
                                    }],
                                c: [{
                                        name: 'connection',
                                        reg: /^IN IP(\d) (\S*)/,
                                        names: ['version', 'ip'],
                                        format: "IN IP%d %s"
                                    }],
                                b: [{
                                        push: 'bandwidth',
                                        reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
                                        names: ['type', 'limit'],
                                        format: "%s:%s"
                                    }],
                                m: [{
                                        // NB: special - pushes to session
                                        // TODO: rtp/fmtp should be filtered by the payloads found here?
                                        reg: /^(\w*) (\d*) ([\w\/]*)(?: (.*))?/,
                                        names: ['type', 'port', 'protocol', 'payloads'],
                                        format: "%s %d %s %s"
                                    }],
                                a: [
                                    {
                                        push: 'rtp',
                                        reg: /^rtpmap:(\d*) ([\w\-]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
                                        names: ['payload', 'codec', 'rate', 'encoding'],
                                        format: function (o) {
                                            return (o.encoding) ?
                                                "rtpmap:%d %s/%s/%s" :
                                                o.rate ?
                                                    "rtpmap:%d %s/%s" :
                                                    "rtpmap:%d %s";
                                        }
                                    },
                                    {
                                        //a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
                                        //a=fmtp:111 minptime=10; useinbandfec=1
                                        push: 'fmtp',
                                        reg: /^fmtp:(\d*) ([\S| ]*)/,
                                        names: ['payload', 'config'],
                                        format: "fmtp:%d %s"
                                    },
                                    {
                                        name: 'control',
                                        reg: /^control:(.*)/,
                                        format: "control:%s"
                                    },
                                    {
                                        name: 'rtcp',
                                        reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
                                        names: ['port', 'netType', 'ipVer', 'address'],
                                        format: function (o) {
                                            return (o.address != null) ?
                                                "rtcp:%d %s IP%d %s" :
                                                "rtcp:%d";
                                        }
                                    },
                                    {
                                        push: 'rtcpFbXMessage',
                                        reg: /^rtcp-fb:(\*|\d*) x-message ([\S| ]*)/,
                                        names: ['payload', 'param'],
                                        format: function (o) {
                                            var payload = o.payload === '*' ? '%s' : '%d';
                                            return "rtcp-fb:" + payload + " x-message %s";
                                        }
                                    },
                                    {
                                        push: 'rtcpFbTrrInt',
                                        reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
                                        names: ['payload', 'value'],
                                        format: "rtcp-fb:%d trr-int %d"
                                    },
                                    {
                                        push: 'rtcpFb',
                                        reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
                                        names: ['payload', 'type', 'subtype'],
                                        format: function (o) {
                                            return (o.subtype != null) ?
                                                "rtcp-fb:%s %s %s" :
                                                "rtcp-fb:%s %s";
                                        }
                                    },
                                    {
                                        //a=extmap:1/recvonly URI-gps-string
                                        push: 'ext',
                                        reg: /^extmap:([\w_\/]*) (\S*)(?: (\S*))?/,
                                        names: ['value', 'uri', 'config'],
                                        format: function (o) {
                                            return (o.config != null) ?
                                                "extmap:%s %s %s" :
                                                "extmap:%s %s";
                                        }
                                    },
                                    {
                                        //a=cryptoscale:1 client AES_CM_128_HMAC_SHA1_80 inline:4CRQeUGzMG/lb4oIMDq4A2J6IeY9AQFD62ic92xs|2^31|1:1
                                        //a=cryptoscale:1 server AES_CM_128_HMAC_SHA1_80 inline:4CRQeUGzMG/lb4oIMDq4A2J6IeY9AQFD62ic92xs|2^31|1:1
                                        push: 'cryptoscale',
                                        reg: /^cryptoscale:(\d*) (client|server) ([\w_]*) (\S*)(?: (\S*))?/,
                                        names: ['id', 'flavor', 'suite', 'config', 'sessionConfig'],
                                        format: function (o) {
                                            return (o.sessionConfig != null) ?
                                                "cryptoscale:%d %s %s %s %s" :
                                                "cryptoscale:%d %s %s %s";
                                        }
                                    },
                                    {
                                        //a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
                                        push: 'crypto',
                                        reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
                                        names: ['id', 'suite', 'config', 'sessionConfig'],
                                        format: function (o) {
                                            return (o.sessionConfig != null) ?
                                                "crypto:%d %s %s %s" :
                                                "crypto:%d %s %s";
                                        }
                                    },
                                    {
                                        name: 'setup',
                                        reg: /^setup:(\w*)/,
                                        format: "setup:%s"
                                    },
                                    {
                                        name: 'mid',
                                        reg: /^mid:([^\s]*)/,
                                        format: "mid:%s"
                                    },
                                    {
                                        name: 'msid',
                                        reg: /^msid:(.*)/,
                                        format: "msid:%s"
                                    },
                                    {
                                        name: 'ptime',
                                        reg: /^ptime:(\d*)/,
                                        format: "ptime:%d"
                                    },
                                    {
                                        name: 'maxptime',
                                        reg: /^maxptime:(\d*)/,
                                        format: "maxptime:%d"
                                    },
                                    {
                                        name: 'direction',
                                        reg: /^(sendrecv|recvonly|sendonly|inactive)/
                                    },
                                    {
                                        name: 'icelite',
                                        reg: /^(ice-lite)/
                                    },
                                    {
                                        name: 'iceUfrag',
                                        reg: /^ice-ufrag:(\S*)/,
                                        format: "ice-ufrag:%s"
                                    },
                                    {
                                        name: 'icePwd',
                                        reg: /^ice-pwd:(\S*)/,
                                        format: "ice-pwd:%s"
                                    },
                                    {
                                        name: 'fingerprint',
                                        reg: /^fingerprint:(\S*) (\S*)/,
                                        names: ['type', 'hash'],
                                        format: "fingerprint:%s %s"
                                    },
                                    {
                                        //a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
                                        //a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0
                                        //a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0
                                        //a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0
                                        //a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0
                                        push: 'candidates',
                                        reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?/,
                                        names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation'],
                                        format: function (o) {
                                            var str = "candidate:%s %d %s %d %s %d typ %s";
                                            str += (o.raddr != null) ? " raddr %s rport %d" : "%v%v";
                                            // NB: candidate has three optional chunks, so %void middles one if it's missing
                                            str += (o.tcptype != null) ? " tcptype %s" : "%v";
                                            if (o.generation != null) {
                                                str += " generation %d";
                                            }
                                            return str;
                                        }
                                    },
                                    {
                                        //a=x-candidate-ipv6:0 1 UDP 2113667327 2001:0:5ef5:79fb:245f:3ec1:3dba:97fb 54400 typ host
                                        //a=x-candidate-ipv6:1162875081 1 udp 2113937151 2001:0:5ef5:79fb:245f:3ec1:3dba:97fb 60017 typ host generation 0
                                        //a=x-candidate-ipv6:3289912957 2 udp 1845501695 2001:0:5ef5:79fb:245f:3ec1:3dba:97fb 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0
                                        push: 'xCandidatesIpv6',
                                        reg: /^x-candidate-ipv6:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?/,
                                        names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation'],
                                        format: function (o) {
                                            var str = "x-candidate-ipv6:%s %d %s %d %s %d typ %s";
                                            str += (o.raddr != null) ? " raddr %s rport %d" : "%v%v";
                                            // NB: candidate has three optional chunks, so %void middles one if it's missing
                                            str += (o.tcptype != null) ? " tcptype %s" : "%v";
                                            if (o.generation != null) {
                                                str += " generation %d";
                                            }
                                            return str;
                                        }
                                    },
                                    {
                                        name: 'endOfCandidates',
                                        reg: /^(end-of-candidates)/
                                    },
                                    {
                                        name: 'remoteCandidates',
                                        reg: /^remote-candidates:(.*)/,
                                        format: "remote-candidates:%s"
                                    },
                                    {
                                        name: 'iceOptions',
                                        reg: /^ice-options:(\S*)/,
                                        format: "ice-options:%s"
                                    },
                                    {
                                        push: "ssrcs",
                                        reg: /^ssrc:(\d*) ([\w_]*):(.*)/,
                                        names: ['id', 'attribute', 'value'],
                                        format: "ssrc:%d %s:%s"
                                    },
                                    {
                                        push: "ssrcGroups",
                                        reg: /^ssrc-group:(\w*) (.*)/,
                                        names: ['semantics', 'ssrcs'],
                                        format: "ssrc-group:%s %s"
                                    },
                                    {
                                        name: "msidSemantic",
                                        reg: /^msid-semantic:\s?(\w*) (\S*)/,
                                        names: ['semantic', 'token'],
                                        format: "msid-semantic: %s %s" // space after ":" is not accidental
                                    },
                                    {
                                        push: 'groups',
                                        reg: /^group:(\w*) (.*)/,
                                        names: ['type', 'mids'],
                                        format: "group:%s %s"
                                    },
                                    {
                                        name: 'rtcpMux',
                                        reg: /^(rtcp-mux)/,
                                        format: 'rtcp-mux'
                                    },
                                    {
                                        name: 'rtcpRsize',
                                        reg: /^(rtcp-rsize)/,
                                        format: 'rtcp-rsize'
                                    },
                                    {
                                        name: 'xMediaBw',
                                        reg: /^x-mediabw:(\S*) send=(\d*);recv=(\d*)/,
                                        names: ['label', 'sendBw', 'receiveBw'],
                                        format: "x-mediabw:%s send=%d;recv=%d"
                                    },
                                    {
                                        name: 'xSsrcRange',
                                        reg: /^x-ssrc-range:(\d*)-(\d*)/,
                                        names: ['ssrcMin', 'ssrcMax'],
                                        format: "x-ssrc-range:%d-%d"
                                    },
                                    {
                                        name: 'label',
                                        reg: /^label:(\S*)/,
                                        format: "label:%s"
                                    },
                                    {
                                        name: 'xSource',
                                        reg: /^x-source:(\S*)/,
                                        format: "x-source:%s"
                                    },
                                    {
                                        name: 'xSourceStreamId',
                                        reg: /^x-source-streamid:(\S*)/,
                                        format: "x-source-streamid:%s"
                                    },
                                    {
                                        name: 'xCaps',
                                        reg: /^x-caps:(\d*) (\S*)/,
                                        names: ['payloadType', 'value'],
                                        format: "x-caps:%d %s"
                                    },
                                    {
                                        name: 'signalingFbXMessage',
                                        reg: /^x-signaling-fb:(\*|\d*) x-message ([\S| ]*)/,
                                        names: ['payload', 'param'],
                                        format: function (o) {
                                            var payload = o.payload === '*' ? '%s' : '%d';
                                            return "x-signaling-fb:" + payload + " x-message %s";
                                        }
                                    },
                                    {
                                        push: 'xMediaSettings',
                                        reg: /^x-mediasettings:([\S| ]*)/,
                                        names: ['settings'],
                                        format: "x-mediasettings:%s"
                                    },
                                    {
                                        push: 'invalid',
                                        names: ["value"]
                                    }
                                ]
                            };
                            // set sensible defaults to avoid polluting the grammar with boring details
                            Object.keys(grammar).forEach(function (key) {
                                var objs = grammar[key];
                                objs.forEach(function (obj) {
                                    if (!obj.reg) {
                                        obj.reg = /(.*)/;
                                    }
                                    if (!obj.format) {
                                        obj.format = "%s";
                                    }
                                });
                            });
                        }, {}], 2: [function (_dereq_, module, exports) {
                            var toIntIfInt = function (v) {
                                return String(Number(v)) === v ? Number(v) : v;
                            };
                            var attachProperties = function (match, location, names, rawName) {
                                if (rawName && !names) {
                                    location[rawName] = toIntIfInt(match[1]);
                                }
                                else {
                                    for (var i = 0; i < names.length; i += 1) {
                                        if (match[i + 1] != null) {
                                            location[names[i]] = toIntIfInt(match[i + 1]);
                                        }
                                    }
                                }
                            };
                            var parseReg = function (obj, location, content) {
                                var needsBlank = obj.name && obj.names;
                                if (obj.push && !location[obj.push]) {
                                    location[obj.push] = [];
                                }
                                else if (needsBlank && !location[obj.name]) {
                                    location[obj.name] = {};
                                }
                                var keyLocation = obj.push ?
                                    {} :
                                    needsBlank ? location[obj.name] : location; // otherwise, named location or root
                                attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
                                if (obj.push) {
                                    location[obj.push].push(keyLocation);
                                }
                            };
                            var grammar = _dereq_('./grammar');
                            var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
                            exports.parse = function (sdp) {
                                var session = {}, media = [], location = session; // points at where properties go under (one of the above)
                                // parse lines we understand
                                sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function (l) {
                                    var type = l[0];
                                    var content = l.slice(2);
                                    if (type === 'm') {
                                        media.push({ rtp: [], fmtp: [] });
                                        location = media[media.length - 1]; // point at latest media line
                                    }
                                    for (var j = 0; j < (grammar[type] || []).length; j += 1) {
                                        var obj = grammar[type][j];
                                        if (obj.reg.test(content)) {
                                            return parseReg(obj, location, content);
                                        }
                                    }
                                });
                                session.media = media; // link it up
                                return session;
                            };
                            var fmtpReducer = function (acc, expr) {
                                var s = expr.split('=');
                                if (s.length === 2) {
                                    acc[s[0]] = toIntIfInt(s[1]);
                                }
                                return acc;
                            };
                            exports.parseFmtpConfig = function (str) {
                                return str.split(/\;\s?/).reduce(fmtpReducer, {});
                            };
                            exports.parsePayloads = function (str) {
                                return str.split(' ').map(Number);
                            };
                            exports.parseRemoteCandidates = function (str) {
                                var candidates = [];
                                var parts = str.split(' ').map(toIntIfInt);
                                for (var i = 0; i < parts.length; i += 3) {
                                    candidates.push({
                                        component: parts[i],
                                        ip: parts[i + 1],
                                        port: parts[i + 2]
                                    });
                                }
                                return candidates;
                            };
                        }, { "./grammar": 1 }], 3: [function (_dereq_, module, exports) {
                            var grammar = _dereq_('./grammar');
                            // customized util.format - discards excess arguments and can void middle ones
                            var formatRegExp = /%[sdv%]/g;
                            var format = function (formatStr) {
                                var i = 1;
                                var args = arguments;
                                var len = args.length;
                                return formatStr.replace(formatRegExp, function (x) {
                                    if (i >= len) {
                                        return x; // missing argument
                                    }
                                    var arg = args[i];
                                    i += 1;
                                    switch (x) {
                                        case '%%':
                                            return '%';
                                        case '%s':
                                            return String(arg);
                                        case '%d':
                                            return Number(arg);
                                        case '%v':
                                            return '';
                                    }
                                });
                                // NB: we discard excess arguments - they are typically undefined from makeLine
                            };
                            var makeLine = function (type, obj, location) {
                                var str = obj.format instanceof Function ?
                                    (obj.format(obj.push ? location : location[obj.name])) :
                                    obj.format;
                                var args = [type + '=' + str];
                                if (obj.names) {
                                    for (var i = 0; i < obj.names.length; i += 1) {
                                        var n = obj.names[i];
                                        if (obj.name) {
                                            args.push(location[obj.name][n]);
                                        }
                                        else {
                                            args.push(location[obj.names[i]]);
                                        }
                                    }
                                }
                                else {
                                    args.push(location[obj.name]);
                                }
                                return format.apply(null, args);
                            };
                            // RFC specified order
                            // TODO: extend this with all the rest
                            var defaultOuterOrder = [
                                'v', 'o', 's', 'i',
                                'u', 'e', 'p', 'c',
                                'b', 't', 'r', 'z', 'a'
                            ];
                            var defaultInnerOrder = ['i', 'c', 'b', 'a'];
                            module.exports = function (session, opts) {
                                opts = opts || {};
                                // ensure certain properties exist
                                if (session.version == null) {
                                    session.version = 0; // "v=0" must be there (only defined version atm)
                                }
                                if (session.name == null) {
                                    session.name = " "; // "s= " must be there if no meaningful name set
                                }
                                session.media.forEach(function (mLine) {
                                    if (mLine.payloads == null) {
                                        mLine.payloads = "";
                                    }
                                });
                                var outerOrder = opts.outerOrder || defaultOuterOrder;
                                var innerOrder = opts.innerOrder || defaultInnerOrder;
                                var sdp = [];
                                // loop through outerOrder for matching properties on session
                                outerOrder.forEach(function (type) {
                                    grammar[type].forEach(function (obj) {
                                        if (obj.name in session && session[obj.name] != null) {
                                            sdp.push(makeLine(type, obj, session));
                                        }
                                        else if (obj.push in session && session[obj.push] != null) {
                                            session[obj.push].forEach(function (el) {
                                                sdp.push(makeLine(type, obj, el));
                                            });
                                        }
                                    });
                                });
                                // then for each media line, follow the innerOrder
                                session.media.forEach(function (mLine) {
                                    sdp.push(makeLine('m', grammar.m[0], mLine));
                                    innerOrder.forEach(function (type) {
                                        grammar[type].forEach(function (obj) {
                                            if (obj.name in mLine && mLine[obj.name] != null) {
                                                sdp.push(makeLine(type, obj, mLine));
                                            }
                                            else if (obj.push in mLine && mLine[obj.push] != null) {
                                                mLine[obj.push].forEach(function (el) {
                                                    sdp.push(makeLine(type, obj, el));
                                                });
                                            }
                                        });
                                    });
                                });
                                return sdp.join('\r\n') + '\r\n';
                            };
                        }, { "./grammar": 1 }], "sdp-transform": [function (_dereq_, module, exports) {
                            var parser = _dereq_('./parser');
                            var writer = _dereq_('./writer');
                            exports.write = writer;
                            exports.parse = parser.parse;
                            exports.parseFmtpConfig = parser.parseFmtpConfig;
                            exports.parsePayloads = parser.parsePayloads;
                            exports.parseRemoteCandidates = parser.parseRemoteCandidates;
                        }, { "./parser": 2, "./writer": 3 }] }, {}, [])("sdp-transform");
            });
            define('microsoft-sdp-transform', ['microsoft-sdp-transform/lib/sdp-transform'], function (main) { return main; });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/webrtc/sessionDescriptorUtils', ["require", "exports", '../constants', '../common/utils'], factory);
                }
            })(function (require, exports) {
                var constants_1 = require('../constants');
                var utils_1 = require('../common/utils');
                function forCodec(media, spec, callback) {
                    if (media.rtp) {
                        media.rtp.some(function (rtpParam, index) {
                            var payload = rtpParam.payload;
                            if (spec.name.toLowerCase() !== rtpParam.codec.toLowerCase() || spec.rate !== rtpParam.rate || spec.encoding !== rtpParam.encoding) {
                                return false;
                            }
                            var codec = {
                                rtp: rtpParam
                            };
                            media.fmtp = media.fmtp || [];
                            var fmtpExists = media.fmtp.some(function (fmtpParam) {
                                if (rtpParam.payload !== fmtpParam.payload) {
                                    return false;
                                }
                                codec.fmtp = fmtpParam;
                                return true;
                            });
                            var updatedCodec = callback(codec);
                            if (updatedCodec === null) {
                                media.payloads = media.payloads.toString().split(' ').filter(function (el) {
                                    return rtpParam.payload !== +el;
                                }).join(' ');
                                media.fmtp = media.fmtp.filter(function (fmtpParam) {
                                    return rtpParam.payload !== fmtpParam.payload;
                                });
                                media.rtp.splice(index, 1);
                            }
                            else {
                                if (codec.rtp.payload !== payload) {
                                    // update payloads
                                    media.payloads = media.payloads.toString().split(' ').map(function (el) {
                                        return +el === payload ? codec.rtp.payload : +el;
                                    }).join(' ');
                                    // update fmtp as well
                                    if (codec.fmtp) {
                                        codec.fmtp.payload = codec.rtp.payload;
                                    }
                                }
                                if (!fmtpExists && codec.fmtp) {
                                    media.fmtp.push(codec.fmtp);
                                }
                            }
                            return true;
                        });
                    }
                }
                function removeCodec(media, codec) {
                    var matchIndex = -1;
                    media.rtp.forEach(function (rtpParam, index) {
                        if (codec.codec.toLowerCase() === rtpParam.codec.toLowerCase() && codec.rate === rtpParam.rate && codec.encoding === rtpParam.encoding) {
                            matchIndex = index;
                        }
                    });
                    if (matchIndex >= 0 && media.rtp.length > 1) {
                        var payload = media.rtp[matchIndex].payload;
                        media.rtp.splice(matchIndex, 1);
                        media.payloads = media.payloads.split(' ').filter(function (el) {
                            return payload !== +el;
                        }).join(' ');
                        media.fmtp = media.fmtp.filter(function (fmtpParam) {
                            return payload !== fmtpParam.payload;
                        });
                    }
                }
                function getModality(media) {
                    if (media.label) {
                        if (constants_1["default"].MEDIA_LABEL.audio === media.label) {
                            return constants_1["default"].MODALITY.audio;
                        }
                        else if (constants_1["default"].MEDIA_LABEL.video === media.label) {
                            return constants_1["default"].MODALITY.video;
                        }
                        else if (constants_1["default"].MEDIA_LABEL.screensharing === media.label) {
                            return constants_1["default"].MODALITY.screensharing;
                        }
                    }
                    else {
                        if (constants_1["default"].MEDIA_TYPE.audio === media.type) {
                            return constants_1["default"].MODALITY.audio;
                        }
                        else if (constants_1["default"].MEDIA_TYPE.video === media.type) {
                            return constants_1["default"].MODALITY.video;
                        }
                    }
                    return null;
                }
                function getLabelForModality(modality) {
                    if (constants_1["default"].MODALITY.audio === modality) {
                        return constants_1["default"].MEDIA_LABEL.audio;
                    }
                    else if (constants_1["default"].MODALITY.video === modality) {
                        return constants_1["default"].MEDIA_LABEL.video;
                    }
                    else if (constants_1["default"].MODALITY.screensharing === modality) {
                        return constants_1["default"].MEDIA_LABEL.screensharing;
                    }
                    return null;
                }
                function getModalities(session) {
                    return session.media.reduce(function (modalities, media) {
                        if (media.port !== 0) {
                            var modality = getModality(media);
                            //here we take only the first media direction
                            if (!(modality in modalities)) {
                                var direction = media.direction ? media.direction.toLowerCase() : constants_1["default"].MEDIA_STATE.sendReceive;
                                modalities[modality] = direction;
                            }
                        }
                        ;
                        return modalities;
                    }, {});
                }
                function getTypeFromModality(modality) {
                    return modality === constants_1["default"].MODALITY.audio ? constants_1["default"].MEDIA_TYPE.audio : constants_1["default"].MEDIA_TYPE.video;
                }
                function getBundle(session) {
                    var bundle;
                    if (session.groups) {
                        var bundleGroup = utils_1["default"].find(session.groups, function (group) {
                            return 'BUNDLE' === group.type;
                        });
                        if (bundleGroup) {
                            var primaryMediaMid = bundleGroup.mids.split(' ')[0];
                            bundle = utils_1["default"].find(session.media, function (media) {
                                return primaryMediaMid === media.mid;
                            });
                        }
                    }
                    return bundle || null;
                }
                exports.__esModule = true;
                exports["default"] = {
                    forCodec: forCodec,
                    getModality: getModality,
                    getModalities: getModalities,
                    removeCodec: removeCodec,
                    getLabelForModality: getLabelForModality,
                    getTypeFromModality: getTypeFromModality,
                    getBundle: getBundle
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/webrtc/transform/candidateTransform', ["require", "exports", '../sessionDescriptorUtils'], factory);
                }
            })(function (require, exports) {
                var sessionDescriptorUtils_1 = require('../sessionDescriptorUtils');
                function CandidateTransform() {
                    var tcpTypeMapping = [
                        { jsep: 'active', msSdp: 'tcp-act' },
                        { jsep: 'passive', msSdp: 'tcp-pass' },
                        { jsep: 'so', msSdp: 'tcp-so' }
                    ];
                    this.fromMsSdp = function (media) {
                        media.candidates = media.candidates || [];
                        if (media.xCandidatesIpv6) {
                            media.xCandidatesIpv6.forEach(function (candidate) {
                                media.candidates.push(candidate);
                            });
                            delete media.xCandidatesIpv6;
                        }
                        media.candidates.forEach(function (candidate) {
                            transformCandidate(candidate, true);
                        });
                    };
                    this.toMsSdp = function (media, model) {
                        media.candidates = media.candidates || [];
                        // sort candidates by foundation to make MP happy
                        media.candidates.sort(function (a, b) {
                            if (a.foundation !== b.foundation) {
                                return a.foundation - b.foundation;
                            }
                            if (a.component !== b.component) {
                                return a.component - b.component;
                            }
                            // it is important to order default candidates prior to non-default ones, for the filtering step
                            return +isDefault(b, media, model) - +isDefault(a, media, model);
                        });
                        media.candidates = media.candidates.filter(function (candidate, index) {
                            transformCandidate(candidate, false);
                            // filter out candidates having same foundation and component to make MPC happy
                            // assumption is that default candidates are ordered prior to non-default ones, sorting step makes this happen
                            var prevCandidate = media.candidates[index - 1];
                            return !prevCandidate || prevCandidate.component !== candidate.component || prevCandidate.foundation !== candidate.foundation;
                        });
                        transformBundle(media, model);
                    };
                    function transformBundle(media, model) {
                        // native clients want bundled media ports to match, as well as bundled media connection line to be defined
                        // transform only if media is enabled and has no candidates of its own
                        if (media.port && !media.candidates.length) {
                            var bundle = sessionDescriptorUtils_1["default"].getBundle(model);
                            if (bundle) {
                                media.port = bundle.port;
                                media.connection = bundle.connection;
                            }
                        }
                    }
                    function transformCandidate(candidate, msSdp) {
                        delete candidate.generation;
                        // tcp candidates need special treatment
                        if (candidate.transport.match(/tcp/i)) {
                            transformTcpCandidate(candidate, msSdp);
                        }
                    }
                    function transformTcpCandidate(candidate, msSdp) {
                        tcpTypeMapping.some(function (mapping) {
                            if (msSdp) {
                                if (mapping.msSdp === candidate.transport.toLowerCase()) {
                                    candidate.transport = 'tcp';
                                    candidate.tcptype = mapping.jsep;
                                    return true;
                                }
                            }
                            else if (candidate.tcptype && mapping.jsep === candidate.tcptype.toLowerCase()) {
                                candidate.transport = mapping.msSdp;
                                delete candidate.tcptype;
                                return true;
                            }
                            return false;
                        });
                    }
                    function isDefault(candidate, media, model) {
                        var connection = media.connection || model.connection, isSame = function (candidate, ip, port) {
                            return candidate.port === port && candidate.ip === ip;
                        };
                        if (!connection) {
                            return false;
                        }
                        // rtp
                        if (1 === candidate.component) {
                            return isSame(candidate, connection.ip, media.port);
                        }
                        // rtcp
                        return media.rtcp ? isSame(candidate, media.rtcp.ip || connection.ip, media.rtcp.port) : false;
                    }
                }
                exports.__esModule = true;
                exports["default"] = {
                    build: function () {
                        return new CandidateTransform();
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/webrtc/webRtcConstants', ["require", "exports"], factory);
                }
            })(function (require, exports) {
                exports.__esModule = true;
                exports["default"] = {
                    STREAM_ID: {
                        audio: 'mainAudio',
                        video: 'mainVideo',
                        screensharing: 'applicationsharingVideo'
                    },
                    STREAM_ID_DELIMITER: '-'
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/webrtc/transform/streamTransform', ["require", "exports", '../../constants', '../../common/utils', '../webRtcConstants'], factory);
                }
            })(function (require, exports) {
                var constants_1 = require('../../constants');
                var utils_1 = require('../../common/utils');
                var webRtcConstants_1 = require('../webRtcConstants');
                var StreamIdentifiers = [
                    { label: constants_1["default"].MEDIA_LABEL.audio, id: webRtcConstants_1["default"].STREAM_ID.audio },
                    { label: constants_1["default"].MEDIA_LABEL.video, id: webRtcConstants_1["default"].STREAM_ID.video },
                    { label: constants_1["default"].MEDIA_LABEL.screensharing, id: webRtcConstants_1["default"].STREAM_ID.screensharing }
                ].reduce(function (identifiers, mapping) {
                    identifiers[mapping.label] = mapping.id;
                    return identifiers;
                }, {});
                var CName = utils_1["default"].uniqueId();
                function SsrcTransform() {
                    this.fromMsSdp = function (media) {
                        if (0 === media.port) {
                            return;
                        }
                        // ortc and NGC clients don't add a=ssrc attributes and we need to generate those from x-ssrc-range
                        // however a=ssrc should only be added if we are sending something
                        if (!isRecvOnly(media)) {
                            if (media.ssrcs) {
                                // remote client is webrtc, update msids to match the pattern
                                updateMsids(media.ssrcs, function (msidId, msidAppData) {
                                    return getMsidValue(msidId, msidAppData, media.label);
                                });
                            }
                            else {
                                // remote client is ngc, inject ssrc attributes
                                var flowSsrcs = getFlowSsrcs(media);
                                if (flowSsrcs.length > 0) {
                                    flowSsrcs.forEach(function (ssrc) {
                                        // always build msid from the primary stream ssrc
                                        addStream(media, ssrc, CName, getMsidValue(flowSsrcs[0], flowSsrcs[0], media.label));
                                    });
                                }
                                else if (media.xSsrcRange) {
                                    addStream(media, media.xSsrcRange.ssrcMin, CName, getMsidValue(media.xSsrcRange.ssrcMin, media.xSsrcRange.ssrcMin, media.label));
                                }
                            }
                        }
                        delete media.xSsrcRange;
                    };
                    this.toMsSdp = function (media) {
                        if (0 === media.port) {
                            return;
                        }
                        var ssrc;
                        if (media.ssrcs && media.ssrcs[0]) {
                            ssrc = media.ssrcs[0].id;
                        }
                        else if (isRecvOnly(media)) {
                            // https://code.google.com/p/webrtc/issues/detail?id=4740
                            // webrtc/media/engine/webrtcvoiceengine.h
                            // webrtc/media/engine/webrtcvideoengine2.cc
                            if ('audio' === media.type) {
                                ssrc = 0xFA17FA17;
                            }
                            else if ('video' === media.type) {
                                ssrc = 1;
                            }
                        }
                        if (void 0 !== ssrc) {
                            // add x-ssrc-range attribute
                            media.xSsrcRange = { ssrcMin: ssrc, ssrcMax: ssrc };
                        }
                    };
                    function getFlowSsrcs(media) {
                        if (media.ssrcGroups) {
                            var ssrcGroup;
                            media.ssrcGroups.some(function (group) {
                                if ('FID' === group.semantics) {
                                    ssrcGroup = group;
                                    return true;
                                }
                                return false;
                            });
                            if (ssrcGroup) {
                                return ssrcGroup.ssrcs.split(' ').map(function (value) {
                                    return +value;
                                });
                            }
                        }
                        return [];
                    }
                    function addStream(media, ssrc, cname, msid) {
                        media.ssrcs = media.ssrcs || [];
                        media.ssrcs.push({
                            attribute: 'cname',
                            id: ssrc,
                            value: cname
                        });
                        media.ssrcs.push({
                            attribute: 'msid',
                            id: ssrc,
                            value: msid
                        });
                    }
                    function updateMsids(ssrcs, func) {
                        ssrcs.filter(function (ssrc) {
                            return 'msid' === ssrc.attribute;
                        }).forEach(function (ssrc) {
                            var msid = ssrc.value.split(' ');
                            ssrc.value = func(msid[0], msid[1] || msid[0]);
                        });
                    }
                    function getMsidValue(msidId, msidAppData, label) {
                        var prefix = getMsidPrefix(label);
                        return prefix + msidId + ' ' + prefix + msidAppData;
                    }
                    function getMsidPrefix(label) {
                        return StreamIdentifiers[label] ? StreamIdentifiers[label] + webRtcConstants_1["default"].STREAM_ID_DELIMITER : '';
                    }
                    function isRecvOnly(media) {
                        return 'recvonly' === media.direction;
                    }
                }
                exports.__esModule = true;
                exports["default"] = {
                    build: function () {
                        return new SsrcTransform();
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/webrtc/transform/rtcpTransform', ["require", "exports"], factory);
                }
            })(function (require, exports) {
                function RtcpTransform() {
                    this.toMsSdp = function (media, session, context) {
                        if ('offer' === context.type) {
                            if (media.rtcp) {
                                // keep port part of rtcp only, explicitly setting it to default rtp port
                                media.rtcp = {
                                    port: media.port
                                };
                            }
                        }
                        else {
                            delete media.rtcp;
                        }
                    };
                }
                exports.__esModule = true;
                exports["default"] = {
                    build: function () {
                        return new RtcpTransform();
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/common/userAgentAdapter', ["require", "exports"], factory);
                }
            })(function (require, exports) {
                // Below variable and check to allow references to this module (which runs code
                // in global scope) from Mocha Unit Tests: 
                var exportedWindow = undefined;
                if ((typeof window !== 'undefined') && (typeof navigator !== 'undefined')) {
                    exportedWindow = window;
                    window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;
                    window.MediaStream = window.MediaStream || window.webkitMediaStream || window.mozMediaStream || window.msMediaStream;
                    window.attachMediaStream = function (elem, mediaStream) {
                        if (typeof elem.srcObject !== 'undefined') {
                            elem.srcObject = mediaStream;
                        }
                        else if (typeof elem.src !== 'undefined') {
                            elem.src = window.URL.createObjectURL(mediaStream);
                        }
                    };
                    window.detachMediaStream = function (elem) {
                        if (typeof elem.srcObject !== 'undefined') {
                            elem.srcObject = null;
                        }
                        else if (typeof elem.src !== 'undefined') {
                            if (elem.src) {
                                var oldSrc = elem.src;
                                elem.src = ''; //TreatNullAs=EmptyString] is not set
                                window.URL.revokeObjectURL(oldSrc); //maybe we dont need to revoke url...
                            }
                        }
                    };
                    if (typeof navigator.mozGetUserMedia !== 'undefined' && typeof mozRTCPeerConnection !== 'undefined') {
                        window.RTCPeerConnection = mozRTCPeerConnection;
                        window.RTCSessionDescription = mozRTCSessionDescription;
                        var applyForceChangeSsrcWorkaround = function () {
                            var native = window.RTCPeerConnection.prototype.setRemoteDescription;
                            window.RTCPeerConnection.prototype.setRemoteDescription = function (description) {
                                var getParentMediaStream = function (track) {
                                    var streams = self.getLocalStreams() || [];
                                    return streams.find(function (stream) {
                                        var streamTracks = ('audio' === track.kind ? stream.getAudioTracks() : stream.getVideoTracks()) || [];
                                        return streamTracks.some(function (streamTrack) {
                                            return streamTrack.id === track.id;
                                        });
                                    });
                                };
                                if ('offer' === description.type) {
                                    // FF sends RTCP BYE for all outgoing streams as part of applying updated local description, and continues streaming without changing SSRCs like nothing ever happened
                                    // we need to remove and add back all media tracks in order to trigger SSRC change, work-arounding the behavior above
                                    // see https://bugzilla.mozilla.org/show_bug.cgi?id=1232234 for details
                                    var self = this, senders = self.getSenders() || [];
                                    senders.forEach(function (sender) {
                                        var track = sender.track, stream = getParentMediaStream(track);
                                        if (stream) {
                                            self.removeTrack(sender);
                                            self.addTrack(track, stream);
                                        }
                                    });
                                }
                                native.apply(this, arguments);
                            };
                            window.RTCPeerConnection.prototype.getStats = function () {
                                return {};
                            };
                        };
                        applyForceChangeSsrcWorkaround();
                        navigator.getUserMedia = function (constraints, onSuccess, onFail) {
                            return navigator.mozGetUserMedia(constraints, onSuccess, onFail);
                        };
                    }
                    else if (typeof navigator.webkitGetUserMedia !== 'undefined' && typeof webkitRTCPeerConnection !== 'undefined') {
                        window.RTCPeerConnection = webkitRTCPeerConnection;
                        navigator.getUserMedia = function (constraints, onSuccess, onFail) {
                            // chrome does not support deviceId constraint, we convert it to use optional.sourceId
                            var polyfillDeviceId = function (constraints) {
                                if (constraints && constraints.deviceId && constraints.deviceId.exact) {
                                    if (!constraints.optional) {
                                        constraints.optional = [];
                                    }
                                    constraints.optional.push({ sourceId: constraints.deviceId.exact });
                                    delete constraints.deviceId;
                                }
                            };
                            if (constraints) {
                                polyfillDeviceId(constraints.audio);
                                polyfillDeviceId(constraints.video);
                            }
                            return navigator.webkitGetUserMedia(constraints, onSuccess, onFail);
                        };
                    }
                    if (typeof RTCIceGatherer !== 'undefined') {
                        // older versions of Microsoft Edge don't have getStats implemented
                        var getStats = function () {
                            return Promise.resolve();
                        };
                        if (!RTCRtpSender.prototype.getStats) {
                            RTCRtpSender.prototype.getStats = getStats;
                        }
                        if (!RTCRtpSender.prototype.msGetStats) {
                            RTCRtpSender.prototype.msGetStats = getStats;
                        }
                        if (!RTCRtpReceiver.prototype.getStats) {
                            RTCRtpReceiver.prototype.getStats = getStats;
                        }
                        if (!RTCRtpReceiver.prototype.msGetStats) {
                            RTCRtpReceiver.prototype.msGetStats = getStats;
                        }
                        if (!RTCIceTransport.prototype.getStats) {
                            RTCIceTransport.prototype.getStats = getStats;
                        }
                        if (!RTCIceTransport.prototype.msGetStats) {
                            RTCIceTransport.prototype.msGetStats = getStats;
                        }
                        // same applies to contributing sources
                        if (!RTCRtpReceiver.prototype.getContributingSources) {
                            RTCRtpReceiver.prototype.getContributingSources = function () { return []; };
                        }
                        // as well as requestSendCSRC
                        if (!RTCRtpReceiver.prototype.requestSendCSRC) {
                            RTCRtpReceiver.prototype.requestSendCSRC = function () { };
                        }
                    }
                }
                exports.__esModule = true;
                exports["default"] = {
                    window: exportedWindow
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/webrtc/transform/msSdpTransform', ["require", "exports", './candidateTransform', './streamTransform', './rtcpTransform', '../../helper', '../../common/userAgentAdapter', '../../constants'], factory);
                }
            })(function (require, exports) {
                var candidateTransform_1 = require('./candidateTransform');
                var streamTransform_1 = require('./streamTransform');
                var rtcpTransform_1 = require('./rtcpTransform');
                var helper_1 = require('../../helper');
                var userAgentAdapter_1 = require('../../common/userAgentAdapter');
                var constants_1 = require('../../constants');
                var labels = {
                    audio: 'main-audio',
                    video: 'main-video'
                };
                var profiles = {
                    udpTlsRtpSavpf: 'UDP/TLS/RTP/SAVPF',
                    rtpSavpf: 'RTP/SAVPF',
                    rtpSavp: 'RTP/SAVP'
                };
                function MsSdpTransform(_context) {
                    this.toMsSdp = _toMsSdp;
                    this.fromMsSdp = _fromMsSdp;
                    var logger = _context.logger, settings = _context.settings, window = userAgentAdapter_1["default"].window, candidateTransform = candidateTransform_1["default"].build(), streamTransform = streamTransform_1["default"].build(), rtcpTransform = rtcpTransform_1["default"].build();
                    function _toMsSdp(sdp, context) {
                        sdp.msidSemantic = { semantic: 'WMS', token: '*' };
                        sdp.media.forEach(function (media) {
                            media.protocol = profiles.rtpSavp;
                            media.label = media.label || _getLabel(media.type);
                            //remove all properties from disabled modality that are not needed for NGC
                            if (media.port === 0) {
                                for (var prop in media) {
                                    if (media.hasOwnProperty(prop) && ['type', 'port', 'protocol', 'payloads'].indexOf(prop) < 0) {
                                        delete media[prop];
                                    }
                                }
                                media.payloads = 34; //NGC puts always payloads to 34 when disabling modality
                            }
                            streamTransform.toMsSdp(media);
                            if (media.crypto) {
                                // append â€œ|2^31â€ to the crypto attributes
                                media.crypto.forEach(function (crypto) {
                                    crypto.config += '|2^31';
                                });
                            }
                            // DTLS-SRTP
                            // Firefox uses a session level fingerprint attribute, normalize it to media level
                            if (media.port !== 0 && sdp.fingerprint) {
                                media.fingerprint = sdp.fingerprint;
                            }
                            if (media.fingerprint) {
                                // remove setup:actpass attribute from all offers for compatibility with legacy clients
                                if (_isOffer(context)) {
                                    delete media.setup;
                                }
                            }
                            candidateTransform.toMsSdp(media, sdp);
                            rtcpTransform.toMsSdp(media, sdp, context);
                            if (media.invalid) {
                                logger.error('Unknown SDP attributes!', media.invalid);
                                // delete all invalid attributes
                                delete media.invalid;
                            }
                            transformExtensions(media, false);
                            if (media.port !== 0) {
                                if (media.type === constants_1["default"].MEDIA_TYPE.audio && settings.webrtcAudioChannelSignalingFeedback) {
                                    media.signalingFbXMessage = {
                                        payload: '*',
                                        param: settings.webrtcAudioChannelSignalingFeedback
                                    };
                                }
                                else if (media.type === constants_1["default"].MEDIA_TYPE.video && settings.webrtcVideoChannelSignalingFeedback) {
                                    media.signalingFbXMessage = {
                                        payload: '*',
                                        param: settings.webrtcVideoChannelSignalingFeedback
                                    };
                                }
                            }
                        });
                        // remove session level fingerprint attribute
                        delete sdp.fingerprint;
                        return sdp;
                    }
                    function _fromMsSdp(sdp, context) {
                        var srtpInfo = helper_1["default"].getSrtpInfo(sdp);
                        for (var mi = sdp.media.length - 1; mi >= 0; --mi) {
                            var media = sdp.media[mi];
                            // add msidSemantic only if there are media with ssrc
                            if ((media.ssrcs && media.ssrcs[0]) || media.xSsrcRange) {
                                sdp.msidSemantic = { semantic: 'WMS', token: '*' };
                            }
                            // profile amongst other things specifies whether DTLS-SRTP is used
                            media.protocol = profiles.udpTlsRtpSavpf;
                            if (!srtpInfo.dtls || (srtpInfo.sdes && settings.preferSdesSrtp)) {
                                media.protocol = profiles.rtpSavpf;
                            }
                            if (media.port === 0) {
                                // firefox does not tolerate rejected media without direction...
                                if (!media.direction) {
                                    media.direction = 'inactive';
                                }
                                continue;
                            }
                            streamTransform.fromMsSdp(media);
                            delete media.cryptoscale;
                            // DTLS-SRTP
                            if (media.fingerprint) {
                                // WebRTC.org stack requires all offers to have a setup:actpass attribute. Neither RFC5763 nor Firefox
                                // WebRTC stack have such a requirement, however, to keep things simple, we will always replace whatever
                                // offer has with setup:actpass.
                                if (_isOffer(context)) {
                                    media.setup = 'actpass';
                                }
                            }
                            if (media.crypto) {
                                for (var i = media.crypto.length - 1; i >= 0; --i) {
                                    var crypto = media.crypto[i];
                                    // allowing only those crypto attribute lines with no MKI field
                                    if (crypto.config.match(/.*\|\d+:\d+/)) {
                                        media.crypto.splice(i, 1);
                                        continue;
                                    }
                                    // ripping of the lifetime value of â€œ2^31â€ from the line
                                    crypto.config = crypto.config.replace(/(.*)\|2\^\d+/, '$1');
                                }
                            }
                            if (media.remoteCandidates) {
                                // this is a re-invite, originated by ORTC or native endpoint, containing a single candidate.
                                // remove it to make WebRTC stack believe that transport has not changed
                                delete media.candidates;
                                delete media.xCandidatesIpv6;
                                delete media.remoteCandidates;
                            }
                            candidateTransform.fromMsSdp(media);
                            if (media.rtcpFbXMessage) {
                                delete media.rtcpFbXMessage;
                            }
                            transformExtensions(media, true);
                        }
                        return sdp;
                    }
                    function transformExtensions(media, incoming) {
                        // forward slash cannot be used in MS-SDP extmap attribute due to SDP parsing issues in legacy clients
                        var backslashEncodedExtensions = [{ name: 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time', encoded: 'http:\\\\www.webrtc.org\\experiments\\rtp-hdrext\\abs-send-time' }];
                        if (media.ext) {
                            media.ext.forEach(function (extension) {
                                backslashEncodedExtensions.some(function (backslashEncodedExtension) {
                                    var input = incoming ? backslashEncodedExtension.encoded : backslashEncodedExtension.name;
                                    var output = incoming ? backslashEncodedExtension.name : backslashEncodedExtension.encoded;
                                    if (input === extension.uri) {
                                        extension.uri = output;
                                        return true;
                                    }
                                    return false;
                                });
                            });
                        }
                    }
                    function _isOffer(context) {
                        return 'offer' === context.type;
                    }
                    function _getLabel(label) {
                        return labels.hasOwnProperty(label) && labels[label] || 'undefined';
                    }
                }
                exports.__esModule = true;
                exports["default"] = MsSdpTransform;
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/common/formatParameters', ["require", "exports", './utils'], factory);
                }
            })(function (require, exports) {
                var utils_1 = require('./utils');
                function FormatParameters(fmtpString) {
                    var parameters = {}, self = this;
                    this.setIfMissing = function (name, value) {
                        if (!self.contains(name)) {
                            parameters[name] = value;
                        }
                    };
                    this.get = function (name) {
                        return parameters[name];
                    };
                    this.contains = function (name) {
                        return parameters.hasOwnProperty(name);
                    };
                    this.toString = function () {
                        var result = '';
                        utils_1["default"].forOwn(parameters, function (value, key) {
                            result += (result ? ';' : '') + key;
                            if (typeof value !== 'undefined') {
                                result += '=' + value;
                            }
                        });
                        return result;
                    };
                    (function () {
                        if (fmtpString) {
                            fmtpString.split(';').forEach(function (parameter) {
                                var splitParameter = parameter.split('=');
                                parameters[splitParameter[0]] = splitParameter[1];
                            });
                        }
                    })();
                }
                exports.__esModule = true;
                exports["default"] = {
                    build: function (fmtpString) {
                        return new FormatParameters(fmtpString);
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/webrtc/webRtcSessionDescription', ["require", "exports", 'microsoft-sdp-transform', '../constants', '../helper', './transform/msSdpTransform', '../common/formatParameters', './sessionDescriptorUtils'], factory);
                }
            })(function (require, exports) {
                var SdpT = require('microsoft-sdp-transform');
                var constants_1 = require('../constants');
                var helper_1 = require('../helper');
                var msSdpTransform_1 = require('./transform/msSdpTransform');
                var formatParameters_1 = require('../common/formatParameters');
                var sessionDescriptorUtils_1 = require('./sessionDescriptorUtils');
                function SessionDescription(context, sessionType, sdp, remote) {
                    var _settings = context.settings, _mediaManager = context.mediaManager, _sdpTransform = context.sdpTransform, _logger = context.logger, _sdpModel = SdpT.parse(sdp), _msSdpT = new msSdpTransform_1["default"](context), _modalities;
                    /**
                     * Getters and setters
                     */
                    this.getModalities = function () {
                        return _modalities || sessionDescriptorUtils_1["default"].getModalities(_sdpModel);
                    };
                    this.updateModalities = function (modalities) {
                        _modalities = modalities;
                    };
                    this.getSrtpInfo = function () {
                        return helper_1["default"].getSrtpInfo(_sdpModel);
                    };
                    this.getVideoCodecs = function () {
                        var codecs = [];
                        _sdpModel.media.forEach(function (media) {
                            if ('video' === media.type) {
                                codecs = media.rtp.map(function (rtpParams) {
                                    return rtpParams.codec.toLowerCase();
                                });
                            }
                        });
                        return codecs;
                    };
                    /**
                     * Inject max-fs/max-fps
                     */
                    function injectH264FormatParameters(model) {
                        model.media.forEach(function (media, idx) {
                            var mediaEntity = _mediaManager.getMediaEntity(idx);
                            if (constants_1["default"].MEDIA_TYPE.video !== mediaEntity.getType()) {
                                return;
                            }
                            sessionDescriptorUtils_1["default"].forCodec(media, { name: 'h264', rate: 90000 }, function (codec) {
                                var capability = mediaEntity.getVideoCapabilities();
                                if (!capability) {
                                    return;
                                }
                                codec.fmtp = codec.fmtp || { payload: codec.rtp.payload };
                                var fmtp = formatParameters_1["default"].build(codec.fmtp.config);
                                fmtp.setIfMissing('max-fs', capability.getMaxFS()); // The value of max-fs is an integer indicating the maximum frame size in units of macroblocks, 640x480
                                fmtp.setIfMissing('max-fps', capability.getMaxFPS()); // The value of max-fps is an integer in units of hundredths of frames per second
                                codec.fmtp.config = fmtp.toString();
                            });
                            return true;
                        });
                    }
                    this.usePrimaryAudioCodecOnly = function (otherPartyCodecs) {
                        var nonPrimaryCodecs = ['cn', 'telephone-event'];
                        _sdpModel.media.forEach(function (media) {
                            if (constants_1["default"].MEDIA_TYPE.audio === media.type) {
                                var primaryCodecs = media.rtp.filter(function (rtpParams) {
                                    return otherPartyCodecs.indexOf(rtpParams.codec.toLowerCase()) !== -1
                                        && nonPrimaryCodecs.indexOf(rtpParams.codec.toLowerCase()) === -1;
                                });
                                if (primaryCodecs.length === 0) {
                                    throw new Error('there is no matching primary audio codec');
                                }
                                var redundantCodecs = media.rtp.filter(function (rtpParams) {
                                    return rtpParams !== primaryCodecs[0]
                                        && nonPrimaryCodecs.indexOf(rtpParams.codec.toLowerCase()) === -1;
                                });
                                redundantCodecs.forEach(function (codec) {
                                    sessionDescriptorUtils_1["default"].removeCodec(media, codec);
                                });
                            }
                        });
                    };
                    this.isCodecSwitchSupported = function () {
                        return !_sdpModel.media.some(function (media) {
                            return constants_1["default"].MEDIA_TYPE.audio === media.type && media.xMediaSettings && containsMediaSetting(media.xMediaSettings, 'codecswitchunsupported');
                        });
                    };
                    function containsMediaSetting(mediaSettings, setting) {
                        return mediaSettings.some(function (mediaSetting) {
                            return mediaSetting.settings.indexOf(setting) !== -1;
                        });
                    }
                    // createOffer(offer from pc), toLocal(offered mods), toOffer(local description from pc)
                    this.toOffer = function () {
                        _applyMediaFixups(_sdpModel, function (mtype, sdpMedia) {
                            _fixMediaCandidates(_settings, sdpMedia);
                        });
                        //populate model if it is initial call
                        if (_mediaManager.isEmpty()) {
                            _mediaManager.fromOffer(_sdpModel, _modalities);
                        }
                        _mediaManager.syncModalities(_modalities, false);
                        _sdpModel = _sdpTransform.toOffer(_sdpModel, _mediaManager, _modalities);
                        if (!_settings.disableMsSdp) {
                            _msSdpT.toMsSdp(_sdpModel, { type: sessionType });
                        }
                        // format params must be injected into inflated MS-SDP model
                        injectH264FormatParameters(_sdpModel);
                        // update modalities from the actual offer
                        _modalities = sessionDescriptorUtils_1["default"].getModalities(_sdpModel);
                        return SdpT.write(_sdpModel);
                    };
                    // createAnswer(answer from pc), toLocal(negotiated mods), toAnswer(local description from pc)
                    this.toAnswer = function () {
                        _applyMediaFixups(_sdpModel, function (mediaType, sdpMedia) {
                            _fixMediaCandidates(_settings, sdpMedia);
                        });
                        _mediaManager.syncModalities(_modalities, true);
                        _sdpModel = _sdpTransform.toAnswer(_sdpModel, _mediaManager, _modalities);
                        if (!_settings.disableMsSdp) {
                            _msSdpT.toMsSdp(_sdpModel, { type: sessionType });
                        }
                        // format params must be injected into inflated MS-SDP model
                        injectH264FormatParameters(_sdpModel);
                        // update modalities from the actual answer
                        _modalities = sessionDescriptorUtils_1["default"].getModalities(_sdpModel);
                        return SdpT.write(_sdpModel);
                    };
                    // createAnswer(process answer from remote), getModalities, toRemote(negotiated mods)
                    // createOffer(process offer faarom remote), getModalities, toRemote(negotiated mods)
                    this.toRemote = function (negotiateModalities) {
                        _modalities = negotiateModalities;
                        _mediaManager.fromRemote(_sdpModel, _modalities); //modalities sync is performed inside
                        _sdpModel = _sdpTransform.toRemote(_sdpModel, _mediaManager, _modalities);
                        return SdpT.write(_sdpModel);
                    };
                    this.getVideoRecvCapabilities = function () {
                        var capabilities = {};
                        _sdpModel.media.filter(function (media) { return 'video' === media.type; }).some(function (media) {
                            sessionDescriptorUtils_1["default"].forCodec(media, { name: 'h264', rate: 90000 }, function (codec) {
                                if (codec.fmtp) {
                                    var fmtp = formatParameters_1["default"].build(codec.fmtp.config);
                                    var maxFS = fmtp.get('max-fs');
                                    if (!isNaN(maxFS) && maxFS) {
                                        capabilities.maxFS = +maxFS;
                                    }
                                    var maxFPS = fmtp.get('max-fps');
                                    if (!isNaN(maxFPS) && maxFPS) {
                                        capabilities.maxFPS = +maxFPS / 100; //fps is defined in hundredths of frames per second
                                    }
                                }
                            });
                            return true;
                        });
                        return capabilities;
                    };
                    this.needToWaitIceCandidates = function () {
                        if (context.bundled) {
                            // in case of bundling check if bundled media port is set
                            var bundle = sessionDescriptorUtils_1["default"].getBundle(_sdpModel);
                            return bundle && bundle.port === 9;
                        }
                        // otherwise just check if all media ports are set
                        return _sdpModel.media.some(function (media) {
                            return media.port === 9;
                        });
                    };
                    function processBundle() {
                        if ('answer' === sessionType && _sdpModel.groups) {
                            context.bundled = true;
                        }
                    }
                    (function () {
                        if (remote && !_settings.disableMsSdp) {
                            _msSdpT.fromMsSdp(_sdpModel, { type: sessionType });
                        }
                        processBundle();
                    })();
                }
                function createInactiveSdp(context, type_, sdp, modalities) {
                    var settings = context.settings, 
                    //logger = context.logger,
                    msSdpT = new msSdpTransform_1["default"](context), model = SdpT.parse(sdp);
                    _applyMediaFixups(model, function (mediaType, sdpMedia) {
                        if (sdpMedia.port !== 0 && !modalities[mediaType]) {
                            _disableMedia(sdpMedia);
                        }
                        sdpMedia.direction = 'inactive';
                        _fixMediaCandidates(settings, sdpMedia);
                    });
                    if (!settings.disableMsSdp) {
                        msSdpT.toMsSdp(model, { type: type_ });
                    }
                    return SdpT.write(model);
                }
                /**
                 * Internal
                 */
                function _disableMedia(sdpMedia) {
                    sdpMedia.port = 0;
                    for (var prop in sdpMedia) {
                        // FF wants to have connection attributes for disabled m-lines
                        // direction must be disabled on returned answer, ff puts it, chrome sets it to 'sendonly'
                        if (sdpMedia.hasOwnProperty(prop) && ['type', 'port', 'protocol', 'payloads', 'connection', 'direction'].indexOf(prop) < 0) {
                            delete sdpMedia[prop];
                            sdpMedia.direction = 'inactive'; //needed for current chrome (c47, canary is okay)
                        }
                    }
                }
                function _fixMediaCandidates(settings, sdpMedia) {
                    if (sdpMedia.candidates && (settings.iceCandidateType || settings.iceCandidateTransport)) {
                        sdpMedia.candidates = sdpMedia.candidates.filter(function (candidate) {
                            var typeOk = true, transportOk = true;
                            if (settings.iceCandidateType) {
                                typeOk = candidate.type.match(new RegExp(settings.iceCandidateType), 'i');
                            }
                            if (settings.iceCandidateTransport) {
                                transportOk = candidate.transport.match(new RegExp(settings.iceCandidateTransport, 'i'));
                            }
                            return typeOk && transportOk;
                        });
                    }
                }
                function _applyMediaFixups(model, fixupMedia) {
                    for (var i = 0; i < model.media.length; i++) {
                        if (model.media[i].type === 'audio') {
                            fixupMedia(constants_1["default"].MEDIA_TYPE.audio, model.media[i]);
                        }
                        else if (model.media[i].type === 'video') {
                            fixupMedia(constants_1["default"].MEDIA_TYPE.video, model.media[i]);
                        }
                    }
                }
                exports.__esModule = true;
                exports["default"] = {
                    build: function (context) {
                        context = context || {};
                        return {
                            createLocalOffer: function (sdp) {
                                return new SessionDescription(context, 'offer', sdp);
                            },
                            createRemoteOffer: function (sdp) {
                                return new SessionDescription(context, 'offer', sdp, true);
                            },
                            createLocalAnswer: function (sdp) {
                                return new SessionDescription(context, 'answer', sdp);
                            },
                            createRemoteAnswer: function (sdp) {
                                return new SessionDescription(context, 'answer', sdp, true);
                            },
                            createInactiveOfferSdp: createInactiveSdp.bind(null, context, 'offer'),
                            createInactiveAnswerSdp: createInactiveSdp.bind(null, context, 'answer')
                        };
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/webrtc/adapter/webkitSessionDescription', ["require", "exports", '../../common/userAgentAdapter'], factory);
                }
            })(function (require, exports) {
                var userAgentAdapter_1 = require('../../common/userAgentAdapter');
                var rollbackTypeName = 'rollback';
                function SessionDescription() {
                    var args = [].slice.apply(arguments);
                    var rollback = args[0] && isRollback(args[0].type);
                    args.splice(0, rollback ? 1 : 0, null);
                    var sessionDescription = new (Function.prototype.bind.apply(userAgentAdapter_1["default"].window.RTCSessionDescription, args));
                    var originalType = Object.getOwnPropertyDescriptor(userAgentAdapter_1["default"].window.RTCSessionDescription.prototype, 'type');
                    Object.defineProperty(sessionDescription, 'type', {
                        get: function () {
                            return rollback ? rollbackTypeName : originalType.get.call(sessionDescription);
                        },
                        set: function (value) {
                            rollback = isRollback(value);
                            if (!rollback) {
                                originalType.set.call(sessionDescription, value);
                            }
                        }
                    });
                    return sessionDescription;
                }
                function isRollback(sessionType) {
                    return rollbackTypeName === sessionType;
                }
                exports.__esModule = true;
                exports["default"] = {
                    build: function () {
                        return SessionDescription;
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/webrtc/adapter/webkitPeerConnection', ["require", "exports", 'microsoft-sdp-transform', '../sessionDescriptorUtils', '../../common/formatParameters', './webkitSessionDescription', '../../common/userAgentAdapter', '../../common/utils'], factory);
                }
            })(function (require, exports) {
                var sdpTransform = require('microsoft-sdp-transform');
                var sessionDescriptorUtils_1 = require('../sessionDescriptorUtils');
                var formatParameters_1 = require('../../common/formatParameters');
                var webkitSessionDescription_1 = require('./webkitSessionDescription');
                var userAgentAdapter_1 = require('../../common/userAgentAdapter');
                var utils_1 = require('../../common/utils');
                // codecs where Chrome assigns different payload types compared to NGC
                var ASYMMETRIC_CODEC_SPECS = [
                    { name: 'telephone-event', rate: 8000 },
                    { name: 'cn', rate: 16000 }
                ];
                function PeerConnection(capabilityGatherer) {
                    var args, peerConnection, currentLocalDescription, RTCSessionDescription, senders = [];
                    RTCSessionDescription = webkitSessionDescription_1["default"].build();
                    args = [].slice.apply(arguments);
                    args.splice(0, 1, null);
                    // Chrome is not following the standard and is using iceTransports property instead of iceTransportPolicy
                    // https://bugs.chromium.org/p/webrtc/issues/detail?id=4869
                    overrideSetting('iceTransportPolicy', 'iceTransports');
                    peerConnection = new (Function.prototype.bind.apply(userAgentAdapter_1["default"].window.webkitRTCPeerConnection, args));
                    shim();
                    function overrideSetting(settingName, newSettingName) {
                        if (args[1] && args[1][settingName]) {
                            args[1][newSettingName] = args[1][settingName];
                        }
                    }
                    function shim() {
                        shimPromises();
                        shimSetRemoteDescription();
                        shimSetLocalDescription();
                        shimCreateAnswer();
                        shimCreateOffer();
                        shimSenders();
                    }
                    function shimPromises() {
                        [{ name: 'createOffer', reverseArgs: true }, 'createAnswer', 'setRemoteDescription', 'setLocalDescription'].forEach(function (func) {
                            var name = func.name || func, original = peerConnection[name];
                            peerConnection[name] = function () {
                                // this polyfill supports a single argument only, it is also fine if non is provided
                                var args = arguments;
                                return new Promise(function (resolve, reject) {
                                    var arrayArgs = [resolve, reject];
                                    if (args.length > 0) {
                                        arrayArgs.splice(func.reverseArgs ? arrayArgs.length : 0, 0, args[0]);
                                    }
                                    original.apply(peerConnection, arrayArgs);
                                });
                            };
                        });
                    }
                    function Sender(track, stream) {
                        var dtmfSender;
                        Object.defineProperty(this, 'dtmf', {
                            get: function () {
                                if ('audio' === track.kind) {
                                    dtmfSender = dtmfSender || peerConnection.createDTMFSender(track);
                                    return dtmfSender;
                                }
                                return null;
                            }
                        });
                        this.track = track;
                        this._stream = stream;
                    }
                    function shimSenders() {
                        if (peerConnection.getSenders && peerConnection.addTrack && peerConnection.removeTrack) {
                            return;
                        }
                        peerConnection.getSenders = function () {
                            return senders.slice();
                        };
                        peerConnection.addTrack = function (track, stream) {
                            if (!track || !stream) {
                                throw new Error('both media track and stream need to be provided');
                            }
                            var streamExists = peerConnection.getLocalStreams().some(function (localStream) {
                                return localStream.id === stream.id;
                            });
                            if (!streamExists) {
                                peerConnection.addStream(stream);
                            }
                            var sender = utils_1["default"].find(senders, function (sender) {
                                return sender.track.id === track.id;
                            });
                            if (!sender) {
                                sender = new Sender(track, stream);
                                senders.push(sender);
                            }
                            return sender;
                        };
                        peerConnection.removeTrack = function (sender) {
                            // it is fine to remove the entire stream for now, as we are not using it differently in any case
                            peerConnection.getLocalStreams().filter(function (stream) {
                                return stream.id === sender._stream.id;
                            }).forEach(peerConnection.removeStream.bind(peerConnection));
                            utils_1["default"].remove(senders, function (s) {
                                return s === sender;
                            });
                        };
                    }
                    // work-around for specifying offer options with offerToReceiveVideo > 1
                    function shimCreateOffer() {
                        var originalCreateOffer = peerConnection.createOffer;
                        peerConnection.createOffer = function (options) {
                            var args = arguments;
                            if (options && options.offerToReceiveVideo > 1) {
                                options.offerToReceiveVideo = 1;
                            }
                            return originalCreateOffer.apply(peerConnection, args);
                        };
                    }
                    // support for local description rollback, work-arounding https://bugs.chromium.org/p/webrtc/issues/detail?id=4676
                    // this polyfill breaks the single operation queue concept of PC, and results in rollbacks being processed out-of-order,
                    // which shouldn't be an issue, since we never use PC like this.
                    function shimSetLocalDescription() {
                        var originalSetLocalDescription = peerConnection.setLocalDescription;
                        peerConnection.setLocalDescription = function (description) {
                            var performRollback = function () {
                                if (!currentLocalDescription || !peerConnection.remoteDescription) {
                                    return Promise.reject(new Error('rollback requires having both remote and local descriptions set'));
                                }
                                var remoteDescription = new RTCSessionDescription({ type: 'answer', sdp: peerConnection.remoteDescription.sdp });
                                return originalSetLocalDescription(currentLocalDescription).then(function () {
                                    return peerConnection.setRemoteDescription(remoteDescription);
                                });
                            };
                            if ('rollback' === description.type) {
                                if ('have-local-offer' === peerConnection.signalingState) {
                                    return performRollback();
                                }
                                return Promise.reject(new Error('rollback is supported only from have-local-offer state'));
                            }
                            if ('stable' === peerConnection.signalingState && peerConnection.localDescription) {
                                currentLocalDescription = new RTCSessionDescription({ type: 'offer', sdp: peerConnection.localDescription.sdp });
                            }
                            return originalSetLocalDescription(description);
                        };
                    }
                    // work-around for https://bugs.chromium.org/p/webrtc/issues/detail?id=5605
                    function shimSetRemoteDescription() {
                        // we need the following functions to wait until we obtain capabilities
                        ['createOffer', 'createAnswer', 'setLocalDescription'].forEach(function (func) {
                            var original = peerConnection[func];
                            peerConnection[func] = function () {
                                var args = arguments;
                                return capabilityGatherer.gather('video').then(function () {
                                    return original.apply(original, args);
                                });
                            };
                        });
                        // now shim setRemoteDescription to disable video m-line if it does not contain any supported codecs
                        var originalSetRemoteDescription = peerConnection.setRemoteDescription;
                        peerConnection.setRemoteDescription = function (description) {
                            return capabilityGatherer.gather('video').then(function (capabilities) {
                                var codecs = capabilities.codecs;
                                var model = sdpTransform.parse(description.sdp);
                                model.media.forEach(function (media) {
                                    if ('video' === media.type) {
                                        var hasSupported = media.rtp.some(function (rtpParams) {
                                            return codecs.some(function (codec) {
                                                return rtpParams.codec.toLowerCase() === codec.mimeType;
                                            });
                                        });
                                        if (!hasSupported) {
                                            media.port = 0;
                                        }
                                        else {
                                            suppressH264FormatParameters(media);
                                        }
                                    }
                                    // Chrome requires disabled m-lines to have SDES-SRTP crypto attributes - https://bugs.chromium.org/p/webrtc/issues/detail?id=3541
                                    // use bundled media crypto attributes for disabled m-lines. If bundling is disabled use crypto attributes of the first enabled m-line.
                                    // we use the same workaround for making sure bundled media SDES-SRTP crypto attributes are identical, since Chrome rejects
                                    // subsequent attempts to alter local description if crypto attributes don't match.
                                    if (!hasDtls(media)) {
                                        var bundle = sessionDescriptorUtils_1["default"].getBundle(model);
                                        if (bundle) {
                                            media.crypto = bundle.crypto;
                                        }
                                        else if (!media.port) {
                                            model.media.some(function (m) {
                                                if (m.port) {
                                                    media.crypto = m.crypto;
                                                    return true;
                                                }
                                                return false;
                                            });
                                        }
                                    }
                                });
                                description.sdp = sdpTransform.write(model);
                                return originalSetRemoteDescription(description);
                            });
                        };
                    }
                    // work-around for handling asymmetric payload types when creating a re-invite answer - https://bugs.chromium.org/p/chromium/issues/detail?id=625293
                    function shimCreateAnswer() {
                        var originalCreateAnswer = peerConnection.createAnswer;
                        peerConnection.createAnswer = function () {
                            var args = arguments;
                            return originalCreateAnswer.apply(peerConnection, args).then(function (answer) {
                                // patch the answer only if we already have local description set
                                if (!peerConnection.localDescription || !peerConnection.localDescription.sdp) {
                                    return answer;
                                }
                                var localDescriptionModel = sdpTransform.parse(peerConnection.localDescription.sdp);
                                var asymmetricCodecs = [];
                                localDescriptionModel.media.forEach(function (media) {
                                    ASYMMETRIC_CODEC_SPECS.forEach(function (asymmetricCodec) {
                                        sessionDescriptorUtils_1["default"].forCodec(media, asymmetricCodec, function (codec) {
                                            asymmetricCodecs.push(codec);
                                        });
                                    });
                                });
                                if (asymmetricCodecs.length) {
                                    var answerModel = sdpTransform.parse(answer.sdp);
                                    var changed = false;
                                    answerModel.media.forEach(function (media) {
                                        asymmetricCodecs.forEach(function (asymmetricCodec) {
                                            sessionDescriptorUtils_1["default"].forCodec(media, { name: asymmetricCodec.rtp.codec, rate: asymmetricCodec.rtp.rate }, function (codec) {
                                                if (codec.rtp.payload !== asymmetricCodec.rtp.payload) {
                                                    codec.rtp.payload = asymmetricCodec.rtp.payload;
                                                    changed = true;
                                                }
                                            });
                                        });
                                    });
                                    if (changed) {
                                        answer = new RTCSessionDescription({ type: answer.type, sdp: sdpTransform.write(answerModel) });
                                    }
                                }
                                return answer;
                            });
                        };
                    }
                    function suppressH264FormatParameters(media) {
                        // Chrome will restart send stream even if unsupported format type parameters change - https://bugs.chromium.org/p/webrtc/issues/detail?id=6160
                        sessionDescriptorUtils_1["default"].forCodec(media, { name: 'h264', rate: 90000 }, function (codec) {
                            if (codec.fmtp) {
                                var fmtp = formatParameters_1["default"].build(), originalFmtp = formatParameters_1["default"].build(codec.fmtp.config);
                                // only preserve the following static parameters
                                ['level-asymmetry-allowed', 'packetization-mode', 'profile-level-id'].forEach(function (name) {
                                    if (originalFmtp.contains(name)) {
                                        fmtp.setIfMissing(name, originalFmtp.get(name));
                                    }
                                });
                                codec.fmtp.config = fmtp.toString();
                            }
                        });
                    }
                    function hasDtls(media) {
                        return 'RTP/SAVPF' !== media.protocol;
                    }
                    return peerConnection;
                }
                exports.__esModule = true;
                exports["default"] = {
                    build: function (capabilityGatherer) {
                        return PeerConnection.bind(null, capabilityGatherer);
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/webrtc/adapter/webkitCapabilityGatherer', ["require", "exports", 'microsoft-sdp-transform', '../../common/userAgentAdapter'], factory);
                }
            })(function (require, exports) {
                var sdpTransform = require('microsoft-sdp-transform');
                var userAgentAdapter_1 = require('../../common/userAgentAdapter');
                function CapabilityGatherer(context) {
                    var self = this, RTCPeerConnection = userAgentAdapter_1["default"].window.webkitRTCPeerConnection, selfGlobal;
                    this.gather = function (kind) {
                        if ('video' !== kind && 'audio' !== kind) {
                            return Promise.reject(new Error('capabilities for ' + kind + ' are not supported'));
                        }
                        if (!selfGlobal.gatherTask) {
                            selfGlobal.gatherTask = new Promise(function (resolve, reject) {
                                var pc = new RTCPeerConnection(null);
                                pc.createOffer(function (description) {
                                    var codecs = {}, model = sdpTransform.parse(description.sdp);
                                    model.media.forEach(function (media) {
                                        codecs[media.type] = media.rtp.map(function (rtpParams) {
                                            return {
                                                mimeType: rtpParams.codec.toLowerCase()
                                            };
                                        });
                                    });
                                    pc.close();
                                    return resolve(codecs);
                                }, function (error) {
                                    selfGlobal.gatherTask = null;
                                    pc.close();
                                    reject(error);
                                }, { offerToReceiveVideo: 1, offerToReceiveAudio: 1 });
                            });
                        }
                        return selfGlobal.gatherTask.then(function (codecs) {
                            return { codecs: codecs[kind] };
                        });
                    };
                    (function () {
                        selfGlobal = context.global.webkitCapabilityGatherer = context.global.webkitCapabilityGatherer || {};
                        self.gather('video');
                    })();
                }
                exports.__esModule = true;
                exports["default"] = {
                    build: function (context) {
                        return new CapabilityGatherer(context);
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/webrtc/transform/webkitSdpTransform', ["require", "exports", '../sessionDescriptorUtils', '../../constants', '../../common/utils'], factory);
                }
            })(function (require, exports) {
                var sessionDescriptorUtils_1 = require('../sessionDescriptorUtils');
                var constants_1 = require('../../constants');
                var utils_1 = require('../../common/utils');
                /**
                SDP transform class
                */
                function WebkitSdpTransform() {
                    function removeG722Codec(media) {
                        sessionDescriptorUtils_1["default"].removeCodec(media, {
                            codec: 'g722',
                            rate: 8000,
                            encoding: 2
                        });
                    }
                    function getBundle(model) {
                        if (!model.groups) {
                            return null;
                        }
                        return utils_1["default"].find(model.groups, function (group) {
                            return group.type === 'BUNDLE';
                        });
                    }
                    function disabledMedia(mtype, label, protocol) {
                        return {
                            type: mtype,
                            port: 0,
                            label: label,
                            payloads: 36,
                            protocol: protocol
                        };
                    }
                    /*
                    Native -> Ms
                    */
                    function splitMedia(mediaEntity, media, mediaTracks, direction) {
                        var mid = mediaEntity.getMid();
                        var modality = mediaEntity.getModality();
                        var newMedia = utils_1["default"].deepClone(media);
                        newMedia.label = sessionDescriptorUtils_1["default"].getLabelForModality(modality);
                        newMedia.direction = direction;
                        newMedia.mid = mid;
                        newMedia.ssrcs = [];
                        newMedia.ssrcGroups = [];
                        if (direction === constants_1["default"].MEDIA_STATE.send || direction === constants_1["default"].MEDIA_STATE.sendReceive) {
                            var track = utils_1["default"].find(mediaTracks, function (track) {
                                return track.modality === modality;
                            });
                            var ssrcs = [], ssrcGroups = [];
                            if (track) {
                                var ssrcIds = media.ssrcs.filter(function (ssrc) {
                                    return ssrc.attribute === 'msid' && (track.track === getTrackId(ssrc.value));
                                }).map(function (ssrc) {
                                    return ssrc.id;
                                });
                                if (media.ssrcs) {
                                    ssrcs = media.ssrcs.filter(function (ssrc) {
                                        return ssrcIds.indexOf(ssrc.id) > -1;
                                    });
                                }
                                if (media.ssrcGroups) {
                                    ssrcGroups = media.ssrcGroups.filter(function (ssrcGroup) {
                                        var ssrcs = ssrcGroup.ssrcs.split(" ");
                                        return utils_1["default"].find(ssrcs, function (ssrc) {
                                            return ssrcIds.indexOf(+ssrc) > -1;
                                        });
                                    });
                                }
                            }
                            else if (direction === constants_1["default"].MEDIA_STATE.send || direction === constants_1["default"].MEDIA_STATE.send) {
                                //exceptional case! no track => disable m line
                                return disabledMedia(media.type, sessionDescriptorUtils_1["default"].getLabelForModality(modality), media.protocol);
                            }
                            newMedia.ssrcs = ssrcs;
                            newMedia.ssrcGroups = ssrcGroups;
                        }
                        return newMedia;
                    }
                    function fromNative(sdpModel, mediaManager, modalities, isOffer) {
                        var resModel = utils_1["default"].deepClone(sdpModel);
                        //get audio & video mods from chrome
                        var audioMedia = utils_1["default"].find(resModel.media, function (media) {
                            return media.type === constants_1["default"].MEDIA_TYPE.audio;
                        });
                        var videoMedia = utils_1["default"].find(resModel.media, function (media) {
                            return media.type === constants_1["default"].MEDIA_TYPE.video;
                        });
                        var nativeMedias = {};
                        nativeMedias[constants_1["default"].MODALITY.audio] = audioMedia;
                        nativeMedias[constants_1["default"].MODALITY.video] = videoMedia;
                        nativeMedias[constants_1["default"].MODALITY.screensharing] = videoMedia;
                        var firstMediaEntities = {};
                        firstMediaEntities[constants_1["default"].MODALITY.audio] = mediaManager.getMediaEntitiesByModality(constants_1["default"].MODALITY.audio)[0];
                        firstMediaEntities[constants_1["default"].MODALITY.video] = mediaManager.getMediaEntitiesByModality(constants_1["default"].MODALITY.video)[0];
                        firstMediaEntities[constants_1["default"].MODALITY.screensharing] = mediaManager.getMediaEntitiesByModality(constants_1["default"].MODALITY.screensharing)[0];
                        //create sdp using model
                        resModel.media = [];
                        mediaManager.getMediaEntities().forEach(function (mEntity) {
                            var newMedia;
                            var direction = modalities[mEntity.getModality()];
                            if (mEntity.isEnabled() && nativeMedias[mEntity.getModality()].port !== 0 && (mEntity === firstMediaEntities[mEntity.getModality()] || direction !== constants_1["default"].MEDIA_STATE.send)) {
                                if (mEntity !== firstMediaEntities[mEntity.getModality()]) {
                                    direction = constants_1["default"].MEDIA_STATE.receive;
                                }
                                newMedia = splitMedia(mEntity, nativeMedias[mEntity.getModality()], mediaManager.getMediaTracks(), direction);
                                if (mEntity !== firstMediaEntities[mEntity.getModality()]) {
                                    newMedia.candidates = [];
                                }
                            }
                            else {
                                newMedia = disabledMedia(mEntity.getType(), sessionDescriptorUtils_1["default"].getLabelForModality(mEntity.getModality()), nativeMedias[mEntity.getModality()].protocol);
                            }
                            //if media is disabled -> set mEntity port to 0
                            if (newMedia.port === 0) {
                                mEntity.disable();
                            }
                            resModel.media.push(newMedia);
                        });
                        //bundling fixed
                        var bundle = getBundle(resModel);
                        if (bundle) {
                            bundle.mids = resModel.media.map(function (m) {
                                return m.mid;
                            }).filter(function (mid) {
                                return mid;
                            }).join(' ');
                        }
                        return resModel;
                    }
                    function getTrackId(msid) {
                        return msid.split(' ')[1];
                    }
                    this.toOffer = function (sdpModel, mediaManager, modalities) {
                        return fromNative(sdpModel, mediaManager, modalities, true);
                    };
                    this.toAnswer = function (sdpModel, mediaManager, modalities) {
                        return fromNative(sdpModel, mediaManager, modalities, false);
                    };
                    /*
                    Ms -> Native
                    */
                    function mergeDirections(a, b) {
                        if (a === constants_1["default"].MEDIA_STATE.sendReceive || b === constants_1["default"].MEDIA_STATE.sendReceive) {
                            return constants_1["default"].MEDIA_STATE.sendReceive;
                        }
                        if (a === b) {
                            return a;
                        }
                        if (a && b && a !== b) {
                            return constants_1["default"].MEDIA_STATE.sendReceive;
                        }
                        return a || b;
                    }
                    this.toRemote = function (sdpModel, mediaManager, modalities) {
                        var resModel = utils_1["default"].deepClone(sdpModel), audioMedia = null, videoMedia = null, bundle = getBundle(resModel);
                        // disable media lines
                        // ideally this needs to be done outside of this component
                        resModel.media.forEach(function (media, idx) {
                            var mediaEntity = mediaManager.getMediaEntity(idx);
                            if (mediaEntity.isDisabled()) {
                                media.port = 0;
                            }
                        });
                        //without bundling we can only keep 1 audio and 1 video
                        if (!bundle) {
                            var existingTypes = {};
                            //suppress lines
                            resModel.media.forEach(function (media, idx) {
                                var mediaEntity = mediaManager.getMediaEntity(idx);
                                if (mediaEntity.getType() in existingTypes) {
                                    mediaEntity.disable();
                                    media.port = 0;
                                }
                                else {
                                    existingTypes[mediaEntity.getType()] = true;
                                }
                            });
                        }
                        //fixup dirs
                        resModel.media.forEach(function (media) {
                            var modality = sessionDescriptorUtils_1["default"].getModality(media);
                            if (modalities[modality] === constants_1["default"].MEDIA_STATE.send) {
                                //default direction is sendrecv if missing nb we are not looking into session level as that can contain direction too, on that case we will insert direction under media directly
                                if (!media.direction || media.direction.toLowerCase() !== constants_1["default"].MEDIA_STATE.receive) {
                                    media.direction = constants_1["default"].MEDIA_STATE.receive;
                                }
                            }
                        });
                        //audio
                        var media = utils_1["default"].find(resModel.media, function (m) {
                            return m.type === constants_1["default"].MEDIA_TYPE.audio;
                        });
                        if (media) {
                            if (media.port !== 0) {
                                audioMedia = utils_1["default"].deepClone(media);
                                audioMedia.mid = 'audio';
                                delete audioMedia.label;
                                removeG722Codec(audioMedia);
                            }
                            else {
                                audioMedia = disabledMedia(constants_1["default"].MEDIA_TYPE.audio, undefined, media.protocol);
                            }
                        }
                        //get video mEntitys
                        var videoMedias = resModel.media.filter(function (m) {
                            return m.type === constants_1["default"].MEDIA_TYPE.video;
                        });
                        if (videoMedias.length > 0) {
                            var enabledVideoMedias = videoMedias.filter(function (m) {
                                return m.port !== 0;
                            });
                            if (enabledVideoMedias.length > 0) {
                                videoMedia = utils_1["default"].deepClone(enabledVideoMedias[0]);
                                videoMedia.mid = 'video';
                                videoMedia.direction = null;
                                delete videoMedia.label;
                                videoMedia.ssrcs = [];
                                videoMedia.ssrcGroups = [];
                                enabledVideoMedias.forEach(function (media) {
                                    if (media.ssrcs) {
                                        videoMedia.ssrcs = videoMedia.ssrcs.concat(media.ssrcs);
                                    }
                                    if (media.ssrcGroups) {
                                        videoMedia.ssrcGroups = videoMedia.ssrcGroups.concat(media.ssrcGroups);
                                    }
                                    videoMedia.direction = mergeDirections(videoMedia.direction, media.direction || constants_1["default"].MEDIA_STATE.sendReceive);
                                });
                            }
                            else {
                                videoMedia = disabledMedia(constants_1["default"].MEDIA_TYPE.video, undefined, videoMedias[0].protocol);
                            }
                        }
                        //preserve order
                        resModel.media = [audioMedia, videoMedia].filter(function (media) {
                            return media;
                        });
                        if (mediaManager.getMediaEntities()[0].getModality() !== constants_1["default"].MODALITY.audio) {
                            resModel.media.reverse();
                        }
                        //bundling
                        if (bundle) {
                            bundle.mids = resModel.media.map(function (m) {
                                return m.mid;
                            }).filter(function (mid) {
                                return mid;
                            }).join(' ');
                        }
                        return resModel;
                    };
                }
                exports.__esModule = true;
                exports["default"] = {
                    build: function () {
                        return WebkitSdpTransform;
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/webrtc/adapter/webkitAdapter', ["require", "exports", './webkitPeerConnection', './webkitSessionDescription', './webkitCapabilityGatherer', '../transform/webkitSdpTransform'], factory);
                }
            })(function (require, exports) {
                var webkitPeerConnection_1 = require('./webkitPeerConnection');
                var webkitSessionDescription_1 = require('./webkitSessionDescription');
                var webkitCapabilityGatherer_1 = require('./webkitCapabilityGatherer');
                var webkitSdpTransform_1 = require('../transform/webkitSdpTransform');
                function WebkitAdapter(context) {
                    var capabilityGatherer = webkitCapabilityGatherer_1["default"].build(context);
                    this.SdpTransform = webkitSdpTransform_1["default"].build();
                    this.RTCPeerConnection = webkitPeerConnection_1["default"].build(capabilityGatherer);
                    this.RTCRtpReceiver = {
                        // output of capability gatherer is already W3C compliant, no need to preprocess
                        getCapabilities: capabilityGatherer.gather
                    };
                    this.RTCSessionDescription = webkitSessionDescription_1["default"].build();
                }
                exports.__esModule = true;
                exports["default"] = {
                    build: function (context) {
                        return new WebkitAdapter(context);
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/webrtc/adapter/webrtcAdapter', ["require", "exports", './webkitAdapter', '../../common/userAgentAdapter'], factory);
                }
            })(function (require, exports) {
                var webkitAdapter_1 = require('./webkitAdapter');
                var userAgentAdapter_1 = require('../../common/userAgentAdapter');
                function UnsupportedAdapter() {
                    function throwUnsupported() {
                        throw new Error('unsupported platform');
                    }
                    this.SdpTransform = throwUnsupported;
                    this.RTCPeerConnection = throwUnsupported;
                    this.RTCSessionDescription = throwUnsupported;
                    this.RTCRtpReceiver = throwUnsupported;
                }
                function GenericAdapter(nativeRTCPeerConnection, nativeRTCSessionDescription, nativeRTCRtpReceiver) {
                    this.SdpTransform = DummySdpTransform;
                    this.RTCPeerConnection = nativeRTCPeerConnection;
                    this.RTCSessionDescription = nativeRTCSessionDescription;
                    this.RTCRtpReceiver = nativeRTCRtpReceiver;
                }
                function DummySdpTransform() {
                    function reflective(model) {
                        return model;
                    }
                    this.toOffer = reflective;
                    this.toAnswer = reflective;
                    this.toRemote = reflective;
                }
                function isWebkitRtc() {
                    return typeof userAgentAdapter_1["default"].window.webkitRTCPeerConnection !== 'undefined';
                }
                function isMozillaRtc() {
                    return typeof userAgentAdapter_1["default"].window.mozRTCPeerConnection !== 'undefined';
                }
                exports.__esModule = true;
                exports["default"] = {
                    build: function (context) {
                        if (isWebkitRtc()) {
                            return webkitAdapter_1["default"].build(context);
                        }
                        if (isMozillaRtc()) {
                            // for now return noop adapter for Mozilla
                            return new GenericAdapter(userAgentAdapter_1["default"].window.mozRTCPeerConnection, userAgentAdapter_1["default"].window.RTCSessionDescription, userAgentAdapter_1["default"].window.RTCRtpReceiver);
                        }
                        return new UnsupportedAdapter();
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/webrtc/videoCapabilities', ["require", "exports"], factory);
                }
            })(function (require, exports) {
                var VideoCapabilities = (function () {
                    function VideoCapabilities(maxFS, maxFPS) {
                        this.maxFS = maxFS;
                        this.maxFPS = maxFPS;
                    }
                    VideoCapabilities.prototype.setMaxFS = function (maxFS, onChange) {
                        if (this.maxFS !== maxFS) {
                            this.maxFS = maxFS;
                            if (onChange) {
                                onChange(this);
                                return true;
                            }
                        }
                        return false;
                    };
                    ;
                    VideoCapabilities.prototype.getMaxFS = function () {
                        return this.maxFS;
                    };
                    VideoCapabilities.prototype.getMaxFPS = function () {
                        return this.maxFPS;
                    };
                    return VideoCapabilities;
                }());
                exports.VideoCapabilities = VideoCapabilities;
                exports.__esModule = true;
                exports["default"] = {
                    build: function (maxFS, maxFPS) {
                        return new VideoCapabilities(maxFS, maxFPS);
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/webrtc/mediaManager', ["require", "exports", './sessionDescriptorUtils', '../constants', '../common/utils', './videoCapabilities'], factory);
                }
            })(function (require, exports) {
                var sessionDescriptorUtils_1 = require('./sessionDescriptorUtils');
                var constants_1 = require('../constants');
                var utils_1 = require('../common/utils');
                var videoCapabilities_1 = require('./videoCapabilities');
                var MediaEntity = (function () {
                    function MediaEntity(modality, mid, mtype, streamId, xSourceStreamId, renderer, videoCapabilities) {
                        this.modality = modality;
                        this.mid = mid;
                        this.mtype = mtype;
                        this.streamId = streamId;
                        this.xSourceStreamId = xSourceStreamId;
                        this.renderer = renderer;
                        this.videoCapabilities = videoCapabilities;
                    }
                    MediaEntity.create = function (settings, listener, modality, mid) {
                        var mtype = sessionDescriptorUtils_1["default"].getTypeFromModality(modality);
                        var videoCapabilities = null;
                        if (mtype === constants_1["default"].MEDIA_TYPE.video) {
                            videoCapabilities = videoCapabilities_1["default"].build(settings.webrtcVideoCapabilityMaxFS || 1200, settings.webrtcVideoCapabilityMaxFPS || 3000);
                        }
                        var me = new MediaEntity(modality, mid, mtype, null, null, null, videoCapabilities);
                        listener.mediaEntityCreated(me);
                        return me;
                    };
                    MediaEntity.prototype.clone = function () {
                        return new MediaEntity(this.modality, this.mid, this.mtype, this.streamId, this.xSourceStreamId, this.renderer, this.videoCapabilities);
                    };
                    /*
                    Basic properties
                    */
                    MediaEntity.prototype.getModality = function () {
                        return this.modality;
                    };
                    MediaEntity.prototype.getType = function () {
                        return this.mtype;
                    };
                    MediaEntity.prototype.getMid = function () {
                        return this.mid;
                    };
                    /*
                    Enable/disable
                    */
                    MediaEntity.prototype.disable = function () {
                        this.mid = null;
                    };
                    MediaEntity.prototype.enable = function (modality, mid) {
                        this.modality = modality;
                        this.mid = mid;
                    };
                    MediaEntity.prototype.isDisabled = function () {
                        return !this.mid;
                    };
                    MediaEntity.prototype.isEnabled = function () {
                        return !!this.mid;
                    };
                    /*
                    Caps
                    */
                    MediaEntity.prototype.getVideoCapabilities = function () {
                        return this.videoCapabilities;
                    };
                    /*
                    Renderer
                    */
                    MediaEntity.prototype.getRenderer = function () {
                        return this.renderer;
                    };
                    MediaEntity.prototype.setRenderer = function (renderer) {
                        this.renderer = renderer;
                    };
                    /*
                    Stream Id
                    */
                    MediaEntity.prototype.getStreamId = function () {
                        return this.streamId;
                    };
                    MediaEntity.prototype.setStreamId = function (streamId) {
                        this.streamId = streamId;
                    };
                    /*
                    X Source Stream Id
                    */
                    MediaEntity.prototype.getXSourceStreamId = function () {
                        return this.xSourceStreamId;
                    };
                    MediaEntity.prototype.setXSourceStreamId = function (xSourceStreamId) {
                        this.xSourceStreamId = xSourceStreamId;
                    };
                    return MediaEntity;
                }());
                exports.MediaEntity = MediaEntity;
                ;
                /*
                */
                var MediaManager = (function () {
                    function MediaManager(context, listener) {
                        this.mediaEntities = [];
                        this.mediaEntitiesBackup = [];
                        this.midId = 0;
                        this.mediaTracks = [];
                        this.logger = context.logger;
                        this.settings = context.settings;
                        this.numVideoChannels = context.numVideoChannels;
                        this.listener = listener;
                    }
                    MediaManager.prototype.generateMid = function (idx) {
                        return 'media_' + idx;
                    };
                    //we call this only once!
                    MediaManager.prototype.fromOffer = function (sdpModel, modalities) {
                        var _this = this;
                        sdpModel.media.forEach(function (media) {
                            if (media.type === constants_1["default"].MEDIA_TYPE.audio) {
                                if (constants_1["default"].MODALITY.audio in modalities) {
                                    _this.addMediaEntity(constants_1["default"].MODALITY.audio);
                                }
                            }
                            else if (media.type === constants_1["default"].MEDIA_TYPE.video) {
                                if (constants_1["default"].MODALITY.video in modalities) {
                                    //add additional video mlines for multiview scenario
                                    for (var i = 0; i < _this.numVideoChannels; i++) {
                                        _this.addMediaEntity(constants_1["default"].MODALITY.video);
                                    }
                                }
                                if (constants_1["default"].MODALITY.screensharing in modalities) {
                                    _this.addMediaEntity(constants_1["default"].MODALITY.screensharing);
                                }
                            }
                        });
                    };
                    ;
                    MediaManager.prototype.fromRemote = function (sdpModel, modalities) {
                        var _this = this;
                        sdpModel.media.forEach(function (media, idx) {
                            var modality = sessionDescriptorUtils_1["default"].getModality(media);
                            if (media.port === 0 || !(modality in modalities)) {
                                if (_this.mediaEntities[idx]) {
                                    _this.mediaEntities[idx].disable();
                                }
                                else {
                                    _this.addDisabledMediaEntity(modality);
                                }
                                _this.mediaEntities[idx].setStreamId(null);
                            }
                            else {
                                if (_this.mediaEntities[idx]) {
                                    _this.mediaEntities[idx].enable(modality, media.mid || _this.generateMid(idx));
                                }
                                else {
                                    _this.addMediaEntity(modality, media.mid || _this.generateMid(idx));
                                }
                                //save msid
                                if (media.ssrcs) {
                                    var ssrc = utils_1["default"].find(media.ssrcs, function (ssrc) {
                                        return ssrc.attribute === 'msid';
                                    });
                                    if (!ssrc) {
                                        _this.logger.warn('No ssrc msid for media of type ' + media.type + ' with mid ' + media.mid);
                                    }
                                    else {
                                        _this.mediaEntities[idx].setStreamId(ssrc.value.split(' ')[0]);
                                    }
                                }
                                //xSourceStreamId
                                _this.mediaEntities[idx].setXSourceStreamId(media.xSourceStreamId);
                            }
                        });
                    };
                    ;
                    MediaManager.prototype.isEmpty = function () {
                        return this.mediaEntities.length === 0;
                    };
                    ;
                    MediaManager.prototype.addMediaEntity = function (modality, mid) {
                        this.mediaEntities.push(MediaEntity.create(this.settings, this.listener, modality, mid || this.generateMid(this.mediaEntities.length)));
                    };
                    ;
                    MediaManager.prototype.addDisabledMediaEntity = function (modality) {
                        this.mediaEntities.push(MediaEntity.create(this.settings, this.listener, modality, null));
                    };
                    ;
                    MediaManager.prototype.getMediaEntities = function () {
                        return this.mediaEntities;
                    };
                    ;
                    MediaManager.prototype.getMediaEntity = function (idx) {
                        return this.mediaEntities[idx];
                    };
                    ;
                    MediaManager.prototype.getMediaEntityByMid = function (mid) {
                        return utils_1["default"].find(this.mediaEntities, function (entity) {
                            return entity.getMid() === mid;
                        });
                    };
                    ;
                    MediaManager.prototype.getMediaEntitiesByModality = function (modality) {
                        return this.mediaEntities.filter(function (entity) {
                            return entity.getModality() === modality;
                        });
                    };
                    ;
                    MediaManager.prototype.getMediaEntitiesByRenderer = function (renderer) {
                        return this.mediaEntities.filter(function (entity) {
                            return entity.getRenderer() === renderer;
                        });
                    };
                    ;
                    MediaManager.prototype.getMediaEntityByStreamId = function (streamId) {
                        return utils_1["default"].find(this.mediaEntities, function (entity) {
                            return entity.getStreamId() === streamId;
                        });
                    };
                    ;
                    MediaManager.prototype.reset = function () {
                        this.mediaEntities = [];
                    };
                    ;
                    MediaManager.prototype.syncModalities = function (modalities, disableOnly) {
                        this.disableModalities(modalities);
                        if (!disableOnly) {
                            this.enableModalities(modalities);
                            this.addModalities(modalities);
                        }
                    };
                    //
                    MediaManager.prototype.enableModalities = function (modalities) {
                        var _this = this;
                        this.mediaEntities.forEach(function (mEntity, idx) {
                            if ((mEntity.getModality() in modalities) && mEntity.isDisabled()) {
                                mEntity.enable(mEntity.getModality(), _this.generateMid(idx));
                            }
                        });
                    };
                    MediaManager.prototype.disableModalities = function (modalities) {
                        this.mediaEntities.forEach(function (mEntity) {
                            if (!(mEntity.getModality() in modalities)) {
                                mEntity.disable();
                            }
                        });
                    };
                    MediaManager.prototype.addModalities = function (modalities) {
                        //add new modalities
                        var currModalities = {};
                        this.mediaEntities.map(function (mEntity) {
                            return mEntity.getModality();
                        }).forEach(function (modality) {
                            currModalities[modality] = true;
                        });
                        for (var modality in modalities) {
                            if (!(modality in currModalities)) {
                                this.addMediaEntity(modality);
                            }
                        }
                    };
                    //
                    MediaManager.prototype.setMediaTracks = function (mediaTracks) {
                        this.mediaTracks = mediaTracks;
                    };
                    MediaManager.prototype.getMediaTracks = function () {
                        return this.mediaTracks;
                    };
                    //
                    MediaManager.prototype.backup = function () {
                        var _this = this;
                        this.mediaEntitiesBackup = [];
                        this.mediaEntities.forEach(function (m) {
                            _this.mediaEntitiesBackup.push(m.clone());
                        });
                    };
                    MediaManager.prototype.commit = function () {
                        this.mediaEntitiesBackup = [];
                    };
                    MediaManager.prototype.rollback = function () {
                        this.mediaEntities = this.mediaEntitiesBackup;
                    };
                    return MediaManager;
                }());
                exports.__esModule = true;
                exports["default"] = {
                    build: function (context, listener) {
                        return new MediaManager(context, listener);
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/webrtc/statistics/webrtcStatistics', ["require", "exports", '../../helper'], factory);
                }
            })(function (require, exports) {
                var helper_1 = require('../../helper');
                function WebrtcStatistics(sessionId, context) {
                    var peerConnection, negotiatedModalities, streamStartDetection, terminated = false, logger = context.logger.createChild('WebrtcStatistics'), report = {
                        localStreams: [],
                        remoteStreams: [],
                        webrtc: {
                            CorrelationId: sessionId,
                            Extensions: {
                                WebRTCStats: {},
                                OfferedSrtp: 'none',
                                NegotiatedSrtp: 'none',
                                IceConnectionState: 'none',
                                SignalingState: 'none',
                                AudioTransportRecvBitrate: 0,
                                AudioTransportSendBitrate: 0,
                                AudioPayloadSendBitrate: 0,
                                AudioPayloadRecvBitrate: 0,
                                VideoPayloadSendBitrate: 0,
                                VideoPayloadRecvBitrate: 0,
                                TimerAudioTransportRecvBitrate: 0,
                                TimerAudioTransportSendBitrate: 0,
                                TimerAudioPayloadRecvBitrate: 0,
                                TimerAudioPayloadSendBitrate: 0,
                                TimerVideoPayloadRecvBitrate: 0,
                                TimerVideoPayloadSendBitrate: 0,
                                StartTime: new Date().getTime(),
                                EndTime: new Date().getTime()
                            }
                        }
                    }, self = this;
                    this.setIceConnectionState = function (state) {
                        report.webrtc.Extensions.IceConnectionStatePrevious = report.webrtc.Extensions.IceConnectionState;
                        report.webrtc.Extensions.IceConnectionState = state;
                    };
                    this.setSignalingConnectionState = function (state) {
                        report.webrtc.Extensions.SignalingStatePrevious = report.webrtc.Extensions.SignalingState;
                        report.webrtc.Extensions.SignalingState = state;
                    };
                    function setStartTime(modalities) {
                        if (!report.webrtc.Extensions.WebRTCStats.ssrc_audio_send || !report.webrtc.Extensions.WebRTCStats.ssrc_audio_recv ||
                            !report.webrtc.Extensions.WebRTCStats.ssrc_video_send || !report.webrtc.Extensions.WebRTCStats.ssrc_video_recv) {
                            return false;
                        }
                        function ifExistsAndZeroSetNow(counter, timer) {
                            if (counter && (!timer || (timer !== -1))) {
                                return new Date().getTime();
                            }
                            return 0;
                        }
                        report.webrtc.Extensions.TimerAudioPayloadRecvBitrate = helper_1["default"].hasReceiveDirectionality(modalities.audio) ?
                            ifExistsAndZeroSetNow(report.webrtc.Extensions.WebRTCStats.ssrc_audio_recv.bytesReceived, report.webrtc.Extensions.TimerAudioPayloadRecvBitrate) : -1;
                        report.webrtc.Extensions.TimerAudioPayloadSendBitrate = helper_1["default"].hasSendDirectionality(modalities.audio) ?
                            ifExistsAndZeroSetNow(report.webrtc.Extensions.WebRTCStats.ssrc_audio_send.bytesSent, report.webrtc.Extensions.TimerAudioPayloadSendBitrate) : -1;
                        report.webrtc.Extensions.TimerVideoPayloadRecvBitrate = helper_1["default"].hasReceiveDirectionality(modalities.video) ?
                            ifExistsAndZeroSetNow(report.webrtc.Extensions.WebRTCStats.ssrc_video_recv.bytesReceived, report.webrtc.Extensions.TimerVideoPayloadRecvBitrate) : -1;
                        report.webrtc.Extensions.TimerVideoPayloadSendBitrate = helper_1["default"].hasSendDirectionality(modalities.video) ?
                            ifExistsAndZeroSetNow(report.webrtc.Extensions.WebRTCStats.ssrc_video_send.bytesSent, report.webrtc.Extensions.TimerVideoSendBitrate) : -1;
                        // may be i need to get rid of the seaparate timers for transport
                        report.webrtc.Extensions.TimerAudioTransportRecvBitrate = helper_1["default"].hasReceiveDirectionality(modalities.audio) ?
                            ifExistsAndZeroSetNow(report.webrtc.Extensions.WebRTCStats.ssrc_audio_recv.bytesReceived, report.webrtc.Extensions.TimerAudioTransportRecvBitrate) : -1;
                        report.webrtc.Extensions.TimerAudioTransportSendBitrate = helper_1["default"].hasSendDirectionality(modalities.audio) ?
                            ifExistsAndZeroSetNow(report.webrtc.Extensions.WebRTCStats.ssrc_audio_send.bytesSent, report.webrtc.Extensions.TimerAudioTransportSendBitrate) : -1;
                        // if all timers are set - we can stop, however i need to check which modalities are configured.
                        if (report.webrtc.Extensions.TimerVideoPayloadRecvBitrate &&
                            report.webrtc.Extensions.TimerVideoPayloadSendBitrate &&
                            report.webrtc.Extensions.TimerAudioPayloadRecvBitrate &&
                            report.webrtc.Extensions.TimerAudioPayloadSendBitrate &&
                            report.webrtc.Extensions.TimerAudioTransportRecvBitrate &&
                            report.webrtc.Extensions.TimerAudioTransportSendBitrate) {
                            return true;
                        }
                        return false;
                    }
                    function detectStreamStart() {
                        return new Promise(function (resolve) {
                            if (peerConnection) {
                                peerConnection.getStats(function (results) {
                                    report.webrtc.Extensions.WebRTCStats = getWebrtcReport(results);
                                    resolve();
                                }, function (error) {
                                    logger.error('detectStreamStart getreport getstats failure', error);
                                    resolve();
                                });
                            }
                            else {
                                resolve();
                            }
                        }).catch(function (error) {
                            logger.log('detectCallStart error', error);
                        });
                    }
                    var activeModalities = void 0;
                    this.startWaitingForStreamStart = function (offeredModalities, innerCall) {
                        if (!streamStartDetection && !innerCall) {
                            activeModalities = offeredModalities;
                        }
                        if (streamStartDetection && !innerCall) {
                            return;
                        }
                        streamStartDetection = true;
                        detectStreamStart().then(function () {
                            setTimeout(function () {
                                if (setStartTime(offeredModalities) || terminated) {
                                    streamStartDetection = false;
                                    return;
                                }
                                self.startWaitingForStreamStart(activeModalities, true);
                            }, 1000);
                        }).catch(function (error) {
                            logger.error('startWaitingForStreamStart error', error);
                        });
                    };
                    this.setNegotiatedModalities = function (modalities) {
                        negotiatedModalities = modalities;
                        activeModalities = modalities;
                    };
                    this.setPeerConnection = function (pc) {
                        peerConnection = pc;
                    };
                    this.setReport = function (utReport) {
                        report = utReport;
                    };
                    this.getCachedReport = function () {
                        return report;
                    };
                    this.setTerminated = function () {
                        report.webrtc.Extensions.EndTime = new Date().getTime();
                        terminated = true;
                    };
                    this.calculateAverages = function () {
                        var callEndTime = report.webrtc.Extensions.EndTime;
                        function doTheCalc(counter, timer) {
                            if (counter && (callEndTime - timer) && (timer !== -1)) {
                                return Math.round((counter * 8) / (callEndTime - timer));
                            }
                            return 0;
                        }
                        function getCounter(container, path) {
                            return path.split('.').reduce(function (x, y) {
                                return (typeof x === 'undefined' || x === null) ? x : x[y];
                            }, container);
                        }
                        report.webrtc.Extensions.AudioPayloadRecvBitrate = doTheCalc(getCounter(report.webrtc.Extensions.WebRTCStats, 'ssrc_audio_recv.bytesReceived'), report.webrtc.Extensions.TimerAudioPayloadRecvBitrate);
                        report.webrtc.Extensions.AudioPayloadSendBitrate = doTheCalc(getCounter(report.webrtc.Extensions.WebRTCStats, 'ssrc_audio_send.bytesSent'), report.webrtc.Extensions.TimerAudioPayloadSendBitrate);
                        report.webrtc.Extensions.VideoPayloadRecvBitrate = doTheCalc(getCounter(report.webrtc.Extensions.WebRTCStats, 'ssrc_video_recv.bytesReceived'), report.webrtc.Extensions.TimerVideoPayloadRecvBitrate);
                        report.webrtc.Extensions.VideoPayloadSendBitrate = doTheCalc(getCounter(report.webrtc.Extensions.WebRTCStats, 'ssrc_video_send.bytesSent'), report.webrtc.Extensions.TimerVideoPayloadSendBitrate);
                        report.webrtc.Extensions.AudioTransportRecvBitrate = doTheCalc(getCounter(report.webrtc.Extensions.WebRTCStats, 'ssrc_audio_send.pair.bytesReceived'), report.webrtc.Extensions.TimerAudioTransportRecvBitrate);
                        report.webrtc.Extensions.AudioTransportSendBitrate = doTheCalc(getCounter(report.webrtc.Extensions.WebRTCStats, 'ssrc_audio_send.pair.bytesSent'), report.webrtc.Extensions.TimerAudioTransportSendBitrate);
                    };
                    function getWebrtcReport(results) {
                        var rawDict = {};
                        // this unwraps the objects into a dict
                        function unwrapResults(rawResults) {
                            if (rawResults.result) {
                                rawResults.result().forEach(function (report) {
                                    if (report) {
                                        report.names().forEach(function (name) {
                                            rawDict[report.type] = rawDict[report.type] || {};
                                            rawDict[report.type][report.id] = rawDict[report.type][report.id] || {};
                                            rawDict[report.type][report.id][name] = report.stat(name);
                                        });
                                        rawDict[report.type][report.id].id = report.id;
                                    }
                                });
                            }
                        }
                        // those are names of the non-PI fields we are safe to report to telemetry - separated by the field container
                        var sourceNicelist = ['codecImplementationName', 'googFrameHeightReceived', 'googFrameWidthReceived', 'googNacksSent',
                            'googRenderDelayMs', 'googTargetDelayMs', 'googPlisSent', 'googFrameRateDecoded', 'googFrameRateOutput', 'googMinPlayoutDelayMs',
                            'googMaxDecodeMs', 'googFrameRateReceived', 'googCaptureStartNtpTimeMs', 'googFirsSent', 'googDecodeMs', 'googCodecName',
                            'googCurrentDelayMs', 'audioInputLevel', 'transportId', 'audioOutputLevel', 'id', 'googCodecName', 'googEchoCancellationEchoDelayMedian',
                            'googEchoCancellationEchoDelayStdDev', 'googEchoCancellationQualityMin', 'googEchoCancellationReturnLoss', 'googEchoCancellationReturnLossEnhancement',
                            'googJitterReceived', 'googRtt', 'googTypingNoiseState', 'mediaType', 'packetsLost', 'packetsSent', 'bytesReceived', 'bytesSent', 'googAccelerateRate',
                            'googCaptureStartNtpTimeMs', 'googCurrentDelayMs', 'googDecodingCNG', 'googDecodingCTN', 'googDecodingCTSG', 'googDecodingNormal', 'googDecodingPLC',
                            'googDecodingPLCCNG', 'googExpandRate', 'googJitterBufferMs', 'googPreemptiveExpandRate', 'googPreferredJitterBufferMs',
                            'googSecondaryDecodedRate', 'googSpeechExpandRate', 'packetsReceived'];
                        var transportNicelist = ['dtlsCipher', 'googComponent', 'id', 'srtpCipher', 'selectedCandidatePairId'];
                        var selectedCandidatePairNicelist = ['bytesSent', 'bytesReceived', 'googActiveConnection', 'googChannelId',
                            'googLocalCandidateType', 'googReadable', 'googRemoteCandidateType', 'id', 'googRtt',
                            'googTransportType', 'googWritable', 'packetsDiscardedOnSend', 'packetsSent'];
                        //VideoBwe / bweforvideo
                        var bweNicelist = ['googActualEncBitrate', 'googAvailableReceiveBandwidth', 'googAvailableSendBandwidth', 'googBucketDelay', 'googRetransmitBitrate', 'googTargetEncBitrate', 'googTransmitBitrate'];
                        // PI fields filter
                        function nicification(notNiceDict, niceList) {
                            var niceDict = {};
                            for (var property in notNiceDict) {
                                if (notNiceDict.hasOwnProperty(property)) {
                                    if (niceList.indexOf(property) !== -1) {
                                        niceDict[property] = notNiceDict[property];
                                    }
                                }
                            }
                            return niceDict;
                        }
                        // remove PI from the dict, and combine source, transport, and selected pair together
                        function processSource(source) {
                            var finalSource = {};
                            finalSource = nicification(source, sourceNicelist);
                            if (source.hasOwnProperty('transportId')) {
                                var transport = rawDict['googComponent'][source.transportId];
                                finalSource['transport'] = nicification(transport, transportNicelist);
                                if (transport.hasOwnProperty('selectedCandidatePairId')) {
                                    var selectedCandidatePair = rawDict['googCandidatePair'][transport.selectedCandidatePairId];
                                    finalSource['pair'] = nicification(selectedCandidatePair, selectedCandidatePairNicelist);
                                }
                            }
                            return finalSource;
                        }
                        unwrapResults(results);
                        var finalResult = {};
                        if (!rawDict['ssrc']) {
                            return {};
                        }
                        for (var key in rawDict['ssrc']) {
                            if (rawDict['ssrc'][key].hasOwnProperty('transportId')) {
                                var source = rawDict['ssrc'][key];
                                var fancySourceName = source.id.replace(/[0-9]+/, source.mediaType || 'audio');
                                finalResult[fancySourceName] = processSource(source);
                            }
                        }
                        if (rawDict['VideoBwe'] && rawDict['VideoBwe']['bweforvideo']) {
                            finalResult['bweStat'] = {};
                            var finalBwe = nicification(rawDict['VideoBwe']['bweforvideo'], bweNicelist);
                            for (var bwe in finalBwe) {
                                if (finalBwe.hasOwnProperty(bwe)) {
                                    finalResult['bweStat'][bwe] = finalBwe[bwe];
                                }
                            }
                        }
                        return finalResult;
                    }
                    this.getWebrtcReport = function (results) {
                        return getWebrtcReport(results);
                    };
                    this.setNegotiatedSrtpInfo = function (srtpInfo) {
                        report.webrtc.Extensions.NegotiatedSrtp = getSrtpReport(srtpInfo);
                    };
                    this.setOfferedSrtpInfo = function (srtpInfo) {
                        report.webrtc.Extensions.OfferedSrtp = getSrtpReport(srtpInfo);
                    };
                    this.getReport = function () {
                        return new Promise(function (resolve) {
                            if (peerConnection) {
                                if (negotiatedModalities) {
                                    report.localStreams = getStreamsReport(peerConnection.getLocalStreams(), {
                                        audio: helper_1["default"].hasSendDirectionality(negotiatedModalities.audio),
                                        video: helper_1["default"].hasSendDirectionality(negotiatedModalities.video)
                                    });
                                    report.remoteStreams = getStreamsReport(peerConnection.getRemoteStreams(), {
                                        audio: helper_1["default"].hasReceiveDirectionality(negotiatedModalities.audio),
                                        video: helper_1["default"].hasReceiveDirectionality(negotiatedModalities.video)
                                    });
                                }
                                try {
                                    peerConnection.getStats(function (results) {
                                        report.webrtc.Extensions.WebRTCStats = getWebrtcReport(results);
                                        self.calculateAverages();
                                        resolve(report);
                                    }, function (error) {
                                        report.webrtc.Extensions.WebRTCStats = { getStatsError: error };
                                        logger.error('getreport getstats resolve error', error);
                                        resolve(report);
                                    });
                                }
                                catch (error) {
                                    // If the RTCPeerConnection object's RTCPeerConnection signalingState is closed,
                                    // throw an InvalidStateError exception.
                                    report.webrtc.Extensions.WebRTCStats = { getStatsError: error };
                                    logger.error('getreport getstats catch error', error);
                                    resolve(report);
                                }
                            }
                            else {
                                logger.log('getreport else resolve');
                                resolve(report);
                            }
                        });
                    };
                    function getSrtpReport(srtpInfo) {
                        var report = '';
                        if (srtpInfo.dtls) {
                            report += 'dtls';
                        }
                        if (srtpInfo.sdes) {
                            report += 'sdes';
                        }
                        return report;
                    }
                    function getStreamsReport(streams, types) {
                        var stats = [];
                        streams.forEach(function (stream) {
                            var streamStats = { tracks: [] };
                            stats.push(streamStats);
                            stream.getTracks().forEach(function (track) {
                                if (('audio' === track.kind && types.audio) || ('video' === track.kind && types.video)) {
                                    streamStats.tracks.push({
                                        stream: stream,
                                        track: track
                                    });
                                }
                            });
                        });
                        return stats;
                    }
                }
                exports.__esModule = true;
                exports["default"] = {
                    build: function (sessionId, context) {
                        return new WebrtcStatistics(sessionId, context);
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/common/dtmfUtils', ["require", "exports"], factory);
                }
            })(function (require, exports) {
                exports.defaultSettings = {
                    toneDuration: 200,
                    toneGap: 100
                };
                var DTMFQueue = (function () {
                    function DTMFQueue(logger) {
                        this.queue = [];
                        this.logger = logger;
                    }
                    DTMFQueue.prototype.cleanup = function () {
                        this.queue.forEach(function (e) {
                            e.reject({ notSent: e.tones });
                        });
                        this.queue = [];
                    };
                    DTMFQueue.prototype.waitForNotification = function (tones) {
                        var _this = this;
                        if (!tones) {
                            return Promise.reject(new Error('invalid input'));
                        }
                        this.logger.log('sending dtmf tones: ', tones);
                        return new Promise(function (resolve, reject) {
                            _this.queue.push({
                                tones: tones,
                                resolve: resolve,
                                reject: reject
                            });
                        });
                    };
                    DTMFQueue.prototype.toneSent = function (tone) {
                        if (this.queue[0]) {
                            if (tone === this.queue[0].tones[0]) {
                                this.queue[0].tones = this.queue[0].tones.substr(1);
                                if (this.queue[0].tones === '') {
                                    this.queue[0].resolve();
                                    this.queue.shift();
                                }
                            }
                            else {
                                this.queue[0].reject(new Error('sent tone does not match: expected \'' + this.queue[0].tones[0] + '\' got \'' + tone + '\''));
                                this.queue.shift();
                                this.toneSent(tone);
                            }
                        }
                    };
                    return DTMFQueue;
                }());
                exports.DTMFQueue = DTMFQueue;
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/webrtc/webRtcDtmfSender', ["require", "exports", '../common/dtmfUtils'], factory);
                }
            })(function (require, exports) {
                var DTMFUtils = require('../common/dtmfUtils');
                var WebRtcDTMFSender = (function () {
                    function WebRtcDTMFSender(logger, settings) {
                        this.webRtcSender = null;
                        this.queue = new DTMFUtils.DTMFQueue(logger);
                        this.settings = settings ? settings : DTMFUtils.defaultSettings;
                    }
                    WebRtcDTMFSender.prototype.sendDtmf = function (peerConnection, tones) {
                        if (!peerConnection || !peerConnection.getSenders) {
                            return Promise.reject(new Error('bad peerConnection'));
                        }
                        this.syncSender(peerConnection);
                        if (!this.webRtcSender) {
                            return Promise.reject(new Error('not available'));
                        }
                        this.webRtcSender.ontonechange = this.onToneChange.bind(this);
                        this.webRtcSender.insertDTMF(this.webRtcSender.toneBuffer + tones, this.settings.toneDuration, this.settings.toneGap);
                        return this.queue.waitForNotification(tones);
                    };
                    WebRtcDTMFSender.prototype.canSendDtmf = function (peerConnection) {
                        if (!peerConnection || !peerConnection.getSenders) {
                            return false;
                        }
                        this.syncSender(peerConnection);
                        return this.webRtcSender ? this.webRtcSender.canInsertDTMF : false;
                    };
                    WebRtcDTMFSender.prototype.dispose = function () {
                        this.queue.cleanup();
                    };
                    WebRtcDTMFSender.prototype.syncSender = function (peerConnection) {
                        var sender = peerConnection.getSenders().filter(function (sender) { return sender.dtmf && sender.dtmf.canInsertDTMF; })[0];
                        if (this.webRtcSender && sender && sender.dtmf != this.webRtcSender) {
                            this.webRtcSender.ontonechange = null;
                            this.queue.cleanup();
                        }
                        this.webRtcSender = sender ? sender.dtmf : null;
                    };
                    WebRtcDTMFSender.prototype.onToneChange = function (event) {
                        if (event.tone) {
                            this.queue.toneSent(event.tone);
                        }
                    };
                    return WebRtcDTMFSender;
                }());
                exports.WebRtcDTMFSender = WebRtcDTMFSender;
                exports.__esModule = true;
                exports["default"] = {
                    build: function (logger, settings) {
                        return new WebRtcDTMFSender(logger, settings);
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/webrtc/remoteStreamManager', ["require", "exports", '../constants', '../common/utils'], factory);
                }
            })(function (require, exports) {
                var constants_1 = require('../constants');
                var utils_1 = require('../common/utils');
                var RemoteStreamManager = (function () {
                    function RemoteStreamManager(listener) {
                        this.listener = listener;
                        this.streams = {};
                        this.currStream = {};
                        for (var modality in constants_1["default"].MODALITY) {
                            this.streams[modality] = [];
                            this.currStream[modality] = 0;
                        }
                    }
                    RemoteStreamManager.prototype.addStream = function (stream, modality) {
                        if (!modality) {
                            return;
                        }
                        if (this.streams[modality].indexOf(stream) === -1) {
                            this.streams[modality].push(stream);
                            this.listener.streamAdded(stream, modality);
                        }
                    };
                    RemoteStreamManager.prototype.removeStream = function (stream) {
                        // check if removed stream matches what we have added previously
                        for (var modality in this.streams) {
                            if (utils_1["default"].remove(this.streams[modality], function (s) {
                                return s === stream;
                            })) {
                                this.listener.streamRemoved(stream, modality);
                                return;
                            }
                        }
                    };
                    RemoteStreamManager.prototype.getStream = function (modality) {
                        var idx = (this.currStream[modality]++) % this.streams[modality].length;
                        return this.streams[modality][idx];
                    };
                    return RemoteStreamManager;
                }());
                exports.RemoteStreamManager = RemoteStreamManager;
                exports.__esModule = true;
                exports["default"] = {
                    build: function (listener) {
                        return new RemoteStreamManager(listener);
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/device/videoRenderer', ["require", "exports"], factory);
                }
            })(function (require, exports) {
                function VideoRenderer(element, cb) {
                    var video = document.createElement('video'), lastNotifiedVideoWidth = 0, lastNotifiedVideoHeight = 0, stream = null, onVideoDataUpdated = function () {
                        if (cb && cb.onVideoSizeChanged) {
                            var width = video.videoWidth, height = video.videoHeight;
                            if (width < 32 || height < 32) {
                                //temp: workaround for Microsoft Edge where all video events that should report video size are fired before actual video size is known
                                width = height = 0;
                            }
                            if ((lastNotifiedVideoWidth !== width) || (lastNotifiedVideoHeight !== height)) {
                                lastNotifiedVideoWidth = width;
                                lastNotifiedVideoHeight = height;
                                cb.onVideoSizeChanged(width, height);
                            }
                        }
                    }, onVideoError = function () {
                        if (cb && cb.onError) {
                            cb.onError(video ? video.error : 'no video');
                        }
                    };
                    video.autoplay = true;
                    video.muted = true;
                    this.getVideoElement = function () {
                        return video;
                    };
                    this.dispose = function () {
                        detachEventListeners();
                        video = null;
                    };
                    this.reattachEventListeners = function () {
                        detachEventListeners();
                        attachEventListeners();
                    };
                    this.attachMediaStream = attachMediaStream;
                    function attachEventListeners() {
                        video.addEventListener('loadedmetadata', onVideoDataUpdated);
                        video.addEventListener('timeupdate', onVideoDataUpdated);
                        video.addEventListener('error', onVideoError);
                    }
                    function detachEventListeners() {
                        video.removeEventListener('loadedmetadata', onVideoDataUpdated);
                        video.removeEventListener('timeupdate', onVideoDataUpdated);
                        video.removeEventListener('error', onVideoError);
                        attachMediaStream(null);
                    }
                    function attachMediaStream(mediaStream) {
                        if (stream === mediaStream) {
                            return;
                        }
                        if (stream) {
                            //note not stopping the stream here
                            if (!mediaStream) {
                                element.removeChild(video);
                            }
                            window.detachMediaStream(video);
                        }
                        if (mediaStream) {
                            video.hidden = (mediaStream.getVideoTracks().length === 0);
                            window.attachMediaStream(video, mediaStream); //NB! not detaching when stream changed
                            if (!stream) {
                                element.appendChild(video);
                            }
                        }
                        stream = mediaStream;
                    }
                    (function () {
                        attachEventListeners();
                    })();
                }
                exports.__esModule = true;
                exports["default"] = VideoRenderer;
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/webrtc/webRtcVideoSizeTracker', ["require", "exports", '../common/userAgentAdapter'], factory);
                }
            })(function (require, exports) {
                var userAgentAdapter_1 = require('../common/userAgentAdapter');
                var WebRtcVideoSizeTracker = function (videoElement, config) {
                    var window = userAgentAdapter_1["default"].window, elementSizeTrackingRef, originalVideoElementSize = {
                        width: videoElement.offsetWidth,
                        height: videoElement.offsetHeight
                    };
                    function videoElementSizeChanged() {
                        return originalVideoElementSize.width !== videoElement.offsetWidth ||
                            originalVideoElementSize.height !== videoElement.offsetHeight;
                    }
                    function saveCurrentVideoElementSize() {
                        originalVideoElementSize.width = videoElement.offsetWidth;
                        originalVideoElementSize.height = videoElement.offsetHeight;
                    }
                    this.onSizeChange = function (callback) {
                        if (elementSizeTrackingRef) {
                            return;
                        }
                        var interval = Math.floor(Math.random() * Math.abs(config.interval.max - config.interval.min)) + config.interval.min;
                        elementSizeTrackingRef = window.setInterval(function () {
                            if (videoElementSizeChanged()) {
                                saveCurrentVideoElementSize();
                                callback(videoElement.offsetWidth, videoElement.offsetHeight);
                            }
                        }, interval);
                    };
                    this.dispose = function () {
                        if (elementSizeTrackingRef) {
                            window.clearInterval(elementSizeTrackingRef);
                        }
                    };
                };
                exports.__esModule = true;
                exports["default"] = {
                    build: function (videoElement, config) {
                        return new WebRtcVideoSizeTracker(videoElement, config);
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/webrtc/resolutionTable', ["require", "exports"], factory);
                }
            })(function (require, exports) {
                var ResolutionTable = (function () {
                    function ResolutionTable() {
                        var _this = this;
                        this.MACROBLOCK_SIZE = 16;
                        this.resolutions = [
                            { width: 320, height: 180 },
                            { width: 426, height: 240 },
                            { width: 640, height: 360 },
                            { width: 960, height: 540 },
                            { width: 1280, height: 720 },
                            { width: 1920, height: 1080 },
                            { width: 2560, height: 1440 },
                            { width: 3840, height: 2160 }
                        ];
                        this.table = this.resolutions.map(function (res) {
                            return { width: res.width, height: res.height, fs: Math.ceil(res.width / _this.MACROBLOCK_SIZE) * Math.ceil(res.height / _this.MACROBLOCK_SIZE) };
                        });
                    }
                    ResolutionTable.prototype.getResolution = function (maxFs) {
                        for (var i = this.table.length - 1; i >= 0; i--) {
                            if (this.table[i].fs <= maxFs) {
                                return this.table[i];
                            }
                        }
                        return this.table[0];
                    };
                    ResolutionTable.prototype.getMaxFS = function (w, h) {
                        var ws = Math.max(w, h);
                        var hs = Math.min(w, h);
                        for (var i = 0; i < this.table.length; i++) {
                            if (this.table[i].width >= ws && this.table[i].height >= hs) {
                                return this.table[i].fs;
                            }
                        }
                        return this.table.slice(-1)[0].fs;
                    };
                    ResolutionTable.prototype.getResolutions = function () {
                        return this.resolutions;
                    };
                    return ResolutionTable;
                }());
                exports.__esModule = true;
                exports["default"] = {
                    build: function () {
                        return new ResolutionTable();
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/webrtc/remoteRendererManager', ["require", "exports", '../constants', '../common/utils', '../device/videoRenderer', './webRtcVideoSizeTracker', './resolutionTable', '../helper'], factory);
                }
            })(function (require, exports) {
                var constants_1 = require('../constants');
                var utils_1 = require('../common/utils');
                var videoRenderer_1 = require('../device/videoRenderer');
                var webRtcVideoSizeTracker_1 = require('./webRtcVideoSizeTracker');
                var resolutionTable_1 = require('./resolutionTable');
                var helper_1 = require('../helper');
                /*
                interface IRendererListener {
                    rendererSubscribed: (renderer: RemoteRenderer) => void;
                    rendererUnsubscribed: (renderer: RemoteRenderer) => void;
                    rendererSizeChanged: (renderer: RemoteRenderer, width: int, height: int) => void;
                }
                */
                function RemoteRendererManager(context, listener) {
                    var _self = this;
                    var _settings = context.settings;
                    var _logger = context.logger;
                    var _streamManager = context.streamManager;
                    var _mediaManager = context.mediaManager;
                    var _listener = listener;
                    var _resolutionTable = resolutionTable_1["default"].build();
                    var _videoRenderers = [];
                    var RemoteRenderer = function (element, cb) {
                        videoRenderer_1["default"].call(this, element, cb);
                        var _that = this;
                        var _videoElementTracker;
                        var _baseDispose = this.dispose;
                        var _deferredSubscribe = null;
                        var _width, _height;
                        var _rendererType;
                        function _trackElementSizeChange() {
                            if (!_settings.webrtcVideoCapabilityCheckIntervalMin || !_settings.webrtcVideoCapabilityCheckIntervalMax) {
                                _logger.info('skipping video size tracking');
                                return;
                            }
                            _videoElementTracker = webRtcVideoSizeTracker_1["default"]
                                .build(_that.getVideoElement(), {
                                interval: {
                                    min: _settings.webrtcVideoCapabilityCheckIntervalMin,
                                    max: _settings.webrtcVideoCapabilityCheckIntervalMax
                                }
                            });
                            _videoElementTracker.onSizeChange(function (width, height) {
                                console.log('video renderer size changed, updating capabilities');
                                _width = width;
                                _height = height;
                                listener.rendererSizeChanged(_that, width, height);
                            });
                        }
                        /*
                        */
                        this._updateStream = function () {
                            if (!_rendererType) {
                                return;
                            }
                            var stream = _streamManager.getStream(_rendererType);
                            _that.attachMediaStream(stream);
                            if (_deferredSubscribe) {
                                _deferredSubscribe.resolve();
                                _deferredSubscribe = null;
                            }
                        };
                        this._rejectPendingSubscription = function () {
                            if (_deferredSubscribe) {
                                _deferredSubscribe.reject(new Error('renderer subscription rejected'));
                                _deferredSubscribe = null;
                            }
                            listener.rendererUnsubscribed(_that);
                        };
                        this.subscribeVideoAsync = function (msi, appSharing) {
                            _logger.info('subscribeVideoAsync', 'msi:', msi);
                            _rendererType = appSharing ? constants_1["default"].RENDERER_TYPE.screensharing : constants_1["default"].RENDERER_TYPE.video;
                            return new Promise(function (resolve) {
                                _that._rejectPendingSubscription();
                                if (_videoRenderers.indexOf(_that) === -1) {
                                    _videoRenderers.push(_that);
                                    listener.rendererSubscribed(_that);
                                }
                                _trackElementSizeChange();
                                var stream = _streamManager.getStream(_rendererType);
                                if (!stream) {
                                    _logger.warn('subscribeVideoAsync', 'could not get stream', 'rendererType', _rendererType);
                                    _deferredSubscribe = helper_1["default"].defer();
                                    resolve(_deferredSubscribe.promise);
                                }
                                else {
                                    _that.attachMediaStream(stream);
                                    _logger.info('subscribeVideoAsync', 'subscribed', 'rendererType', _rendererType, 'streamId:', stream.id);
                                    resolve();
                                }
                            });
                        };
                        this.dispose = function () {
                            if (_videoElementTracker) {
                                _videoElementTracker.dispose();
                            }
                            this._rejectPendingSubscription();
                            utils_1["default"].remove(_videoRenderers, function (value) {
                                return value === _that;
                            });
                            _baseDispose();
                        };
                        this.getModality = function () {
                            return _rendererType;
                        };
                        this.getWidth = function () {
                            return _width;
                        };
                        this.getHeight = function () {
                            return _height;
                        };
                    };
                    /*
                    */
                    this.unsubscribeAll = function () {
                        _videoRenderers.forEach(function (renderer) {
                            renderer._rejectPendingSubscription();
                        });
                        _videoRenderers = [];
                    };
                    this.stopRenderers = function () {
                        _videoRenderers.forEach(function (renderer) {
                            renderer._updateStream(); //note this will remove video element from the div!
                        });
                    };
                    this.stopVideoRenderers = function (modality) {
                        _videoRenderers.filter(function (renderer) { return renderer.getModality() === modality; }).forEach(function (renderer) {
                            renderer._updateStream(); //note this will remove video element from the div!
                        });
                    };
                    this.startVideoRenderers = function (modality) {
                        _videoRenderers.filter(function (renderer) { return renderer.getModality() === modality; }).forEach(function (renderer) {
                            renderer._updateStream();
                        });
                    };
                    this.createRemoteRenderer = function (element, cb) {
                        return new RemoteRenderer(element, cb);
                    };
                    //temp solution
                    this.getRenderersByModality = function (modality) {
                        return _videoRenderers.filter(function (renderer) { return renderer.getModality() === modality; }) || [];
                    };
                }
                exports.__esModule = true;
                exports["default"] = {
                    build: function (context, listener) {
                        return new RemoteRendererManager(context, listener);
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/extensions/dominantSpeakerHistoryExtension', ["require", "exports"], factory);
                }
            })(function (require, exports) {
                var DSI_NOTIFICATION_TYPE = 'DominantSpeakerInfo';
                var DominantSpeakerHistoryExtension = (function () {
                    function DominantSpeakerHistoryExtension() {
                        this.notificationType = DSI_NOTIFICATION_TYPE;
                        this.manager = null;
                        this.callback = null;
                    }
                    DominantSpeakerHistoryExtension.prototype.initialize = function (manager, options) {
                        if (!manager) {
                            return;
                        }
                        this.manager = manager;
                        this.manager.addNotificationListener(this, this.notificationType);
                        if (options && options.callback) {
                            this.callback = options.callback;
                        }
                    };
                    DominantSpeakerHistoryExtension.prototype.dispose = function () {
                        this.manager.removeNotificationListener(this, this.notificationType);
                        this.manager = null;
                        this.callback = null;
                    };
                    DominantSpeakerHistoryExtension.prototype.onNotification = function (content) {
                        var info = content;
                        this.processInfo(info);
                    };
                    DominantSpeakerHistoryExtension.prototype.processInfo = function (info) {
                        if (!this.callback) {
                            return;
                        }
                        this.callback(info.previousDominantSpeakerHistory);
                    };
                    return DominantSpeakerHistoryExtension;
                }());
                exports.__esModule = true;
                exports["default"] = DominantSpeakerHistoryExtension;
                ;
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/extensions/extensionFactory', ["require", "exports", './dominantSpeakerHistoryExtension', '../constants'], factory);
                }
            })(function (require, exports) {
                var dominantSpeakerHistoryExtension_1 = require('./dominantSpeakerHistoryExtension');
                var constants_1 = require('../constants');
                var ExtensionFactory = (function () {
                    function ExtensionFactory() {
                    }
                    ExtensionFactory.getExtension = function (extensionType) {
                        if (extensionType = constants_1["default"].EXTENSION_TYPE.dominantSpeakerHistory) {
                            return new dominantSpeakerHistoryExtension_1["default"]();
                        }
                        throw new Error('Extension of type ' + extensionType + ' is not found');
                    };
                    return ExtensionFactory;
                }());
                exports.__esModule = true;
                exports["default"] = ExtensionFactory;
                ;
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/extensions/extensionsManager', ["require", "exports", './extensionFactory'], factory);
                }
            })(function (require, exports) {
                var extensionFactory_1 = require('./extensionFactory');
                var ExtensionsManager = (function () {
                    function ExtensionsManager() {
                        this.extensions = [];
                        this.listeners = {};
                    }
                    ExtensionsManager.prototype.dispose = function () {
                        this.extensions = null;
                        this.listeners = null;
                    };
                    ExtensionsManager.prototype.addExtension = function (extensionType, options) {
                        var extension = extensionFactory_1["default"].getExtension(extensionType);
                        extension.initialize(this, options);
                        this.extensions.push(extension);
                    };
                    ExtensionsManager.prototype.processNotification = function (notificationType, content) {
                        var listeners = this.listeners[notificationType];
                        if (listeners) {
                            listeners.forEach(function (listener) {
                                listener.onNotification(content);
                            });
                        }
                    };
                    ExtensionsManager.prototype.addNotificationListener = function (extension, notificationType) {
                        if (!this.listeners[notificationType]) {
                            this.listeners[notificationType] = [];
                        }
                        this.listeners[notificationType].push(extension);
                    };
                    ExtensionsManager.prototype.removeNotificationListener = function (extension, notificationType) {
                        var listeners = this.listeners[notificationType];
                        if (!listeners) {
                            return;
                        }
                        var index = listeners.indexOf(extension);
                        if (index >= 0) {
                            listeners.splice(index, 1);
                        }
                        if (!listeners.length) {
                            delete this.listeners[notificationType];
                        }
                    };
                    return ExtensionsManager;
                }());
                exports.__esModule = true;
                exports["default"] = ExtensionsManager;
                ;
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/common/activeSpeaker/activeSpeakerManager', ["require", "exports"], factory);
                }
            })(function (require, exports) {
                var ActiveSpeakerManager = (function () {
                    function ActiveSpeakerManager(onActiveSpeakersChanged, onDominantSpeakersChanged) {
                        this.onActiveSpeakersChanged = onActiveSpeakersChanged;
                        this.onDominantSpeakersChanged = onDominantSpeakersChanged;
                    }
                    ActiveSpeakerManager.prototype.setStrategy = function (strategy) {
                        this.dshStrategy = strategy;
                        if (this.dshStrategy) {
                            this.dshStrategy.setOnDominantSpeakerChanged(this.onDominantSpeakerHistoryChanged.bind(this));
                        }
                    };
                    ActiveSpeakerManager.prototype.onContributingSourcesChanged = function (sources) {
                        this.onActiveSpeakersChanged(sources);
                        if (this.dshStrategy) {
                            this.dshStrategy.setSources(sources);
                        }
                    };
                    ActiveSpeakerManager.prototype.onDominantSpeakerHistoryChanged = function (sources) {
                        this.onDominantSpeakersChanged(sources);
                    };
                    ActiveSpeakerManager.prototype.dispose = function () {
                        if (this.dshStrategy) {
                            this.dshStrategy.dispose();
                            this.dshStrategy = null;
                        }
                        this.onActiveSpeakersChanged = null;
                        this.onDominantSpeakersChanged = null;
                    };
                    ;
                    return ActiveSpeakerManager;
                }());
                exports.ActiveSpeakerManager = ActiveSpeakerManager;
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/webrtc/render/audioRenderer', ["require", "exports", '../../common/userAgentAdapter', '../../common/utils'], factory);
                }
            })(function (require, exports) {
                var userAgentAdapter_1 = require('../../common/userAgentAdapter');
                var utils_1 = require('../../common/utils');
                var AudioRenderer = (function () {
                    function AudioRenderer(context) {
                        this.window = userAgentAdapter_1["default"].window;
                        this.logger = context.logger.createChild('audio');
                    }
                    AudioRenderer.prototype.play = function (stream) {
                        if (!this.audio) {
                            this.audio = document.createElement('audio');
                            document.body.appendChild(this.audio);
                            this.audio.autoplay = true;
                            this.audio.addEventListener('error', this.onAudioError);
                        }
                        else {
                            this.window.detachMediaStream(this.audio);
                        }
                        this.logger.log('starting playout');
                        this.window.attachMediaStream(this.audio, stream);
                        this.stream = stream;
                    };
                    AudioRenderer.prototype.stop = function () {
                        if (this.audio) {
                            this.logger.log('stopping playout');
                            this.audio.removeEventListener('error', this.onAudioError);
                            document.body.removeChild(this.audio);
                            this.window.detachMediaStream(this.audio);
                            this.audio = null;
                            this.stream = null;
                        }
                    };
                    AudioRenderer.prototype.getStream = function () {
                        return this.stream;
                    };
                    AudioRenderer.prototype.dispose = function () {
                        this.stop();
                    };
                    AudioRenderer.prototype.onAudioError = function (errorEvent) {
                        if (errorEvent) {
                            this.logger.error('error event occured:', this.toString(errorEvent));
                        }
                        else {
                            this.logger.error('error event occured', 'error:', this.audio ? this.audio.error : '<no audio element>');
                        }
                    };
                    // TODO: this needs to be moved to utils one day
                    AudioRenderer.prototype.toString = function (event) {
                        if (event) {
                            var xstr_1 = {};
                            utils_1["default"].forOwn(event, function (value, name) {
                                try {
                                    xstr_1[name] = (typeof value === 'function') ? xstr_1[name] = value() : xstr_1[name] = value;
                                }
                                catch (e) {
                                    xstr_1[name] = 'error: ' + e;
                                }
                            });
                            return JSON.stringify(xstr_1);
                        }
                    };
                    return AudioRenderer;
                }());
                exports.__esModule = true;
                exports["default"] = AudioRenderer;
                ;
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/webrtc/webRtcSession', ["require", "exports", '../constants', '../helper', './webRtcSessionDescription', './adapter/webrtcAdapter', './mediaManager', './statistics/webrtcStatistics', '../common/utils', './webRtcDtmfSender', './remoteStreamManager', './remoteRendererManager', './resolutionTable', '../extensions/extensionsManager', '../common/activeSpeaker/activeSpeakerManager', './render/audioRenderer'], factory);
                }
            })(function (require, exports) {
                var constants_1 = require('../constants');
                var helper_1 = require('../helper');
                var webRtcSessionDescription_1 = require('./webRtcSessionDescription');
                var webrtcAdapter_1 = require('./adapter/webrtcAdapter');
                var mediaManager_1 = require('./mediaManager');
                var webrtcStatistics_1 = require('./statistics/webrtcStatistics');
                var utils_1 = require('../common/utils');
                var webRtcDtmfSender_1 = require('./webRtcDtmfSender');
                var remoteStreamManager_1 = require('./remoteStreamManager');
                var remoteRendererManager_1 = require('./remoteRendererManager');
                var resolutionTable_1 = require('./resolutionTable');
                var extensionsManager_1 = require('../extensions/extensionsManager');
                var activeSpeakerManager_1 = require('../common/activeSpeaker/activeSpeakerManager');
                var audioRenderer_1 = require('./render/audioRenderer');
                var WebRtcSession = function (_context, sessionId, callback) {
                    this.configureModalitiesAsync = _configureModalitiesAsync;
                    this.createOfferAsync = _createOffer;
                    this.processOfferAsync = _processOffer;
                    this.createAnswerAsync = _createAnswer;
                    this.processAnswerAsync = _processAnswer;
                    this.completeNegotiationAsync = _completeNegotiationAsync;
                    this.rejectNegotiationAsync = _rejectNegotiationAsync;
                    this.createRemoteRenderer = _createRemoteRenderer;
                    this.getStatsAsync = _getStatsAsync;
                    this.terminate = _terminate;
                    this.sendDtmf = _sendDtmf;
                    this.canSendDtmf = _canSendDtmf;
                    this.onNegotiationRequired = null;
                    this.onSessionErrorOccurred = null;
                    this.getExtensionsManager = _getExtenstionsManager;
                    this._deviceSelectionChanged = _deviceSelectionChanged;
                    this._onTerminated = null;
                    var _that = this;
                    var _settings = _context.maContext.settings;
                    var _logger = _context.getLogger().createChild('webrtc');
                    var _deviceManager = _context.getDeviceManager();
                    var _webrtcAdapter = webrtcAdapter_1["default"].build({
                        global: _context.maContext
                    });
                    var _mediaManager = mediaManager_1["default"].build({
                        logger: _logger,
                        settings: _settings,
                        numVideoChannels: (_context.config && _context.config.isConference && _settings.numVideoChannelsGvc) ? _settings.numVideoChannelsGvc : 1
                    }, {
                        mediaEntityCreated: _mediaEntityCreated
                    });
                    var _resolutionTable = resolutionTable_1["default"].build();
                    var _sessionDescription = webRtcSessionDescription_1["default"].build({
                        sdpTransform: new _webrtcAdapter.SdpTransform(),
                        mediaManager: _mediaManager,
                        settings: _settings,
                        logger: _logger
                    });
                    var _peerConnection = null;
                    var _peerConnectionPromise;
                    var _userStreamRef = null;
                    var _displayStreamRef = null;
                    var _iceCandidatesDeferred = helper_1["default"].defer();
                    var _triggerRenegotiationFlag = false;
                    var _canTriggerRenegotiation = true;
                    var _forceMediaStreamUpdate = false;
                    var _offeredDescription;
                    var _negotiatedModalities = {};
                    var _offeredModalities; //on offerer this is snapshot of the configured modalities, on answerer what offerer offered
                    var _configuredModalities; //most recently configured modalities
                    var _negotiatingModalities; //snapshot of _configuredModalities when offer is created, used to detect cases where user configures different modalities during a renegotiation
                    var _iceDisconnectedTimer = null;
                    var _statistics = webrtcStatistics_1["default"].build(sessionId, {
                        logger: _logger
                    });
                    var _statisticsReport = Promise.resolve({});
                    var _terminated = false;
                    var _initiator = false;
                    var _dtmfSender = webRtcDtmfSender_1["default"].build(_logger, _settings.dtmf);
                    var _streamManager = remoteStreamManager_1["default"].build({
                        streamAdded: streamAdded,
                        streamRemoved: streamRemoved
                    });
                    var _rendererManager = remoteRendererManager_1["default"].build({
                        settings: _settings,
                        logger: _logger,
                        streamManager: _streamManager,
                        mediaManager: _mediaManager,
                        session: this
                    }, {
                        rendererSubscribed: _rendererSubscribed,
                        rendererUnsubscribed: _rendererUnsubscribed,
                        rendererSizeChanged: _rendererSizeChanged
                    });
                    var _configuredModalitiesPromise = Promise.resolve();
                    var _passiveModalities = _context.config.passiveModalities;
                    var _senders = {};
                    var _extensionsManager = null;
                    var _activeSpeakerManager = new activeSpeakerManager_1.ActiveSpeakerManager(callback.onContributingSourcesChanged, callback.onDominantSpeakerChanged);
                    var _audioRenderer = new audioRenderer_1["default"]({
                        logger: _logger
                    });
                    /*
                    Add listeners
                    */
                    function _rendererSubscribed(renderer) {
                        var mediaEntity = _mediaManager.getMediaEntitiesByModality(renderer.getModality())[0];
                        if (mediaEntity) {
                            mediaEntity.setRenderer(renderer);
                        }
                    }
                    function _rendererUnsubscribed(renderer) {
                        var mediaEntity = _mediaManager.getMediaEntitiesByRenderer(renderer)[0];
                        if (mediaEntity) {
                            mediaEntity.setRenderer(null);
                        }
                    }
                    function _rendererSizeChanged(renderer, width, height) {
                        var maxFS = _resolutionTable.getMaxFS(width, height);
                        var mediaEntity = _mediaManager.getMediaEntitiesByRenderer(renderer)[0];
                        if (!mediaEntity || !mediaEntity.getVideoCapabilities()) {
                            _logger.warn('no capabilities for provided modality:', renderer.getModality());
                            return;
                        }
                        mediaEntity.getVideoCapabilities().setMaxFS(maxFS, function () {
                            _triggerRenegotiation(true);
                        });
                    }
                    function _mediaEntityCreated(mediaEntity) {
                        var renderer = _rendererManager.getRenderersByModality(mediaEntity.getModality())[0];
                        mediaEntity.setRenderer(renderer);
                        if (renderer) {
                            _rendererSizeChanged(renderer, renderer.getWidth(), renderer.getHeight());
                        }
                    }
                    ;
                    /*
                    */
                    function _raiseError(mediaError) {
                        _logger.error('Media error occurred', 'type:', mediaError.type, 'detail:', mediaError.detail);
                        if (_that.onSessionErrorOccurred) {
                            _that.onSessionErrorOccurred(mediaError);
                        }
                    }
                    function streamAdded(stream, modality) {
                        if (constants_1["default"].MODALITY.audio === modality) {
                            _audioRenderer.play(stream);
                        }
                        else if (constants_1["default"].MODALITY.video === modality || constants_1["default"].MODALITY.screensharing === modality) {
                            _rendererManager.startVideoRenderers(modality);
                        }
                        else {
                            _logger.warn('unsupported stream modality:', modality);
                        }
                    }
                    function streamRemoved(stream, modality) {
                        if (constants_1["default"].MODALITY.audio === modality) {
                            if (_audioRenderer.getStream() === stream) {
                                // stop playout if stream we were playing got removed
                                _audioRenderer.stop();
                            }
                        }
                        else if (constants_1["default"].MODALITY.video === modality || constants_1["default"].MODALITY.screensharing === modality) {
                            _rendererManager.stopVideoRenderers(modality);
                        }
                        else {
                            _logger.warn('unsupported stream modality:', modality);
                        }
                    }
                    function setNegotiatedModalities(modalities) {
                        _negotiatedModalities = modalities;
                        _statistics.setNegotiatedModalities(modalities);
                    }
                    // candidate gathering may start when we do setLocalDescription to peerconnection.
                    // We detect if we need to call _resetCandidateGathering by checking if any of the modalities in sdp
                    // we are using setLocalDescription has port = 9
                    function _resetCandidateGathering() {
                        _logger.log('reset candidate gathering');
                        _iceCandidatesDeferred.promise.then(function () { }, function () { }); //suppress the warning if nobody has subscribed
                        _iceCandidatesDeferred.reject(new Error('reset candidate gathering')); // will have to cancel 'pending' waiters if any
                        _iceCandidatesDeferred = helper_1["default"].defer();
                    }
                    function _completeCandidateGathering() {
                        _iceCandidatesDeferred.resolve();
                    }
                    function _resetPeerConnection() {
                        _logger.log('reset peer connection');
                        _rendererManager.stopRenderers();
                        _audioRenderer.dispose();
                        if (_dtmfSender) {
                            _dtmfSender.dispose();
                            _dtmfSender = null;
                        }
                        if (_peerConnection) {
                            _peerConnection.close();
                        }
                        disposeStreams();
                        _peerConnection = null;
                        _peerConnectionPromise = null;
                        _resetCandidateGathering();
                        _canTriggerRenegotiation = true;
                        _negotiatedModalities = {};
                    }
                    function _startIceDisconnectedTimer() {
                        if (!_settings.iceDisconnectedTimeoutMs) {
                            return;
                        }
                        _iceDisconnectedTimer = setTimeout(function () {
                            _logger.error('ice disconnected for ', _settings.iceDisconnectedTimeoutMs, 'ms. Raise CONSTANTS.MEDIA_ERROR.iceConnectionError');
                            _raiseError({
                                type: constants_1["default"].MEDIA_ERROR.iceConnectionError,
                                detail: 'ice transport disconnected'
                            });
                        }, _settings.iceDisconnectedTimeoutMs);
                    }
                    function _clearIceDisconnectedTimer() {
                        if (_iceDisconnectedTimer) {
                            clearTimeout(_iceDisconnectedTimer);
                            _iceDisconnectedTimer = null;
                        }
                    }
                    function _createIceServers(relays) {
                        return relays.reduce(function (arr, relay) {
                            relay.addresses.map(function (address) {
                                function _createIceServer(port, transport) {
                                    return {
                                        urls: relay.type + ':' + address + ':' + port + (transport ? '?transport=' + transport : ''),
                                        credential: relay.password,
                                        username: relay.username
                                    };
                                }
                                if (relay.udpPort === relay.tcpPort) {
                                    arr.push(_createIceServer(relay.udpPort));
                                }
                                else {
                                    arr.push(_createIceServer(relay.udpPort, 'udp'));
                                    arr.push(_createIceServer(relay.tcpPort, 'tcp'));
                                }
                            });
                            return arr;
                        }, []);
                    }
                    function _configureCrypto(optional) {
                        var sdes;
                        if (_offeredDescription) {
                            var srtpInfo = _offeredDescription.getSrtpInfo();
                            _statistics.setOfferedSrtpInfo(srtpInfo);
                            sdes = !srtpInfo.dtls || (srtpInfo.sdes && _settings.preferSdesSrtp);
                        }
                        else {
                            sdes = _settings.preferSdesSrtp;
                        }
                        if (sdes) {
                            _logger.log('configuring peer connection to use sdes');
                            optional.optional = [{
                                    DtlsSrtpKeyAgreement: false
                                }];
                        }
                        _statistics.setNegotiatedSrtpInfo({
                            dtls: !sdes,
                            sdes: !!sdes
                        });
                    }
                    function _assurePeerConnectionAsync() {
                        if (!_peerConnectionPromise) {
                            _peerConnectionPromise = _context.maContext.getRelayManager().queryRelaysAsync('turn', _context.config.isRemoteClientLync).then(function (relays) {
                                var optional = {};
                                _configureCrypto(optional);
                                _logger.log('create peer connection');
                                _peerConnection = new _webrtcAdapter.RTCPeerConnection({
                                    iceServers: _createIceServers(relays),
                                    rtcpMuxPolicy: 'require',
                                    iceTransportPolicy: _context.config.iceTransportPolicy ? _context.config.iceTransportPolicy : constants_1["default"].ICE_TRANSPORT_POLICY.all
                                }, optional);
                                _statistics.setPeerConnection(_peerConnection);
                                _peerConnection.onnegotiationneeded = function (event) {
                                    var pc = event.target;
                                    _logger.log('onnegotiationneeded', 'signalingState:', pc.signalingState);
                                    //we could _triggerRenegotiation but then we need to be sure user has called configureModalities before...
                                };
                                _peerConnection.onsignalingstatechange = function (event) {
                                    var pc = event.target;
                                    _statistics.setSignalingConnectionState(pc.signalingState);
                                    _logger.log('onsignalingstatechange', 'signalingState:', pc.signalingState);
                                };
                                _peerConnection.onaddstream = function (event) {
                                    //note on chrome onstream added for new stream can happen before previous one is removed
                                    _logger.log('onaddstream', 'stream:', event.stream);
                                    var mediaEntity = _mediaManager.getMediaEntityByStreamId(event.stream.id);
                                    if (mediaEntity) {
                                        _streamManager.addStream(event.stream, mediaEntity.getModality());
                                    }
                                    else {
                                        _logger.error("Can not find media entity with stream id " + event.stream.id);
                                    }
                                };
                                _peerConnection.ontrack = function (event) {
                                    _logger.log('ontrack', 'track:', event.track);
                                    //....
                                };
                                _peerConnection.onremovestream = function (event) {
                                    _logger.log('onremovestream', 'stream:', event.stream);
                                    _streamManager.removeStream(event.stream);
                                };
                                _peerConnection.onicecandidate = function (event) {
                                    _logger.log('onicecandidate', 'candidate:', event.candidate);
                                    if (!event.candidate) {
                                        _completeCandidateGathering();
                                    }
                                };
                                _peerConnection.onicegatheringstatechange = function (event) {
                                    var pc = event.target;
                                    _logger.log('onicegatheringstatechange', 'iceGatheringState:', pc.iceGatheringState);
                                };
                                _peerConnection.oniceconnectionstatechange = function (event) {
                                    var pc = event.target;
                                    _statistics.setIceConnectionState(pc.iceConnectionState);
                                    _logger.log('oniceconnectionstatechange', 'iceConnectionState:', pc.iceConnectionState, 'pc.signalingState:', pc.signalingState);
                                    if (pc.iceConnectionState === 'failed') {
                                        _raiseError({
                                            type: constants_1["default"].MEDIA_ERROR.iceConnectionError,
                                            detail: 'ice transport failed'
                                        });
                                    }
                                    if (pc.iceConnectionState === 'disconnected') {
                                        _startIceDisconnectedTimer();
                                    }
                                    else {
                                        _clearIceDisconnectedTimer();
                                    }
                                };
                            });
                        }
                        return _peerConnectionPromise;
                    }
                    function _throwIfModalitiesNotConfigured(message) {
                        if (!_configuredModalities) {
                            throw new Error(message);
                        }
                    }
                    function _createNegotiationConstraints(modalities) {
                        //add parameter here for offer/answer differentiation when needed
                        function canReceive(direction) {
                            //on case inactive ask offer and answer to contain receive direction Here is current behaviour on chrome
                            //Even there are no media streams added to peer connection offer still contains modality with
                            //send only direction! if we put canReceive then offer contains receive only on both cases we would have _fixupSDP
                            //that would make direction to inactive. Now on the answerer side there is another side effect:
                            //if offer has inactive direction and we dont have canReceive and no streams in peer connection then
                            //the answer would have modality disabled, but if we put canReceive to answer options then the negotiated
                            //modality would not be disabled and would stay inactive!
                            //Have not investigated fully how this is in firefox!
                            return !!direction && (helper_1["default"].hasReceiveDirectionality(direction) || direction === 'inactive');
                        }
                        return {
                            offerToReceiveAudio: +canReceive(modalities.audio),
                            offerToReceiveVideo: +canReceive(modalities.video) + +canReceive(modalities.screensharing)
                        };
                    }
                    function _triggerRenegotiation(force) {
                        if (_canTriggerRenegotiation) {
                            _canTriggerRenegotiation = false;
                            _triggerRenegotiationFlag = false;
                            _logger.log('triggering renegotiation');
                            _mediaManager.backup();
                            if (_that.onNegotiationRequired) {
                                _that.onNegotiationRequired();
                            }
                        }
                        else if (force) {
                            _logger.log('renegotiation postponed');
                            _triggerRenegotiationFlag = true;
                        }
                    }
                    function _configureModalitiesAsync(modalities) {
                        var pendingPromise = _configuredModalitiesPromise.then(function () {
                            return new Promise(function (resolve) {
                                if (!modalities || (!modalities.audio && !modalities.video && !modalities.screensharing)) {
                                    throw new Error('Invalid parameters!' + JSON.stringify(modalities));
                                }
                                var needNewRenegotiation = !_configuredModalities || !helper_1["default"].areNegotiatedDirectionsFulfilled(modalities, _negotiatedModalities);
                                _configuredModalities = modalities; //assign always as if negotiated already confirms to desired but current configured is different (other side did not want to receive)
                                _logger.log('configure modalities', 'audio:', modalities.audio, 'video:', modalities.video, 'screensharing', modalities.screensharing, 'peerconnection:', !!_peerConnection, 'pc.signalingState:', (!!_peerConnection ? _peerConnection.signalingState : '-'), 'needNewRenegotiation:', needNewRenegotiation);
                                if (needNewRenegotiation) {
                                    _triggerRenegotiation(); //NB! if we ant to _triggerRenegotiation also from onnegotiationneeded then in here we could check for stable peer connection state also
                                }
                                resolve(_configuredModalities);
                            });
                        });
                        _configuredModalitiesPromise = pendingPromise.catch(function (error) {
                            _logger.warn('Error during configuring modalities: ', error);
                        });
                        return pendingPromise;
                    }
                    function _updatePeerConnectionStreamsAsync(modalities, canRemoveTracks, canAddTracks) {
                        var isSendingAudio = helper_1["default"].hasSendDirectionality(_negotiatedModalities.audio), //use previous modalities
                        isSendingVideo = helper_1["default"].hasSendDirectionality(_negotiatedModalities.video), isSendingScreenSharing = helper_1["default"].hasSendDirectionality(_negotiatedModalities.screensharing), isOnHold = helper_1["default"].isOnHold(_negotiatedModalities), wantSendAudio = helper_1["default"].hasSendDirectionality(modalities.audio), wantSendVideo = helper_1["default"].hasSendDirectionality(modalities.video), wantSendScreenSharing = helper_1["default"].hasSendDirectionality(modalities.screensharing), wantToHold = helper_1["default"].isOnHold(modalities);
                        return _assurePeerConnectionAsync().then(function () {
                            _logger.log('updatePeerConnectionStreamsAsync', 'pc state', _peerConnection.signalingState, 'hold', '[', isOnHold, '->', wantToHold, ']', 'audio', '[', isSendingAudio, '->', wantSendAudio, ']', 'video', '[', isSendingVideo, '->', wantSendVideo, ']', 'screensharing', '[', isSendingScreenSharing, '->', wantSendScreenSharing, ']');
                            // stream constraints changed
                            if (isOnHold !== wantToHold) {
                                if (_userStreamRef) {
                                    _userStreamRef.setHold(wantToHold);
                                }
                                if (_displayStreamRef) {
                                    _displayStreamRef.setHold(wantToHold);
                                }
                                if (wantToHold) {
                                    return; //will not touch media streams
                                }
                            }
                            if (isSendingAudio !== wantSendAudio ||
                                isSendingVideo !== wantSendVideo ||
                                isSendingScreenSharing !== wantSendScreenSharing ||
                                _forceMediaStreamUpdate) {
                                if (canAddTracks) {
                                    _forceMediaStreamUpdate = false; //reset flag only when we can canAddTracks see usage of canRemoveTracks, canAddTracks arguments
                                }
                                var removeTracks = function () {
                                    removeUserTracks();
                                    removeDisplayTracks();
                                    if (_peerConnection.getSenders().length) {
                                        throw new Error("not all tracks were removed");
                                    }
                                };
                                var removeUserTracks = function () {
                                    removeTracksByModality(constants_1["default"].MODALITY.audio);
                                    removeTracksByModality(constants_1["default"].MODALITY.video);
                                };
                                var removeDisplayTracks = function () {
                                    removeTracksByModality(constants_1["default"].MODALITY.screensharing);
                                };
                                var removeTracksByModality = function (modality) {
                                    if (modality in _senders) {
                                        _logger.log('remove sender', 'track kind:', _senders[modality].track.kind, 'track id:', _senders[modality].track.id);
                                        _peerConnection.removeTrack(_senders[modality]);
                                        delete _senders[modality];
                                    }
                                };
                                var addTrack = function (gumTrack, gumStream, modality) {
                                    if (!gumTrack) {
                                        return;
                                    }
                                    // add only the first track from the collection
                                    _logger.log('add media track', 'kind:', gumTrack.kind, 'id:', gumTrack.id);
                                    if (_senders[modality]) {
                                        throw new Error('track already created, modality:' + modality + ", kind:" + gumTrack.kind + ', id:' + gumTrack.id);
                                    }
                                    _senders[modality] = _peerConnection.addTrack(gumTrack, gumStream);
                                };
                                if (canRemoveTracks) {
                                    _logger.log('not using any media(track api) track, remove all senders');
                                    removeTracks();
                                    if (!canAddTracks || (!wantSendAudio && !wantSendVideo)) {
                                        disposeUserStream();
                                    }
                                    if (!canAddTracks || !wantSendScreenSharing) {
                                        disposeDisplayStream();
                                    }
                                }
                                if (canAddTracks) {
                                    var streamOperations = [];
                                    if (wantSendAudio || wantSendVideo) {
                                        var mediaStream = _deviceManager._getMediaStream({ audio: wantSendAudio, video: wantSendVideo });
                                        streamOperations.push(mediaStream.start().then(function () {
                                            try {
                                                addTrack(mediaStream.getObject().getAudioTracks()[0], mediaStream.getObject(), constants_1["default"].MODALITY.audio);
                                                addTrack(mediaStream.getObject().getVideoTracks()[0], mediaStream.getObject(), constants_1["default"].MODALITY.video);
                                                if (canRemoveTracks) {
                                                    disposeUserStream(); //note: current implementation stops all tracks when last ref is dropped
                                                }
                                                mediaStream.onApplyConstraints = function (change) {
                                                    if (_userStreamRef === mediaStream) {
                                                        var gumStream = _userStreamRef.getObject();
                                                        _logger.log('remove media stream', 'audio tracks:', gumStream.getAudioTracks(), 'video tracks:', gumStream.getVideoTracks());
                                                        removeUserTracks();
                                                    }
                                                    change.then(function () {
                                                        if (_userStreamRef === mediaStream) {
                                                            addTrack(mediaStream.getObject().getAudioTracks()[0], mediaStream.getObject(), constants_1["default"].MODALITY.audio);
                                                            addTrack(mediaStream.getObject().getVideoTracks()[0], mediaStream.getObject(), constants_1["default"].MODALITY.video);
                                                        }
                                                    });
                                                };
                                                _userStreamRef = mediaStream;
                                            }
                                            catch (error) {
                                                removeUserTracks();
                                                disposeUserStream();
                                                mediaStream.dispose();
                                                throw error;
                                            }
                                        }));
                                    }
                                    if (wantSendScreenSharing) {
                                        var displayStream = _deviceManager._getMediaStream({ video: true });
                                        streamOperations.push(displayStream.start().then(function () {
                                            try {
                                                addTrack(displayStream.getObject().getVideoTracks()[0], displayStream.getObject(), constants_1["default"].MODALITY.screensharing);
                                                if (canRemoveTracks) {
                                                    disposeDisplayStream(); //note: current implementation stops all tracks when last ref is dropped
                                                }
                                                _displayStreamRef = displayStream;
                                            }
                                            catch (error) {
                                                removeDisplayTracks();
                                                disposeDisplayStream();
                                                displayStream.dispose();
                                                throw error;
                                            }
                                        }));
                                    }
                                    return Promise.all(streamOperations);
                                }
                            }
                        });
                    }
                    function _createOffer() {
                        return new Promise(function (resolve) {
                            _logger.log('create [offer] configured:', _configuredModalities);
                            _initiator = true;
                            _throwIfModalitiesNotConfigured('no configured modalities to create offer for');
                            _canTriggerRenegotiation = false;
                            _negotiatingModalities = helper_1["default"].excludePassiveModalities(_configuredModalities, _passiveModalities, _offeredModalities); // take snapshot
                            _offeredModalities = _negotiatingModalities; //we offer what has been configured
                            var modalities = helper_1["default"].negotiateModalities(_offeredModalities, _negotiatingModalities);
                            if (!helper_1["default"].isOnHold(modalities)) {
                                resolve(_updatePeerConnectionStreamsAsync(_offeredModalities, true, true).then(function () {
                                    var constraints = _createNegotiationConstraints(_offeredModalities);
                                    _logger.log('create [offer]', 'offered:', _offeredModalities, 'constraints:', constraints);
                                    return _peerConnection.createOffer(constraints);
                                }).then(function (offer) {
                                    _logger.debug('create [offer] offer from peer connection', 'sdp:', offer.sdp);
                                    // figure out if we need to wait for ice candidates to be gathered
                                    var description = _sessionDescription.createLocalOffer(offer.sdp);
                                    if (description.needToWaitIceCandidates()) {
                                        _resetCandidateGathering();
                                    }
                                    _statistics.startWaitingForStreamStart(_offeredModalities);
                                    // use offer as a local description without any modifications
                                    var ld = new _webrtcAdapter.RTCSessionDescription({ sdp: offer.sdp, type: 'offer' });
                                    // setLocalDescription is what will start ice candidate gathering
                                    return Promise.all([_peerConnection.setLocalDescription(ld), _iceCandidatesDeferred.promise]);
                                }).then(function () {
                                    // get fresh local description from pc, it will include candidates
                                    var description = _sessionDescription.createLocalOffer(_peerConnection.localDescription.sdp);
                                    description.updateModalities(_offeredModalities);
                                    // description needs to be aware of the tracks we are sending
                                    _mediaManager.setMediaTracks(getMediaTracks());
                                    var sdp = description.toOffer();
                                    _logger.debug('CREATE OFFER', 'sdp:', sdp);
                                    return { blob: sdp, modalities: modalities };
                                }));
                            }
                            else {
                                resolve(_updatePeerConnectionStreamsAsync(_offeredModalities, true, true).then(function () {
                                    var sdp = _sessionDescription.createInactiveOfferSdp(_peerConnection.localDescription.sdp, _offeredModalities);
                                    _logger.debug('CREATE OFFER hold', 'sdp:', sdp);
                                    return { blob: sdp, modalities: modalities };
                                }));
                            }
                        });
                    }
                    function getMediaTracks() {
                        var tracks = [];
                        utils_1["default"].forOwn(_senders, function (sender, modality) {
                            tracks.push({ track: sender.track.id, modality: modality });
                        });
                        return tracks;
                    }
                    function _processOffer(mediaContent) {
                        return new Promise(function (resolve) {
                            var offer = mediaContent.blob;
                            _logger.debug('process [offer]', 'sdp:', offer);
                            _initiator = false;
                            _offeredDescription = _sessionDescription.createRemoteOffer(offer);
                            _canTriggerRenegotiation = false;
                            _offeredModalities = helper_1["default"].invertModalities(_offeredDescription.getModalities());
                            var result = Promise.resolve(_offeredModalities);
                            if (helper_1["default"].hasSendDirectionality(_offeredModalities.video) || helper_1["default"].hasReceiveDirectionality(_offeredModalities.video)) {
                                var codecs = _offeredDescription.getVideoCodecs();
                                result = _webrtcAdapter.RTCRtpReceiver.getCapabilities('video').then(function (capabilities) {
                                    var match = capabilities.codecs.some(function (capCodec) {
                                        return codecs.some(function (codec) {
                                            return capCodec.mimeType === codec;
                                        });
                                    });
                                    if (!match) {
                                        _logger.warn('offer doesn\'t contain any supported video codecs');
                                        var acceptableModalities = utils_1["default"].shallowClone(_offeredModalities);
                                        acceptableModalities.video = void 0;
                                        return acceptableModalities;
                                    }
                                    return _offeredModalities;
                                }).catch(function (error) {
                                    _logger.error('failed to get video capability', error);
                                    return _offeredModalities;
                                });
                            }
                            resolve(result.then(function (acceptableModalities) {
                                _logger.log('process [offer]', 'offered:', _offeredModalities, 'acceptable:', acceptableModalities);
                                return acceptableModalities;
                            }));
                        });
                    }
                    function handleVideoRecvCapabilities(description) {
                        if (_settings.enableLocalVideoConstraints && _userStreamRef && _userStreamRef.hasVideo()) {
                            var capabilities = description.getVideoRecvCapabilities();
                            if (capabilities.maxFS && capabilities.maxFPS) {
                                return _userStreamRef.applyConstraints(capabilities);
                            }
                            _logger.error('remote endpoint didn\'t specify video receive capability');
                        }
                        return Promise.resolve(false);
                    }
                    function _createAnswer(provisional) {
                        return new Promise(function (resolve) {
                            if (provisional) {
                                resolve({});
                                return; //early
                            }
                            _logger.log('create [answer]', 'offered:', _offeredModalities, 'configured:', _configuredModalities);
                            _throwIfModalitiesNotConfigured('no configured modalities to create answer for');
                            _negotiatingModalities = helper_1["default"].excludePassiveModalities(_configuredModalities, _passiveModalities, _offeredModalities); // take snapshot
                            var modalities = helper_1["default"].negotiateModalities(_offeredModalities, _negotiatingModalities);
                            if (!helper_1["default"].isOnHold(modalities)) {
                                resolve(_updatePeerConnectionStreamsAsync(modalities, true, false).then(function () {
                                    return handleVideoRecvCapabilities(_offeredDescription);
                                }).then(function () {
                                    return handleCodecSwitchUnsupported();
                                }).then(function () {
                                    var sdp = _offeredDescription.toRemote(modalities);
                                    _logger.log('create [answer] set remote description', 'negotiated:', modalities, 'sdp:', sdp);
                                    return _peerConnection.setRemoteDescription(new _webrtcAdapter.RTCSessionDescription({ sdp: sdp, type: 'offer' }));
                                }).then(function () {
                                    return _updatePeerConnectionStreamsAsync(modalities, false, true);
                                }).then(function () {
                                    return _peerConnection.createAnswer();
                                }).then(function (answer) {
                                    _logger.debug('create [answer] answer from peer connection', 'sdp:', answer.sdp);
                                    var description = _sessionDescription.createLocalAnswer(answer.sdp);
                                    // figure out if we need to wait for ice candidates to be gathered
                                    if (description.needToWaitIceCandidates()) {
                                        _resetCandidateGathering();
                                    }
                                    _statistics.startWaitingForStreamStart(modalities);
                                    // use answer as a local description without any modifications
                                    var ld = new _webrtcAdapter.RTCSessionDescription({ sdp: answer.sdp, type: 'answer' });
                                    // setLocalDescription is what will start ice candidate gathering
                                    return Promise.all([_peerConnection.setLocalDescription(ld), _iceCandidatesDeferred.promise]);
                                }).then(function () {
                                    // get fresh local description from pc, it will include candidates
                                    var description = _sessionDescription.createLocalAnswer(_peerConnection.localDescription.sdp);
                                    description.updateModalities(modalities);
                                    _mediaManager.setMediaTracks(getMediaTracks());
                                    var sdp = description.toAnswer();
                                    // answered modalities might differ from configured modalities, since they are based on the actual sdp emitted by UA  
                                    modalities = description.getModalities();
                                    setNegotiatedModalities(modalities);
                                    _logger.debug('CREATE ANSWER', 'sdp:', sdp);
                                    return { blob: sdp, modalities: _negotiatedModalities };
                                }));
                            }
                            else {
                                resolve(_updatePeerConnectionStreamsAsync(modalities, true, true).then(function () {
                                    setNegotiatedModalities(modalities); //assign after _updatePeerConnectionStreamsAsync because it is used inside!
                                    var sdp = _sessionDescription.createInactiveAnswerSdp(_peerConnection.localDescription.sdp, _negotiatedModalities);
                                    _logger.debug('CREATE ANSWER hold', 'sdp:', sdp);
                                    return { blob: sdp, modalities: _negotiatedModalities };
                                }));
                            }
                        });
                    }
                    function handleCodecSwitchUnsupported() {
                        if (_offeredDescription.isCodecSwitchSupported()) {
                            return Promise.resolve();
                        }
                        return _webrtcAdapter.RTCRtpReceiver.getCapabilities(constants_1["default"].MEDIA_TYPE.audio).then(function (capabilities) {
                            var localAudioCodecs = capabilities.codecs.map(function (capCodec) {
                                return capCodec.mimeType;
                            });
                            _offeredDescription.usePrimaryAudioCodecOnly(localAudioCodecs);
                        }).catch(function (error) {
                            _logger.error('failed to set primary codec based on audio capability', error);
                        });
                    }
                    function _processAnswer(mediaContent, provisional) {
                        return new Promise(function (resolve) {
                            var answer = mediaContent.blob;
                            _logger.debug(provisional ? 'PROCESS PRANSWER' : 'PROCESS ANSWER', 'sdp:', answer);
                            if (provisional) {
                                _logger.log('process [pranswer]');
                                // we do not set provisional answer, since no of the browsers support it correctly
                                resolve({});
                                return; //early
                            }
                            var description = _sessionDescription.createRemoteAnswer(answer);
                            var modalities = helper_1["default"].invertModalities(description.getModalities());
                            setNegotiatedModalities(modalities);
                            if (!helper_1["default"].isOnHold(_negotiatedModalities)) {
                                var sdp = description.toRemote(_negotiatedModalities);
                                _logger.log('process [answer] set remote description', 'negotiated:', _negotiatedModalities, 'sdp:', sdp);
                                resolve(_peerConnection.setRemoteDescription(new _webrtcAdapter.RTCSessionDescription({ sdp: sdp, type: 'answer' })).then(function () {
                                    return _negotiatedModalities;
                                }).then(function () {
                                    return handleVideoRecvCapabilities(description);
                                }).then(function (changed) {
                                    if (changed) {
                                        _triggerRenegotiation(true);
                                    }
                                }).then(function () {
                                    return _negotiatedModalities;
                                }));
                            }
                            else {
                                resolve(_negotiatedModalities);
                            }
                        });
                    }
                    function _completeNegotiationAsync() {
                        return new Promise(function (resolve) {
                            _mediaManager.commit();
                            //note with current implementation if initial offer did not have video receive capability then there is no new renegotiation triggered
                            //this is feature of current implementation we will change when needed
                            var valuableConfiguredModalities = helper_1["default"].excludePassiveModalities(_configuredModalities, _passiveModalities, _offeredModalities);
                            var needNewRenegotiation = (_forceMediaStreamUpdate && !helper_1["default"].isOnHold(_negotiatedModalities)) ||
                                !helper_1["default"].areNegotiatedDirectionsAcceptable(valuableConfiguredModalities, _negotiatingModalities, _negotiatedModalities) || _triggerRenegotiationFlag, isComplete = !needNewRenegotiation;
                            _canTriggerRenegotiation = true;
                            _logger.log('negotiation completed', 'isComplete:', isComplete, 'configured:', _configuredModalities, 'negotiating:', _negotiatingModalities, 'offered:', _offeredModalities, 'negotiated:', _negotiatedModalities);
                            if (needNewRenegotiation) {
                                _triggerRenegotiation();
                            }
                            resolve({ isComplete: isComplete, activeModalities: _negotiatedModalities, offeredModalities: _offeredModalities, attemptedModalities: _negotiatingModalities, configuredModalities: _configuredModalities, initiator: _initiator });
                        });
                    }
                    function _rejectNegotiationAsync(error, retry) {
                        return new Promise(function (resolve) {
                            _mediaManager.rollback();
                            var isComplete = error === constants_1["default"].RENEGOTIATION_ERROR.local;
                            var promise = Promise.resolve();
                            _logger.warn('negotiation rejected', 'isComplete:', isComplete, 'error:', error, 'configured:', _configuredModalities, 'negotiating:', _negotiatingModalities, 'offered:', _offeredModalities, 'negotiated:', _negotiatedModalities);
                            if (_peerConnection) {
                                if ('have-local-offer' === _peerConnection.signalingState) {
                                    _logger.log('rolling back local description');
                                    promise = _peerConnection.setLocalDescription(new _webrtcAdapter.RTCSessionDescription({ type: 'rollback' }));
                                }
                                else {
                                    _logger.error('cannot rollback local description in currrent state:', _peerConnection.signalingState);
                                }
                            }
                            resolve(promise.then(function () {
                                if (retry) {
                                    _logger.log('retrying failed negotiation');
                                    _triggerRenegotiation();
                                }
                                return {
                                    isComplete: isComplete,
                                    activeModalities: _negotiatedModalities,
                                    offeredModalities: _offeredModalities,
                                    attemptedModalities: _negotiatingModalities,
                                    configuredModalities: _configuredModalities,
                                    initiator: _initiator
                                };
                            }));
                        });
                    }
                    function _createRemoteRenderer(element, cb) {
                        return _rendererManager.createRemoteRenderer(element, cb);
                    }
                    function _deviceSelectionChanged() {
                        //currently deviceSelectionChanged does not tell us what devices changed but it could, however this information seems not needed right now...
                        if (_peerConnection) {
                            //NB! _negotiatedModalities are set during negotiation (but before negotiation completion) thus we have case
                            //where dev selection changes while we negotiate hold but _negotiatedModalities do not reflect the state yet
                            //on that case no new renegotiation is triggered because negotiation is ongoing and complete negotiation
                            //checks for hold too and will allow _forceMediaStreamUpdate to be set while on hold
                            if (!helper_1["default"].isOnHold(_negotiatedModalities)) {
                                _forceMediaStreamUpdate = true;
                                _triggerRenegotiation();
                            }
                        }
                    }
                    function _terminate() {
                        _logger.log('terminate');
                        _statistics.setTerminated();
                        if (_extensionsManager) {
                            _extensionsManager.dispose();
                            _extensionsManager = null;
                        }
                        return _getStatsAsync().then(function () {
                            _terminated = true;
                            _rendererManager.unsubscribeAll();
                            _resetPeerConnection();
                            _clearIceDisconnectedTimer();
                            if (_that._onTerminated) {
                                _that._onTerminated(_that);
                            }
                        });
                    }
                    function disposeStreams() {
                        disposeUserStream();
                        disposeDisplayStream();
                    }
                    function disposeUserStream() {
                        if (_userStreamRef) {
                            _userStreamRef.dispose();
                            _userStreamRef = null;
                        }
                    }
                    function disposeDisplayStream() {
                        if (_displayStreamRef) {
                            _displayStreamRef.dispose();
                            _displayStreamRef = null;
                        }
                    }
                    function _getStatsAsync() {
                        if (!_terminated) {
                            _statisticsReport = _statisticsReport.then(function () {
                                return _statistics.getReport();
                            }).then(function (report) {
                                return report;
                            }).catch(function (error) {
                                _logger.error('getting statistics should never fail:', error);
                                return {};
                            });
                        }
                        return _statisticsReport;
                    }
                    function _sendDtmf(dtmfCode) {
                        return _dtmfSender.sendDtmf(_peerConnection, dtmfCode);
                    }
                    function _canSendDtmf() {
                        return _dtmfSender.canSendDtmf(_peerConnection);
                    }
                    function _getExtenstionsManager() {
                        if (!_extensionsManager) {
                            _extensionsManager = new extensionsManager_1["default"]();
                            _extensionsManager.addExtension(constants_1["default"].EXTENSION_TYPE.dominantSpeakerHistory, {
                                callback: _activeSpeakerManager.onDominantSpeakerHistoryChanged.bind(_activeSpeakerManager)
                            });
                        }
                        return _extensionsManager;
                    }
                };
                exports.__esModule = true;
                exports["default"] = {
                    build: function (context, callId, callback) {
                        return new WebRtcSession(context, callId, callback);
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/ortc/ortcTransport', ["require", "exports", '../constants', '../helper', '../common/utils'], factory);
                }
            })(function (require, exports) {
                var constants_1 = require('../constants');
                var helper_1 = require('../helper');
                var utils_1 = require('../common/utils');
                function IceTransport(_type, _logger, _iceCompletionMonitor, _raiseError, _iceOptions, _parentGatherer, _parentTransport) {
                    var _that = this;
                    var _deferredLocalCandidates = helper_1["default"].defer();
                    var _iceCompletedCb;
                    var _started;
                    this.nominatedCandidatePair = null;
                    _logger.log('create RTCIceGatherer', 'options:', JSON.stringify(_iceOptions.iceGathererOptions));
                    if (!_parentGatherer) {
                        this.iceGatherer = new RTCIceGatherer(_iceOptions.iceGathererOptions);
                    }
                    else {
                        this.iceGatherer = _parentGatherer.createAssociatedGatherer();
                    }
                    _logger.log('create RTCIceTransport');
                    if (!_parentTransport) {
                        this.iceTransport = new RTCIceTransport();
                    }
                    else {
                        this.iceTransport = _parentTransport.createAssociatedTransport();
                    }
                    this.getLocalCandidatesAsync = function () {
                        return _deferredLocalCandidates.promise;
                    };
                    this.start = function (remoteIceCandidates, remoteIceParams) {
                        if (_started) {
                            throw new Error('already started!');
                        }
                        _started = true;
                        _iceCompletedCb = _iceCompletionMonitor.createCb(_iceOptions.iceRole);
                        _logger.log('RTCIceTransport setRemoteCandidates', 'candidates:', JSON.stringify(remoteIceCandidates));
                        _that.iceTransport.setRemoteCandidates(remoteIceCandidates);
                        _logger.log('RTCIceTransport start', 'remoteIceParams:', JSON.stringify(remoteIceParams), 'role:', _iceOptions.iceRole);
                        _that.iceTransport.start(_that.iceGatherer, remoteIceParams, _iceOptions.iceRole);
                        _logger.log('RTCIceTransport start', 'role:', _that.iceTransport.role);
                    };
                    this.dispose = function () {
                        _logger.log('dispose');
                        //        if (_started) { TODO: for some reason we need to call stop for rtcp icetransport even if we haven't started it!
                        _that.iceTransport.stop();
                        //        }
                        _that.iceTransport = null;
                        _that.iceGatherer = null;
                        if (_deferredLocalCandidates.isPending()) {
                            _deferredLocalCandidates.reject(new Error('operation canceled due to stop'));
                        }
                        if (_iceCompletedCb) {
                            _iceCompletedCb.dispose();
                        }
                    };
                    this.iceGatherer.onlocalcandidate = function (event) {
                        _logger.log('RTCIceGatherer.onlocalcandidate', 'candidate:', JSON.stringify(event.candidate));
                        if (Object.keys(event.candidate).length === 0) {
                            _deferredLocalCandidates.resolve();
                        }
                    };
                    this.iceGatherer.onerror = function (event) {
                        _logger.error('RTCIceGatherer.onerror', 'event:', event);
                        _deferredLocalCandidates.reject(new Error('IceGatherer failed!'));
                    };
                    this.iceTransport.onicestatechange = function () {
                        if (_that.iceTransport) {
                            _logger.log('RTCIceTransport.onicestatechange', 'state:', _that.iceTransport.state);
                            if (_that.iceTransport.state === 'completed') {
                                _logger.log('pair:', JSON.stringify(_that.iceTransport.getNominatedCandidatePair()));
                                _that.nominatedCandidatePair = _that.iceTransport.getNominatedCandidatePair();
                                _iceCompletedCb.iceCompleted();
                            }
                            // end call when audio transport gets disconnected!
                            if (_type === 'audio' && _that.iceTransport.state === 'disconnected') {
                                _logger.error('audio ICE transport disconnected, ending call!');
                                _raiseError({
                                    type: constants_1["default"].MEDIA_ERROR.iceConnectionError,
                                    detail: 'ice transport disconnected'
                                });
                            }
                        }
                    };
                    this.iceTransport.oncandidatepairchange = function (event) {
                        _logger.log('RTCIceTransport.oncandidatepairchange', 'event:', event);
                    };
                }
                function DtlsTransport(_logger, _iceTransport, _raiseError) {
                    var _that = this;
                    var _started = false;
                    this.dtlsTransport = new RTCDtlsTransport(_iceTransport);
                    this.dtlsTransport.ondtlsstatechange = function () {
                        _logger.log('RTCDtlsTransport.ondtlsstatechange', 'state:', event.state, 'role:', _that.dtlsTransport ? _that.dtlsTransport.getLocalParameters().role : '');
                    };
                    this.dtlsTransport.onerror = function (event) {
                        _logger.error('RTCDtlsTransport.onerror', 'event:', event);
                        _raiseError({
                            type: constants_1["default"].MEDIA_ERROR.srtpError,
                            detail: event
                        });
                    };
                    this.startAsync = function (remoteDtlsParams) {
                        if (_started) {
                            throw new Error('already started!');
                        }
                        _started = true;
                        _logger.log('RTCDtlsTransport.start', 'params:', JSON.stringify(remoteDtlsParams));
                        _that.dtlsTransport.start(remoteDtlsParams);
                        return Promise.resolve();
                    };
                    this.dispose = function () {
                        if (_started) {
                            _that.dtlsTransport.stop();
                        }
                        _that.dtlsTransport = null;
                    };
                }
                function MediaTransport(_type, _logger, _iceCompletionMonitor, _raiseError, _iceOptions, _enableRtcpDemux) {
                    var _iceTransport, _rtcpIceTransport, _dtlsTransport;
                    var _started = false;
                    _iceTransport = new IceTransport(_type, _logger.createChild('IceT'), _iceCompletionMonitor, _raiseError, _iceOptions);
                    _dtlsTransport = new DtlsTransport(_logger.createChild('DtlsT'), _iceTransport.iceTransport, _raiseError);
                    if (_enableRtcpDemux) {
                        _rtcpIceTransport = new IceTransport(_type, _logger.createChild('RtcpIceT'), _iceCompletionMonitor, _raiseError, _iceOptions, _iceTransport.iceGatherer, _iceTransport.iceTransport);
                    }
                    Object.defineProperty(this, 'iceTransport', {
                        get: function () {
                            return _iceTransport.iceTransport;
                        }
                    });
                    Object.defineProperty(this, 'dtlsTransport', {
                        get: function () {
                            return _dtlsTransport ? _dtlsTransport.dtlsTransport : null;
                        }
                    });
                    function _filterCandidates(candidates) {
                        var filtered = candidates;
                        if (_iceOptions.iceCandidateType || _iceOptions.iceCandidateTransport) {
                            filtered = filtered.filter(function (candidate) {
                                var typeOk = true, transportOk = true;
                                if (_iceOptions.iceCandidateType) {
                                    typeOk = candidate.type.match(new RegExp(_iceOptions.iceCandidateType), 'i');
                                }
                                if (_iceOptions.iceCandidateTransport) {
                                    transportOk = candidate.protocol.match(new RegExp(_iceOptions.iceCandidateTransport, 'i'));
                                }
                                return typeOk && transportOk;
                            });
                        }
                        // EDGE is leaking user's IP address even tho the iceTransportPolicy is set to RELAY only
                        // http://skype.vso.io/721760)
                        if (_iceOptions.iceGathererOptions.gatherPolicy === constants_1["default"].ICE_TRANSPORT_POLICY.relay) {
                            filtered.forEach(function (filteredCandidate) {
                                filteredCandidate.relatedAddress = filteredCandidate.ip;
                                filteredCandidate.relatedPort = filteredCandidate.port;
                            });
                        }
                        return filtered;
                    }
                    function _getLocalParams() {
                        return {
                            iceParams: _iceTransport.iceGatherer.getLocalParameters(),
                            iceCandidates: _filterCandidates(_iceTransport.iceGatherer.getLocalCandidates()),
                            iceCandidatePair: _iceTransport.nominatedCandidatePair,
                            dtlsParams: _dtlsTransport ? _dtlsTransport.dtlsTransport.getLocalParameters() : null,
                            rtcpIceParams: _rtcpIceTransport ? _rtcpIceTransport.iceGatherer.getLocalParameters() : null,
                            rtcpIceCandidates: _rtcpIceTransport ? _filterCandidates(_rtcpIceTransport.iceGatherer.getLocalCandidates()) : null,
                            rtcpIceCandidatePair: _rtcpIceTransport ? _rtcpIceTransport.nominatedCandidatePair : null
                        };
                    }
                    this.getLocalParamsAsync = function () {
                        var getParamsPromise;
                        if (_rtcpIceTransport) {
                            getParamsPromise = Promise.all([_iceTransport.getLocalCandidatesAsync(), _rtcpIceTransport.getLocalCandidatesAsync()]);
                        }
                        else {
                            getParamsPromise = _iceTransport.getLocalCandidatesAsync();
                        }
                        return getParamsPromise.then(function () {
                            return _getLocalParams();
                        });
                    };
                    this.startAsync = function (remoteParams) {
                        if (_started) {
                            throw new Error('already started!');
                        }
                        var ret = Promise.resolve();
                        _started = true;
                        _iceTransport.start(remoteParams.iceCandidates, remoteParams.iceParams);
                        if (_rtcpIceTransport) {
                            if (!remoteParams.doRtcpMux) {
                                _rtcpIceTransport.start(remoteParams.rtcpIceCandidates, remoteParams.rtcpIceParams);
                            }
                            else {
                                _rtcpIceTransport.dispose();
                                _rtcpIceTransport = null;
                            }
                        }
                        if (remoteParams.enableDtls) {
                            ret = _dtlsTransport.startAsync(remoteParams.dtlsParams);
                        }
                        return ret;
                    };
                    // call this before throwing the object away
                    this.dispose = function () {
                        _logger.log('dispose');
                        _iceTransport.dispose();
                        _iceTransport = null;
                        if (_rtcpIceTransport) {
                            _rtcpIceTransport.dispose();
                            _rtcpIceTransport = null;
                        }
                        if (_dtlsTransport) {
                            _dtlsTransport.dispose();
                            _dtlsTransport = null;
                        }
                    };
                }
                function IceCompletionMonitor(_logger, _transportCb) {
                    var _callbacks = [];
                    var _triggeredIceReinvite = false;
                    var _deferredWaitCallbacks = helper_1["default"].defer();
                    var _controllingTransportCount = 0;
                    function Callback(_iceRole) {
                        this.dispose = function () {
                            utils_1["default"].remove(_callbacks, function (value) {
                                return value === this;
                            });
                        };
                        this.gotCallback = false;
                        this.iceCompleted = function () {
                            this.gotCallback = true;
                            this.gotCallbackFromControlling = _iceRole === 'controlling';
                            var arrivedCallbacs = 0;
                            var arrivedCallbacsFromControlling = 0;
                            for (var i = 0; i < _callbacks.length; i++) {
                                if (_callbacks[i].gotCallback) {
                                    arrivedCallbacs++;
                                }
                                if (_callbacks[i].gotCallbackFromControlling) {
                                    arrivedCallbacsFromControlling++;
                                }
                            }
                            if (arrivedCallbacsFromControlling && arrivedCallbacsFromControlling === _controllingTransportCount && !_triggeredIceReinvite) {
                                _logger.log('IceCompletionMonitor REINVITE');
                                _triggeredIceReinvite = true;
                                _transportCb.triggerIceReinvite();
                            }
                            if (arrivedCallbacs && arrivedCallbacs === _callbacks.length) {
                                _logger.log('IceCompletionMonitor ALL COMPLETE');
                                _deferredWaitCallbacks.resolve();
                            }
                        };
                    }
                    this.createCb = function (iceRole) {
                        var cb = new Callback(iceRole);
                        _callbacks.push(cb);
                        if (iceRole === 'controlling') {
                            _triggeredIceReinvite = false;
                            _controllingTransportCount++;
                        }
                        // reset promise. nobody should be waiting at this point actually
                        _deferredWaitCallbacks.reject(undefined);
                        _deferredWaitCallbacks = helper_1["default"].defer();
                        return cb;
                    };
                    this.waitAllCallbacksAsync = function () {
                        return _deferredWaitCallbacks.promise;
                    };
                }
                function OrtcTransport(_logger, _settings, _transportCb, _relayMgr, _isRemoteClientLync, _iceTransportPolicy, _enableRtcpDemux) {
                    var _aTransport, _vTransport, _sTransport;
                    var _startedModalities = [false, false];
                    var _iceTransportPolicy = _iceTransportPolicy ? _iceTransportPolicy : constants_1["default"].ICE_TRANSPORT_POLICY.all;
                    var _iceCompletionMonitor = new IceCompletionMonitor(_logger, _transportCb);
                    var _relayPromise;
                    Object.defineProperty(this, 'audioTransport', {
                        get: function () { return _aTransport ? _aTransport : null; }
                    });
                    Object.defineProperty(this, 'videoTransport', {
                        get: function () { return _vTransport ? _vTransport : null; }
                    });
                    Object.defineProperty(this, 'screensharingTransport', {
                        get: function () { return _sTransport ? _sTransport : null; }
                    });
                    function _queryRelaysAsync() {
                        if (!_relayPromise) {
                            _relayPromise = _relayMgr.queryRelaysAsync('msturn', _isRemoteClientLync);
                        }
                        return _relayPromise;
                    }
                    this.assureInitAsync = function (iceRole, modalities) {
                        return new Promise(function (resolve) {
                            _logger.log('assureInitAsync');
                            var ret = _queryRelaysAsync().then(function (relays) {
                                var iceOptions = {
                                    iceRole: iceRole,
                                    iceCandidateType: _settings.iceCandidateType,
                                    iceCandidateTransport: _settings.iceCandidateTransport,
                                    iceGathererOptions: {
                                        'gatherPolicy': _iceTransportPolicy,
                                        'iceServers': relays.reduce(function (arr, relay) {
                                            //todo: urls can be string or sequence (array) thus we can merge two iceServers elements in to single one
                                            relay.addresses.map(function (address) {
                                                arr.push({
                                                    urls: relay.type + ':' + address + ':' + relay.udpPort + '?transport=udp',
                                                    credential: relay.password,
                                                    username: relay.username
                                                });
                                                arr.push({
                                                    urls: relay.type + ':' + address + ':' + relay.tcpPort + '?transport=tcp',
                                                    credential: relay.password,
                                                    username: relay.username
                                                });
                                            });
                                            return arr;
                                        }, [])
                                    }
                                };
                                if (!_aTransport && modalities[0]) {
                                    _logger.log('assureInitAsync AUDIO ' + iceOptions.iceRole);
                                    _aTransport = new MediaTransport('audio', _logger.createChild('AT'), _iceCompletionMonitor, _transportCb.raiseError, iceOptions, _enableRtcpDemux);
                                }
                                if (!_vTransport && modalities[1]) {
                                    _logger.log('assureInitAsync VIDEO ' + iceOptions.iceRole);
                                    _vTransport = new MediaTransport('video', _logger.createChild('VT'), _iceCompletionMonitor, _transportCb.raiseError, iceOptions, _enableRtcpDemux);
                                }
                                if (!_sTransport && modalities[2]) {
                                    _logger.log('assureInitAsync SCREENSHARING ' + iceOptions.iceRole);
                                    _sTransport = new MediaTransport('video', _logger.createChild('ST'), _iceCompletionMonitor, _transportCb.raiseError, iceOptions, _enableRtcpDemux);
                                }
                            });
                            resolve(ret);
                        });
                    };
                    // gather local candidates and other params
                    this.getLocalParamsAsync = function () {
                        _logger.log('getLocalParamsAsync');
                        return new Promise(function (resolve) {
                            var aPromise = Promise.resolve(), vPromise = Promise.resolve(), sPromise = Promise.resolve();
                            if (_aTransport) {
                                aPromise = _aTransport.getLocalParamsAsync();
                            }
                            if (_vTransport) {
                                vPromise = _vTransport.getLocalParamsAsync();
                            }
                            if (_sTransport) {
                                sPromise = _sTransport.getLocalParamsAsync();
                            }
                            resolve(Promise.all([aPromise, vPromise, sPromise]));
                        });
                    };
                    this.waitIceCompletionIfNeededAsync = function (remoteParams) {
                        return new Promise(function (resolve) {
                            var ret = '';
                            // if remote offer contained candidate pair then need to wait ice completed state before sending answer!
                            if ((remoteParams[0] && remoteParams[0].iceCandidatePair) || (remoteParams[1] && remoteParams[1].iceCandidatePair)) {
                                _logger.log('waiting ICE completed state!');
                                ret = _iceCompletionMonitor.waitAllCallbacksAsync();
                            }
                            resolve(ret);
                        });
                    };
                    this.configureTransportAsync = function (remoteParams, modalities) {
                        return new Promise(function (resolve) {
                            var aPromise = Promise.resolve(), vPromise = Promise.resolve(), sPromise = Promise.resolve();
                            if (modalities[0] && !_startedModalities[0]) {
                                aPromise = _aTransport.startAsync(remoteParams[0]);
                            }
                            else if (!modalities[0] && _startedModalities[0]) {
                                _aTransport.dispose();
                                _aTransport = null;
                            }
                            if (modalities[1] && !_startedModalities[1]) {
                                vPromise = _vTransport.startAsync(remoteParams[1]);
                            }
                            else if (!modalities[1] && _startedModalities[1]) {
                                _vTransport.dispose();
                                _vTransport = null;
                            }
                            if (modalities[2] && !_startedModalities[2]) {
                                sPromise = _sTransport.startAsync(remoteParams[2]);
                            }
                            else if (!modalities[2] && _startedModalities[2]) {
                                _sTransport.dispose();
                                _sTransport = null;
                            }
                            _startedModalities = modalities;
                            resolve(Promise.all([aPromise, vPromise, sPromise]));
                        });
                    };
                    // call this before throwing the object away
                    this.stop = function () {
                        if (_aTransport) {
                            _aTransport.dispose();
                            _aTransport = null;
                        }
                        if (_vTransport) {
                            _vTransport.dispose();
                            _vTransport = null;
                        }
                        if (_sTransport) {
                            _sTransport.dispose();
                            _sTransport = null;
                        }
                    };
                }
                exports.__esModule = true;
                exports["default"] = OrtcTransport;
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/ortc/ortcHelper', ["require", "exports", '../constants', '../helper', '../common/utils'], factory);
                }
            })(function (require, exports) {
                var constants_1 = require('../constants');
                var helper_1 = require('../helper');
                var utils_1 = require('../common/utils');
                function compareStr(a, b) {
                    return a.toLowerCase() === b.toLowerCase();
                }
                function getStateFromDescr(descr) {
                    if (descr.enabled) {
                        if (descr.send && descr.recv) {
                            return constants_1["default"].MEDIA_STATE.sendReceive;
                        }
                        else if (descr.send) {
                            return constants_1["default"].MEDIA_STATE.send;
                        }
                        else if (descr.recv) {
                            return constants_1["default"].MEDIA_STATE.receive;
                        }
                        else {
                            return constants_1["default"].MEDIA_STATE.inactive;
                        }
                    }
                    else {
                        return null;
                    }
                }
                function getTransportIdxForLabel(label) {
                    var transportIdx;
                    if (label === constants_1["default"].MEDIA_LABEL.audio) {
                        return 0;
                    }
                    if (label === constants_1["default"].MEDIA_LABEL.video) {
                        return 1;
                    }
                    if (label === constants_1["default"].MEDIA_LABEL.screensharing) {
                        return 2;
                    }
                    throw new Error('unsupported label: ' + label);
                }
                function getTypeForLabel(label) {
                    if (label === constants_1["default"].MEDIA_LABEL.audio) {
                        return constants_1["default"].MEDIA_TYPE.audio;
                    }
                    if (label === constants_1["default"].MEDIA_LABEL.video) {
                        return constants_1["default"].MEDIA_TYPE.video;
                    }
                    if (label === constants_1["default"].MEDIA_LABEL.screensharing) {
                        return constants_1["default"].MEDIA_TYPE.video;
                    }
                    throw new Error('unsupported label: ' + label);
                }
                function getDescrFromState(state, label) {
                    return {
                        enabled: !!state,
                        type: getTypeForLabel(label),
                        label: label,
                        send: helper_1["default"].hasSendDirectionality(state),
                        recv: helper_1["default"].hasReceiveDirectionality(state)
                    };
                }
                function findDescrFromMedia(media, label) {
                    for (var i = 0; i < media.length; i++) {
                        if (media[i].descr.label === label) {
                            return media[i].descr;
                        }
                    }
                    return {
                        enabled: false,
                        type: getTypeForLabel(label),
                        label: label,
                        send: false,
                        recv: false
                    };
                }
                function getModalitiesFromMedia(mediaParams) {
                    var modalities = {};
                    var audioDescr = findDescrFromMedia(mediaParams, constants_1["default"].MEDIA_LABEL.audio);
                    var videoDescr = findDescrFromMedia(mediaParams, constants_1["default"].MEDIA_LABEL.video);
                    var screensharingDescr = findDescrFromMedia(mediaParams, constants_1["default"].MEDIA_LABEL.screensharing);
                    if (audioDescr.enabled) {
                        modalities.audio = getStateFromDescr(audioDescr);
                    }
                    if (videoDescr.enabled) {
                        modalities.video = getStateFromDescr(videoDescr);
                    }
                    if (screensharingDescr.enabled) {
                        modalities.screensharing = getStateFromDescr(screensharingDescr);
                    }
                    return modalities;
                }
                function codecByPayload(payload, codecs) {
                    return utils_1["default"].find(codecs, function (codec, index, codecs) {
                        if (codec.preferredPayloadType === +payload) {
                            return true;
                        }
                    });
                }
                ;
                function getCodecIndexByPayload(payload, codecs) {
                    return utils_1["default"].findIndex(codecs, function (codec, index, codecs) {
                        if (codec.preferredPayloadType === payload) {
                            return true;
                        }
                    });
                }
                ;
                function codecByName(name, codecs) {
                    return utils_1["default"].find(codecs, function (codec, index, codecs) {
                        if (compareStr(codec.name, name)) {
                            return true;
                        }
                    });
                }
                ;
                function codecNameByPayload(payload, codecs) {
                    return codecByPayload(payload, codecs).name;
                }
                function matchCodecCaps(local, remote, useLocalPayloadType, isSender) {
                    var codecs = [];
                    if (local && remote) {
                        // processing all codecs except rtx
                        local.filter(function (lcodec) { return !compareStr(lcodec.name, 'rtx'); }).forEach(function (lcodec) {
                            for (var i = 0; i < remote.length; i++) {
                                var rcodec = remote[i];
                                if (compareStr(lcodec.name, rcodec.name) &&
                                    compareStr(lcodec.kind, rcodec.kind) &&
                                    lcodec.numChannels === rcodec.numChannels &&
                                    lcodec.clockRate === rcodec.clockRate) {
                                    var codec = utils_1["default"].shallowClone(isSender ? rcodec : lcodec);
                                    codec.preferredPayloadType = useLocalPayloadType ? lcodec.preferredPayloadType : rcodec.preferredPayloadType;
                                    codecs.push(codec);
                                    break;
                                }
                            }
                        });
                        // now processing rtx codecs only
                        local.filter(function (lcodec) { return compareStr(lcodec.name, 'rtx'); }).forEach(function (lcodec) {
                            for (var i = 0; i < remote.length; i++) {
                                var rcodec = remote[i];
                                if (compareStr(lcodec.name, rcodec.name) &&
                                    compareStr(lcodec.kind, rcodec.kind) &&
                                    lcodec.numChannels === rcodec.numChannels &&
                                    lcodec.clockRate === rcodec.clockRate &&
                                    compareStr(codecNameByPayload(lcodec.parameters.apt, local), codecNameByPayload(rcodec.parameters.apt, remote))) {
                                    // here we need to assign correct payload based on what is written in _codecs_ -
                                    // not local/remote and save it in parameters.apt
                                    var codec = utils_1["default"].shallowClone(isSender ? rcodec : lcodec);
                                    codec.preferredPayloadType = useLocalPayloadType ? lcodec.preferredPayloadType : rcodec.preferredPayloadType;
                                    codec.parameters.apt = codecByName(codecByPayload(lcodec.parameters.apt, local).name, codecs).preferredPayloadType;
                                    codecs.push(codec);
                                    break;
                                }
                            }
                        });
                        return codecs;
                    }
                    ;
                }
                function findMatchingSdesParams(localSdesParamsList, remoteSdesParamsList) {
                    //NB! this function is not fully complete and it depends on the order of the elements in the lists as first successful match is taken
                    function _doSdesParamsMatch(a, b) {
                        var aKeyParams0 = a.keyParams[0];
                        var bKeyParams0 = b.keyParams[0];
                        return a.cryptoSuite === b.cryptoSuite && aKeyParams0.mkiLength === bKeyParams0.mkiLength && aKeyParams0.mkiValue === bKeyParams0.mkiValue;
                    }
                    for (var i = 0; i < remoteSdesParamsList.length; ++i) {
                        var sdesRemote = remoteSdesParamsList[i];
                        for (var j = 0; j < localSdesParamsList.length; ++j) {
                            var sdesLocal = localSdesParamsList[j];
                            if (_doSdesParamsMatch(sdesRemote, sdesLocal)) {
                                return {
                                    localSdesParams: utils_1["default"].shallowClone(sdesLocal),
                                    remoteSdesParams: utils_1["default"].shallowClone(sdesRemote)
                                };
                            }
                        }
                    }
                    return null;
                }
                function matchHeaderExtensions(local, remote) {
                    var hrdExtPrms = [];
                    if (local && remote) {
                        local.forEach(function (lenc) {
                            for (var i = 0; i < remote.length; i++) {
                                var renc = remote[i];
                                if (lenc.kind === renc.kind && lenc.uri === renc.uri) {
                                    hrdExtPrms.push(lenc);
                                }
                            }
                        });
                    }
                    return hrdExtPrms;
                }
                function matchRtpCaps(local, remote, useLocalPayloadType, isSender) {
                    var rtpCaps = null;
                    if (local && remote) {
                        rtpCaps = {
                            codecs: matchCodecCaps(local.codecs, remote.codecs, useLocalPayloadType, isSender),
                            headerExtensions: matchHeaderExtensions(local.headerExtensions, remote.headerExtensions),
                            fecMechanisms: local.fecMechanisms.filter(function (n) {
                                return remote.fecMechanisms.indexOf(n) !== -1;
                            })
                        };
                    }
                    return rtpCaps;
                }
                function getSendParams(rtpCaps, ssrcRange, rtcpSsrc, rtcpReducecdSize, doRtcpMux, rtxSsrc) {
                    return RTCRtpParameters(// eslint-disable-line new-cap
                    '', codecCapsToCodecParams(rtpCaps.codecs), hdrExtToHdrExtParams(rtpCaps.headerExtensions), getEncParams(ssrcRange, rtxSsrc), RTCRtcpParameters(rtcpSsrc, '', rtcpReducecdSize, doRtcpMux)); // eslint-disable-line new-cap
                }
                function getRecvParams(rtpCaps, ssrcRange, rtcpSsrc, rtcpReducecdSize, doRtcpMux, rtxSsrc) {
                    return getSendParams(rtpCaps, ssrcRange, rtcpSsrc, rtcpReducecdSize, doRtcpMux, rtxSsrc);
                }
                function codecCapsToCodecParams(codecCaps) {
                    var codecPrms = [];
                    codecCaps.forEach(function (codec) {
                        codecPrms.push(RTCRtpCodecParameters(codec.name, codec.preferredPayloadType, // eslint-disable-line new-cap
                        codec.clockRate, codec.numChannels, codec.rtcpFeedback, codec.parameters, codec.ptime, codec.maxptime));
                    });
                    return codecPrms;
                }
                function hdrExtToHdrExtParams(hdrExt) {
                    var hrdExtPrms = [];
                    hdrExt.forEach(function (enc) {
                        hrdExtPrms.push(RTCRtpHeaderExtensionParameters(enc.uri, enc.preferredId, enc.preferredEncrypt)); // eslint-disable-line new-cap
                    });
                    return hrdExtPrms;
                }
                function getEncParams(ssrcRange, rtxSsrc) {
                    var encPrms = [];
                    encPrms.push(RTCRtpEncodingParameters(ssrcRange, 0, 0, rtxSsrc, 1.0)); // eslint-disable-line new-cap
                    return encPrms;
                }
                function RTCRtpParameters(inMuxId, inCodecs, inHeaderExtensions, inEncodings, inRtcp) {
                    return {
                        muxId: inMuxId || '',
                        codecs: inCodecs,
                        headerExtensions: inHeaderExtensions,
                        encodings: inEncodings,
                        rtcp: inRtcp,
                        degradationPreference: 'balanced'
                    };
                }
                function RTCRtpCodecParameters(inName, inPayloadType, inClockRate, inNumChannels, inRtcpFeedback, inParameters, ptime, maxptime) {
                    return {
                        name: inName,
                        payloadType: inPayloadType,
                        clockRate: inClockRate,
                        numChannels: inNumChannels,
                        rtcpFeedback: inRtcpFeedback,
                        parameters: inParameters,
                        ptime: ptime,
                        maxptime: maxptime
                    };
                }
                function RTCRtpHeaderExtensionParameters(uri, id, encrypt) {
                    return {
                        uri: uri,
                        id: id,
                        encrypt: encrypt
                    };
                }
                function RTCRtcpParameters(inSsrc, inCname, inReducecdSize, inMux) {
                    return {
                        ssrc: inSsrc,
                        cname: inCname,
                        reducedSize: inReducecdSize,
                        mux: inMux
                    };
                }
                function hasRtx(codecs) {
                    return codecs.some(function (codec) { return compareStr(codec.name, 'rtx'); });
                }
                function getRtxSsrc(rtpCaps, localParams, remoteParams, isSender) {
                    // we need to check if we have a rtx codec in rtpCaps.codecs and reset rtcSsrc to 0 or let it be
                    return hasRtx(rtpCaps.codecs) ? (isSender ? localParams.rtxSsrc : remoteParams.rtxSsrc) : 0;
                }
                function RTCRtpEncodingParameters(inSsrcRange, inCodecPayloadType, inFec, inRtx, inPriority, inMaxBitRate, inMinQuality, inFramerateBias, inResolutionScale, inFramerateScale, inQualityScale, inActive, inEncodingId, inDependencyEncodingIds) {
                    return {
                        ssrc: inSsrcRange.min,
                        ssrcRange: inSsrcRange,
                        codecPayloadType: inCodecPayloadType,
                        fec: inFec,
                        rtx: inRtx ? { ssrc: inRtx } : 0,
                        priority: inPriority || 1.0,
                        maxBitrate: inMaxBitRate,
                        minQuality: inMinQuality || 0,
                        framerateBias: inFramerateBias || 0.5,
                        resolutionScale: inResolutionScale || 1.0,
                        framerateScale: inFramerateScale || 1.0,
                        active: inActive || true,
                        encodingId: inEncodingId,
                        dependencyEncodingId: inDependencyEncodingIds
                    };
                }
                exports.__esModule = true;
                exports["default"] = {
                    getStateFromDescr: getStateFromDescr,
                    getDescrFromState: getDescrFromState,
                    getCodecIndexByPayload: getCodecIndexByPayload,
                    findDescrFromMedia: findDescrFromMedia,
                    getModalitiesFromMedia: getModalitiesFromMedia,
                    findMatchingSdesParams: findMatchingSdesParams,
                    matchRtpCaps: matchRtpCaps,
                    getSendParams: getSendParams,
                    getRecvParams: getRecvParams,
                    getTransportIdxForLabel: getTransportIdxForLabel,
                    RTCRtpCodecParameters: RTCRtpCodecParameters,
                    RTCRtpHeaderExtensionParameters: RTCRtpHeaderExtensionParameters,
                    RTCRtcpParameters: RTCRtcpParameters,
                    hasRtx: hasRtx,
                    getRtxSsrc: getRtxSsrc,
                    RTCRtpEncodingParameters: RTCRtpEncodingParameters
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/ortc/ortcChannelStats', ["require", "exports", '../helper', '../common/utils'], factory);
                }
            })(function (require, exports) {
                var helper_1 = require('../helper');
                var utils_1 = require('../common/utils');
                function OrtcChannelStats(context, transport, sender, receiver) {
                    var logger = context.logger.createChild('ChannelStats');
                    this.getReport = function () {
                        var report = {};
                        report.extended = {
                            mediaDiagnostic: {
                                reason: getMediaDiagnosticReason()
                            }
                        };
                        function updateReportWith(provider, name, msStats) {
                            if (!provider) {
                                return;
                            }
                            var taskName = name + '.' + (msStats ? 'msGetStats' : 'getStats');
                            var promise = new Promise(function (resolve) {
                                logger.log(taskName, 'start');
                                resolve(msStats ? provider.msGetStats() : provider.getStats());
                            }).then(function (stats) {
                                logger.log(taskName, 'complete');
                                report[name] = report[name] || {};
                                utils_1["default"].forOwn(stats, function (value) {
                                    // spec does not guarantee RTCStats.type to be unique, should we use value.id instead?
                                    report[name][value.type || value.msType] = value;
                                });
                            }).catch(function (error) {
                                logger.warn(taskName, 'failed:', error);
                                // terminate error
                            });
                            return helper_1["default"].timeout(promise, 5000, taskName).catch(function (error) {
                                logger.warn(taskName, 'failed:', error);
                                // terminate error
                            });
                        }
                        return new Promise(function (resolve) {
                            Promise.all([
                                updateReportWith(transport, 'iceTransport', false),
                                updateReportWith(transport, 'iceTransport', true),
                                updateReportWith(sender, 'sender', false),
                                updateReportWith(sender, 'sender', true),
                                updateReportWith(receiver, 'receiver', false),
                                updateReportWith(receiver, 'receiver', true)
                            ]).then(function () {
                                resolve(report);
                            }).catch(function (error) {
                                logger.error('getting statistics should never fail', error);
                                resolve(report);
                            });
                        });
                    };
                    function getMediaDiagnosticReason() {
                        if (!transport) {
                            return 'CheckNotCompleted';
                        }
                        var state = transport.state;
                        if (state === 'new' || state === 'checking' || state === 'connected') {
                            return 'CheckNotCompleted';
                        }
                        if (state === 'completed') {
                            return 'CheckSucceed';
                        }
                        if (state === 'failed') {
                            return 'CheckFailed';
                        }
                        if (state === 'disconnected' || state === 'closed') {
                            return 'MediaTimeout';
                        }
                        return 'Unknown DiagnosticReason';
                    }
                }
                exports.__esModule = true;
                exports["default"] = {
                    build: function (context, transport, sender, receiver) {
                        return new OrtcChannelStats(context, transport, sender, receiver);
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/ortc/ortcDtmfSender', ["require", "exports", '../common/dtmfUtils'], factory);
                }
            })(function (require, exports) {
                var DTMFUtils = require('../common/dtmfUtils');
                var OrtcDTMFSender = (function () {
                    function OrtcDTMFSender(logger, settings) {
                        this.queue = new DTMFUtils.DTMFQueue(logger);
                        this.settings = settings ? settings : DTMFUtils.defaultSettings;
                    }
                    OrtcDTMFSender.prototype.sendDtmf = function (sender, tones) {
                        if (!sender) {
                            return Promise.reject(new Error('bad sender'));
                        }
                        this.syncSender(sender);
                        if (!this.ortcSender.canInsertDTMF) {
                            return Promise.reject(new Error('not available'));
                        }
                        this.ortcSender.insertDTMF(this.ortcSender.toneBuffer + tones, this.settings.toneDuration, this.settings.toneGap);
                        return this.queue.waitForNotification(tones);
                    };
                    OrtcDTMFSender.prototype.canSendDtmf = function (sender) {
                        if (!sender) {
                            return false;
                        }
                        this.syncSender(sender);
                        return this.ortcSender ? this.ortcSender.canInsertDTMF : false;
                    };
                    OrtcDTMFSender.prototype.dispose = function () {
                        this.queue.cleanup();
                    };
                    OrtcDTMFSender.prototype.syncSender = function (sender) {
                        if (!this.ortcSender || this.ortcSender.sender !== sender) {
                            if (this.ortcSender) {
                                this.ortcSender.ontonechange = null;
                                this.queue.cleanup();
                                this.ortcSender = null;
                            }
                            this.ortcSender = new RTCDtmfSender(sender);
                            this.ortcSender.ontonechange = this.onToneChange.bind(this);
                        }
                    };
                    OrtcDTMFSender.prototype.onToneChange = function (event) {
                        if (event.tone) {
                            this.queue.toneSent(event.tone);
                        }
                    };
                    return OrtcDTMFSender;
                }());
                exports.OrtcDTMFSender = OrtcDTMFSender;
                exports.__esModule = true;
                exports["default"] = {
                    build: function (logger, settings) {
                        return new OrtcDTMFSender(logger, settings);
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/ortc/ortcMediaChannel', ["require", "exports", './ortcHelper', '../constants', './ortcChannelStats', '../common/utils', './ortcDtmfSender'], factory);
                }
            })(function (require, exports) {
                var ortcHelper_1 = require('./ortcHelper');
                var constants_1 = require('../constants');
                var ortcChannelStats_1 = require('./ortcChannelStats');
                var utils_1 = require('../common/utils');
                var ortcDtmfSender_1 = require('./ortcDtmfSender');
                function OrtcMediaChannel(_logger, _settings, _type, _label, _raiseError, _ssrcRange, maintainResolution) {
                    var _that = this;
                    var _rtpSender = null;
                    var _rtpReceiver = null;
                    var _recvTrack = null; // since RTCRtpReceiver.track each time returns new track instance, we need to cache it
                    var _currMediaStreamRef = null;
                    var _sdesTransport = null;
                    var _localSdesParamsList = null;
                    var _sendActive = false;
                    var _recvActive = false;
                    var _sendRemoteSsrc;
                    var _recvRemoteSsrc;
                    var _contributingSourcesPollingInterval = 1000;
                    var _lastSources = [];
                    var _dtmfSender = ortcDtmfSender_1["default"].build(_logger, _settings.dtmf);
                    this.type = _type;
                    this.label = _label;
                    this.subscribedMsi = constants_1["default"].MSI.unsubscribe; // unsubscribed
                    this.onContributingSourcesChanged = null;
                    if (!_settings.disableSdes) {
                        _localSdesParamsList = RTCSrtpSdesTransport.getLocalParameters().filter(_filterLocalSdesParamsList);
                    }
                    function _getLocalRtpCaps() {
                        // Assuming receiver and sender to return same capabilities
                        var rtpCaps = RTCRtpReceiver.getCapabilities(_type);
                        var i;
                        if (rtpCaps.codecs) {
                            if (_type === constants_1["default"].MEDIA_TYPE.audio && _settings.audioCodec) {
                                var keepCodecs = ['cn', 'red'];
                                utils_1["default"].remove(rtpCaps.codecs, function (value) {
                                    var codecName = value.name.toLowerCase();
                                    return codecName !== _settings.audioCodec.toLowerCase() && keepCodecs.indexOf(codecName) === -1;
                                });
                            }
                            else if (_type === constants_1["default"].MEDIA_TYPE.video && _settings.videoCodec) {
                                utils_1["default"].remove(rtpCaps.codecs, function (value) {
                                    return value.name.toLowerCase() !== _settings.videoCodec.toLowerCase();
                                });
                            }
                        }
                        if (_type === constants_1["default"].MEDIA_TYPE.audio) {
                            // workaround for chrome && firefox issue: if we offer opus with pt. 106, neither chrome nor firefox will work.
                            // They answer with opus pt. 106 also but actually fail to play back stream sent from Microsoft Edge
                            for (i = rtpCaps.codecs.length - 1; i >= 0; i--) {
                                if (rtpCaps.codecs[i].preferredPayloadType === 106) {
                                    rtpCaps.codecs[i].preferredPayloadType = 111;
                                    _logger.log('Opus payloadType fix, change payload type 106->111 for', rtpCaps.codecs[i].name);
                                }
                            }
                        }
                        return rtpCaps;
                    }
                    function _filterLocalSdesParamsList(elem) {
                        return elem.cryptoSuite !== 'SCALE_AES_CM_128_HMAC_SHA1_80'; //ignoring SCALE_AES_CM_128_HMAC_SHA1_80 cryptoscale for now because issues sending stream to MP
                    }
                    this.getLocalParameters = function () {
                        var rtpCaps = _getLocalRtpCaps();
                        var localParams = {
                            sdesParamsList: _localSdesParamsList,
                            rtpCaps: rtpCaps,
                            rtxSsrc: ortcHelper_1["default"].hasRtx(rtpCaps.codecs) ? _ssrcRange.min + 50 : 0,
                            ssrcRange: _ssrcRange
                        };
                        return {
                            sender: localParams,
                            receiver: utils_1["default"].deepClone(localParams)
                        };
                    };
                    function _replaceMediaStreamIfDifferent(mediaStreamRef) {
                        var tracks, currTrack, newTrack;
                        if (_isAudio()) {
                            currTrack = _currMediaStreamRef.getObject().getAudioTracks()[0];
                            tracks = mediaStreamRef.getObject().getAudioTracks();
                        }
                        else {
                            currTrack = _currMediaStreamRef.getObject().getVideoTracks()[0];
                            tracks = mediaStreamRef.getObject().getVideoTracks();
                        }
                        newTrack = tracks.length ? tracks[0] : null;
                        if (newTrack === null) {
                            _logger.error('media track is not available');
                            return;
                        }
                        var currDevId = currTrack.getSettings().deviceId;
                        var newDevId = newTrack.getSettings().deviceId;
                        if (currDevId !== newDevId) {
                            _logger.log('replacing media track', 'currDevID:', currDevId, 'newDevID:', newDevId, 'currTrackID:', currTrack.id, 'newTrackID:', newTrack.id);
                            _rtpSender.setTrack(newTrack);
                            _currMediaStreamRef.dispose();
                            _currMediaStreamRef = mediaStreamRef.clone();
                        }
                        else {
                            _logger.log('NOT replacing media track', 'currDevID:', currDevId, 'newDevID:', newDevId, 'currTrackID:', currTrack.id, 'newTrackID:', newTrack.id);
                        }
                    }
                    function _assureSdesTransport(iceTransport, negotiatedParams) {
                        if (!_sdesTransport) {
                            _logger.debug('RTCSrtpSdesTransport', 'local:', JSON.stringify(negotiatedParams.sdesParamsList[0]), 'remote:', JSON.stringify(negotiatedParams.remoteSdesParams));
                            _sdesTransport = new RTCSrtpSdesTransport(iceTransport, negotiatedParams.sdesParamsList[0], negotiatedParams.remoteSdesParams);
                            _sdesTransport.onerror = function (event) {
                                _logger.log('RTCSrtpSdesTransport.onerror', 'event:', event);
                                _raiseError({
                                    type: constants_1["default"].MEDIA_ERROR.srtpError,
                                    detail: event
                                });
                            };
                        }
                    }
                    function _isAudio() {
                        return _type === constants_1["default"].MEDIA_TYPE.audio;
                    }
                    function _isVideo() {
                        return _type === constants_1["default"].MEDIA_TYPE.video;
                    }
                    function _destroySdesTransport() {
                        if (_sdesTransport) {
                            _sdesTransport = null;
                        }
                    }
                    function _updateContributingSources() {
                        if (_recvActive && _rtpReceiver) {
                            var sources;
                            try {
                                sources = _rtpReceiver.getContributingSources();
                            }
                            catch (error) {
                                _logger.error('failed to retrieve contributing sources from receiver', 'error:', error);
                                return;
                            }
                            if (!sources) {
                                _logger.warn('could not retrieve contributing sources from receiver');
                                return;
                            }
                            sources = sources.map(function (source) {
                                return source.csrc;
                            });
                            var hasNotChanged = (_lastSources.length === sources.length) && sources.every(function (element, index) {
                                return element === _lastSources[index];
                            });
                            if (!hasNotChanged) {
                                _logger.debug('contributing sources changed', 'sources:', sources);
                                if (_that.onContributingSourcesChanged) {
                                    _that.onContributingSourcesChanged(sources);
                                }
                            }
                            _lastSources = sources;
                            setTimeout(_updateContributingSources, _contributingSourcesPollingInterval);
                        }
                        else {
                            _logger.debug('receiver is missing, stop polling for contributing sources');
                        }
                    }
                    function _requestSendCsrc(csrc) {
                        if (_recvActive && _rtpReceiver) {
                            _logger.log('_requestSendCsrc', 'csrc:', csrc);
                            try {
                                _rtpReceiver.requestSendCSRC(csrc);
                            }
                            catch (error) {
                                // TODO: treat this as an error and return false once requestSendCSRC API is supported in winmain
                                _logger.error('failed to request send csrc', 'error:', error);
                            }
                            return true;
                        }
                        return false;
                    }
                    function _createReceiver(mediaTransport, negotiatedMediaParams) {
                        _logger.log('_rtpReceiver create');
                        if (negotiatedMediaParams.enableDtls) {
                            if (negotiatedMediaParams.rtcpMux) {
                                _rtpReceiver = new RTCRtpReceiver(mediaTransport.dtlsTransport, _type);
                            }
                            else {
                                throw new Error('rtcpMux=false not supported with dtls!');
                            }
                        }
                        else {
                            _assureSdesTransport(mediaTransport.iceTransport, negotiatedMediaParams);
                            _rtpReceiver = new RTCRtpReceiver(_sdesTransport, _type);
                        }
                        _recvTrack = _rtpReceiver.track;
                        _rtpReceiver.onerror = function (event) {
                            _logger.error('_rtpReceiver.onerror', 'event:', event);
                            _raiseError({
                                type: constants_1["default"].MEDIA_ERROR.internalError,
                                detail: event
                            });
                        };
                    }
                    function _createSender(mediaTransport, mediaStreamRef, negotiatedMediaParams) {
                        var sendTrack;
                        if (_isAudio()) {
                            sendTrack = mediaStreamRef.getObject().getAudioTracks()[0];
                        }
                        else {
                            sendTrack = mediaStreamRef.getObject().getVideoTracks()[0];
                        }
                        _logger.log('_rtpSender create trackID:', sendTrack.id);
                        if (negotiatedMediaParams.enableDtls) {
                            if (negotiatedMediaParams.rtcpMux) {
                                _rtpSender = new RTCRtpSender(sendTrack.clone(), mediaTransport.dtlsTransport);
                            }
                            else {
                                throw new Error('rtcpMux=false not supported with dtls!');
                            }
                        }
                        else {
                            _assureSdesTransport(mediaTransport.iceTransport, negotiatedMediaParams);
                            _rtpSender = new RTCRtpSender(sendTrack.clone(), _sdesTransport);
                        }
                        if (_isAudio()) {
                            mediaStreamRef.onMute = function (doMute) {
                                if (_rtpSender) {
                                    _rtpSender.track.enabled = !doMute;
                                }
                            };
                        }
                        _rtpSender.onerror = function (event) {
                            _logger.error('_rtpSender.onerror', 'event:', event);
                            _raiseError({
                                type: constants_1["default"].MEDIA_ERROR.internalError,
                                detail: event
                            });
                        };
                        _rtpSender.onssrcconflict = function (event) {
                            _logger.error('_rtpSender.onssrcconflict', 'event:', event);
                        };
                    }
                    function _getRecvParams(negotiatedMediaParams) {
                        var params = ortcHelper_1["default"].getRecvParams(negotiatedMediaParams.rtpCaps, negotiatedMediaParams.remoteSsrcRange, _ssrcRange.min, negotiatedMediaParams.rtcpReducedSize, negotiatedMediaParams.rtcpMux, negotiatedMediaParams.rtxSsrc);
                        if (maintainResolution) {
                            // ORTC spec says that configuring degradation preference on RtpReceiver has no effect. The truth however is that it does have effect when used with MS specific RTCP extensions and H264UC codec.
                            params.degradationPreference = 'maintain-resolution';
                        }
                        params.encodings[0].active = _recvActive;
                        return params;
                    }
                    function _getSendParams(negotiatedMediaParams) {
                        var params = ortcHelper_1["default"].getSendParams(negotiatedMediaParams.rtpCaps, _ssrcRange, negotiatedMediaParams.remoteSsrcRange.min, negotiatedMediaParams.rtcpReducedSize, negotiatedMediaParams.rtcpMux, negotiatedMediaParams.rtxSsrc);
                        params.encodings[0].active = _sendActive;
                        return params;
                    }
                    function _configureReceiver(descr, mediaParams, mediaTransport) {
                        if (_rtpReceiver && _hasSsrcChanged(mediaParams.remoteSsrcRange, _recvRemoteSsrc)) {
                            _logger.log('SSRC changed, resetting receiver');
                            _stopReceiver();
                        }
                        if (!_rtpReceiver) {
                            _createReceiver(mediaTransport, mediaParams);
                            _recvRemoteSsrc = mediaParams.remoteSsrcRange;
                        }
                        _recvActive = !!descr.recv;
                        var recvParams = _getRecvParams(mediaParams);
                        _logger.debug('_rtpReceiver.receive:', JSON.stringify(recvParams));
                        _rtpReceiver.receive(recvParams);
                        if (_recvActive) {
                            if (_isAudio()) {
                                // contributing sources make sense for audio channels only
                                _updateContributingSources();
                            }
                            else if (_that.subscribedMsi !== constants_1["default"].MSI.unsubscribe) {
                                // clients managed to subscribe before video channel has been configured
                                _requestSendCsrc(_that.subscribedMsi);
                            }
                        }
                    }
                    function _stopReceiver() {
                        if (_rtpReceiver) {
                            _logger.log('_rtpReceiver stop & destroy');
                            _recvActive = false;
                            _recvTrack = null;
                            _rtpReceiver.stop();
                            _rtpReceiver = null;
                        }
                    }
                    function _configureSender(descr, mediaParams, mediaTransport, mediaStreamRef) {
                        if (_rtpSender && _hasSsrcChanged(mediaParams.remoteSsrcRange, _sendRemoteSsrc)) {
                            _logger.log('SSRC changed, resetting sender');
                            _stopSender();
                        }
                        _sendActive = !!descr.send;
                        if (_sendActive) {
                            if (_currMediaStreamRef) {
                                // media track may have been changed
                                _replaceMediaStreamIfDifferent(mediaStreamRef);
                            }
                            else {
                                _currMediaStreamRef = mediaStreamRef.clone();
                            }
                            if (!_rtpSender) {
                                _createSender(mediaTransport, _currMediaStreamRef, mediaParams);
                                _sendRemoteSsrc = mediaParams.remoteSsrcRange;
                            }
                            var sendParams = _getSendParams(mediaParams);
                            _logger.debug('_rtpSender.send:', JSON.stringify(sendParams));
                            _rtpSender.send(sendParams);
                        }
                        else {
                            _stopSender();
                            _disposeLocalStream();
                        }
                    }
                    function _stopSender() {
                        if (_dtmfSender) {
                            _dtmfSender.dispose();
                            _dtmfSender = null;
                        }
                        if (_rtpSender) {
                            _logger.log('_rtpSender stop & destroy');
                            _sendActive = false;
                            _rtpSender.stop();
                            _rtpSender = null;
                        }
                    }
                    function _disposeLocalStream() {
                        if (_currMediaStreamRef) {
                            _currMediaStreamRef.dispose();
                            _currMediaStreamRef = null;
                        }
                    }
                    function _hasSsrcChanged(newRemoteSsrcRange, oldRemoteSsrcRange) {
                        return oldRemoteSsrcRange && newRemoteSsrcRange && (newRemoteSsrcRange.min !== oldRemoteSsrcRange.min || newRemoteSsrcRange.max !== oldRemoteSsrcRange.max);
                    }
                    function _disable() {
                        _stopReceiver();
                        _stopSender();
                        _disposeLocalStream();
                        _destroySdesTransport();
                    }
                    this.configureChannel = function (mediaParams, mediaTransport, mediaStreamRef) {
                        _logger.log('configureChannel', 'type:', _type, 'descr:', JSON.stringify(mediaParams.descr));
                        if (mediaParams.descr.enabled) {
                            _configureReceiver(mediaParams.descr, mediaParams.receiver, mediaTransport);
                            _configureSender(mediaParams.descr, mediaParams.sender, mediaTransport, mediaStreamRef);
                        }
                        else {
                            _disable();
                        }
                    };
                    this.updateLocalMediaStream = function (mediaStreamRef) {
                        if (_rtpSender) {
                            _replaceMediaStreamIfDifferent(mediaStreamRef);
                        }
                    };
                    this.canSubscribe = function () {
                        return _recvActive && _rtpReceiver && _that.subscribedMsi === constants_1["default"].MSI.unsubscribe && _isVideo();
                    };
                    this.subscribe = function (msi) {
                        if (_that.subscribedMsi === constants_1["default"].MSI.unsubscribe && _isVideo()) {
                            _that.subscribedMsi = msi;
                            return _requestSendCsrc(_that.subscribedMsi);
                        }
                        throw new Error('invalid call for subscribe:' + _that.subscribedMsi + 'type:' + _type);
                    };
                    this.unsubscribe = function () {
                        if (_that.subscribedMsi === constants_1["default"].MSI.unsubscribe || !_isVideo()) {
                            throw new Error('invalid call for unsubscribe:' + _that.subscribedMsi + 'type:' + _type);
                        }
                        _that.subscribedMsi = constants_1["default"].MSI.unsubscribe;
                        _requestSendCsrc(_that.subscribedMsi);
                    };
                    this.getReportsAsync = function () {
                        var receiver = _recvActive ? _rtpReceiver : null, sender = _sendActive ? _rtpSender : null;
                        var iceTransport = receiver ? receiver.transport.transport : (sender ? sender.transport.transport : null);
                        var stats = ortcChannelStats_1["default"].build({
                            logger: _logger
                        }, iceTransport, sender, receiver);
                        return stats.getReport();
                    };
                    this.getSendTrack = function () {
                        return _sendActive && _rtpSender ? _rtpSender.track : null;
                    };
                    this.getRecvTrack = function () {
                        return _recvActive && _rtpReceiver ? _recvTrack : null;
                    };
                    this.terminate = function () {
                        _disable();
                        _logger.log('termiated');
                    };
                    this.sendDtmf = function (dtmfCode) {
                        return _dtmfSender.sendDtmf(_rtpSender, dtmfCode);
                    };
                    this.canSendDtmf = function () {
                        return _dtmfSender.canSendDtmf(_rtpSender);
                    };
                }
                exports.__esModule = true;
                exports["default"] = OrtcMediaChannel;
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/ortc/ortcNegotiation', ["require", "exports", './ortcHelper', '../constants', '../common/utils'], factory);
                }
            })(function (require, exports) {
                var ortcHelper_1 = require('./ortcHelper');
                var constants_1 = require('../constants');
                var utils_1 = require('../common/utils');
                function OrtcNegotiation(_logger, _settings, _numVideoChannels) {
                    this.processOffer = _processOffer;
                    this.createMediaDescriptorsForAnswer = _createMediaDescriptorsForAnswer;
                    this.createAnswer = _createAnswer;
                    this.createMediaDescriptorsForOffer = _createMediaDescriptorsForOffer;
                    this.createOffer = _createOffer;
                    this.processAnswer = _processAnswer;
                    this.completeNegotiation = _completeNegotiation;
                    var _offeredParams = null;
                    var _pendingNegotiatedParams = null;
                    var _negotiatedParams = null;
                    function _processOffer(offeredParams) {
                        _offeredParams = offeredParams;
                        _logger.debug('PROCESS OFFER', 'params:', JSON.stringify(_offeredParams));
                    }
                    function _negotiateMediaDescriptor(localDescr, remoteDescr) {
                        if (!remoteDescr) {
                            remoteDescr = { enabled: true, send: true, recv: true };
                        }
                        var send = localDescr.send && localDescr.enabled && remoteDescr.recv && remoteDescr.enabled;
                        var recv = localDescr.recv && localDescr.enabled && remoteDescr.send && remoteDescr.enabled;
                        // NB: put media into inactive only if someone explicitly specified inactive (enabled true, send false, recv false)
                        var enabled = localDescr.enabled && remoteDescr.enabled && (send || recv || (!localDescr.send && !localDescr.recv) || (!remoteDescr.send && !remoteDescr.recv));
                        return {
                            enabled: enabled,
                            type: localDescr.type,
                            label: localDescr.label,
                            send: send,
                            recv: recv
                        };
                    }
                    function _createMediaDescriptorsForAnswer(localModalities) {
                        // answer can't add anything, it's possible that remote side added something however
                        if (_negotiatedParams && _negotiatedParams.media.length > _offeredParams.media.length) {
                            throw new Error('Invalid remote offer - removed media lines');
                        }
                        var descrs = [];
                        var descr;
                        var audioAdded = false, screensharingAdded = false;
                        var videoAddedCnt = 0;
                        for (var i = 0; i < _offeredParams.media.length; i++) {
                            // things which are not supported
                            if (_negotiatedParams && _negotiatedParams.media[i]) {
                                if (_negotiatedParams.media[i].type !== _offeredParams.media[i].type) {
                                    throw new Error('Changing media type not supported'); // allowed by RFC but not supported here..
                                }
                                if (_negotiatedParams.media[i].label && _offeredParams.media[i].label && _negotiatedParams.media[i].label !== _offeredParams.media[i].label) {
                                    throw new Error('Changing media label not supported'); // allowed by RFC but not supported here..
                                }
                            }
                            if (_offeredParams.media[i].descr.label === constants_1["default"].MEDIA_LABEL.audio && !audioAdded) {
                                descr = _negotiateMediaDescriptor(ortcHelper_1["default"].getDescrFromState(localModalities.audio, constants_1["default"].MEDIA_LABEL.audio), _offeredParams.media[i].descr);
                                descrs.push(descr);
                                audioAdded = true;
                            }
                            else if (_offeredParams.media[i].descr.label === constants_1["default"].MEDIA_LABEL.video && videoAddedCnt < _numVideoChannels) {
                                descr = _negotiateMediaDescriptor(ortcHelper_1["default"].getDescrFromState(localModalities.video, constants_1["default"].MEDIA_LABEL.video), _offeredParams.media[i].descr);
                                //  send can be on only for first video channel
                                if (videoAddedCnt > 0) {
                                    descr.send = false;
                                }
                                descrs.push(descr);
                                videoAddedCnt++;
                            }
                            else if (_offeredParams.media[i].descr.label === constants_1["default"].MEDIA_LABEL.screensharing && !screensharingAdded) {
                                descr = _negotiateMediaDescriptor(ortcHelper_1["default"].getDescrFromState(localModalities.screensharing, constants_1["default"].MEDIA_LABEL.screensharing), _offeredParams.media[i].descr);
                                descrs.push(descr);
                                screensharingAdded = true;
                            }
                            else {
                                descrs.push({
                                    enabled: false,
                                    type: _offeredParams.media[i].descr.type,
                                    label: _negotiatedParams && _negotiatedParams.media[i] ? _negotiatedParams.media[i].descr.label : _offeredParams.media[i].descr.label // don't forget the label if we knew it before
                                });
                            }
                        }
                        return descrs;
                    }
                    function _createTransportParams(localTransportParams, remoteParams) {
                        var remoteTransportParams = remoteParams ? remoteParams.transportParams : [];
                        for (var i = 0; i < localTransportParams.length; i++) {
                            if (localTransportParams[i]) {
                                // by default prefer rtcp-mux. If other side asked for demux then use demux
                                localTransportParams[i].doRtcpMux = remoteTransportParams[i] && !remoteTransportParams[i].doRtcpMux ? false : true;
                            }
                            if (localTransportParams[i] && remoteTransportParams[i]) {
                                var canUseSdes = false;
                                // detect if we can use SDES - if it's not disabled locally and remote side had sdesParamsList
                                for (var m = 0; !_settings.disableSdes && m < remoteParams.media.length; m++) {
                                    if (remoteParams.media[m].receiver &&
                                        remoteParams.media[m].receiver.sdesParamsList &&
                                        remoteParams.media[m].receiver.sdesParamsList.length) {
                                        canUseSdes = true;
                                    }
                                }
                                if (remoteTransportParams[i].doRtcpMux) {
                                    localTransportParams[i].rtcpIceParams = null;
                                    localTransportParams[i].rtcpIceCandidates = null;
                                }
                                // since ortc doesn't set dtlstransport role correctly, need to overwrite it here based on remote parameters
                                // ortc always returns role 'auto' which is ok for first offer. For subsequent offers/answers need to use either 'client'
                                // or 'server' based on what's negotiated for this session(https://tools.ietf.org/html/rfc5763)
                                if (localTransportParams[i].dtlsParams && remoteTransportParams[i].dtlsParams) {
                                    localTransportParams[i].dtlsParams.role = remoteTransportParams[i].dtlsParams.role === 'client' ? 'server' : 'client';
                                }
                                // if sdes usage is possible, don't use dtls.
                                // Also no point to use dtls parameters if remote side didn't have dtls params
                                if (canUseSdes || !remoteTransportParams[i].dtlsParams) {
                                    localTransportParams[i].dtlsParams = null;
                                }
                            }
                            else {
                                // workaround for old clients which don't tolerate setup=actpass - in first offer never put setup (dtlsparams.role) attribute
                                if (localTransportParams[i] && localTransportParams[i].dtlsParams) {
                                    localTransportParams[i].dtlsParams.role = null;
                                }
                            }
                        }
                        return localTransportParams;
                    }
                    function _matchChannelParams(localChannelParams, remoteChannelParams, isOfferer, isSender) {
                        var matchingSdes;
                        var localParams = isSender ? localChannelParams.sender : localChannelParams.receiver;
                        var remoteParams = isSender ? remoteChannelParams.receiver : remoteChannelParams.sender;
                        if (localParams.sdesParamsList && remoteParams.sdesParamsList) {
                            matchingSdes = ortcHelper_1["default"].findMatchingSdesParams(localParams.sdesParamsList, remoteParams.sdesParamsList);
                        }
                        var sdesParamsList = [];
                        var remoteSdesParams;
                        if (matchingSdes) {
                            sdesParamsList.push(matchingSdes.localSdesParams);
                            remoteSdesParams = matchingSdes.remoteSdesParams;
                        }
                        var rtpCaps = ortcHelper_1["default"].matchRtpCaps(localParams.rtpCaps, remoteParams.rtpCaps, isOfferer, isSender);
                        return {
                            ssrcRange: localParams.ssrcRange,
                            remoteSsrcRange: remoteParams.ssrcRange,
                            rtxSsrc: ortcHelper_1["default"].getRtxSsrc(rtpCaps, localParams, remoteParams, isSender),
                            sdesParamsList: sdesParamsList,
                            remoteSdesParams: remoteSdesParams,
                            rtpCaps: rtpCaps
                        };
                    }
                    function _createMediaParams(descr, channelParams, justAdded, bundledWithOther, rtcpReducedSize) {
                        if (!descr.enabled) {
                            return { descr: descr };
                        }
                        else {
                            var params = channelParams;
                            params.sender.rtcpReducedSize = rtcpReducedSize;
                            params.receiver.rtcpReducedSize = rtcpReducedSize;
                            params.descr = descr;
                            params.justAdded = justAdded;
                            params.bundledWithOther = bundledWithOther;
                            return params;
                        }
                    }
                    function _createAnswer(descrs, localTransportParams, localMediaChannelParams, provisional) {
                        var answeredParams = {
                            isOffer: false,
                            sessionVersion: _offeredParams.sessionVersion,
                            transportParams: _createTransportParams(localTransportParams, _offeredParams),
                            media: []
                        };
                        var firstVideoChannelSeen = false;
                        for (var i = 0; i < descrs.length; i++) {
                            var bundledWithOther = firstVideoChannelSeen && descrs[i].label === constants_1["default"].MEDIA_LABEL.video; // video streams except 1st one
                            if (descrs[i].label === constants_1["default"].MEDIA_LABEL.video) {
                                firstVideoChannelSeen = true;
                            }
                            var channelParams = {};
                            var descr = utils_1["default"].shallowClone(descrs[i]);
                            if (descr.enabled) {
                                var transportIdx = ortcHelper_1["default"].getTransportIdxForLabel(descr.label);
                                var transportParams = answeredParams.transportParams[transportIdx];
                                var receiverChannelParams = _matchChannelParams(localMediaChannelParams[i], _offeredParams.media[i], false, false);
                                var senderChannelParams = _matchChannelParams(localMediaChannelParams[i], _offeredParams.media[i], false, true);
                                if (receiverChannelParams.sdesParamsList.length && receiverChannelParams.remoteSdesParams) {
                                    receiverChannelParams.sdesParamsList[0].tag = receiverChannelParams.remoteSdesParams.tag; // answer needs to contain selected tag from offer
                                }
                                if (senderChannelParams.sdesParamsList.length && senderChannelParams.remoteSdesParams) {
                                    senderChannelParams.sdesParamsList[0].tag = senderChannelParams.remoteSdesParams.tag;
                                }
                                channelParams.receiver = receiverChannelParams;
                                channelParams.sender = senderChannelParams;
                                if (!_verifyTransportAndMediaParams(descr, transportParams, channelParams.receiver) ||
                                    !_verifyTransportAndMediaParams(descr, transportParams, channelParams.sender)) {
                                    descr.enabled = false;
                                    _logger.warn('Rejecting media since unable to match parameters');
                                }
                            }
                            answeredParams.media.push(_createMediaParams(descr, channelParams, false, bundledWithOther, _offeredParams.media[i].receiver.rtcpReducedSize));
                        }
                        _logger.debug(provisional ? 'CREATE PRANSWER' : 'CREATE ANSWER', 'params:', JSON.stringify(answeredParams));
                        if (!provisional) {
                            _pendingNegotiatedParams = _verifyAndNegotiateParameters(answeredParams, _offeredParams, false);
                        }
                        return answeredParams;
                    }
                    function _createMediaDescriptorsForOffer(localModalities) {
                        var descrs = [];
                        var descr;
                        var audioAdded = false, screensharingAdded = false;
                        var videoAddedCnt = 0;
                        // first check if already negotiated sdp has slots for audio & video, if yes, reuse them. Also if it has some extra slots, make sure they are rejected
                        if (_negotiatedParams) {
                            for (var i = 0; i < _negotiatedParams.media.length; i++) {
                                if (_negotiatedParams.media[i].descr.label === constants_1["default"].MEDIA_LABEL.audio && !audioAdded) {
                                    descr = ortcHelper_1["default"].getDescrFromState(localModalities.audio, constants_1["default"].MEDIA_LABEL.audio);
                                    descrs.push(descr);
                                    audioAdded = true;
                                }
                                else if (_negotiatedParams.media[i].descr.label === constants_1["default"].MEDIA_LABEL.video && videoAddedCnt < _numVideoChannels) {
                                    descr = ortcHelper_1["default"].getDescrFromState(localModalities.video, constants_1["default"].MEDIA_LABEL.video); // results rejected if no localModalities.audio
                                    //  send can be on only for first video channel
                                    if (videoAddedCnt > 0) {
                                        descr.send = false;
                                    }
                                    descrs.push(descr);
                                    videoAddedCnt++;
                                }
                                else if (_negotiatedParams.media[i].descr.label === constants_1["default"].MEDIA_LABEL.screensharing && !screensharingAdded) {
                                    descr = ortcHelper_1["default"].getDescrFromState(localModalities.screensharing, constants_1["default"].MEDIA_LABEL.screensharing); //
                                    //  send can be on only for first channel
                                    descrs.push(descr);
                                    screensharingAdded = true;
                                }
                                else {
                                    descrs.push({
                                        enabled: false,
                                        type: _negotiatedParams.media[i].descr.type,
                                        label: _negotiatedParams.media[i].descr.label
                                    });
                                }
                            }
                        }
                        if (!audioAdded && localModalities.audio) {
                            descr = ortcHelper_1["default"].getDescrFromState(localModalities.audio, constants_1["default"].MEDIA_LABEL.audio); // results rejected if no localModalities.audio
                            descrs.push(descr);
                        }
                        if (!screensharingAdded && localModalities.screensharing) {
                            descr = ortcHelper_1["default"].getDescrFromState(localModalities.screensharing, constants_1["default"].MEDIA_LABEL.screensharing);
                            // results rejected if no localModalities.screensharing
                            descrs.push(descr);
                        }
                        for (var j = videoAddedCnt; j < _numVideoChannels && localModalities.video; j++) {
                            descr = ortcHelper_1["default"].getDescrFromState(localModalities.video, constants_1["default"].MEDIA_LABEL.video);
                            //  send can be on only for first video channel
                            if (j > 0) {
                                descr.send = false;
                            }
                            descrs.push(descr);
                        }
                        return descrs;
                    }
                    function _createOffer(descrs, localTransportParams, localMediaChannelParams) {
                        var offer = {
                            isOffer: true,
                            sessionVersion: _negotiatedParams ? _negotiatedParams.sessionVersion : 0,
                            transportParams: _createTransportParams(localTransportParams, _negotiatedParams),
                            media: []
                        };
                        var firstVideoChannelSeen = false;
                        for (var i = 0; i < descrs.length; i++) {
                            var isMediaEnabled = _negotiatedParams && _negotiatedParams.media[i] && _negotiatedParams.media[i].descr.enabled;
                            var mediaJustAdded = !isMediaEnabled && descrs[i].enabled;
                            var channelParams;
                            if (mediaJustAdded) {
                                channelParams = localMediaChannelParams[i];
                            }
                            else {
                                channelParams = _negotiatedParams.media[i];
                            }
                            var bundledWithOther = firstVideoChannelSeen && descrs[i].label === constants_1["default"].MEDIA_LABEL.video; // video streams except 1st one
                            if (descrs[i].label === constants_1["default"].MEDIA_LABEL.video) {
                                firstVideoChannelSeen = true;
                            }
                            offer.media.push(_createMediaParams(descrs[i], channelParams, mediaJustAdded, bundledWithOther, true));
                        }
                        _offeredParams = offer;
                        _logger.debug('CREATE OFFER', 'params:', JSON.stringify(_offeredParams));
                        return _offeredParams;
                    }
                    function _processAnswer(answeredParams) {
                        _logger.debug('PROCESS ANSWER', 'params:', JSON.stringify(answeredParams));
                        _pendingNegotiatedParams = _verifyAndNegotiateParameters(_offeredParams, answeredParams, true);
                    }
                    function _verifyTransportAndMediaParams(descr, transportParams, channelParams) {
                        if (descr.enabled) {
                            // no sdes params
                            if (!channelParams.sdesParamsList.length || !channelParams.remoteSdesParams) {
                                // also dtls not enabled or no dtls params
                                if (!transportParams.dtlsParams) {
                                    _logger.warn('no sdes nor dtls params:', channelParams.sdesParamsList, channelParams.remoteSdesParams, transportParams.dtlsParams);
                                    return false;
                                }
                            }
                            if (!channelParams.rtpCaps.codecs.length) {
                                _logger.warn('no common codecs!', channelParams.rtpCaps);
                                return false;
                            }
                        }
                        return true;
                    }
                    function _getNegotiatedTransportParams(localTransportP, remoteTransportP) {
                        var transportP = [];
                        for (var i = 0; i < Math.max(localTransportP.length, remoteTransportP.length); i++) {
                            var negotiatedP = null;
                            if (localTransportP[i] && remoteTransportP[i]) {
                                negotiatedP = utils_1["default"].shallowClone(remoteTransportP[i]);
                                negotiatedP.doRtcpMux = localTransportP[i].doRtcpMux && remoteTransportP[i].doRtcpMux;
                                negotiatedP.enableDtls = localTransportP[i].dtlsParams && remoteTransportP[i].dtlsParams;
                            }
                            transportP.push(negotiatedP);
                        }
                        return transportP;
                    }
                    function _getNegotiatedMediaParams(localMediaP, remoteMediaP, negotiatedTransportP, isOfferer) {
                        function composeParams(isSender) {
                            var localParams = isSender ? localMediaP.sender : localMediaP.receiver;
                            var remoteParams = isSender ? remoteMediaP.sender : remoteMediaP.receiver;
                            var params = _matchChannelParams(localMediaP, remoteMediaP, isOfferer, isSender);
                            params.rtcpMux = transportParams.doRtcpMux;
                            params.rtcpReducedSize = localParams.rtcpReducedSize && remoteParams.rtcpReducedSize;
                            params.enableDtls = transportParams.enableDtls;
                            return params;
                        }
                        var descr = _negotiateMediaDescriptor(localMediaP.descr, remoteMediaP.descr);
                        var mediaParams = { descr: descr };
                        if (descr.enabled) {
                            var transportIdx = ortcHelper_1["default"].getTransportIdxForLabel(descr.label);
                            var transportParams = negotiatedTransportP[transportIdx];
                            mediaParams.descr = descr;
                            mediaParams.sender = composeParams(true);
                            mediaParams.receiver = composeParams(false);
                            if (!_verifyTransportAndMediaParams(descr, transportParams, mediaParams.sender) ||
                                !_verifyTransportAndMediaParams(descr, transportParams, mediaParams.receiver)) {
                                throw new Error('Failed to verify negotiated parameters!');
                            }
                        }
                        return mediaParams;
                    }
                    function _verifyAndNegotiateParameters(localParams, remoteParams, isOfferer) {
                        if (localParams.media.length !== remoteParams.media.length) {
                            throw new Error('Number of media lines doesn\'t match in offer & answer l:' + localParams.media.length + ' r: ' + remoteParams.media.length);
                        }
                        var negotiatedParams = {
                            sessionVersion: isOfferer ? localParams.sessionVersion : remoteParams.sessionVersion,
                            transportParams: _getNegotiatedTransportParams(localParams.transportParams, remoteParams.transportParams),
                            media: []
                        };
                        for (var i = 0; i < localParams.media.length; i++) {
                            negotiatedParams.media.push(_getNegotiatedMediaParams(localParams.media[i], remoteParams.media[i], negotiatedParams.transportParams, isOfferer));
                        }
                        return negotiatedParams;
                    }
                    function _completeNegotiation() {
                        _pendingNegotiatedParams.sessionVersion++;
                        _negotiatedParams = _pendingNegotiatedParams;
                        _logger.debug('NEGOTIATED', 'params:', JSON.stringify(_negotiatedParams));
                        return _negotiatedParams;
                    }
                }
                exports.__esModule = true;
                exports["default"] = OrtcNegotiation;
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/ortc/ortcSdp', ["require", "exports", 'microsoft-sdp-transform', '../constants', './ortcHelper', '../common/utils', '../common/formatParameters'], factory);
                }
            })(function (require, exports) {
                var SdpT = require('microsoft-sdp-transform');
                var constants_1 = require('../constants');
                var ortcHelper_1 = require('./ortcHelper');
                var utils_1 = require('../common/utils');
                var formatParameters_1 = require('../common/formatParameters');
                function OrtcSdp() {
                    function _encodeExtensionUri(uri, isIncomingSdp) {
                        return isIncomingSdp ? uri.replace(/\\/g, '/') : uri.replace(/\//g, '\\');
                    }
                    function _compareStr(a, b) {
                        return a.toLowerCase() === b.toLowerCase();
                    }
                    function _isIpv4(ip) {
                        return ip.indexOf(':') === -1;
                    }
                    function _getHostIp(transportParams) {
                        var sortedCandidates = transportParams.iceCandidates.slice(0).sort(function (a, b) { return b.priority - a.priority; }); // sort descending by priority
                        for (var j = 0; j < sortedCandidates.length; j++) {
                            if (sortedCandidates[j].type === 'host') {
                                return sortedCandidates[j].ip;
                            }
                        }
                        return '0.0.0.0'; // this is error actually but we put it here to allow testing with removed host candidates (force relay)
                    }
                    function _getDirection(send, recv) {
                        if (send && recv) {
                            return 'sendrecv';
                        }
                        else if (send) {
                            return 'sendonly';
                        }
                        else if (recv) {
                            return 'recvonly';
                        }
                        else {
                            return 'inactive';
                        }
                    }
                    function _getTransport(protocol, tcpType) {
                        var p = protocol.toUpperCase();
                        if (p === 'TCP') {
                            switch (tcpType.toLowerCase()) {
                                case 'active':
                                    return 'TCP-ACT';
                                case 'passive':
                                    return 'TCP-PASS';
                                case 'so':
                                    return 'TCP-SO';
                            }
                        }
                        return p;
                    }
                    function _addCandidate(candidate, component, candidatesOut) {
                        candidatesOut.push({
                            foundation: candidate.foundation,
                            component: component,
                            transport: _getTransport(candidate.protocol, candidate.tcpType),
                            priority: candidate.priority,
                            ip: candidate.ip,
                            port: candidate.port,
                            type: candidate.type,
                            raddr: !_compareStr(candidate.type, 'host') ? candidate.relatedAddress : void 0,
                            rport: !_compareStr(candidate.type, 'host') ? candidate.relatedPort : void 0
                        });
                    }
                    function _addCandidates(candidatesIn, component, candidatesOut, candidatesIpv6Out) {
                        if (candidatesIn) {
                            candidatesIn.forEach(function (candidate) {
                                // ipv4
                                if (_isIpv4(candidate.ip)) {
                                    _addCandidate(candidate, component, candidatesOut);
                                }
                                else {
                                    _addCandidate(candidate, component, candidatesIpv6Out);
                                }
                            });
                        }
                    }
                    // rfc 5245 4.1.4 use local from this pair
                    // return candidates of the same foundation indexed by component id(rtp -> 0, rtcp - >1)
                    function _getDefaultCandidates(transportParams) {
                        // if candidate pair chosen, use local candidate from there
                        if (transportParams.iceCandidatePair) {
                            return { 0: transportParams.iceCandidatePair.local,
                                1: transportParams.rtcpIceCandidatePair ? transportParams.rtcpIceCandidatePair.local : null };
                        }
                        else {
                            // otherwise select highest priority candidate. NB: rfc 5245 says we should select relay or srflx candidate instead...
                            var sortedCandidates = transportParams.iceCandidates.slice(0).sort(function (a, b) { return b.priority - a.priority; }); // sort descending by priority
                            var defaultRTPCandidate = sortedCandidates[0];
                            // find matching rtcp candidate if any
                            var defaultRTCPCandidate = null;
                            if (transportParams.rtcpIceCandidates) {
                                for (var i = 0; i < transportParams.rtcpIceCandidates.length; ++i) {
                                    var rtcpCandidate = transportParams.rtcpIceCandidates[i];
                                    if (rtcpCandidate.foundation === defaultRTPCandidate.foundation) {
                                        defaultRTCPCandidate = rtcpCandidate;
                                        break;
                                    }
                                }
                            }
                            return {
                                0: defaultRTPCandidate,
                                1: defaultRTCPCandidate
                            };
                        }
                    }
                    function _makeMediaParams(transportParams, mediaCaps, isOffer, sessionLevelDefaultCandidate) {
                        var receiverMediaParams = mediaCaps.receiver;
                        var media = {
                            rtp: [],
                            fmtp: [],
                            rtcpFb: [],
                            ext: [],
                            type: mediaCaps.descr.type,
                            port: 0,
                            protocol: 'RTP/SAVP',
                            payloads: '',
                            cryptoscale: [],
                            crypto: [],
                            candidates: [],
                            xCandidatesIpv6: []
                        };
                        if (!mediaCaps.descr.enabled) {
                            // need to add at least 1 dummy payload type!
                            if (media.type === constants_1["default"].MEDIA_TYPE.video) {
                                media.payloads = '34'; // H263 - like mediamanager does
                            }
                            else {
                                media.payloads = '9'; // G722
                            }
                            return media;
                        }
                        var defaultCandidates = _getDefaultCandidates(transportParams);
                        var defaultCandidateRTP = defaultCandidates[0];
                        var defaultCandidateRTCP = defaultCandidates[1];
                        media.port = defaultCandidateRTP.port;
                        // if session level default candidate has different IP than media one, then add another c line to media level
                        if (sessionLevelDefaultCandidate.ip !== defaultCandidateRTP.ip) {
                            media.connection = {
                                version: _isIpv4(defaultCandidateRTP.ip) ? 4 : 6,
                                ip: defaultCandidateRTP.ip
                            };
                        }
                        media.iceUfrag = transportParams.iceParams.usernameFragment;
                        media.icePwd = transportParams.iceParams.password;
                        if (media.type === constants_1["default"].MEDIA_TYPE.audio) {
                            var codecCaps = _getCodecPtimeCapabilities(receiverMediaParams.rtpCaps.codecs);
                            media.maxptime = codecCaps.maxptime;
                            media.ptime = codecCaps.ptime;
                        }
                        media.direction = _getDirection(mediaCaps.descr.send, mediaCaps.descr.recv);
                        media.xSsrcRange = {
                            ssrcMin: receiverMediaParams.ssrcRange.min,
                            ssrcMax: receiverMediaParams.ssrcRange.max
                        };
                        media.ssrcGroups = _transformRtxSsrc(mediaCaps.sender.rtxSsrc, mediaCaps.sender.ssrcRange.min);
                        media.label = mediaCaps.descr.label;
                        // only first video should have x-source line
                        if (!mediaCaps.bundledWithOther) {
                            media.xSource = mediaCaps.descr.label;
                        }
                        if (receiverMediaParams.rtcpReducedSize) {
                            media.rtcpRsize = true;
                        }
                        if (isOffer && mediaCaps.justAdded) {
                            if (transportParams.doRtcpMux) {
                                media.rtcpMux = true;
                            }
                            media.rtcp = { port: (defaultCandidateRTCP && defaultCandidateRTCP.port) || media.port + 1 };
                        }
                        else {
                            if (transportParams.doRtcpMux) {
                                media.rtcpMux = true;
                            }
                            else {
                                media.rtcp = { port: (defaultCandidateRTCP && defaultCandidateRTCP.port) || media.port + 1 };
                            }
                        }
                        var rtcpFbXMessage = null;
                        if (receiverMediaParams.rtpCaps && receiverMediaParams.rtpCaps.codecs) {
                            receiverMediaParams.rtpCaps.codecs.forEach(function (codec) {
                                media.rtp.push({
                                    payload: codec.preferredPayloadType,
                                    codec: codec.name,
                                    rate: codec.clockRate,
                                    encoding: codec.numChannels > 1 ? codec.numChannels : void 0
                                });
                                var fmtpConfigLine = '';
                                utils_1["default"].forOwn(codec.parameters, function (param, paramKey) {
                                    if (fmtpConfigLine !== '') {
                                        fmtpConfigLine += ';';
                                    }
                                    fmtpConfigLine += (paramKey === 'events') ? param : paramKey + '=' + param;
                                });
                                if (fmtpConfigLine !== '') {
                                    media.fmtp.push({
                                        payload: codec.preferredPayloadType,
                                        config: fmtpConfigLine
                                    });
                                }
                                media.payloads += (media.payloads ? ' ' : '') + codec.preferredPayloadType;
                                // NB: assuming all codecs share the same x-message attribute!
                                for (var i = 0; i < codec.rtcpFeedback.length; i++) {
                                    if (_compareStr(codec.rtcpFeedback[i].type, 'x-message')) {
                                        rtcpFbXMessage = codec.rtcpFeedback[i].parameter;
                                    }
                                    else {
                                        media.rtcpFb.push({
                                            payload: codec.preferredPayloadType,
                                            type: codec.rtcpFeedback[i].type,
                                            subtype: codec.rtcpFeedback[i].parameter
                                        });
                                    }
                                }
                            });
                            if (rtcpFbXMessage) {
                                media.rtcpFb.push({
                                    payload: '*',
                                    type: 'x-message',
                                    subtype: rtcpFbXMessage
                                });
                            }
                        }
                        if (receiverMediaParams.rtpCaps && receiverMediaParams.rtpCaps.headerExtensions) {
                            receiverMediaParams.rtpCaps.headerExtensions.forEach(function (extension) {
                                media.ext.push({
                                    value: extension.preferredId,
                                    uri: _encodeExtensionUri(extension.uri, false)
                                });
                            });
                        }
                        function mkiConfigString(keyParam) {
                            return keyParam.mkiLength !== 0 ? '|' + keyParam.mkiValue + ':' + keyParam.mkiLength : '';
                        }
                        if (receiverMediaParams.sdesParamsList) {
                            for (var j = 0; j < receiverMediaParams.sdesParamsList.length; ++j) {
                                var sdesP = receiverMediaParams.sdesParamsList[j];
                                // TODO: review rfc4568!
                                if (_compareStr(sdesP.cryptoSuite, 'AES_CM_128_HMAC_SHA1_80')) {
                                    media.crypto.push({
                                        id: sdesP.tag,
                                        suite: 'AES_CM_128_HMAC_SHA1_80',
                                        config: sdesP.keyParams[0].keyMethod + ':' + sdesP.keyParams[0].keySalt + '|' + sdesP.keyParams[0].lifetime + mkiConfigString(sdesP.keyParams[0])
                                    });
                                }
                                else if (_compareStr(sdesP.cryptoSuite, 'SCALE_AES_CM_128_HMAC_SHA1_80')) {
                                    media.cryptoscale.push({
                                        id: sdesP.tag,
                                        flavor: 'client',
                                        suite: 'AES_CM_128_HMAC_SHA1_80',
                                        config: sdesP.keyParams[0].keyMethod + ':' + sdesP.keyParams[0].keySalt + '|' + sdesP.keyParams[0].lifetime + mkiConfigString(sdesP.keyParams[0])
                                    });
                                }
                            }
                        }
                        // ice candidates and remoteCandidates will not be added for bundled stream (other video streams after 1st one)
                        if (!mediaCaps.bundledWithOther) {
                            // ICE completed - add only candidate from selected iceCandidatePair
                            if (transportParams.iceCandidatePair) {
                                // add only selected local candidate
                                _addCandidates([transportParams.iceCandidatePair.local], 1, media.candidates, media.xCandidatesIpv6);
                                // add local rtcp candidate only if rtcp mux not used
                                if (transportParams.rtcpIceCandidatePair && !transportParams.doRtcpMux) {
                                    _addCandidates([transportParams.rtcpIceCandidatePair.local], 2, media.candidates, media.xCandidatesIpv6);
                                }
                                // if ice role is controlling, then also add remote-candidates attribute regardless if it is offer or answer
                                //if (isOffer && iceRoleControllig) { // according to spec only put remote candidates on controlling side offer but native media agent wants to always get it !
                                media.remoteCandidates = '1 ' + transportParams.iceCandidatePair.remote.ip + ' ' + transportParams.iceCandidatePair.remote.port;
                                // rtcp candidate pair only goes if we have agreed to not do rtcpMux
                                if (!transportParams.doRtcpMux) {
                                    media.remoteCandidates += ' 2 ' + transportParams.rtcpIceCandidatePair.remote.ip + ' ' + transportParams.rtcpIceCandidatePair.remote.port;
                                }
                                else {
                                    media.remoteCandidates += ' 2 ' + transportParams.iceCandidatePair.remote.ip + ' ' + transportParams.iceCandidatePair.remote.port;
                                }
                            }
                            else {
                                // rtp ice candidates
                                _addCandidates(transportParams.iceCandidates, 1, media.candidates, media.xCandidatesIpv6);
                                // rtcp candidates we add always if the media stream is first added by that offer or if negotiation didn't result with rtcp muxing
                                if ((isOffer && mediaCaps.justAdded) || !transportParams.doRtcpMux) {
                                    _addCandidates(transportParams.rtcpIceCandidates, 2, media.candidates, media.xCandidatesIpv6);
                                }
                            }
                            media.candidates.sort(function (a, b) {
                                return (+a.foundation - +b.foundation) || ((a.foundation === b.foundation) && (a.component - b.component));
                            });
                            media.xCandidatesIpv6.sort(function (a, b) {
                                return (+a.foundation - +b.foundation) || ((a.foundation === b.foundation) && (a.component - b.component));
                            });
                            if (transportParams.dtlsParams) {
                                //{"role":"auto","fingerprints":[{"algorithm":"sha-256","value":"DE:17:AB:E7:A8:EA:96:D7:FB:D7:C8:9A:1C:D3:A3:DC:87:92:6F:F9:D9:3E:12:35:C1:AD:C0:98:57:EC:F2:1D"}]}
                                media.fingerprint = {
                                    type: transportParams.dtlsParams.fingerprints[0].algorithm,
                                    hash: transportParams.dtlsParams.fingerprints[0].value
                                };
                                switch (transportParams.dtlsParams.role) {
                                    case 'auto':
                                        media.setup = 'actpass';
                                        break;
                                    case 'client':
                                        media.setup = 'active';
                                        break;
                                    case 'server':
                                        media.setup = 'passive';
                                        break;
                                }
                            }
                        }
                        return media;
                    }
                    this.paramsToSdp = function (params) {
                        var sdp = {}, activeTransport = params.transportParams[0] || params.transportParams[1] || params.transportParams[2], hostIp = _getHostIp(activeTransport), defaultCandidates = _getDefaultCandidates(activeTransport), defaultCandidateRTP = defaultCandidates[0];
                        sdp.version = 0;
                        sdp.origin = {
                            username: '-',
                            sessionId: 0,
                            sessionVersion: params.sessionVersion,
                            netType: 'IN',
                            ipVer: _isIpv4(hostIp) ? 4 : 6,
                            address: hostIp
                        };
                        sdp.bandwidth = [
                            {
                                type: 'CT',
                                limit: 99980
                            }
                        ];
                        sdp.timing = {
                            start: 0,
                            stop: 0
                        };
                        sdp.name = 'session';
                        sdp.connection = {
                            version: _isIpv4(defaultCandidateRTP.ip) ? 4 : 6,
                            ip: defaultCandidateRTP.ip
                        };
                        // FIXME: hardcoded table
                        sdp.xMediaBw = {
                            label: constants_1["default"].MEDIA_LABEL.video,
                            sendBw: 8100,
                            receiveBw: 8000
                        };
                        sdp.media = [];
                        for (var i = 0; i < params.media.length; i++) {
                            var transportIdx = ortcHelper_1["default"].getTransportIdxForLabel(params.media[i].descr.label);
                            var transportParams = params.transportParams[transportIdx];
                            sdp.media.push(_makeMediaParams(transportParams, params.media[i], params.isOffer, defaultCandidateRTP));
                        }
                        return SdpT.write(sdp);
                    };
                    function _getProtocol(transport) {
                        var t = transport.toLowerCase();
                        switch (t) {
                            case 'tcp-act':
                            case 'tcp-pass':
                            case 'tcp-so':
                                return 'tcp';
                            default:
                                return t;
                        }
                    }
                    function _getTcpType(transport) {
                        switch (transport.toLowerCase()) {
                            case 'tcp-act':
                                return 'active';
                            case 'tcp-pass':
                                return 'passive';
                            case 'tcp-so':
                                return 'so';
                            default:
                                return void 0;
                        }
                    }
                    function _getCandidate(candidateIn) {
                        var cand = {
                            foundation: candidateIn.foundation,
                            priority: candidateIn.priority,
                            ip: candidateIn.ip,
                            protocol: _getProtocol(candidateIn.transport),
                            port: candidateIn.port,
                            type: candidateIn.type
                        };
                        if (!_compareStr(candidateIn.type, 'host')) {
                            cand.tcpType = _getTcpType(candidateIn.transport);
                            cand.relatedAddress = candidateIn.raddr;
                            cand.relatedPort = candidateIn.rport;
                        }
                        return cand;
                    }
                    function _getCandidates(mediaParamsSdp, component, candidatesOut) {
                        // ipv4 candidates
                        if (mediaParamsSdp.candidates) {
                            mediaParamsSdp.candidates.forEach(function (candidate) {
                                // only take RTP or RTCP
                                if (candidate.component === component) {
                                    candidatesOut.push(_getCandidate(candidate));
                                }
                            });
                        }
                        // ipv6 candidates
                        if (mediaParamsSdp.xCandidatesIpv6) {
                            mediaParamsSdp.xCandidatesIpv6.forEach(function (candidate) {
                                // only take RTP or RTCP
                                if (candidate.component === component) {
                                    candidatesOut.push(_getCandidate(candidate));
                                }
                            });
                        }
                    }
                    function _getKeyParamsFromConfig(configLine) {
                        var regexp = /(\w+):([a-zA-Z0-9+\/]+={0,2})(\|([0-9\^]+))?(\|([0-9]+):([0-9]+))?/;
                        var match = configLine.match(regexp);
                        if (!match) {
                            return void 0;
                        }
                        var res = {
                            keyMethod: match[1],
                            keySalt: match[2],
                            mkiValue: 0,
                            mkiLength: 0
                        };
                        if (typeof match[4] !== 'undefined') {
                            res.lifetime = match[4];
                        }
                        if (typeof match[7] !== 'undefined') {
                            res.mkiValue = +match[6];
                            res.mkiLength = +match[7];
                        }
                        return res;
                    }
                    function _getTransportParams(sdpParams, mediaSdpParams) {
                        var params = {};
                        params.iceParams = {
                            usernameFragment: mediaSdpParams.iceUfrag,
                            password: mediaSdpParams.icePwd
                        };
                        params.iceCandidates = [];
                        // only take RTP(1) candidates
                        _getCandidates(mediaSdpParams, 1, params.iceCandidates);
                        params.doRtcpMux = !!mediaSdpParams.rtcpMux;
                        // populate rtcpIceParams, rtcpIceCandidates, rtcpDtlsParams only if no rtcpMux given
                        if (!mediaSdpParams.rtcpMux) {
                            params.rtcpIceParams = {
                                usernameFragment: mediaSdpParams.iceUfrag,
                                password: mediaSdpParams.icePwd
                            };
                            params.rtcpIceCandidates = [];
                            // only take RTCP(2) candidates
                            _getCandidates(mediaSdpParams, 2, params.rtcpIceCandidates);
                            if (sdpParams.icelite) {
                                params.rtcpIceParams.iceLite = true;
                            }
                        }
                        if (mediaSdpParams.remoteCandidates) {
                            params.iceCandidatePair = {}; // TODO, add actual candidate values.
                        }
                        // ff puts fingerprint to session level, chrome/ortc puts to media level. Either way is ok
                        if (sdpParams.fingerprint || mediaSdpParams.fingerprint) {
                            var fingerprint = mediaSdpParams.fingerprint ? mediaSdpParams.fingerprint : sdpParams.fingerprint;
                            var setup = mediaSdpParams.setup ? mediaSdpParams.setup : sdpParams.setup;
                            //{"role":"auto","fingerprints":[{"algorithm":"sha-256","value":"DE:17:AB:E7:A8:EA:96:D7:FB:D7:C8:9A:1C:D3:A3:DC:87:92:6F:F9:D9:3E:12:35:C1:AD:C0:98:57:EC:F2:1D"}]}
                            var role = 'auto';
                            switch (setup) {
                                case 'actpass':
                                    role = 'auto';
                                    break;
                                case 'active':
                                    role = 'client';
                                    break;
                                case 'passive':
                                    role = 'server';
                                    break;
                            }
                            params.dtlsParams = {
                                role: role,
                                fingerprints: [{ algorithm: fingerprint.type, value: fingerprint.hash }]
                            };
                        }
                        if (sdpParams.icelite) {
                            params.iceParams.iceLite = true;
                        }
                        return params;
                    }
                    function _getRTPCaps(mediaSdpParams) {
                        var codecs = [];
                        var headerExtensions = [];
                        mediaSdpParams.rtp.forEach(function (rtpDescr) {
                            var codec = {
                                name: rtpDescr.codec,
                                kind: mediaSdpParams.type,
                                clockRate: rtpDescr.rate,
                                preferredPayloadType: rtpDescr.payload,
                                numChannels: rtpDescr.encoding ? rtpDescr.encoding : 1,
                                rtcpFeedback: []
                            };
                            if (mediaSdpParams.type === constants_1["default"].MEDIA_TYPE.audio) {
                                codec.ptime = mediaSdpParams.ptime;
                                codec.maxptime = mediaSdpParams.maxptime;
                            }
                            codecs.push(codec);
                        });
                        // post-processing for codecs to insert fmtp options into existing codecs
                        if (mediaSdpParams.fmtp) {
                            mediaSdpParams.fmtp.forEach(function (line) {
                                var newfmtp = formatParameters_1["default"].build(line.config);
                                if (newfmtp.contains('apt')) {
                                    var codecIndex = ortcHelper_1["default"].getCodecIndexByPayload(line.payload, codecs);
                                    codecs[codecIndex].parameters = { apt: newfmtp.get('apt') };
                                }
                            });
                        }
                        ;
                        if (mediaSdpParams.ext) {
                            mediaSdpParams.ext.forEach(function (extension) {
                                headerExtensions.push({
                                    kind: mediaSdpParams.type,
                                    uri: _encodeExtensionUri(extension.uri, true),
                                    preferredId: extension.value
                                });
                            });
                        }
                        return {
                            codecs: codecs,
                            headerExtensions: headerExtensions,
                            fecMechanisms: []
                        };
                    }
                    function _getMediaDescriptor(mediaSdpParams) {
                        if (!mediaSdpParams.direction) {
                            mediaSdpParams.direction = 'sendrecv';
                        }
                        var direction = mediaSdpParams.direction.toLowerCase();
                        var enabled = parseInt(mediaSdpParams.port, 10) !== 0;
                        var getLabel = function () {
                            if (enabled && !mediaSdpParams.label) {
                                if (constants_1["default"].MEDIA_TYPE.audio === mediaSdpParams.type) {
                                    return constants_1["default"].MEDIA_LABEL.audio;
                                }
                                if (constants_1["default"].MEDIA_TYPE.video === mediaSdpParams.type) {
                                    return constants_1["default"].MEDIA_LABEL.video;
                                }
                            }
                            return mediaSdpParams.label;
                        };
                        return {
                            enabled: enabled,
                            type: mediaSdpParams.type,
                            label: getLabel(),
                            send: enabled ? (direction === 'sendrecv' || direction === 'sendonly') : false,
                            recv: enabled ? (direction === 'sendrecv' || direction === 'recvonly') : false
                        };
                    }
                    function _getRtxSsrc(ssrcGroups) {
                        if (ssrcGroups) {
                            var rtx = utils_1["default"].find(ssrcGroups, function (line) {
                                return line.semantics === 'FID';
                            });
                            if (rtx) {
                                return +rtx.ssrcs.split(' ')[1]; // rtx ssrc is passed as the second ssrc port in FID line
                            }
                        }
                        return 0;
                    }
                    function _transformRtxSsrc(rtxSsrc, ssrc) {
                        if (rtxSsrc) {
                            return [{ semantics: 'FID', ssrcs: ssrc + ' ' + rtxSsrc }]; // relaying on + to do toString for ssrc and rtxSsrc
                        }
                        return [];
                    }
                    function _getMediaParams(mediaSdpParams) {
                        var sdesParamsList = [];
                        function addSdesParams(tag, suite, keyParams, sessionParams) {
                            sdesParamsList.push({
                                tag: tag,
                                cryptoSuite: suite,
                                keyParams: keyParams,
                                sessionParams: sessionParams
                            });
                        }
                        var descr = _getMediaDescriptor(mediaSdpParams);
                        if (!descr.enabled) {
                            var media = {
                                rtpCaps: null,
                                ssrcRange: null,
                                rtcpReducedSize: false
                            };
                            return {
                                descr: descr,
                                receiver: media,
                                sender: media
                            };
                        }
                        else {
                            if (mediaSdpParams.cryptoscale) {
                                mediaSdpParams.cryptoscale.forEach(function (elem) {
                                    var keyParams = _compareStr(elem.flavor, 'server') ? _getKeyParamsFromConfig(elem.config) : void 0;
                                    if (keyParams) {
                                        addSdesParams(elem.id, 'SCALE_' + elem.suite, [keyParams], []);
                                    }
                                });
                            }
                            if (mediaSdpParams.crypto) {
                                mediaSdpParams.crypto.forEach(function (elem) {
                                    var keyParams = _getKeyParamsFromConfig(elem.config);
                                    if (keyParams) {
                                        addSdesParams(elem.id, elem.suite, [keyParams], []);
                                    }
                                });
                            }
                            var mediaParams = {
                                rtpCaps: _getRTPCaps(mediaSdpParams),
                                sdesParamsList: sdesParamsList,
                                ssrcRange: {
                                    min: mediaSdpParams.xSsrcRange ? mediaSdpParams.xSsrcRange.ssrcMin : 0,
                                    max: mediaSdpParams.xSsrcRange ? mediaSdpParams.xSsrcRange.ssrcMax : 0
                                },
                                rtxSsrc: _getRtxSsrc(mediaSdpParams.ssrcGroups),
                                rtcpReducedSize: mediaSdpParams.rtcpRsize ? true : false
                            };
                            return {
                                descr: _getMediaDescriptor(mediaSdpParams),
                                receiver: mediaParams,
                                sender: utils_1["default"].deepClone(mediaParams)
                            };
                        }
                    }
                    function _getCodecPtimeCapabilities(codecs) {
                        if (codecs.length === 0) {
                            return { ptime: 0, maxptime: 0 };
                        }
                        var ptime = codecs[0].ptime; // we take ptime of the codec with highest priority
                        var maxptime = codecs[0].maxptime;
                        codecs.forEach(function (codec) {
                            if (maxptime > codec.maxptime && codec.maxptime > 0) {
                                maxptime = codec.maxptime;
                            }
                        });
                        return {
                            ptime: ptime,
                            maxptime: maxptime
                        };
                    }
                    this.sdpToParams = function (sdp) {
                        var sdpParams = SdpT.parse(sdp);
                        var params = {
                            sessionVersion: sdpParams.origin.sessionVersion,
                            transportParams: [],
                            media: []
                        };
                        // assuming all media lines are always present. if not active, port will be 0
                        for (var i = 0; i < sdpParams.media.length; i++) {
                            var sdpMedia = sdpParams.media[i];
                            var media = _getMediaParams(sdpMedia);
                            params.media.push(media);
                            if (media.descr.enabled) {
                                var transportIdx = ortcHelper_1["default"].getTransportIdxForLabel(media.descr.label);
                                if (!params.transportParams[transportIdx]) {
                                    params.transportParams[transportIdx] = _getTransportParams(sdpParams, sdpMedia);
                                }
                            }
                        }
                        return params;
                    };
                }
                exports.__esModule = true;
                exports["default"] = OrtcSdp;
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/ortc/ortcSsrcGenerator', ["require", "exports"], factory);
                }
            })(function (require, exports) {
                function SsrcGenerator() {
                    var MAX_SSRC_VALUE = 0xffffff00;
                    var ssrc = Math.floor(Math.random() * (MAX_SSRC_VALUE - 1)) + 1;
                    this.nextAudioStreamSsrc = function () {
                        return nextSsrc(0);
                    };
                    this.nextVideoStreamSsrc = function () {
                        return nextSsrc(99);
                    };
                    function nextSsrc(range) {
                        var currentSsrc;
                        do {
                            currentSsrc = ssrc;
                            ssrc = (ssrc + range + 1) % MAX_SSRC_VALUE;
                            // ssrc should be greater then 0
                            if (ssrc === 0) {
                                ssrc = 1;
                            }
                        } while (currentSsrc + range > MAX_SSRC_VALUE);
                        return { min: currentSsrc, max: currentSsrc + range };
                    }
                }
                exports.__esModule = true;
                exports["default"] = {
                    build: function () {
                        return new SsrcGenerator();
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/ortc/ortcVideoRendererGroup', ["require", "exports", '../device/videoRenderer', '../common/utils', '../constants', '../helper'], factory);
                }
            })(function (require, exports) {
                var videoRenderer_1 = require('../device/videoRenderer');
                var utils_1 = require('../common/utils');
                var constants_1 = require('../constants');
                var helper_1 = require('../helper');
                function OrtcVideoRendererGroup(context) {
                    var logger = context.logger.createChild('OrtcVideoRendererGroup'), subscriptions = [], channels = [];
                    this.create = function (element, callback) {
                        return new OrtcVideoRenderer(element, callback);
                    };
                    this.update = function (mediaChannels) {
                        channels = mediaChannels;
                        subscriptions.forEach(function (subscription) {
                            subscription.update();
                        });
                    };
                    this.terminate = function () {
                        subscriptions.forEach(function (subscription) {
                            subscription.dispose();
                        });
                    };
                    function OrtcVideoRenderer(element, callback) {
                        videoRenderer_1["default"].call(this, element, callback);
                        var self = this, baseDispose = this.dispose, disposed = false, deferred = helper_1["default"].defer(), subscription, subscribedMsi;
                        this.updateRecvTrack = function (msi, track) {
                            logger.log('renderer.updateRecvTrack - attachMediaStream', 'msi:', msi, 'track:', track);
                            subscribedMsi = msi;
                            self.attachMediaStream(track ? new MediaStream([track]) : null); //okay it replace with new stream
                        };
                        this.subscribeVideoAsync = function (msi, appSharing) {
                            logger.info('subscribeVideoAsync', 'msi:', msi);
                            //assert(!disposed);
                            var rendererType = appSharing ? constants_1["default"].RENDERER_TYPE.screensharing : constants_1["default"].RENDERER_TYPE.video;
                            return new Promise(function (resolve) {
                                // if not given, subscribe to any (-2)
                                if (typeof msi === 'undefined') {
                                    msi = constants_1["default"].MSI.subscribeAny;
                                }
                                if (!disposed) {
                                    //optimizing user not to subscribe for same msi several times in a row ...
                                    var isNewMsi = subscribedMsi !== msi;
                                    if (isNewMsi) {
                                        unsubscribeIfSubscribed();
                                    }
                                    if (deferred.isPending()) {
                                        deferred.resolve(); //resubscribed succeed previous operation, or fail???
                                        deferred = helper_1["default"].defer();
                                    }
                                    if (msi === constants_1["default"].MSI.unsubscribe || !isNewMsi) {
                                        // if msi unsubscribe given, then we are done here
                                        deferred.resolve();
                                    }
                                    else {
                                        subscribeInternal(rendererType, msi);
                                    }
                                }
                                resolve(deferred.promise);
                            });
                        };
                        this.dispose = function () {
                            logger.debug('disposing remote renderer');
                            unsubscribeIfSubscribed();
                            if (deferred.isPending()) {
                                deferred.reject(new Error('disposing renderer'));
                            }
                            disposed = true;
                            baseDispose();
                        };
                        function unsubscribeIfSubscribed() {
                            if (subscription) {
                                subscription.remove(self);
                                subscription = void 0;
                            }
                            subscribedMsi = void 0;
                        }
                        function subscribeInternal(rendererType, msi) {
                            //create new "array" of subscribers, i.e. many video elements can render same video...
                            if (!getSubscription(rendererType, msi)) {
                                //basically create new class...
                                var deferredMediaChannelSubscribed = helper_1["default"].defer(), renderers = [], subscribedMediaChannel, disposed = false, track = null, dispose = function () {
                                    if (!disposed) {
                                        renderers = []; //clean up renderers used when we get disposed before renderers themselves
                                        if (deferredMediaChannelSubscribed.isPending()) {
                                            deferredMediaChannelSubscribed.reject(new Error('disposing renderer'));
                                        }
                                        if (subscribedMediaChannel) {
                                            subscribedMediaChannel.unsubscribe(); //last one unsubscribes
                                        }
                                        utils_1["default"].remove(subscriptions, function (subscription) {
                                            return subscription.rendererType === rendererType && subscription.msi === msi;
                                        });
                                        disposed = true;
                                    }
                                }, update = function () {
                                    if (deferredMediaChannelSubscribed.isPending()) {
                                        var channel = getSubscribableChannel(rendererType);
                                        if (channel) {
                                            channel.subscribe(msi);
                                            subscribedMediaChannel = channel;
                                            deferredMediaChannelSubscribed.resolve();
                                        }
                                    }
                                    if (subscribedMediaChannel) {
                                        var newTrack = subscribedMediaChannel.getRecvTrack();
                                        if (newTrack !== track) {
                                            track = newTrack;
                                            renderers.forEach(function (renderer) {
                                                renderer.updateRecvTrack(msi, track);
                                            });
                                        }
                                    }
                                };
                                subscriptions.push({
                                    rendererType: rendererType,
                                    msi: msi,
                                    add: function (renderer, deferred) {
                                        //NB! works with q promises. i.e. if deferred is rejected outside, there is no error to reject or resolve it later again it will be noop
                                        deferredMediaChannelSubscribed.promise.then(deferred.resolve, deferred.reject);
                                        renderers.push(renderer);
                                        update();
                                    },
                                    remove: function (renderer) {
                                        utils_1["default"].remove(renderers, function (value) {
                                            return value === renderer;
                                        });
                                        if (renderers.length === 0) {
                                            dispose();
                                        }
                                    },
                                    update: update,
                                    dispose: dispose
                                });
                            }
                            subscription = getSubscription(rendererType, msi);
                            subscription.add(self, deferred);
                        }
                        function getSubscription(rendererType, msi) {
                            return utils_1["default"].find(subscriptions, function (subscription) {
                                return subscription.rendererType === rendererType && subscription.msi === msi;
                            });
                        }
                        function getSubscribableChannel(rendererType) {
                            return utils_1["default"].find(channels, function (channel) {
                                return channel.canSubscribe() && channel.label === getLabelForModality(rendererType);
                            });
                        }
                        function getLabelForModality(modality) {
                            switch (modality) {
                                case constants_1["default"].MODALITY.video:
                                    return constants_1["default"].MEDIA_LABEL.video;
                                case constants_1["default"].MODALITY.screensharing:
                                    return constants_1["default"].MEDIA_LABEL.screensharing;
                            }
                        }
                    }
                }
                exports.__esModule = true;
                exports["default"] = {
                    build: function (context) {
                        return new OrtcVideoRendererGroup(context);
                    }
                };
            });
            // Highlevel logic of the dominant speaker history strategy is that 
            // it generated and sorts a histogram of participantsâ€™ speaking time:
            // 1. setSources event comes
            // 2. sourcesâ€™ timestamps are collected
            // 3. timer is raised
            // 4. another setSources events come
            // 5. timer triggers
            // 6. histogram is generated and sorted
            // 7. onDominantSpeakerChanged event is raised
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/common/activeSpeaker/dshGeneratingStrategy', ["require", "exports", '../utils'], factory);
                }
            })(function (require, exports) {
                var utils_1 = require('../utils');
                var DEFAULT_TIME_TO_PROMOTE = 3000;
                var Source = (function () {
                    function Source(source) {
                        this.id = source;
                        this.startTimestamp = 0;
                        this.totalTime = 0;
                    }
                    return Source;
                }());
                var DHSGeneratingStategy = (function () {
                    function DHSGeneratingStategy(settings) {
                        this.sources = [];
                        this.timeToPromote = settings && settings.timeToPromote || DEFAULT_TIME_TO_PROMOTE;
                    }
                    DHSGeneratingStategy.prototype.setSources = function (sourceIds) {
                        sourceIds = sourceIds || [];
                        var activeSources = sourceIds.map(this.getOrCreateSource.bind(this));
                        var passiveSources = this.excludeSources(this.sources, activeSources);
                        activeSources.forEach(this.updateSourceTimestamp.bind(this, true));
                        passiveSources.forEach(this.updateSourceTimestamp.bind(this, false));
                        if (!this.ping) {
                            this.ping = this.setupTimer();
                        }
                    };
                    DHSGeneratingStategy.prototype.setOnDominantSpeakerChanged = function (callback) {
                        this.callback = callback;
                    };
                    DHSGeneratingStategy.prototype.dispose = function () {
                        this.clearTimer();
                        this.sources = null;
                        this.callback = null;
                    };
                    DHSGeneratingStategy.prototype.excludeSources = function (src, target) {
                        return src.filter(function (source) {
                            return !target.some(function (targetSource) {
                                return source.id === targetSource.id;
                            });
                        });
                    };
                    DHSGeneratingStategy.prototype.setupTimer = function () {
                        var _this = this;
                        var trigger = function () {
                            var candidates = _this.arrangeSources().map(_this.toSourceId);
                            if (candidates.length && !utils_1["default"].deepEqual(_this.candidates, candidates)) {
                                _this.candidates = candidates;
                                if (_this.callback) {
                                    _this.callback(candidates);
                                }
                            }
                            _this.resetTimers();
                            _this.ping = null;
                        };
                        return setTimeout(trigger, this.timeToPromote);
                    };
                    DHSGeneratingStategy.prototype.clearTimer = function () {
                        if (this.ping) {
                            clearTimeout(this.ping);
                            this.ping = null;
                        }
                    };
                    DHSGeneratingStategy.prototype.resetTimers = function () {
                        this.sources.forEach(function (source) {
                            source.totalTime = 0;
                        });
                    };
                    DHSGeneratingStategy.prototype.getOrCreateSource = function (sourceId) {
                        if (!this.isExist(sourceId)) {
                            var source = new Source(sourceId);
                            this.sources.push(source);
                            return source;
                        }
                        else {
                            return this.sourceById(sourceId);
                        }
                    };
                    DHSGeneratingStategy.prototype.isExist = function (sourceId) {
                        return this.sources.some(function (source) {
                            return sourceId === source.id;
                        });
                    };
                    DHSGeneratingStategy.prototype.sourceById = function (sourceId) {
                        return utils_1["default"].find(this.sources, function (source) {
                            return sourceId === source.id;
                        });
                    };
                    DHSGeneratingStategy.prototype.updateSourceTimestamp = function (isSpeaking, source) {
                        if (isSpeaking) {
                            // mute -> speaking = setup timer
                            // speaking -> speaking = ignoring
                            if (!source.startTimestamp) {
                                source.startTimestamp = Date.now();
                            }
                        }
                        else {
                            // speaking -> mute = reset timer, increase total time
                            // mute -> mute = ingoring
                            if (source.startTimestamp) {
                                source.totalTime += Date.now() - source.startTimestamp;
                                source.startTimestamp = 0;
                            }
                        }
                    };
                    DHSGeneratingStategy.prototype.arrangeSources = function () {
                        var byTotalTimeDescending = function (a, b) { return b.totalTime - a.totalTime; };
                        return this.sources.sort(byTotalTimeDescending);
                    };
                    DHSGeneratingStategy.prototype.toSourceId = function (source) {
                        return source.id;
                    };
                    return DHSGeneratingStategy;
                }());
                exports.DHSGeneratingStategy = DHSGeneratingStategy;
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/ortc/ortcSession', ["require", "exports", './ortcTransport', './ortcMediaChannel', './ortcNegotiation', './ortcSdp', './ortcSsrcGenerator', './ortcVideoRendererGroup', './ortcHelper', '../constants', '../helper', '../common/utils', '../extensions/extensionsManager', '../common/activeSpeaker/activeSpeakerManager', '../common/activeSpeaker/dshGeneratingStrategy'], factory);
                }
            })(function (require, exports) {
                var ortcTransport_1 = require('./ortcTransport');
                var ortcMediaChannel_1 = require('./ortcMediaChannel');
                var ortcNegotiation_1 = require('./ortcNegotiation');
                var ortcSdp_1 = require('./ortcSdp');
                var ortcSsrcGenerator_1 = require('./ortcSsrcGenerator');
                var ortcVideoRendererGroup_1 = require('./ortcVideoRendererGroup');
                var ortcHelper_1 = require('./ortcHelper');
                var constants_1 = require('../constants');
                var helper_1 = require('../helper');
                var utils_1 = require('../common/utils');
                var extensionsManager_1 = require('../extensions/extensionsManager');
                var activeSpeakerManager_1 = require('../common/activeSpeaker/activeSpeakerManager');
                var dshGeneratingStrategy_1 = require('../common/activeSpeaker/dshGeneratingStrategy');
                function OrtcState() {
                    var _that = this;
                    this.STABLE = 'stable';
                    this.NEGOTIATION_REQUESTED = 'negotiation_requested';
                    this.HAVE_LOCAL_OFFER = 'have_local_offer';
                    this.HAVE_REMOTE_PRANSWER = 'have_remote_pranswer';
                    this.HAVE_REMOTE_ANSWER = 'have_remote_answer';
                    this.HAVE_REMOTE_OFFER = 'have_remote_offer';
                    this.HAVE_LOCAL_PRANSWER = 'have_local_pranswer';
                    this.HAVE_LOCAL_ANSWER = 'have_local_answer';
                    this.TERMINATED = 'terminated';
                    this.state = _that.STABLE;
                    this.changing = false;
                    function _stateChangeError(newState) {
                        throw new Error('Invalid state change:' + _that.state + ' ' + newState + ' changing: ' + _that.changing);
                    }
                    this.change = function (newState, changing) {
                        if (_that.busy) {
                            // FIXME: this is never executed
                            _stateChangeError(newState);
                        }
                        if (changing) {
                            _that.changing = changing;
                        }
                        switch (newState) {
                            case _that.STABLE:
                                if (_that.state !== _that.HAVE_REMOTE_ANSWER && _that.state !== _that.HAVE_LOCAL_ANSWER) {
                                    _stateChangeError(newState);
                                }
                                break;
                            case _that.NEGOTIATION_REQUESTED:
                                if (_that.state !== _that.STABLE) {
                                    _stateChangeError(newState);
                                }
                                break;
                            case _that.HAVE_LOCAL_OFFER:
                                if (_that.state !== _that.STABLE && _that.state !== _that.NEGOTIATION_REQUESTED) {
                                    _stateChangeError(newState);
                                }
                                break;
                            case _that.HAVE_REMOTE_PRANSWER:
                            case _that.HAVE_REMOTE_ANSWER:
                                if (_that.state !== _that.HAVE_LOCAL_OFFER && _that.state !== _that.HAVE_REMOTE_PRANSWER) {
                                    _stateChangeError(newState);
                                }
                                break;
                            case _that.HAVE_REMOTE_OFFER:
                                if (_that.state !== _that.STABLE && _that.state !== _that.NEGOTIATION_REQUESTED) {
                                    _stateChangeError(newState);
                                }
                                break;
                            case _that.HAVE_LOCAL_PRANSWER:
                            case _that.HAVE_LOCAL_ANSWER:
                                if (_that.state !== _that.HAVE_REMOTE_OFFER && _that.state !== _that.HAVE_LOCAL_PRANSWER) {
                                    _stateChangeError(newState);
                                }
                                break;
                            case _that.TERMINATED:
                                break;
                            default:
                                _stateChangeError(newState);
                        }
                        _that.state = newState;
                    };
                    this.complete = function () {
                        _that.changing = false;
                    };
                }
                function OrtcSession(_context, sessionId, callback) {
                    this.configureModalitiesAsync = _configureModalitiesAsync;
                    this.processOfferAsync = _processOfferAsync;
                    this.createAnswerAsync = _createAnswerAsync;
                    this.createOfferAsync = _createOfferAsync;
                    this.processAnswerAsync = _processAnswerAsync;
                    this.completeNegotiationAsync = _completeNegotiationAsync;
                    this.rejectNegotiationAsync = _rejectNegotiationAsync;
                    this.createRemoteRenderer = _createRemoteRenderer;
                    this.sendDtmf = _sendDtmf;
                    this.canSendDtmf = _canSendDtmf;
                    this.getStatsAsync = _getStatsAsync;
                    this.terminate = _terminate;
                    this._deviceSelectionChanged = _deviceSelectionChanged;
                    this._onTerminated = null;
                    this.onNegotiationRequired = null;
                    this.onContributingSourcesChanged = null;
                    this.onSessionErrorOccurred = null;
                    this.getExtensionsManager = _getExtensionsManager;
                    var _settings = _context.maContext.settings;
                    var _iceTransportPolicy = _context.config.iceTransportPolicy ? _context.config.iceTransportPolicy : constants_1["default"].ICE_TRANSPORT_POLICY.all;
                    var _numVideoChannels = _context.config.isConference && _settings.numVideoChannelsGvc ? _settings.numVideoChannelsGvc : 1;
                    var _logger = _context.getLogger().createChild('ortc');
                    var _deviceManager = _context.getDeviceManager();
                    var _that = this;
                    var _enableRtcpDemux = true; // if not set, will not create rtcp icetrandport nor put separate rtcp candidates to the offer. For experimenting only, _enableRtcpDemux = false does not work with NAMA
                    var _remoteOfferedTransportParams = null;
                    var _ortcNegotiation = new ortcNegotiation_1["default"](_logger, _settings, _numVideoChannels);
                    var _audio = null; //html audio element, does not have to be in dom
                    var _ortcSdp = new ortcSdp_1["default"]();
                    var _state = new OrtcState();
                    var _mediaChannels = []; // this has 1:1 mapping to media lines in SDP and to (_offered|_answered|_negotiated)Params.media[] arrays
                    var _activeModalities = {};
                    var _configuredModalities;
                    var _offeredModalities;
                    var _negotiatingModalities;
                    var _forceRenegotiation = false;
                    var _initiator = false;
                    var _transportCb = {
                        triggerIceReinvite: function () {
                            if (_settings.disableIceReinvite) {
                                _logger.log('ICE-reinvite disabled - triggerIceReinvite skipped');
                                return;
                            }
                            _logger.log('triggerIceReinvite');
                            _triggerRenegotiation(true);
                        },
                        raiseError: _raiseError
                    };
                    var _transport = new ortcTransport_1["default"](_logger, _settings, _transportCb, _context.maContext.getRelayManager(), _context.config.isRemoteClientLync, _iceTransportPolicy, _enableRtcpDemux);
                    var _statistics = Promise.resolve({});
                    var _renderers = ortcVideoRendererGroup_1["default"].build({
                        logger: _logger
                    });
                    var ssrcGenerator = ortcSsrcGenerator_1["default"].build();
                    var _configuredModalitiesPromise = Promise.resolve();
                    var _passiveModalities = _context.config.passiveModalities;
                    var _extensionsManager = new extensionsManager_1["default"]();
                    var _activeSpeakerManager = new activeSpeakerManager_1.ActiveSpeakerManager(callback.onContributingSourcesChanged, callback.onDominantSpeakerChanged);
                    _activeSpeakerManager.setStrategy(new dshGeneratingStrategy_1.DHSGeneratingStategy(_context.maContext.settings.activeSpeaker));
                    _logger.log('create session', 'config:', _context.config);
                    // create new channel if missing. Never delete any channels here. _assureChannels is called in createoffer/createanswer.
                    // Since channel creation is not modifying existing rtp sessions, there's no problem if negotiation gets rejected
                    function _assureChannels(descrs) {
                        var videoIdx = 0;
                        for (var i = 0; i < descrs.length; i++) {
                            if (descrs[i].label === constants_1["default"].MEDIA_LABEL.audio && !_mediaChannels[i]) {
                                _mediaChannels[i] = new ortcMediaChannel_1["default"](_logger.createChild('AStrm:'), _settings, descrs[i].type, descrs[i].label, _raiseError, ssrcGenerator.nextAudioStreamSsrc(), false);
                            }
                            else if (descrs[i].label === constants_1["default"].MEDIA_LABEL.video) {
                                if (!_mediaChannels[i]) {
                                    _mediaChannels[i] = new ortcMediaChannel_1["default"](_logger.createChild('VStrm' + videoIdx + ':'), _settings, descrs[i].type, descrs[i].label, _raiseError, ssrcGenerator.nextVideoStreamSsrc(), false);
                                }
                                videoIdx++;
                            }
                            else if (descrs[i].label === constants_1["default"].MEDIA_LABEL.screensharing) {
                                if (!_mediaChannels[i]) {
                                    // for screensharing it is important to maintain resolution when degrading quality.
                                    var maintainRes = !descrs[i].send; // var maintainRes - workaround for Edge's bug,
                                    // which does not create a stream when we try to _send_ with maintain-resolution
                                    _mediaChannels[i] = new ortcMediaChannel_1["default"](_logger.createChild('SSStrm:'), _settings, descrs[i].type, descrs[i].label, _raiseError, ssrcGenerator.nextVideoStreamSsrc(), maintainRes);
                                }
                            }
                            if (_mediaChannels[i] && _mediaChannels[i].type !== descrs[i].type) {
                                throw new Error('Error in media descriptors ch.type: ' + _mediaChannels[i].type + ' descr.type: ' + descrs[i].type);
                            }
                            if (_mediaChannels[i] && _mediaChannels[i].label !== descrs[i].label) {
                                throw new Error('Error in media descriptors ch.label: ' + _mediaChannels[i].label + ' descr.label: ' + descrs[i].label);
                            }
                        }
                    }
                    function _findFirstChannelByLabel(channels, label) {
                        for (var i = 0; i < channels.length; i++) {
                            if (channels[i].label === label) {
                                return channels[i];
                            }
                        }
                        return null;
                    }
                    function _getMediaChannelParams() {
                        var channelParams = [];
                        for (var i = 0; i < _mediaChannels.length; i++) {
                            if (_mediaChannels[i]) {
                                channelParams[i] = _mediaChannels[i].getLocalParameters();
                            }
                        }
                        return channelParams;
                    }
                    function _raiseError(mediaError) {
                        _logger.error('Media error occurred', 'type:', mediaError.type, 'detail:', mediaError.detail);
                        if (_that.onSessionErrorOccurred) {
                            _that.onSessionErrorOccurred(mediaError);
                        }
                    }
                    function _getValues(obj) {
                        if (obj) {
                            var xstr = {};
                            utils_1["default"].forOwn(obj, function (value, name) {
                                try {
                                    xstr[name] = (typeof value === 'function') ? xstr[name] = value() : xstr[name] = value;
                                }
                                catch (e) {
                                    xstr[name] = 'error: ' + e;
                                }
                            });
                            return JSON.stringify(xstr);
                        }
                    }
                    function _onAudioError(error) {
                        if (error) {
                            _logger.error('_audio.onerror', _getValues(error));
                        }
                        else {
                            _logger.error('_audio.onerror', 'error:', _audio ? _audio.error : '<no audio element>');
                        }
                    }
                    function _startOrRestartAudio(audioTrack) {
                        if (!_audio) {
                            _audio = document.createElement('audio');
                            document.body.appendChild(_audio);
                            _audio.autoplay = true;
                            _audio.addEventListener('error', _onAudioError);
                        }
                        else {
                            _audio.removeEventListener('error', _onAudioError);
                            _audio.addEventListener('error', _onAudioError);
                            window.detachMediaStream(_audio);
                        }
                        var audioRecvStream = new MediaStream([audioTrack]);
                        window.attachMediaStream(_audio, audioRecvStream);
                    }
                    function _stopAudio() {
                        if (_audio) {
                            _audio.removeEventListener('error', _onAudioError);
                            document.body.removeChild(_audio);
                            window.detachMediaStream(_audio);
                            _audio = null;
                        }
                    }
                    function _triggerRenegotiation(forceRenegotiation) {
                        if (_state.state === _state.STABLE && !_state.changing) {
                            _state.change(_state.NEGOTIATION_REQUESTED);
                            _logger.log('triggerNegotiation', 'mods:', JSON.stringify(_configuredModalities), 'force:', forceRenegotiation);
                            _forceRenegotiation = false;
                            if (_that.onNegotiationRequired) {
                                _that.onNegotiationRequired();
                            }
                        }
                        else {
                            if (forceRenegotiation) {
                                _forceRenegotiation = true;
                            }
                        }
                    }
                    function _configureModalitiesAsync(modalities) {
                        var pendingPromise = _configuredModalitiesPromise.then(function () {
                            return new Promise(function (resolve) {
                                if (!modalities || (!modalities.audio && !modalities.video && !modalities.screensharing)) {
                                    throw new Error('Invalid parameters!' + JSON.stringify(modalities));
                                }
                                var needNewRenegotiation = !_configuredModalities || !helper_1["default"].areNegotiatedDirectionsFulfilled(modalities, _activeModalities);
                                _configuredModalities = modalities; //assign always as if negotiated already confirms to desired but current configured is different (other side did not want to receive)
                                if (needNewRenegotiation) {
                                    _triggerRenegotiation(); //NB! if we want to _triggerRenegotiation also from onnegotiationneeded then in here we could check for stable peer connection state also
                                }
                                resolve(_configuredModalities);
                            });
                        });
                        _configuredModalitiesPromise = pendingPromise.catch(function (error) {
                            _logger.warn('Error during configuring modalities: ', error);
                        });
                        return pendingPromise;
                    }
                    function _processOfferAsync(mediaContent) {
                        return new Promise(function (resolve) {
                            _initiator = false;
                            var offer = mediaContent.blob;
                            _logger.debug('PROCESS OFFER', 'sdp:', offer);
                            _state.change(_state.HAVE_REMOTE_OFFER);
                            var offeredParams;
                            offeredParams = _ortcSdp.sdpToParams(offer);
                            _ortcNegotiation.processOffer(offeredParams);
                            _remoteOfferedTransportParams = offeredParams.transportParams;
                            _offeredModalities = helper_1["default"].invertModalities(ortcHelper_1["default"].getModalitiesFromMedia(offeredParams.media));
                            resolve(_offeredModalities);
                        });
                    }
                    function _createAnswerAsync(provisional) {
                        return new Promise(function (resolve) {
                            if (provisional) {
                                _state.change(_state.HAVE_LOCAL_PRANSWER, true);
                                _negotiatingModalities = { audio: 'sendrecv', video: 'sendrecv', screensharing: 'sendrecv' }; // sendrecv for provisional
                            }
                            else {
                                _state.change(_state.HAVE_LOCAL_ANSWER, true);
                                if (!_configuredModalities) {
                                    throw new Error('Modalities not configured for answer');
                                }
                                _negotiatingModalities = helper_1["default"].excludePassiveModalities(_configuredModalities, _passiveModalities, _offeredModalities); // take snapshot
                            }
                            var descrs = _ortcNegotiation.createMediaDescriptorsForAnswer(_negotiatingModalities);
                            function isModalityEnabled(label, descr) {
                                return descr.label === label && descr.enabled;
                            }
                            var hasAudio = descrs.some(isModalityEnabled.bind(null, constants_1["default"].MEDIA_LABEL.audio));
                            var hasVideo = descrs.some(isModalityEnabled.bind(null, constants_1["default"].MEDIA_LABEL.video));
                            var hasScreensharing = descrs.some(isModalityEnabled.bind(null, constants_1["default"].MEDIA_LABEL.screensharing));
                            // New IceTransports will be created now internally if needed.
                            // If created in the _createAnswerAsync, they will have the iceRole 'controlled'
                            var ret = _transport.assureInitAsync('controlled', [hasAudio, hasVideo, hasScreensharing]).then(function () {
                                // depending on ice reinvite state we may need to wait ICE completed on answerer before sending answer
                                return _transport.waitIceCompletionIfNeededAsync(_remoteOfferedTransportParams).then(function () {
                                    return _transport.getLocalParamsAsync().then(function (localTransportParams) {
                                        _assureChannels(descrs);
                                        var answeredParams = _ortcNegotiation.createAnswer(descrs, localTransportParams, _getMediaChannelParams(), provisional);
                                        _state.complete();
                                        var answer = _ortcSdp.paramsToSdp(answeredParams);
                                        _logger.debug(provisional ? 'CREATE PRANSWER' : 'CREATE ANSWER', 'sdp:', answer);
                                        return { blob: answer, modalities: _negotiatingModalities };
                                    });
                                });
                            });
                            resolve(ret);
                        });
                    }
                    function _createOfferAsync() {
                        return new Promise(function (resolve) {
                            _initiator = true;
                            _state.change(_state.HAVE_LOCAL_OFFER, true);
                            _negotiatingModalities = helper_1["default"].excludePassiveModalities(_configuredModalities, _passiveModalities, _offeredModalities); // take snapshot
                            _offeredModalities = _negotiatingModalities;
                            // if we have sendDirectionality on screensharing and did not allow it on MA level - bail out
                            if (helper_1["default"].hasSendDirectionality(_negotiatingModalities.screensharing) && !_settings.allowSendScreensharing) {
                                throw new Error('unsupported shreensharing send directionality in _negotiatingModalities' + JSON.stringify(_negotiatingModalities));
                            }
                            var descrs = _ortcNegotiation.createMediaDescriptorsForOffer(_negotiatingModalities);
                            // New IceTransports will be created now internally if needed.
                            // If created in the _createOfferAsync, they will have the iceRole 'controlling'
                            var ret = _transport.assureInitAsync('controlling', [!!_negotiatingModalities.audio, !!_negotiatingModalities.video, !!_negotiatingModalities.screensharing]).then(function () {
                                return _transport.getLocalParamsAsync().then(function (localTransportParams) {
                                    _assureChannels(descrs);
                                    var offeredParams = _ortcNegotiation.createOffer(descrs, localTransportParams, _getMediaChannelParams());
                                    _state.complete();
                                    var offer = _ortcSdp.paramsToSdp(offeredParams);
                                    _logger.debug('CREATE OFFER', 'sdp:', offer);
                                    return { blob: offer, modalities: _negotiatingModalities };
                                });
                            });
                            resolve(ret);
                        });
                    }
                    function _processAnswerAsync(mediaContent, provisional) {
                        return new Promise(function (resolve) {
                            var answer = mediaContent.blob;
                            _logger.debug(provisional ? 'PROCESS PRANSWER' : 'PROCESS ANSWER', 'sdp:', answer);
                            if (provisional) {
                                _state.change(_state.HAVE_REMOTE_PRANSWER);
                                _logger.log('ignoring provisional answer');
                                resolve();
                            }
                            else {
                                _state.change(_state.HAVE_REMOTE_ANSWER);
                                var answeredParams;
                                answeredParams = _ortcSdp.sdpToParams(answer);
                                _ortcNegotiation.processAnswer(answeredParams);
                                resolve(helper_1["default"].invertModalities(ortcHelper_1["default"].getModalitiesFromMedia(answeredParams.media)));
                            }
                        });
                    }
                    function _getMediaIfNeeded(audio, video, screensharing) {
                        return audio || video || screensharing ? _deviceManager._getMediaStream({ audio: audio, video: (video || screensharing) }) : null;
                    }
                    function _completeNegotiationAsync() {
                        return new Promise(function (resolve) {
                            _state.change(_state.STABLE, true);
                            var negotiatedParams = _ortcNegotiation.completeNegotiation();
                            var mediaParams = negotiatedParams.media;
                            var audioDescr = ortcHelper_1["default"].findDescrFromMedia(mediaParams, constants_1["default"].MEDIA_LABEL.audio);
                            var videoDescr = ortcHelper_1["default"].findDescrFromMedia(mediaParams, constants_1["default"].MEDIA_LABEL.video);
                            var screensharingDescr = ortcHelper_1["default"].findDescrFromMedia(mediaParams, constants_1["default"].MEDIA_LABEL.screensharing);
                            var mediaStream = _getMediaIfNeeded(audioDescr.send, videoDescr.send, screensharingDescr.send);
                            var finalize = function (succeeded) {
                                var arg = arguments[1];
                                // release the ref here, _mediaChannels performed mediaStream.clone() if they needed it
                                if (mediaStream) {
                                    mediaStream.dispose();
                                }
                                if (succeeded) {
                                    return arg;
                                }
                                throw arg;
                            };
                            resolve(Promise.all([
                                _transport.configureTransportAsync(negotiatedParams.transportParams, [audioDescr.enabled, videoDescr.enabled, screensharingDescr.enabled]),
                                mediaStream ? mediaStream.start() : Promise.resolve()
                            ]).then(function () {
                                _assureAlive();
                                for (var i = 0; i < mediaParams.length; i++) {
                                    if (mediaParams[i].descr.label === constants_1["default"].MEDIA_LABEL.audio) {
                                        var oldRecvTrack = _mediaChannels[i].getRecvTrack();
                                        _mediaChannels[i].configureChannel(mediaParams[i], _transport.audioTransport, mediaStream);
                                        // if audio receiver started
                                        if (_mediaChannels[i].getRecvTrack() && (_mediaChannels[i].getRecvTrack() !== oldRecvTrack)) {
                                            _startOrRestartAudio(_mediaChannels[i].getRecvTrack());
                                            _mediaChannels[i].onContributingSourcesChanged = _activeSpeakerManager.onContributingSourcesChanged.bind(_activeSpeakerManager);
                                        }
                                        else if (!_mediaChannels[i].getRecvTrack() && oldRecvTrack) {
                                            _stopAudio();
                                            _mediaChannels[i].onContributingSourcesChanged = null;
                                        }
                                    }
                                    else if (mediaParams[i].descr.label === constants_1["default"].MEDIA_LABEL.video) {
                                        _mediaChannels[i].configureChannel(mediaParams[i], _transport.videoTransport, mediaStream);
                                    }
                                    else if (mediaParams[i].descr.label === constants_1["default"].MEDIA_LABEL.screensharing) {
                                        _mediaChannels[i].configureChannel(mediaParams[i], _transport.screensharingTransport, mediaStream);
                                    }
                                }
                                updateRenderers();
                                _state.complete();
                                _activeModalities = ortcHelper_1["default"].getModalitiesFromMedia(mediaParams);
                                var valuableConfiguredModalities = helper_1["default"].excludePassiveModalities(_configuredModalities, _passiveModalities, _offeredModalities);
                                var needNewRenegotiation = _forceRenegotiation ||
                                    !helper_1["default"].areNegotiatedDirectionsAcceptable(valuableConfiguredModalities, _negotiatingModalities, _activeModalities);
                                if (needNewRenegotiation) {
                                    _triggerRenegotiation();
                                }
                                _logger.log('_completeNegotiationAsync: configured:', JSON.stringify(_configuredModalities), '_negotiatingModalities:', JSON.stringify(_negotiatingModalities), 'activeModalities:', JSON.stringify(_activeModalities));
                                return {
                                    isComplete: !needNewRenegotiation,
                                    activeModalities: _activeModalities,
                                    offeredModalities: _offeredModalities,
                                    attemptedModalities: _negotiatingModalities,
                                    configuredModalities: _configuredModalities,
                                    initiator: _initiator
                                };
                            }).then(finalize.bind(null, true), finalize.bind(null, false)));
                        });
                    }
                    function updateRenderers() {
                        _renderers.update(_mediaChannels.filter(function (channel) { return constants_1["default"].MEDIA_LABEL.video === channel.label || constants_1["default"].MEDIA_LABEL.screensharing === channel.label; }));
                    }
                    function _rejectNegotiationAsync(error, retry) {
                        return new Promise(function (resolve) {
                            var isComplete = (error === constants_1["default"].RENEGOTIATION_ERROR.local);
                            _state.state = _state.STABLE;
                            _logger.error('negotiation failed', 'error:', error);
                            if (retry) {
                                _logger.log('retrying failed negotiation');
                                _triggerRenegotiation();
                            }
                            //note on glare case we dont trigger new negotiation because we will receive soon new offer
                            resolve({ isComplete: isComplete, activeModalities: _activeModalities, offeredModalities: _offeredModalities, attemptedModalities: _negotiatingModalities, configuredModalities: _configuredModalities, initiator: _initiator });
                        });
                    }
                    function _createRemoteRenderer(element, callback) {
                        return _renderers.create(element, callback);
                    }
                    function _deviceSelectionChanged() {
                        _logger.log('_deviceSelectionChanged');
                        var sendingAudio = helper_1["default"].hasSendDirectionality(_activeModalities.audio);
                        var sendingVideo = helper_1["default"].hasSendDirectionality(_activeModalities.video);
                        if (!_isTerminated() && (sendingAudio || sendingVideo)) {
                            var mediaStream = _deviceManager._getMediaStream({ audio: sendingAudio, video: sendingVideo });
                            mediaStream.start().then(function () {
                                var channel;
                                if (sendingAudio) {
                                    channel = _findFirstChannelByLabel(_mediaChannels, constants_1["default"].MEDIA_LABEL.audio);
                                    channel.updateLocalMediaStream(mediaStream);
                                }
                                if (sendingVideo) {
                                    channel = _findFirstChannelByLabel(_mediaChannels, constants_1["default"].MEDIA_LABEL.video);
                                    channel.updateLocalMediaStream(mediaStream);
                                }
                                // _mediaChannels performed mediaStream.clone() if they use the track
                                mediaStream.dispose();
                            }).catch(function (error) {
                                _raiseError({
                                    type: constants_1["default"].MEDIA_ERROR.internalError,
                                    detail: error
                                });
                                mediaStream.dispose();
                            });
                        }
                    }
                    function _getStatsAsync() {
                        if (_isTerminated()) {
                            return _statistics;
                        }
                        _statistics = new Promise(function (resolve) {
                            var stats = { localStreams: [{ tracks: [] }], remoteStreams: [{ tracks: [] }] };
                            var audioChannel = _findFirstChannelByLabel(_mediaChannels, constants_1["default"].MEDIA_LABEL.audio);
                            var videoChannel = _findFirstChannelByLabel(_mediaChannels, constants_1["default"].MEDIA_LABEL.video);
                            var screensharingChannel = _findFirstChannelByLabel(_mediaChannels, constants_1["default"].MEDIA_LABEL.screensharing);
                            if (audioChannel && audioChannel.getSendTrack()) {
                                stats.localStreams[0].tracks.push({ stream: null, track: audioChannel.getSendTrack() });
                            }
                            if (videoChannel && videoChannel.getSendTrack()) {
                                stats.localStreams[0].tracks.push({ stream: null, track: videoChannel.getSendTrack() });
                            }
                            if (screensharingChannel && screensharingChannel.getSendTrack()) {
                                stats.localStreams[0].tracks.push({ stream: null, track: screensharingChannel.getSendTrack() });
                            }
                            if (audioChannel && audioChannel.getRecvTrack()) {
                                stats.remoteStreams[0].tracks.push({ stream: null, track: audioChannel.getRecvTrack() });
                            }
                            if (videoChannel && videoChannel.getRecvTrack()) {
                                stats.remoteStreams[0].tracks.push({ stream: null, track: videoChannel.getRecvTrack() });
                            }
                            if (screensharingChannel && screensharingChannel.getRecvTrack()) {
                                stats.remoteStreams[0].tracks.push({ stream: null, track: screensharingChannel.getRecvTrack() });
                            }
                            Promise.all([
                                audioChannel ? audioChannel.getReportsAsync() : {},
                                videoChannel ? videoChannel.getReportsAsync() : {},
                                screensharingChannel ? screensharingChannel.getReportsAsync() : {}
                            ]).then(function (reports) {
                                stats.ortc = {
                                    CorrelationId: sessionId,
                                    mainAudio: reports[0],
                                    mainVideo: reports[1],
                                    appsharingVideo: reports[2]
                                };
                                resolve(stats);
                            }).catch(function (error) {
                                _logger.error('getting statistics should never fail:', error);
                                resolve(stats);
                            });
                        });
                        return _statistics;
                    }
                    function _isTerminated() {
                        return _state.state === _state.TERMINATED;
                    }
                    function _assureAlive() {
                        if (_isTerminated()) {
                            throw new Error('session is already terminated');
                        }
                    }
                    function _terminate() {
                        _logger.log('terminate');
                        _extensionsManager.dispose();
                        return _getStatsAsync().then(function () {
                            _state.change(_state.TERMINATED);
                            _transport.stop();
                            _stopAudio();
                            // this will reject pending async subscriptions too
                            _renderers.terminate();
                            _mediaChannels.forEach(function (channel) {
                                channel.terminate();
                            });
                            if (_that._onTerminated) {
                                _that._onTerminated(_that);
                            }
                        });
                    }
                    function _sendDtmf(dtmfCode) {
                        var channel = _findFirstChannelByLabel(_mediaChannels, constants_1["default"].MEDIA_LABEL.audio);
                        if (channel) {
                            return channel.sendDtmf(dtmfCode);
                        }
                        return Promise.reject(new Error('no audio channel'));
                    }
                    function _canSendDtmf() {
                        var channel = _findFirstChannelByLabel(_mediaChannels, constants_1["default"].MEDIA_LABEL.audio);
                        if (channel) {
                            return channel.canSendDtmf();
                        }
                        return false;
                    }
                    function _getExtensionsManager() {
                        return _extensionsManager;
                    }
                }
                exports.__esModule = true;
                exports["default"] = {
                    build: function (context, callId, callback) {
                        return new OrtcSession(context, callId, callback);
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/statistics/sessionStatistics', ["require", "exports"], factory);
                }
            })(function (require, exports) {
                function SessionStatistics() {
                    var creationTime = new Date().getTime(), initialNegotiationType, currentNegotiationType, negotiationCount = 0, initialNegotiationCompleted = false, multiParty = false, mediaLegId, duration = 0, terminationTime = 0, sessionId = '0', rejectedNegotiationCount = 0, mediaError = {
                        type: 'none',
                        detail: 'none'
                    }, dtmfSuccess = 0, dtmfFailure = 0;
                    this.negotiation = {
                        offering: offering(),
                        answering: answering(),
                        current: current()
                    };
                    this.terminated = function () {
                        terminationTime = new Date().getTime();
                        duration = new Date().getTime() - creationTime;
                    };
                    this.setMultiParty = function () {
                        multiParty = true;
                    };
                    this.setMediaLegId = function (medialeg) {
                        mediaLegId = medialeg;
                    };
                    this.setId = function (id) {
                        sessionId = id;
                    };
                    this.setError = function (error) {
                        mediaError.type = error.type || 'internalError';
                        mediaError.detail = error.detail || error.toString();
                    };
                    this.dtmfResult = function (success) {
                        success ? ++dtmfSuccess : ++dtmfFailure;
                    };
                    this.getReport = function () {
                        return {
                            CorrelationId: sessionId,
                            CallNumber: 0,
                            RetargetCount: 0,
                            CreationTime: getHpTimeFromMillis(creationTime),
                            InitTime: getHpTimeFromMillis(creationTime),
                            TerminationTime: getHpTimeFromMillis(terminationTime),
                            CallDuration: getHpTimeFromMillis(duration),
                            InitialNegotiationType: initialNegotiationType || 'none',
                            InitialNegotiationCompleted: initialNegotiationCompleted,
                            NegotiationCount: negotiationCount,
                            RejectedNegotiationCount: rejectedNegotiationCount,
                            MediaLegId: mediaLegId,
                            MultiParty: multiParty,
                            ErrorType: mediaError.type,
                            ErrorDetail: mediaError.detail,
                            DtmfSuccess: dtmfSuccess,
                            DtmfFailure: dtmfFailure
                        };
                    };
                    function offering() {
                        return {
                            started: function () {
                                currentNegotiationType = 'Offering';
                                negotiationStarted();
                            }
                        };
                    }
                    function answering() {
                        return {
                            started: function () {
                                currentNegotiationType = 'Answering';
                                negotiationStarted();
                            }
                        };
                    }
                    function negotiationStarted() {
                        initialNegotiationType = initialNegotiationType || currentNegotiationType;
                        ++negotiationCount;
                    }
                    function current() {
                        return {
                            completed: function () {
                                if (negotiationCount === 1) {
                                    initialNegotiationCompleted = true;
                                }
                            },
                            rejected: function () {
                                ++rejectedNegotiationCount;
                            }
                        };
                    }
                    function getHpTimeFromMillis(millis) {
                        return millis * 10000; // convert unit from 1ms to 100ns
                    }
                }
                exports.__esModule = true;
                exports["default"] = {
                    build: function () {
                        return new SessionStatistics();
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/statistics/mediaLegId', ["require", "exports", '../common/utils'], factory);
                }
            })(function (require, exports) {
                var utils_1 = require('../common/utils');
                function MediaLegId() {
                    var mediaLegId;
                    this.process = function (incomingLeg) {
                        // if leg is undefined/null - generate, define, and return
                        if (!mediaLegId) {
                            mediaLegId = incomingLeg || utils_1["default"].uniqueId().toUpperCase();
                        }
                        return mediaLegId;
                    };
                }
                exports.__esModule = true;
                exports["default"] = {
                    build: function () {
                        return new MediaLegId();
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/session', ["require", "exports", './webrtc/webRtcSession', './ortc/ortcSession', './statistics/sessionStatistics', './statistics/mediaLegId', './constants'], factory);
                }
            })(function (require, exports) {
                var webRtcSession_1 = require('./webrtc/webRtcSession');
                var ortcSession_1 = require('./ortc/ortcSession');
                var sessionStatistics_1 = require('./statistics/sessionStatistics');
                var mediaLegId_1 = require('./statistics/mediaLegId');
                var constants_1 = require('./constants');
                function Session(session, context, id, callback) {
                    var self = this, statistics = sessionStatistics_1["default"].build(), mediaLegId = mediaLegId_1["default"].build(), settings = context.maContext.settings, rejectedNegotiations = 0;
                    statistics.setId(id);
                    if (context.config.isConference) {
                        statistics.setMultiParty();
                    }
                    this.createOfferAsync = function () {
                        statistics.negotiation.offering.started();
                        return session.createOfferAsync.apply(session, arguments).then(function (mediaContent) {
                            mediaContent.mediaLegId = mediaLegId.process(mediaContent.mediaLegId);
                            return mediaContent;
                        }).catch(function (error) {
                            statistics.setError(error);
                            throw error;
                        });
                    };
                    this.processOfferAsync = function (mediaContent) {
                        statistics.negotiation.answering.started();
                        mediaLegId.process(mediaContent.mediaLegId);
                        return session.processOfferAsync.apply(session, arguments).catch(function (error) {
                            statistics.setError(error);
                            throw error;
                        });
                    };
                    this.processAnswerAsync = function () {
                        return session.processAnswerAsync.apply(session, arguments).catch(function (error) {
                            statistics.setError(error);
                            throw error;
                        });
                    };
                    this.completeNegotiationAsync = function () {
                        rejectedNegotiations = 0;
                        return session.completeNegotiationAsync.apply(session, arguments).then(function (result) {
                            statistics.negotiation.current.completed();
                            return result;
                        }).catch(function (error) {
                            statistics.setError(error);
                            throw error;
                        });
                    };
                    this.rejectNegotiationAsync = function (error) {
                        var retry = ++rejectedNegotiations <= settings.renegotiationAttempts && isRetriableError(error);
                        statistics.negotiation.current.rejected();
                        return session.rejectNegotiationAsync(error, retry).catch(function (error) {
                            statistics.setError(error);
                            throw error;
                        });
                    };
                    this.terminate = function () {
                        statistics.terminated();
                        return session.terminate.apply(session, arguments);
                    };
                    this.getStatsAsync = function () {
                        return session.getStatsAsync.apply(session, arguments).then(function (stats) {
                            statistics.setMediaLegId(mediaLegId.process());
                            stats.metrics = statistics.getReport();
                            return stats;
                        });
                    };
                    this.createAnswerAsync = function () {
                        return session.createAnswerAsync.apply(session, arguments).then(function (mediaContent) {
                            mediaContent.mediaLegId = mediaLegId.process(mediaContent.mediaLegId);
                            return mediaContent;
                        }).catch(function (error) {
                            statistics.setError(error);
                            throw error;
                        });
                    };
                    this.configureModalitiesAsync = session.configureModalitiesAsync;
                    this.createRemoteRenderer = session.createRemoteRenderer;
                    this._deviceSelectionChanged = session._deviceSelectionChanged;
                    this._onTerminated = null;
                    this.sendDtmf = function (dtmfCode) {
                        return session.sendDtmf(dtmfCode).then(function (result) {
                            statistics.dtmfResult(true);
                            return result;
                        }).catch(function (error) {
                            statistics.dtmfResult(false);
                            throw error;
                        });
                    };
                    this.canSendDtmf = function () {
                        return session.canSendDtmf();
                    };
                    this.getExtensionsManager = function () {
                        return session.getExtensionsManager();
                    };
                    session.onNegotiationRequired = callback.onNegotiationRequired;
                    session.onSessionErrorOccurred = function (mediaError) {
                        statistics.setError(mediaError);
                        callback.onSessionErrorOccurred.apply(session, arguments);
                    };
                    session._onTerminated = function () {
                        if (self._onTerminated) {
                            self._onTerminated.apply(session, arguments);
                        }
                    };
                    function isRetriableError(error) {
                        return constants_1["default"].RENEGOTIATION_ERROR.signaling === error || constants_1["default"].RENEGOTIATION_ERROR.media === error;
                    }
                }
                exports.__esModule = true;
                exports["default"] = {
                    build: function (context, id, callback) {
                        var nativeSessionFactory = typeof RTCIceGatherer === 'undefined' ? webRtcSession_1["default"] : ortcSession_1["default"];
                        return new Session(nativeSessionFactory.build.apply(this, arguments), context, id, callback);
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/device/deviceEnumerator', ["require", "exports", '../constants', '../common/utils', '../common/userAgentAdapter'], factory);
                }
            })(function (require, exports) {
                var constants_1 = require('../constants');
                var utils_1 = require('../common/utils');
                var userAgentAdapter_1 = require('../common/userAgentAdapter');
                function DeviceEnumerator(context) {
                    var self = this, window = userAgentAdapter_1["default"].window, logger = context.logger.createChild('DeviceEnumerator'), settings = context.settings, devices, pollingTimer, defaultPollingInterval = 3000, defaultDevices = {}, enumerateDevicesPromise = Promise.resolve(), onDeviceChangeCallbackSupported;
                    defaultDevices[constants_1["default"].MEDIA_DEVICE.microphone] = {
                        id: 'default_audio_device',
                        label: 'Default audio device',
                        kind: constants_1["default"].MEDIA_DEVICE.microphone
                    };
                    defaultDevices[constants_1["default"].MEDIA_DEVICE.camera] = {
                        id: 'default_video_device',
                        label: 'Default video device',
                        kind: constants_1["default"].MEDIA_DEVICE.camera
                    };
                    this.onDevicesChanged = void 0;
                    this.enumerateDevices = function () {
                        if (!window.navigator.mediaDevices || !window.navigator.mediaDevices.enumerateDevices) {
                            return Promise.reject(new Error('device enumeration unsupported'));
                        }
                        enumerateDevicesPromise = enumerateDevicesPromise.then(function () {
                            return window.navigator.mediaDevices.enumerateDevices();
                        }).then(function (devices) {
                            return processDevices(devices);
                        });
                        return enumerateDevicesPromise;
                    };
                    this.getDefaultDevices = function () {
                        return defaultDevices;
                    };
                    this.getDeviceName = function (deviceId) {
                        if (deviceId === defaultDevices[constants_1["default"].MEDIA_DEVICE.microphone].id) {
                            return Promise.resolve(defaultDevices[constants_1["default"].MEDIA_DEVICE.microphone].label);
                        }
                        if (deviceId === defaultDevices[constants_1["default"].MEDIA_DEVICE.camera].id) {
                            return Promise.resolve(defaultDevices[constants_1["default"].MEDIA_DEVICE.camera].label);
                        }
                        var device = devices[deviceId], constraints = device.kind === constants_1["default"].MEDIA_DEVICE.microphone ?
                            { audio: { deviceId: deviceId }, video: true } :
                            { audio: true, video: { deviceId: deviceId } };
                        return window.navigator.mediaDevices.getUserMedia(constraints).then(function () {
                            return self.enumerateDevices();
                        }).then(function (newDevices) {
                            return newDevices[deviceId].label;
                        });
                    };
                    this.startDevicePolling = function () {
                        var devicePollingInterval = typeof settings.devicePollingInterval !== 'undefined' ? settings.devicePollingInterval : defaultPollingInterval;
                        if (devicePollingInterval === 0 || onDeviceChangeCallbackSupported || pollingTimer) {
                            return;
                        }
                        function pollingTask() {
                            self.enumerateDevices().then(function () {
                                pollingTimer = window.setTimeout(pollingTask, devicePollingInterval);
                            });
                        }
                        logger.log('starting device polling');
                        pollingTimer = window.setTimeout(pollingTask, devicePollingInterval);
                    };
                    this.stopDevicePolling = function () {
                        if (pollingTimer) {
                            logger.log('stopping device polling');
                            window.clearTimeout(pollingTimer);
                            pollingTimer = void 0;
                        }
                    };
                    function processDevices(gumDevices) {
                        var devices = convertDevices(gumDevices);
                        return updateDevices(devices);
                    }
                    function convertDevices(gumDevices) {
                        var devices = {};
                        gumDevices.forEach(function (gumDevice) {
                            //NB! last device with same id will overwrite the label and kind!
                            //side effect: all duplicates removed (replaced by last)
                            switch (gumDevice.kind) {
                                case 'audioinput':
                                    if (gumDevice.deviceId !== constants_1["default"].MEDIA_DEVICE.defaultId) {
                                        devices[gumDevice.deviceId] = { id: gumDevice.deviceId, label: gumDevice.label, kind: constants_1["default"].MEDIA_DEVICE.microphone };
                                    }
                                    devices[defaultDevices[constants_1["default"].MEDIA_DEVICE.microphone].id] = defaultDevices[constants_1["default"].MEDIA_DEVICE.microphone];
                                    break;
                                case 'videoinput':
                                    devices[defaultDevices[constants_1["default"].MEDIA_DEVICE.camera].id] = defaultDevices[constants_1["default"].MEDIA_DEVICE.camera];
                                    devices[gumDevice.deviceId] = { id: gumDevice.deviceId, label: gumDevice.label, kind: constants_1["default"].MEDIA_DEVICE.camera };
                                    break;
                            }
                        });
                        return devices;
                    }
                    function updateDevices(newDevices) {
                        var changed = false;
                        if (devices) {
                            utils_1["default"].forOwn(devices, function (value, key) {
                                if (!newDevices.hasOwnProperty(key)) {
                                    changed = true;
                                    logger.log('media device removed', 'kind:', value.kind, 'id:', value.id, 'label:', value.label);
                                }
                                else if (value.label !== newDevices[key].label) {
                                    changed = true;
                                    logger.log('media device label was updated');
                                }
                            });
                            utils_1["default"].forOwn(newDevices, function (value, key) {
                                if (!devices.hasOwnProperty(key)) {
                                    changed = true;
                                    logger.log('media device added', 'kind:', value.kind, 'id:', value.id, 'label:', value.label);
                                }
                            });
                        }
                        devices = newDevices;
                        if (changed && self.onDevicesChanged) {
                            self.onDevicesChanged(devices);
                        }
                        return devices;
                    }
                    function enableOnDeviceChangeCallbackSupport() {
                        onDeviceChangeCallbackSupported = true;
                        self.stopDevicePolling();
                    }
                    if (window.navigator.mediaDevices) {
                        window.navigator.mediaDevices.ondevicechange = function () {
                            enableOnDeviceChangeCallbackSupport();
                            self.enumerateDevices();
                        };
                    }
                }
                exports.__esModule = true;
                exports["default"] = {
                    build: function (context) {
                        return new DeviceEnumerator(context);
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/device/mediaStream', ["require", "exports", '../constants', '../helper', '../webrtc/resolutionTable', '../common/utils', '../common/userAgentAdapter'], factory);
                }
            })(function (require, exports) {
                var constants_1 = require('../constants');
                var helper_1 = require('../helper');
                var resolutionTable_1 = require('../webrtc/resolutionTable');
                var utils_1 = require('../common/utils');
                var userAgentAdapter_1 = require('../common/userAgentAdapter');
                function MediaStreamClient(mediaStream) {
                    var self = this, ms = mediaStream;
                    this.onApplyConstraints = null;
                    this.onMute = null;
                    this.dispose = function () {
                        return ms.dispose(this);
                    };
                    this.clone = function () {
                        return ms.getClient();
                    };
                    this.getObject = function () {
                        return ms.getObject();
                    };
                    this.applyConstraints = function (c) {
                        return ms.applyConstraints(c);
                    };
                    this.setMute = function (doMute) {
                        ms.setMute(doMute);
                    };
                    this.setHold = function (doHold) {
                        ms.setHold(doHold);
                    };
                    this.start = function () {
                        return ms.start();
                    };
                    this.hasAudio = function () {
                        return ms.hasAudio();
                    };
                    this.hasVideo = function () {
                        return ms.hasVideo();
                    };
                    this.getConstraints = function () {
                        return ms.getConstraints();
                    };
                }
                function MediaStream(context, gumConstraints) {
                    var self = this, window = userAgentAdapter_1["default"].window, logger = context.logger.createChild('MediaStream'), refs = [], gumStream, gumPromise, isMuted = false, isHold = false, resTable = resolutionTable_1["default"].build(), selfGlobal;
                    var constraints = {};
                    this.getObject = function () {
                        return gumStream;
                    };
                    this.applyConstraints = function (c) {
                        if (gumStream && c.maxFS && c.maxFPS) {
                            var resolution = resTable.getResolution(c.maxFS);
                            if (constraints.width !== resolution.width || constraints.height !== resolution.height || constraints.fps !== c.maxFPS) {
                                constraints.width = resolution.width;
                                constraints.height = resolution.height;
                                constraints.fps = c.maxFPS;
                                return applyConstraintsInternal().then(function () {
                                    return true;
                                });
                            }
                        }
                        return Promise.resolve(false);
                    };
                    this.getClient = function () {
                        var client = new MediaStreamClient(this);
                        refs.push(client);
                        return client;
                    };
                    this.setMute = function (doMute) {
                        isMuted = doMute;
                        refs.forEach(function (ref) {
                            if (ref.onMute) {
                                ref.onMute(doMute);
                            }
                        });
                        enableDisableTracks();
                    };
                    this.setHold = function (doHold) {
                        isHold = doHold;
                        enableDisableTracks();
                    };
                    this.dispose = function (ref) {
                        if (refs.indexOf(ref) >= 0) {
                            utils_1["default"].remove(refs, function (value) {
                                return value === ref;
                            });
                            if (refs.length === 0) {
                                if (self.onDisposed) {
                                    self.onDisposed();
                                }
                                return stopGumStream();
                            }
                        }
                        return Promise.resolve();
                    };
                    this.start = function () {
                        if (!gumPromise) {
                            gumPromise = updateGumStream(gumConstraints);
                        }
                        return gumPromise;
                    };
                    this.hasAudio = function () {
                        return !!gumStream && gumStream.getAudioTracks().length !== 0;
                    };
                    this.hasVideo = function () {
                        return !!gumStream && gumStream.getVideoTracks().length !== 0;
                    };
                    this.getConstraints = function () {
                        return gumConstraints;
                    };
                    function applyConstraintsInternal() {
                        return new Promise(function (resolve) {
                            logger.log('applying stream constraints:', JSON.stringify(constraints));
                            var p = helper_1["default"].defer();
                            refs.forEach(function (ref) {
                                if (ref.onApplyConstraints) {
                                    ref.onApplyConstraints(p.promise);
                                }
                            });
                            resolve(asGumOperation(function () {
                                stopGumStreamInternal();
                                var policies = generatePolicies();
                                gumPromise = updateGumStreamInternal(policies[0]());
                                policies.slice(1).forEach(function (gumConstraintsPolicy) {
                                    gumPromise = gumPromise.catch(function (error) {
                                        if (constants_1["default"].MEDIA_ERROR.constraintNotSatisfiedError === error.type) {
                                            logger.warn('could not obtain constrained media stream, will attempt weaker policy');
                                            return updateGumStreamInternal(gumConstraintsPolicy());
                                        }
                                        throw error;
                                    });
                                });
                                return gumPromise;
                            }).then(p.resolve).catch(function (error) {
                                logger.error('failed to apply constraints:', JSON.stringify(constraints), 'error:', error);
                                p.reject(error);
                                throw error;
                            }));
                        });
                    }
                    function enableDisableTracks() {
                        if (gumStream) {
                            gumStream.getTracks().forEach(function (track) {
                                if (typeof track.enabled !== 'undefined') {
                                    track.enabled = !(track.kind === 'audio' && isMuted) && !isHold;
                                    logger.log('control media stream track', 'kind:', track.kind, 'enabled:', track.enabled, 'muted:', track.muted);
                                }
                            });
                        }
                    }
                    function updateGumStream(constraints) {
                        logger.log('queueing media stream update to:', JSON.stringify(constraints));
                        return asGumOperation(function () {
                            return updateGumStreamInternal(constraints);
                        });
                    }
                    function updateGumStreamInternal(constraints) {
                        return new Promise(function (resolve, reject) {
                            logger.log('querying user media for stream:', JSON.stringify(constraints));
                            window.navigator.getUserMedia(constraints, resolve, reject);
                        }).catch(function (error) {
                            if ('SourceUnavailableError' === error.name) {
                                error = {
                                    type: constants_1["default"].MEDIA_ERROR.sourceUnavailableError,
                                    detail: 'media device is already used by another process: ' + error.toString()
                                };
                            }
                            else if ('ConstraintNotSatisfiedError' === error.name) {
                                error = {
                                    type: constants_1["default"].MEDIA_ERROR.constraintNotSatisfiedError,
                                    detail: 'could not obtain constrained media stream: ' + error.toString()
                                };
                            }
                            else {
                                error = {
                                    type: constants_1["default"].MEDIA_ERROR.permissionDeniedError,
                                    detail: 'permission to use media device was denied: ' + error.toString()
                                };
                            }
                            throw error;
                        }).then(function (stream) {
                            gumStream = stream;
                            enableDisableTracks();
                            logger.log('media stream updated');
                        });
                    }
                    function asGumOperation(operation) {
                        selfGlobal.gumSerializer = selfGlobal.gumSerializer || Promise.resolve();
                        var appendedOperation = selfGlobal.gumSerializer.then(operation);
                        // make sure we don't leak errors
                        selfGlobal.gumSerializer = appendedOperation.catch(function (error) {
                            logger.warn('previous gum operation failed:', error);
                        });
                        return appendedOperation;
                    }
                    function stopGumStream() {
                        if (!gumPromise) {
                            return Promise.resolve();
                        }
                        logger.log('queueing media stream stop');
                        return asGumOperation(stopGumStreamInternal);
                    }
                    function stopGumStreamInternal() {
                        if (gumStream) {
                            try {
                                gumStream.getTracks().forEach(function (track) {
                                    track.stop();
                                });
                                logger.log('media stream stopped');
                            }
                            catch (error) {
                                logger.warn('failed to stop media stream:', error);
                            }
                        }
                    }
                    /**
                    For constraints we use format used by Chrome and Opera.
                    Firefox uses different format:
                    video: {
                        width: {
                            min: ...
                            max: ...
                        }
                    }
                    We are not planning use this format here, because we are planning settings constraints on firefox using applyConstraints media streams's method.
                    */
                    function generatePolicies() {
                        var policies = resTable.getResolutions().filter(function (r) {
                            return r.width <= constraints.width && r.height <= constraints.height;
                        }).reverse().map(function (r) {
                            return function () {
                                return setMandatoryConstraints({
                                    maxWidth: constraints.width,
                                    minWidth: r.width,
                                    maxHeight: constraints.height,
                                    minHeight: r.height,
                                    maxFrameRate: constraints.fps
                                });
                            };
                        });
                        //no constraint policy
                        policies.push(function () {
                            delete gumConstraints.video.mandatory;
                            return gumConstraints;
                        });
                        return policies;
                    }
                    function setMandatoryConstraints(mandatoryGumConstraints) {
                        if (mandatoryGumConstraints) {
                            logger.log("Setting mandatory constraints", JSON.stringify(mandatoryGumConstraints));
                        }
                        if (constraints.width && constraints.height && constraints.fps) {
                            if (typeof gumConstraints.video !== 'object') {
                                gumConstraints.video = {};
                            }
                            gumConstraints.video.mandatory = mandatoryGumConstraints;
                        }
                        else {
                            delete gumConstraints.video.mandatory;
                        }
                        return gumConstraints;
                    }
                    (function () {
                        selfGlobal = context.global.mediaStream = context.global.mediaStream || {};
                    })();
                }
                exports.__esModule = true;
                exports["default"] = {
                    build: function (context, gumConstraints) {
                        return new MediaStream(context, gumConstraints);
                    }
                };
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/device/deviceManager', ["require", "exports", '../constants', './deviceEnumerator', './mediaStream', '../common/utils', './videoRenderer'], factory);
                }
            })(function (require, exports) {
                var constants_1 = require('../constants');
                var deviceEnumerator_1 = require('./deviceEnumerator');
                var mediaStream_1 = require('./mediaStream');
                var utils_1 = require('../common/utils');
                var videoRenderer_1 = require('./videoRenderer');
                var DeviceManager = function (_context, _callback) {
                    this.enumerateDevicesAsync = _enumerateDevicesAsync;
                    this.getDeviceNameAsync = _getDeviceNameAsync;
                    this.selectDevices = _selectDevices;
                    this.getSelectedDevices = _getSelectDevices;
                    this.muteInputAsync = _muteInputAsync;
                    this.unmuteInputAsync = _unmuteInputAsync;
                    this.createPreviewRenderer = _createPreviewRenderer;
                    //used internally by session
                    this._getMediaStream = _getMediaStream;
                    var _that = this;
                    var _logger = _context.logger;
                    var _devices = {}; //assuming deviceId's are unique i.e. no camera can share same device id with microphone
                    var _deviceEnumerator = deviceEnumerator_1["default"].build({
                        logger: _logger,
                        settings: _context.settings
                    });
                    _deviceEnumerator.onDevicesChanged = function (devices) {
                        _devices = devices;
                        _cachedStreams.forEach(function (cachedStream) {
                            cachedStream.outdateIfAnyDeviceRemoved(devices);
                        });
                        if (_callback.onDevicesChanged) {
                            _callback.onDevicesChanged(utils_1["default"].values(devices));
                        }
                    };
                    // not sure if it is a good idea to have default devices selected by default
                    var _selectedDevices = {
                        microphone: _deviceEnumerator.getDefaultDevices()[constants_1["default"].MEDIA_DEVICE.microphone].id,
                        camera: _deviceEnumerator.getDefaultDevices()[constants_1["default"].MEDIA_DEVICE.camera].id
                    };
                    var _cachedStreams = [];
                    var _cachedStreamGeneration = 0;
                    var _activeRenderers = [];
                    var _globalAudioEnable = true;
                    function _updateRenderersAsync() {
                        if (_activeRenderers.length) {
                            var mediaStream = _getMediaStream({ audio: true, video: true });
                            return mediaStream.start().then(function () {
                                _activeRenderers.forEach(function (renderer) {
                                    renderer._attachMediaStreamRef(mediaStream);
                                });
                            });
                        }
                        return Promise.resolve();
                    }
                    this.Renderer = videoRenderer_1["default"];
                    function _findDeviceByTrack(track, kind) {
                        var devicesArr = utils_1["default"].values(_devices);
                        if (track.getSettings) {
                            var id = track.getSettings().deviceId;
                            return utils_1["default"].find(devicesArr, function (dev) {
                                return dev.kind === kind && dev.id === id;
                            });
                        }
                        return utils_1["default"].find(devicesArr, function (dev) {
                            return dev.kind === kind && dev.label === track.label;
                        });
                    }
                    this.getDefaultDevices = function () {
                        var streamRef = _getMediaStream({ audio: true, video: true });
                        return streamRef.start().catch(function (error) {
                            _logger.error("Could not start stream");
                        }).then(function () {
                            return _enumerateDevicesAsync();
                        }).then(function () {
                            var defaultDevices = _deviceEnumerator.getDefaultDevices();
                            var gumStream = streamRef.getObject();
                            if (gumStream) {
                                var atrack = gumStream.getAudioTracks()[0];
                                var vtrack = gumStream.getVideoTracks()[0];
                                if (atrack) {
                                    var adev = _findDeviceByTrack(atrack, constants_1["default"].MEDIA_DEVICE.microphone);
                                    if (adev) {
                                        defaultDevices[constants_1["default"].MEDIA_DEVICE.microphone] = adev;
                                    }
                                }
                                if (vtrack) {
                                    var vdev = _findDeviceByTrack(vtrack, constants_1["default"].MEDIA_DEVICE.camera);
                                    if (vdev) {
                                        defaultDevices[constants_1["default"].MEDIA_DEVICE.camera] = vdev;
                                    }
                                }
                            }
                            streamRef.dispose();
                            return utils_1["default"].values(defaultDevices);
                        }, function (error) {
                            streamRef.dispose();
                            throw error;
                        });
                    };
                    var LocalVideoRenderer = function (element, cb) {
                        videoRenderer_1["default"].call(this, element, cb);
                        var _that = this, _baseDispose = this.dispose, _streamRef = null, _isDisposed = false;
                        this._attachMediaStreamRef = function (newStreamRef) {
                            try {
                                if (_streamRef) {
                                    /*
                                        * when we attach a new media stream to _video element the event listeners
                                        * that are attached to this element are leaking (camera is not released
                                        * when the stream is stopped) so we need to remove and add them back
                                        *
                                        * This appears to be a bug in Microsoft Edge browser
                                        */
                                    this.reattachEventListeners();
                                    _streamRef.dispose();
                                    _streamRef = null;
                                }
                                newStreamRef.onApplyConstraints = function (change) {
                                    _that.attachMediaStream(null);
                                    change.then(function () {
                                        _that.attachMediaStream(newStreamRef.getObject());
                                    });
                                };
                                this.attachMediaStream(newStreamRef.getObject());
                                _streamRef = newStreamRef;
                            }
                            catch (error) {
                                newStreamRef.dispose();
                                throw error;
                            }
                        };
                        this.dispose = function () {
                            _isDisposed = true;
                            utils_1["default"].remove(_activeRenderers, function (value) {
                                return value === _that;
                            });
                            _baseDispose();
                            if (_streamRef) {
                                _streamRef.dispose();
                                _streamRef = null;
                            }
                        };
                        this.startVideoAsync = function () {
                            var mediaStream = _getMediaStream({ audio: true, video: true });
                            return mediaStream.start().then(function () {
                                if (_isDisposed) {
                                    mediaStream.dispose(); //important or ref counting fails
                                    throw new Error('disposed');
                                }
                                _that._attachMediaStreamRef(mediaStream);
                                _activeRenderers.push(_that);
                            });
                        };
                    };
                    function _getDeviceNameAsync(deviceId) {
                        if (window.RTCIceGatherer) {
                            return _deviceEnumerator.getDeviceName(deviceId);
                        }
                        return Promise.resolve(_devices[deviceId].label);
                    }
                    function _weakCompareObject(a, b) {
                        // fast but limited/weak way of comparing list. x will not equal to y:
                        //  x = {a: 1, b: 2};
                        //  y = {b: 2, a: 1};
                        // in our use case, this limitation should be tolerable, since assumption is that
                        // device list should be stable for us.
                        return JSON.stringify(a) === JSON.stringify(b);
                    }
                    function _enumerateDevicesAsync() {
                        return _deviceEnumerator.enumerateDevices().then(function (devices) {
                            _devices = devices;
                            return utils_1["default"].values(devices);
                        });
                    }
                    // FIXME: this function assumes devices have already been enumerated
                    function _selectDevices(devices) {
                        // devices = {microphone: devId, camera:devId};
                        var newSelectedDevices = {};
                        for (var kind in devices) {
                            if (devices.hasOwnProperty(kind)) {
                                var deviceId = devices[kind];
                                //NB! using device.id as key to index _devices! (this assumes that device id and key in devices are the same)
                                if (_devices.hasOwnProperty(deviceId)) {
                                    newSelectedDevices[kind] = deviceId;
                                }
                                else {
                                    _logger.warn('device selection is invalid', 'kind:', kind, 'id:', deviceId);
                                }
                            }
                        }
                        if (!_weakCompareObject(_selectedDevices, newSelectedDevices)) {
                            var configureModalitiesNeeded = (('camera' in _selectedDevices) ^ ('camera' in newSelectedDevices)) || (('microphone' in _selectedDevices) ^ ('microphone' in newSelectedDevices));
                            _selectedDevices = newSelectedDevices;
                            //note: device change will notify all device (media stream) users such as session and local previews and then those iff they are using media stream ask for the stream again
                            if (_that._deviceSelectionChanged) {
                                // if configureModalitiesNeeded, we rely on user to trigger configureModalities
                                if (!configureModalitiesNeeded) {
                                    _that._deviceSelectionChanged();
                                }
                            }
                            _updateRenderersAsync(); //will throw error out to the user
                        }
                    }
                    function _getSelectDevices() {
                        return _selectedDevices;
                    }
                    function _createPreviewRenderer(element, cb) {
                        return new LocalVideoRenderer(element, cb);
                    }
                    function _createCachedStream(gumConstraints, microphone, camera) {
                        var audio = !!gumConstraints.audio, video = !!gumConstraints.video, _outDated = false, _cachedStream = {
                            getStream: function () {
                                return stream;
                            },
                            isSuitable: function (modalities, devIds) {
                                return !_outDated &&
                                    ((modalities.audio === audio) &&
                                        (modalities.video === video) &&
                                        (!modalities.audio || (microphone === devIds.microphone)) &&
                                        (!modalities.video || (camera === devIds.camera)));
                            },
                            outdateIfAnyDeviceRemoved: function (devices) {
                                if (!_outDated) {
                                    _outDated = !devices[microphone] || !devices[camera];
                                }
                            }
                        }, streamGeneration = _cachedStreamGeneration++, stream = mediaStream_1["default"].build({
                            global: _context,
                            logger: _logger
                        }, gumConstraints);
                        stream.onDisposed = function () {
                            _logger.log('release media stream', 'generation:', streamGeneration, 'cached:', _cachedStreams.length, 'audio:', audio, 'video:', video);
                            utils_1["default"].remove(_cachedStreams, function (value) {
                                return value === _cachedStream;
                            });
                            if (!_cachedStreams.length) {
                                _deviceEnumerator.stopDevicePolling();
                            }
                        };
                        stream.start().then(function () {
                            stream.setMute(!_globalAudioEnable);
                            // update modalities based on the active constraints
                            audio = stream.hasAudio();
                            video = stream.hasVideo();
                            _logger.log('created media stream', 'generation:', streamGeneration, 'cached:', _cachedStreams.length, 'audio:', audio, 'video:', video);
                            handleDevicesPermissionChanged(true, true);
                        }).catch(function (error) {
                            if (error && error.type === constants_1["default"].MEDIA_ERROR.permissionDeniedError) {
                                handleDevicesPermissionChanged(stream.hasAudio(), stream.hasVideo());
                            }
                            utils_1["default"].remove(_cachedStreams, function (value) {
                                return value === _cachedStream;
                            });
                            if (!_cachedStreams.length) {
                                _deviceEnumerator.stopDevicePolling();
                            }
                        });
                        _deviceEnumerator.startDevicePolling();
                        _cachedStreams.push(_cachedStream);
                        return _cachedStream;
                    }
                    function handleDevicesPermissionChanged(hasMicrophonePermission, hasCameraPermission) {
                        if (_callback.onDevicesPermissionChanged) {
                            _callback.onDevicesPermissionChanged({
                                hasMicrophonePermission: hasMicrophonePermission,
                                hasCameraPermission: hasCameraPermission
                            });
                        }
                    }
                    function _getCachedStream(modalities) {
                        // check cached streams if anything is suitable
                        return utils_1["default"].find(_cachedStreams, function (cachedStream) {
                            return cachedStream.isSuitable(modalities, _selectedDevices);
                        });
                    }
                    function _getMediaStream(modalities) {
                        _logger.log('retrieving media stream: ', JSON.stringify(modalities));
                        var cachedStream = _getCachedStream(modalities);
                        if (!cachedStream) {
                            var constraints = {};
                            if (modalities.audio) {
                                if (_selectedDevices.microphone) {
                                    if (_selectedDevices.microphone === _deviceEnumerator.getDefaultDevices()[constants_1["default"].MEDIA_DEVICE.microphone].id) {
                                        constraints.audio = true;
                                    }
                                    else {
                                        constraints.audio = {
                                            deviceId: { exact: _selectedDevices.microphone }
                                        };
                                    }
                                }
                                else {
                                    _logger.warn('ignoring audio modality due to missing microphone selection');
                                }
                            }
                            if (modalities.video) {
                                if (_selectedDevices.camera) {
                                    if (_selectedDevices.camera === _deviceEnumerator.getDefaultDevices()[constants_1["default"].MEDIA_DEVICE.camera].id) {
                                        constraints.video = true;
                                    }
                                    else {
                                        constraints.video = {
                                            deviceId: { exact: _selectedDevices.camera }
                                        };
                                    }
                                }
                                else {
                                    _logger.warn('ignoring video modality due to missing camera selection');
                                }
                            }
                            if (!constraints.audio && !constraints.video) {
                                throw new Error('requesting nothing');
                            }
                            return _createCachedStream(constraints, _selectedDevices.microphone, _selectedDevices.camera).getStream().getClient();
                        }
                        return cachedStream.getStream().getClient();
                    }
                    function _controlAudioAsync(enable) {
                        _globalAudioEnable = enable;
                        _cachedStreams.forEach(function (cachedStream) {
                            cachedStream.getStream().setMute(!enable);
                        });
                        return Promise.resolve();
                    }
                    function _muteInputAsync() {
                        return _controlAudioAsync(false);
                    }
                    function _unmuteInputAsync() {
                        return _controlAudioAsync(true);
                    }
                };
                exports.__esModule = true;
                exports["default"] = DeviceManager;
            });
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/common/capabilities', ["require", "exports", './userAgentAdapter'], factory);
                }
            })(function (require, exports) {
                var userAgentAdapter_1 = require('./userAgentAdapter');
                var Capabilities = (function () {
                    function Capabilities(context) {
                        this.window = userAgentAdapter_1["default"].window;
                        this.overrides = this.getCapabilityOverrides(context.settings);
                        this.audio = this.getCapability('audio');
                        this.video = this.getCapability('video');
                        this.screensharing = this.getCapability('screensharing');
                    }
                    Capabilities.prototype.hasWebRtc = function () {
                        return typeof this.window.RTCPeerConnection !== 'undefined';
                    };
                    Capabilities.prototype.hasOrtc = function () {
                        return typeof this.window.RTCIceGatherer !== 'undefined';
                    };
                    Capabilities.prototype.hasMediaCapture = function () {
                        return !!this.window.navigator.getUserMedia;
                    };
                    Capabilities.prototype.getCapabilityOverrides = function (settings) {
                        var overrides;
                        if (settings.capabilities) {
                            if (this.hasOrtc()) {
                                overrides = settings.capabilities.ortc;
                            }
                            else if (this.hasWebRtc()) {
                                overrides = settings.capabilities.webrtc;
                            }
                        }
                        return overrides || {};
                    };
                    Capabilities.prototype.getCapability = function (name) {
                        if (typeof this.overrides[name] !== 'undefined') {
                            return !!this.overrides[name];
                        }
                        return this.hasMediaCapture() && (this.hasOrtc() || this.hasWebRtc());
                    };
                    return Capabilities;
                }());
                exports.__esModule = true;
                exports["default"] = {
                    build: function (context) { return new Capabilities(context); }
                };
            });
            /*eslint-disable max-depth*/
            /*
                // Media agent factory is exported by this module.
                MediaAgentFactory {
                    // Creates a new media agent and configures it using provided configuration.
                    MediaAgent build(MediaAgentContext, DeviceManagerCallback);
                    // Checks if current platform is supported by media agent.
                    Boolean isPlatformSupported();
                    MediaAgent.Constants constants;
                    MediaAgent.Helper helper;
                }
            
                MediaAgent {
                    // Creates a new media session.
                    MediaSession createSession(MediaSessionCallback sessionCallback, String callId, MediaSessionConfig config);
                    // Retrieves an instance of device manager.
                    DeviceManager getDeviceManager();
                    // See public.d.ts for details
                    Capabilities getCapabilities();
                }
            
                MediaAgentContext {
                    RelayManager getRelayManager();
                    Logger getLogger();
                    Settings settings;
                }
            
                MediaSessionConfig {
                    // Specify if remote user is a Skype For Business (ex-Lync) user
                    Boolean isRemoteClientLync;
                    // Specify if converstion is a Conference
                    Boolean isConference;
                    // Type of ICE Transport Policy, value can be 'all' or 'relay'
                    String iceTransportPolicy;
                }
            
                Settings {
                    // Enables debug logging if true, otherwise disables it.
                    Boolean debug;
                    // Number of video channels to negotiate in case of a group video conference.
                    Number numVideoChannelsGvc;
                    // Number of times media session will attempt to repeat previously rejected negotiation
                    Number renegotiationAttempts;
                    // Prefers SDES-SRTP over DTLS-SRTP if true. This means DTLS-SRTP will not be offered at all. Works only on Chrome.
                    Boolean preferSdesSrtp;
                    // Disables JSEP-SDP to MS-SDP transformation for WebRTC if true.
                    Boolean disableMsSdp;
                    // Disables SDES-SRTP for ORTC if true (will force DTLS-SRTP if remote side also supports it)
                    Boolean disableSdes;
                    // Disables ICE-reinvite generation for ORTC if true.
                    Boolean disableIceReinvite;
                    // Transport of the ICE candidates to gather, regular expression. Leaving this settings undefined will gather candidates regardless of their transport.
                    String iceCandidateTransport;
                    // Type of the ICE candidates to gather, regular expression. Leaving this settings undefined will gather candidates regardless of their type.
                    String iceCandidateType;
                    // Audio codec to negotiate. Leaving this settings undefined will negotiate all supported codecs.
                    String audioCodec;
                    // Video codec to negotiate. Leaving this settings undefined will negotiate all supported codecs.
                    String videoCodec;
                    // Controls device list polling interval on browsers that don't support device change events, 0 disables polling.
                    Number devicePollingInterval;
                    // Controls video renderer size polling interval min value, if set to 0 it will disable polling for changes and will not trigger renegotiation
                    Number webrtcVideoCapabilityCheckIntervalMin;
                    // Controls video renderer size polling interval max value, if set to 0 it will disable polling for changes and will not trigger renegotiation
                    Number webrtcVideoCapabilityCheckIntervalMax;
                    // Default value that will be advertised via SDP to remote indicating what is the width of local renderer used for remote video
                    Number webrtcVideoCapabilityWidth;
                    // Default value that will be advertised via SDP to remote indicating what is the height of local renderer used for remote video
                    Number webrtcVideoCapabilityHeight;
                    // Controls dynamically constrainting local video stream to remote video receiver capability.
                    Boolean enableLocalVideoConstraints;
                    // Signaling feedback capability for audio channel, WebRTC specific.
                    String webrtcAudioChannelSignalingFeedback;
                    // Signaling feedback capability for video channel, WebRTC specific.
                    String webrtcVideoChannelSignalingFeedback;
                }
            
                //
                // Represents a media session between 2 endpoints.
                //
                // Negotiation.
                // On the offerer side negotiation is triggered by modality configuration request. In case of initial configuration
                // or if new configuration differs from what has been negotiated previously, negotiationRequired() callback gets
                // called, signalling that there are changes to communicate to remote endpoint. The actual negotiation is a
                // transaction, that is started on the offerer side by calling createOfferAsync(). Once offer is generated, it
                // should be sent to remote endpoint, where processOfferAsync() should be called, starting an answerer-side
                // negotiation transaction. Answerer analyzes modalities present in an offer, configures its modalities by calling
                // configureModalitiesAsync() and generates an answer by calling createAnswerAsync(). Generated answer is sent to
                // the offerer, where it processes it by calling processAnswerAsync(). For both offerer and answerer negotiation
                // transaction is commited by calling completeNegotiationAsync(). If negotiation is to fail, rejectNegotiationAsync()
                // should be called, with appropriate error, as well as indication whether attempt to negotiate the changes needs to
                // be repeated. In the latter case negotiationRequired() callback shall be called on the offerer side.
                //
                // Offerer call sequence:
                // -> configureModalitiesAsync(modalities)
                // <- negotiationRequired()
                // -> createOfferAsync()
                // -> processAnswerAsync(answer, true)
                // -> processAnswerAsync(answer, true) // provisional answers can be processed multiple times
                // -> processAnswerAsync(answer, false) // final answer should be processed only once
                // -> completeNegotiationAsync()
                // <- negotiationRequired() // ICE reinvite will always follow the initial negotiation
                // -> createOfferAsync()
                // ...
                //
                // Answerer call sequence:
                // -> processOfferAsync(offer)
                // -> configureModalitiesAsync(modalities) // a new negotiation will be triggered if provided modalities cannot be applied in scope of current negotiation
                // -> createAnswer(true)
                // -> createAnswer(false)
                // -> completeNegotiationAsync()
                // ...
                //
                // ICE reinvite.
                // A new negotiation shall be triggered by the caller right after original negotiation completes if at least one of the following is true:
                // 1. A new modality gets added to the session
                // 2. Existing modality is enabled
                //
                // Rendering.
                // Apart from negotiating audio modality clients don't need to do anything special for audio rendering to start.
                // In order to render remote video clients must call subscribeVideoAsync, providing a DOM element, along with media
                // source identifier of interest. The latter can be retrieved from a roster. Once the returned promise resolves,
                // video will get rendered to the provided DOM element. For local video rendering refer to device manager.
                //
                MediaSession {
                    Modalities {
                        enum Modality {
                            'audio',
                            'video',
                            'screensharing'
                        }
                        enum Direction {
                            'sendonly',
                            'recvonly',
                            'sendrecv',
                            'inactive'
                        }
                        dictionary<Modality, Direction>;
                    }
            
                    Message {
                        String blob;        // sdp;
                        String contentType; // 'application/sdp'
                        String mediaLegId:  // 32 HEX allCaps UUID;
                    }
                    MediaError {
                        enum Type {
                            // Fired when transport fails or gets disconnected
                            'iceConnectionError';
                            // Fired if internal error occurs
                            'internalError';
                        }
                        Type type;
                        String detail;
                    }
                    MediaSessionCallback {
                        // Signals that negotiation is required in order to communicate changes to remote endpoint. It is usually
                        // triggered by changes to modality configuration, previously applied via configureModalitiesAsync()
                        // function. After receiving this callback clients should start the actual negotiation by calling
                        // createOfferAsync(). This callback will never be called in case there already is an ongoing negotiation.
                        // Instead, it will be called right after it completes.
                        void onNegotiationRequired();
                        // Signals that a change of dominant speakers occurred. The provided array contains audio source identifiers
                        // (MSI). Dominant speaker is typically a more stable state than "active"; this should be signaled when
                        // participant actually contributes with own audio the most, and it is expected to have noise and echo
                        // filtered out.
                        void onDominantSpeakerChanged(Number[] speakers);
                        // Signals that a change of active speakers occurred. The provided array contains audio source identifiers
                        // (MSI). Active speaker is typically a transient state, derived from a list of contributing sources built
                        // by the mixer; this may include any non-useful contribution such as noise, echo, etc.
                        void onContributingSourcesChanged(Number[] speakers);
                        // Indicates that an error has occurred. In order to recover clients should terminate current session and
                        // create a new one.
                        void onSessionErrorOccurred(MediaError error);
                    }
                    RemoteRenderer {
                        RendererCallback {
                            //will be called on resolution changes only, zero resolution means no frames to render
                            void onVideoSizeChanged(Number width, Number height);
                        }
                        // Requests receiving video identified by the provided MSI.
                        Promise<void> subscribeVideoAsync(Number msi);
                        // Terminates the previous subscription for the provided DOM element and stops rendering video to it.
                        Promise<void> unsubscribeVideoAsync(Element element);
                        // tear down and reject pending async operations, can be called any time but after dispose user can not call
                        // any other method
                        void dispose();
                    }
            
                    // Configures modalities for a media session. In case of initial configuration or if new configuration differs
                    // from what has been previously negotiated, onNegotiationRequired() callback shall be triggered. Calling this
                    // function repeatedly outside of any negotiation transaction shall alter the modalities that will be negotiated
                    // during subsequent negotiation.
                    Promise<void> configureModalitiesAsync(Modalities modalities);
                    // Returns acceptableModalities. If offerer has send only then acceptableModalities has receive only.
                    Promise<Modalities> processOfferAsync(Message offer);
                    // Creates either final or provisional answer depending on the value of provisional attribute. For provisional
                    // answer this function might return an empty object ({}), which signals that provisional answer is not supported.
                    // Clients should ignore this and proceed with call setup.
                    Promise<Message> createAnswerAsync(Boolean provisional);
                    Promise<Message> createOfferAsync();
                    // Returns negotiatedModalities. If answerer can send only negotiatedModalities has receive only
                    Promise<Modalities> processAnswerAsync(Message answer, Boolean provisional);
                    // Completes an ongoing negotiation. Returns active modalities
                    Promise<Modalities> completeNegotiationAsync();
                    // Rejects an ongoing negotiation with the provided error. A new negotiation will be triggered automatically if
                    // retry is true. Returns active modalities
                    Promise<Modalities> rejectNegotiationAsync(Reason reason, Error error); //see RENEGOTIATION_ERROR in constants
                    // create renderer for remote video, this is sync function
                    // video will be rendered to the provided DOM element after subscription see RemoteRenderer for more info
                    RemoteRenderer createRemoteRenderer(Modality modality, Element element, RendererCallback cb)
                    // Completes an ongoing retarget. Should be called only after retarget negotiation is complete.
                    Promise<void> completeRetargetAsync();
                    // Rejects an ongoing retarget with the provided error.
                    Promise<void> rejectRetargetAsync(Error error);
                    Promise<Stats> getStatsAsync();
                    // Terminates this media session.
                    void terminate();
                }
            
                // Provides access to device management functionality. Allows enumerating and configuring media devices, as well as
                // rendering local video.
                DeviceManager {
                    DeviceManagerCallback {
                        void onDevicesChanged(MediaDevice[]);
                        void onDevicesPermissionChanged(DevicePermissions{});
                        // void onDeviceMuted(MediaDevice device); // not supported
                    }
                    PreviewRenderer {
                        RendererCallback {
                            //will be called on resolution changes only, zero resolution means no frames to render
                            void onVideoSizeChanged(Number width, Number height);
                        }
                        // start local video preview, this can cause getUserMedia to invoke UA dependent access dialog
                        Promise<void> startVideoAsync();
                        // tear down and reject pending async operations, can be called any time but after dispose user can not call
                        // any other method
                        void dispose();
                    }
                    SelectedDevices {
                        camera : {
                            id : String,
                            label : String
                        }
                        microphone : {
                            id : String,
                            label : String
                        }
                    }
            
                    Promise<MediaDevice[]> enumerateDevicesAsync();
                    // fetches the name for the device specified by id
                    Promise<String> getDeviceNameAsync(id);
                    void selectDevices({camera: id, microphone: id });
                    SelectedDevices getSelectedDevices();
                    Promise<void> muteInputAsync();
                    Promise<void> unmuteInputAsync();
                    // Renders video captured by the configured camera to the provided DOM element.
                    PreviewRenderer createPreviewRenderer(Element element, RendererCallback cb);
                }
            
                MediaDevice {
                    enum Type {
                        camera,
                        microphone,
                        speaker
                    }
            
                    Type type;
                    String id;
                    String label;
                }
            
                Relay {
                    String address;
                    Number udpPort;
                    Number tcpPort;
                    String username;
                    String password;
                    String type;
                }
            
                RelayManager {
                    Promise<Relay[]> queryRelaysAsync(type); //type is 'turn' or 'msturn'
                }
            
                DevicePermissions {
                    Boolean hasMicrophonePermission;
                    Boolean hasCameraPermission;
                }
            
             ----------------------Renegotiation error scenarios---------------------
            LOCAL                                                           REMOTE
             1) failure on remote MA processOfferAsync/createAnswerAsync:
             configureModalitiesAsync
             createOfferAsync                   offer-->
                                                                            processOfferAsync/createAnswerAsync FAIL
                                                <--rejection                rejectNegotiationAsync(RENEGOTIATION_ERROR.local)
             rejectNegotiationAsync(RENEGOTIATION_ERROR.media)
            
             2) failure on local MA createOffer:
             configureModalitiesAsync
             createOfferAsync FAIL
             rejectNegotiationAsync(RENEGOTIATION_ERROR.local)
            
             3) failure on local MA processAnswer:
             configureModalitiesAsync
             createOfferAsync                   offer-->
                                                                            processOfferAsync
                                                <--answer                   createAnswerAsync
             processAnswerAsync FAIL            ACK-->                      #1 no way to signal failure to remote side
                                                                            completeNegotiationAsync
             rejectNegotiationAsync(RENEGOTIATION_ERROR.local)
            
             4) Glare:
             configureModalitiesAsync                                       configureModalitiesAsync
             createOfferAsync                   offer--><--offer            createOfferAsync
                                                offer(FAIL)-->
                                                                            rejectNegotiationAsync(RENEGOTIATION_ERROR.glare) // assuming one gets rejected, another not
                                                                            processOfferAsync
                                                <--answer                   createAnswerAsync
             processAnswerAsync
             completeNegotiationAsync           ACK-->
                                                                            completeNegotiationAsync
            
             5) Signaling timeout getting answer (on offerer):
             configureModalitiesAsync
             createOfferAsync                   offer-->
                                                                            processOfferAsync
                                                                            createAnswerAsync
                                                <--answer(local timeout)
             rejectNegotiationAsync(RENEGOTIATION_ERROR.signaling)
                                                ACK-->                      #2 ack is send by server and not by other end because see #1
                                                                            completeNegotiationAsync
            
             6) Signaling timeout when waiting ACK (on answerer):
             configureModalitiesAsync
             createOfferAsync                   offer-->
                                                                            processOfferAsync
                                                                            createAnswerAsync
                                                <--answer
             completeNegotiationAsync
                                                ACK(local timeout)-->
                                                                            rejectNegotiationAsync(RENEGOTIATION_ERROR.signaling)
            
             RENEGOTIATION_ERROR.signaling - retry
             RENEGOTIATION_ERROR.glare - don't retry
             RENEGOTIATION_ERROR.media - retry
             RENEGOTIATION_ERROR.local - MA figure out itself
             retry always with latest configured modalities (MA decides how many times)
             */
            (function (factory) {
                if (typeof module === 'object' && typeof module.exports === 'object') {
                    var v = factory(require, exports);
                    if (v !== undefined)
                        module.exports = v;
                }
                else if (typeof define === 'function' && define.amd) {
                    define('../components/media-agent/lib/mediaAgent', ["require", "exports", './session', './device/deviceManager', './common/utils', './common/capabilities', './constants', './helper'], factory);
                }
            })(function (require, exports) {
                var session_1 = require('./session');
                var deviceManager_1 = require('./device/deviceManager');
                var utils_1 = require('./common/utils');
                var capabilities_1 = require('./common/capabilities');
                var constants_1 = require('./constants');
                var helper_1 = require('./helper');
                var MediaAgent = function (context, deviceManagerCallback) {
                    var _logger = context.getLogger().createChild('MA', undefined, context.settings.debug), deviceManagerLogger = _logger.createChild('DeviceManager'), _deviceManager = new deviceManager_1["default"]({
                        logger: deviceManagerLogger,
                        settings: context.settings
                    }, deviceManagerCallback), _activeSessions = [], capabilities = capabilities_1["default"].build({
                        settings: context.settings
                    });
                    _deviceManager._deviceSelectionChanged = function () {
                        _activeSessions.forEach(function (session) {
                            session._deviceSelectionChanged();
                        });
                    };
                    function _getDeviceManager() {
                        return _deviceManager;
                    }
                    this.createSession = function (callback, callId, sessionConfig) {
                        var sessionLogger = _logger.createChild('Session', callId), sessionCtx = {
                            getDeviceManager: _getDeviceManager,
                            getLogger: function () {
                                return sessionLogger;
                            },
                            maContext: context,
                            config: sessionConfig ? sessionConfig : {}
                        }, session = session_1["default"].build(sessionCtx, callId, callback);
                        session._onTerminated = function (session) {
                            utils_1["default"].remove(_activeSessions, function (value) {
                                return value === session;
                            });
                        };
                        _activeSessions.push(session);
                        return session;
                    };
                    this.getDeviceManager = _getDeviceManager;
                    this.getCapabilities = function () {
                        return capabilities;
                    };
                    this.getScreenSharingManager = function () {
                        return {
                            onScreensChanged: function () {
                                return {
                                    dispose: function () { }
                                };
                            },
                            enumerateScreensAsync: function () {
                                return Promise.resolve([]);
                            },
                            enumerateApplicationsAsync: function () {
                                return Promise.resolve([]);
                            }
                        };
                    };
                };
                exports.__esModule = true;
                exports["default"] = {
                    build: function (context, deviceManagerCallback) {
                        return new MediaAgent(context, deviceManagerCallback);
                    },
                    isPlatformSupported: function () {
                        return navigator.getUserMedia && (typeof RTCPeerConnection !== 'undefined' || typeof RTCIceGatherer !== 'undefined');
                    },
                    constants: constants_1["default"],
                    helper: helper_1["default"]
                };
            });
            requireEx = requirejs;
            requireEx(["../components/media-agent/lib/mediaAgent"]);
            Media.MediaAgent = requireEx('../components/media-agent/lib/mediaAgent')['default'];
            window.setTimeout = _setTimeOut;
        })(Media = Web.Media || (Web.Media = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="mediaAgent.js" />
"use strict";
/// <reference path="MediaAgent.ts" />
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Media;
        (function (Media) {
            'use strict';
            var inherit = Web.Utils.inherit;
            var isFunction = Web.Utils.isFunction;
            var URI = Web.Utils.URI;
            var Http = Web.Utils.Http;
            var Event = Web.Utils.Event;
            var WeakMap = Web.Utils.WeakMap;
            var XHR = Web.Stack.XHR;
            /**
             *  Media Relay Manager for MediaAgent
             *
             */
            var UcwaRelayManager = (function () {
                function UcwaRelayManager(ucwa, tm) {
                    var rComm = ucwa.get(ucwa.app.relatedHref('communication'));
                    var rMrasToken = ucwa.get(rComm.link('mediaRelayAccessToken').href);
                    var isInternal = ucwa.get({ rel: 'root' }, null) ? !!ucwa.get({ rel: 'root' }).get('internal', false) : false;
                    // cached TURN redirector url
                    var turnRedirUrl;
                    var fUseTestTurnRelay = false;
                    // relays implementing the standard IETF TURN protocol (used by WebRTC in Chrome/FF)
                    var turnRelays = [];
                    // relays implementing MS TURN protocol (used by ORTC in Microsoft Edge) 
                    var msturnRelays = [];
                    // test TURN relay for topologies not linked with the TURN relay redirector 
                    var testTurnRelays = [{
                            addresses: ['coturn-mdn.cloudapp.net'],
                            udpPort: 3478,
                            tcpPort: 3478,
                            username: 'HxZMPT6f',
                            password: '3F7PkZG8tJKnMIpi',
                            type: 'turn'
                        }];
                    var initPromise;
                    var expiration = 0;
                    function calcExpiration(minutes) {
                        minutes = minutes > 2 ? minutes - 2 : 0;
                        return Web.Date.now() + minutes * 60000;
                    }
                    function getMrasToken() {
                        var promise;
                        msturnRelays = [];
                        turnRelays = [];
                        if (Media.isOrtc()) {
                            promise = ucwa.send('GET', { rel: 'mediaRelayAccessToken' }).then(function () {
                                var username = rMrasToken.get('userName');
                                var password = rMrasToken.get('password');
                                var mediaRelayLinks = rMrasToken.links('mediaRelay');
                                for (var _i = 0, mediaRelayLinks_1 = mediaRelayLinks; _i < mediaRelayLinks_1.length; _i++) {
                                    var link = mediaRelayLinks_1[_i];
                                    var relay = ucwa.get(link.href);
                                    if (!isInternal && relay.get('location') == 'Internet' ||
                                        isInternal && relay.get('location') == 'Intranet') {
                                        msturnRelays.push({
                                            addresses: [relay.get('host')],
                                            udpPort: relay.get('udpPort'),
                                            tcpPort: relay.get('tcpPort'),
                                            password: password,
                                            username: username,
                                            type: 'msturn'
                                        });
                                    }
                                }
                                expiration = calcExpiration(rMrasToken.get('duration'));
                            }).catch(function (err) {
                                Media.log('UcwaRelayManager::getMediaRelayAccessToken error: ', err);
                                tm && tm.record(Web.TelemetryEvent.Call, {
                                    action: 'getMediaRelayAccessToken',
                                    mediaType: Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                    result: 'failed',
                                    reason: err
                                });
                            });
                        }
                        else {
                            promise = ucwa.send('GET', URI.mergeQuery(rComm.link('mediaRelayAccessToken').href, { mrasType: 'ietf' })).then(function () {
                                // mrasToken should contain an array with a single element pointing to 
                                // the Skype TURN relay redirector
                                var mediaRelayLinks = rMrasToken.links('mediaRelay');
                                var rMediaRelay = ucwa.get(mediaRelayLinks[0].href);
                                turnRedirUrl = 'https://' + rMediaRelay.get('host') + '/relay';
                                turnRelays.push({
                                    addresses: [],
                                    udpPort: rMediaRelay.get('udpPort'),
                                    tcpPort: rMediaRelay.get('tcpPort'),
                                    password: rMrasToken.get('password'),
                                    username: rMrasToken.get('userName'),
                                    type: 'turn'
                                });
                                expiration = calcExpiration(rMrasToken.get('duration'));
                            }).catch(function (err) {
                                Media.log('UcwaRelayManager::cannot get an IETF TURN relay redirector; using a test one, err: ' + err);
                                fUseTestTurnRelay = true;
                                expiration = 0;
                                tm && tm.record(Web.TelemetryEvent.Call, {
                                    action: 'getIETFTurnRelayRedirector',
                                    mediaType: Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                    result: 'failed',
                                    reason: err
                                });
                            });
                        }
                        return promise;
                    }
                    initPromise = getMrasToken();
                    return {
                        queryRelaysAsync: function (type) {
                            if (type === void 0) { type = 'msturn'; }
                            return initPromise.then(function () {
                                if (!fUseTestTurnRelay && Web.Date.now() > expiration) {
                                    initPromise = getMrasToken();
                                    return initPromise;
                                }
                            }).then(function () {
                                if (type == 'msturn')
                                    return msturnRelays;
                                if (fUseTestTurnRelay)
                                    return testTurnRelays;
                                var xhr = new XHR;
                                return xhr.send({
                                    type: 'GET',
                                    url: turnRedirUrl,
                                    headers: { 'Accept': 'application/json; charset=utf-8' }
                                }).then(function (response) {
                                    Media.log('GET ' + turnRedirUrl + ' returned ' + response.status +
                                        ' ' + response.responseText);
                                    if (Http.isSuccess(response.status)) {
                                        var resp = JSON.parse(response.responseText);
                                        turnRelays[0].addresses = [resp.relay];
                                        return turnRelays;
                                    }
                                    else {
                                        Media.log('Cannot get an IETF TURN relay; using a test one, err: ' +
                                            response.status + ' ' + response.statusText);
                                        return testTurnRelays;
                                    }
                                });
                            });
                        }
                    };
                }
                return UcwaRelayManager;
            }());
            /**
             * Console logger decorates each line with an optional namespace
             * Required by MediaAgent
             */
            var ConsoleLogger = (function () {
                function ConsoleLogger(options) {
                    if (options === void 0) { options = {}; }
                    var prefix = function () {
                        var namespace = options.namespace;
                        var ns = isFunction(namespace) ? namespace() :
                            namespace || '';
                        return ns + ':';
                    };
                    var fn = function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        return Media.log.apply(Media, [prefix()].concat(args));
                    };
                    this.log = fn;
                    this.info = fn;
                    this.warn = fn;
                    this.error = fn;
                    this.debug = options.debug ? fn : function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                    };
                    this.createChild = function (namespace, debug) {
                        if (debug === void 0) { debug = options.debug; }
                        return new ConsoleLogger({
                            namespace: namespace,
                            debug: debug
                        });
                    };
                }
                return ConsoleLogger;
            }());
            Media.MaxVideoChannels = Media.isWebRtc() ? 1 : 6; // TODO: not sure where this belongs  
            var wm = new WeakMap();
            /**
             * Create or get the media agent for given stack instance
             * @param ucwa: UCWA
             */
            function getMediaAgent(ucwa, tm) {
                if (!wm.has(ucwa)) {
                    var logger_1 = new ConsoleLogger({
                        namespace: 'MA',
                        debug: true
                    });
                    var relayManager_1 = new UcwaRelayManager(ucwa, tm);
                    var maContext = {
                        getLogger: function () { return logger_1; },
                        getRelayManager: function () { return relayManager_1; },
                        settings: {
                            debug: true,
                            preferSdesSrtp: true,
                            enableLocalVideoConstraints: true,
                            iceDisconnectedTimeoutMs: 30000,
                            webrtcVideoCapabilityMaxFS: 1200,
                            webrtcVideoCapabilityMaxFPS: 3000,
                            webrtcVideoCapabilityCheckIntervalMin: 20000,
                            webrtcVideoCapabilityCheckIntervalMax: 30000,
                            webrtcAudioChannelSignalingFeedback: 'app recv:dsh',
                            webrtcVideoChannelSignalingFeedback: 'app recv:csrc,src',
                            numVideoChannelsGvc: Media.MaxVideoChannels
                        }
                    };
                    var devicesEvent_1 = new Event();
                    var permissionsEvent_1 = new Event();
                    var deviceMgrCb = {
                        onDevicesChanged: function (devices) {
                            devicesEvent_1.fire(devices);
                        },
                        onDevicesPermissionChanged: function (permissions) {
                            permissionsEvent_1.fire(permissions);
                        }
                    };
                    var externalMediaAgent = Web.Settings.mediaAgent && Web.Settings.mediaAgent(maContext, deviceMgrCb);
                    var ma = inherit(externalMediaAgent || Media.MediaAgent.build(maContext, deviceMgrCb), {
                        devicesChanged: devicesEvent_1.observer,
                        permissionsChanged: permissionsEvent_1.observer,
                        deviceManagerCallback: deviceMgrCb
                    });
                    wm.set(ucwa, ma);
                }
                return wm.get(ucwa);
            }
            Media.getMediaAgent = getMediaAgent;
        })(Media = Web.Media || (Web.Media = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_5) {
            var Internal;
            (function (Internal) {
                'use strict';
                var Model = Web.Utils.Model;
                var Property = Web.Utils.Property;
                var setHiddenProperty = Web.Utils.setHiddenProperty;
                /**
                 *  Represents the dominannt speaker in a group conversation.
                 *
                 *  Exposes a video channel containing a video stream that is switched between active speakers.
                 *  At any given time this channel streams the current active speaker video. This class also
                 *  exposes a reference to the participant whose video is currently played by the channel.
                 *
                 */
                var WebRtcActiveSpeaker = (function () {
                    function WebRtcActiveSpeaker() {
                        var p = Property();
                        var vsEmpty = new Internal.MediaStream;
                        var videoChannel = (new Internal.VideoChannel({
                            name: 'ActiveSpeaker Channel',
                            isLocal: false
                        }));
                        videoChannel.stream.setSource(vsEmpty);
                        var self = Model({
                            channel: videoChannel,
                            participant: p.asReadOnly()
                        });
                        setHiddenProperty(self, Internal.sInternal, {
                            participant: p,
                            setVideoStream: function (vs) {
                                var stream = videoChannel.stream, format = stream.source.sink.format(), container = stream.source.sink.container();
                                stream.setSource(vs || vsEmpty);
                                // retain the video format and container after setting a new video stream
                                stream.source.sink.format(format);
                                stream.source.sink.container(container);
                                Web.Media.log('WebRtcActiveSpeaker::SetVideoStream  stream %c' + (vs && vs._id()), 'color:green;font-weight:bold');
                            },
                            setVideoStarted: function (val) {
                                return videoChannel.isStarted._set(val);
                            }
                        });
                        return self;
                    }
                    return WebRtcActiveSpeaker;
                }());
                Internal.WebRtcActiveSpeaker = WebRtcActiveSpeaker;
            })(Internal = Model_5.Internal || (Model_5.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="../../media/webRtc/MediaAgentInit.ts" />
/// <reference path="WebRtcActiveSpeaker.ts" />
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var find = Web.Utils.find;
                var guid = Web.Utils.guid;
                var check = Web.Utils.check;
                var async = Web.Utils.async;
                var assert = Web.Utils.assert;
                var extend = Web.Utils.extend;
                var random = Web.Utils.random;
                var values = Web.Utils.values;
                var filter = Web.Utils.filter;
                var foreach = Web.Utils.foreach;
                var isEmptyObject = Web.Utils.isEmptyObject;
                var isNotEmptyString = Web.Utils.isNotEmptyString;
                var Task = Web.Utils.Task;
                var Event = Web.Utils.Event;
                var Command = Web.Utils.Command;
                var DataUri = Web.Utils.DataUri;
                var Promise = Web.Utils.Promise;
                var Property = Web.Utils.Property;
                var Exception = Web.Utils.Exception;
                var Collection = Web.Utils.Collection;
                var StringEnum = Web.Utils.StringEnum;
                var EDoesNotExist = Web.Utils.EDoesNotExist;
                var EInvalidState = Web.Utils.EInvalidState;
                var ENotSupported = Web.Utils.ENotSupported;
                var EInvalidArgument = Web.Utils.EInvalidArgument;
                var setHiddenProperty = Web.Utils.setHiddenProperty;
                var log = Web.Media.log;
                var watch = Web.Media.watch;
                /**
                 * Created by AudioVideoModality to represent an AudioVideo session (call). Can be either
                 * peer-to-peer or multi-party (conference). Only one such session exists when the call is
                 * established. When a P2P conversation is escalated to a conference, a second session
                 * linking this client to the conference is created. Once escalation succeeds, the second
                 * session replaces the original P2P session.
                 *
                 * Uses ORTC in Microsoft Edge or WebRTC in Chrome/FF
                 *
                 */
                var WebRtcAudioVideoSession = (function () {
                    //#endregion
                    function WebRtcAudioVideoSession(options) {
                        var escalated = new Event(), errorOccured = new Event(), self = {}, devices = options.devices, ucwa = options.ucwa, context = options.context, contextType = options.contextType, settings = options.settings, tm = options.tm, participants = options.participants, selfParticipant = options.selfParticipant, conversation = options.conversation, rConversation = options.rConversation, rAVInvitation = options.rAVInvitation, rAVRenegotiation, 
                        // During an outgoing call the server may set up more than one audioVideoSession, because
                        // the remote sip uri that we are calling may be signed in on more than one endpoint.
                        // Therefore we may see multiple pairs of audioVideoNegotiation - audioVideoSession events.
                        // Eventually, one of these sessions will be connected, others will be deleted. We keep
                        // track of these sessions in a dictionary of objects indexed by audioVideoSession hrefs,
                        // where these session objects may have properties:
                        //    resource:  audioVideoSession resource;
                        //    negotiated:  boolean (true if this session was successfully negotiated);
                        //    resumeAudioVideoUri:  present if this is an escalated conference session.
                        avSessions = {}, invitation = options.invitation, rInvitation = options.rInvitation, operationId = options.operationId || guid(), // provided by unittest or generated on the fly
                        sessionContext = options.sessionContext || guid(), // provided by unittest or generated on the fly
                        outAvRenegoOpIds = {}, // list of outgoing audioVideoRenegotiation operationId values
                        remoteUri, escalateAudioVideoUri = options.escalateAudioVideoUri, 
                        // Track if an audio/video session is involved in a P2P to group escalation:
                        //  - None: this session is currently not involved in escalation
                        //  - From: this is the session for the old P2P call that is being escalated
                        //          (it will be set to this state by AVM#startEscalation)
                        //  - To:   this is the session newly created to manage the escalated group cal
                        escalationState = Property({
                            value: escalateAudioVideoUri ? 2 /* To */ : 0 /* None */
                        }), 
                        // Keep track of video configuration before escalation so that it can be configured
                        // the same post-escalation
                        preEscalationVideoConfig = Property(), reason = escalateAudioVideoUri ? Internal.sEscalation : void 0, state = Property({
                            value: invitation || (rInvitation && rInvitation.rel == 'onlineMeetingInvitation') ?
                                Internal.Modality.State.Notified :
                                Internal.Modality.State.Disconnected,
                            reason: reason
                        }), audioState = Property({
                            value: isAudioInvitation() || isVideoInvitation() ?
                                Internal.Modality.State.Notified :
                                Internal.Modality.State.Disconnected,
                            reason: reason
                        }), videoState = Property({
                            value: isVideoInvitation() ?
                                Internal.Modality.State.Notified :
                                Internal.Modality.State.Disconnected,
                            reason: reason
                        }), videoDirection = Property({ value: '' }), 
                        // the dominant speaker (WebRTC)
                        dominantSpeaker = null, 
                        // list of active speakers (ORTC)
                        activeSpeakers = {}, 
                        // reference to videoService.activeSpeaker
                        activeSpeaker = options.activeSpeaker, activeModalities = { audio: false, video: false }, mainVideoStream = new Internal.WebRtcRemoteMediaStream, selfVideoStream = new Internal.WebRtcLocalMediaStream, 
                        // remote video streams
                        videoStreams = Collection(), dfdStart, dfdAccept, dfdOutRenego, isPendingInRenego = false, 
                        // tracks the progress of self participant video toggling; a single task is sufficient 
                        // for both show and remove video since these operations are debounced in Conversation's 
                        // createParticipant
                        dfdSelfVideo, dfdHold, // tracks the progress of the call's hold/resume
                        holdValue, // pending hold/resume value tracked by the task above
                        // the collection of participants whose video was renedered before a video call
                        // was put on hold; used for auto-restoring video when the call is resumed;
                        // participants who left the call or stopped streaming video while the call 
                        // was on hold are removed from this collection
                        participantsWithVideoToRender = {}, promiseFinalAnswer = null, 
                        // video config of the main channel requested by either start or accept;
                        // is needed for setting the initial value of video channel's isStarted property for the
                        // self participant when start/accept is finished.
                        mainVideoConfig = 0 /* NOT_PRESENT */, 
                        // a unique id of this session - handy for debugging this session's
                        // server event subscription
                        callId = options.callId || random(), RemoteHoldState = {
                            Unknown: 0,
                            HoldOffered: 1,
                            HoldAnswered: 2,
                            HoldCompleted: 3,
                            ResumeOffered: 4,
                            ResumeAnswered: 5,
                            ResumeCompleted: 6
                        }, AudioVideoDirection = StringEnum('Inactive', // hold
                        'ReceiveOnly', 'SendOnly', 'SendReceive', // resume
                        'Unknown'), 
                        // A flag to track the renegotiation progress when the remote
                        // participant holds/resumes a 1:1 call.
                        //
                        // Detect that the remote participant holds/resumes a 1:1 call:
                        //
                        // 1. Examine an incoming audioVideo renegotiation offer.
                        // 2. if the offer has "a=inactive" field (for m=audio or m=video),
                        //    it is a HOLD request, mark it and expect an answer.
                        //    Otherwise, it MIGHT be a RESUME request (but not necessarily),
                        //    so mark it that way.
                        // 3. Examine the generated answer. 
                        //    If the answer has "a=inactive" field, it is a HOLD request, mark 
                        //    it as such and expect "audioVideoRenegotiation completed".
                        //    Otherwise, it MIGHT be a RESUME request (but not necessarily),
                        //    so mark it that way.
                        // 4. Examine the incoming "audioVideoRenegotiation completed" event, 
                        //    process the marker set in previous steps. Complete the negotiation 
                        //    and set the onHold property based on the negotiated audio modality 
                        //    state.
                        remoteHoldState = RemoteHoldState.Unknown, isUnmuteRequested = selfParticipant.audio.isUnmuteRequested, isClean = Property({ value: false }), // whether this session has been cleaned up
                        mediaAgent = initMediaAgent(), mediaSession, mediaSessionCb, mediaDMInitialized = devices['_dm'].map(function (_dm) { return !!_dm; });
                        assert(conversation);
                        //#region mute
                        function hardMuteUnmute(val) {
                            if (!mediaDMInitialized())
                                return;
                            var deviceManager = devices['_dm']();
                            return val ?
                                deviceManager.muteInputAsync() :
                                deviceManager.unmuteInputAsync();
                        }
                        // mutes/unmutes the audio channel or returns the mute status
                        var muted = Property({
                            value: false,
                            get: function () { return muted(); },
                            set: Command(function (val, reason) {
                                var dfd;
                                // soft mute is applicable in conference mode
                                // if cleaning up an old p2p avs after escalation, must hardunmute
                                if (isConferencing() && reason !== Internal.sEscalation) {
                                    var rel = val ? 'muteAudio' : 'unmuteAudio', rAudio = ucwa.get(selfParticipant[Internal.sInternal].audioLink);
                                    // Triggered when accepting unmute request from remote - undo hard mute
                                    if (!val && isUnmuteRequested()) {
                                        isUnmuteRequested(false);
                                        dfd = hardMuteUnmute(val).then(function () { return val; });
                                    }
                                    else {
                                        // Regular self mute/unmute 
                                        dfd = Task.run(function () {
                                            if (!rAudio || !rAudio.hasLink(rel))
                                                return ucwa.send('GET', selfParticipant[Internal.sInternal].audioLink);
                                            else
                                                return rAudio;
                                        }).then(function (rAudio) {
                                            return ucwa.send('POST', rAudio.link(rel).href);
                                        }).then(function () {
                                            if (!val && isUnmuteRequested())
                                                isUnmuteRequested(false);
                                            return val;
                                        });
                                    }
                                }
                                else {
                                    // P2P self mute
                                    dfd = hardMuteUnmute(val).then(function () { return val; });
                                }
                                tm && tm.monitor(dfd, Web.TelemetryEvent.Call, {
                                    action: val ? 'muteAudio' : 'unmuteAudio',
                                    type: isConferencing() ? 'conf' : 'p2p',
                                    mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                    callId: callId
                                }, { sendEndEventOnly: true });
                                return dfd;
                            }, mediaDMInitialized)
                        });
                        //#endregion mute
                        //#region onHold
                        // holds/resumes audio/video or returns the onHold status
                        var onHold = Property({
                            value: false,
                            get: function () { return onHold(); },
                            set: function (val) {
                                if (!isConferencing() && participants.size() > 0) {
                                    // the call is on hold when the remote puts on hold; so when
                                    // the local participant requests hold, the plugin will not
                                    // renegotiate, and no need to wait for renegotiation result
                                    if (participants(0).audio.isOnHold() && !onHold())
                                        return val;
                                }
                                var audioConfig = val ? 4 /* NO_ACTIVE_MEDIA */ : 3 /* BOTH */;
                                // TODO: do we need to consider remote video in this like in setting renegotiation offer?
                                mainVideoConfig = activeModalities.video ?
                                    (val ?
                                        4 /* NO_ACTIVE_MEDIA */ :
                                        (selfParticipant[Internal.sInternal].videoStartedBeforeHold() ?
                                            3 /* BOTH */ :
                                            2 /* RECEIVE */) // Self video was off before hold
                                    ) :
                                    0 /* NOT_PRESENT */; // No video
                                holdValue = val;
                                // save or reset video channel's isStarted property value prior to putting call on hold
                                selfParticipant[Internal.sInternal].videoStartedBeforeHold(val ?
                                    selfParticipant.video.channels(0).isStarted() : undefined);
                                selfParticipant[Internal.sInternal].audioOnHold(val);
                                return Task.run(function () {
                                    return mediaSession.configureModalitiesAsync(stripEmptyModalities({
                                        audio: Internal.MediaEnum.enumcastMediaConfig(audioConfig),
                                        video: Internal.MediaEnum.enumcastMediaConfig(mainVideoConfig)
                                    }));
                                }).then(function () {
                                    return startTrackingHoldResume();
                                }).then(function () {
                                    return handleMeetingVideoOnHoldResume(val);
                                }).then(function () { return val; });
                            }
                        });
                        //#endregion onHold
                        options = null;
                        ucwa.event(onServerEvent);
                        watch('WebRtcAudioVideoSession(' + callId + ')::state:', state);
                        watch('WebRtcAudioVideoSession(' + callId + ')::audioState:', audioState);
                        watch('WebRtcAudioVideoSession(' + callId + ')::videoState:', videoState);
                        // audio state should always match the session state
                        state.when(Internal.Modality.State.Connected, function (reason) {
                            return audioState(Internal.Modality.State.Connected, reason);
                        });
                        state.when(Internal.Modality.State.Disconnected, function (reason) {
                            audioState(Internal.Modality.State.Disconnected, reason);
                            videoState(Internal.Modality.State.Disconnected, reason);
                        });
                        // note that the reset method will be called with the "reason" parameter if the
                        // reason was set when property values were changed.
                        // also note the reset of participant.[audio|video].state is done inside AVM.
                        videoState.when(Internal.Modality.State.Disconnected, resetVideo);
                        Property.observe([state, videoState, videoDirection], function (s, vs, vd) {
                            if (s == Internal.Modality.State.Connected && vs == Internal.Modality.State.Connected)
                                renderVideo(vd);
                        });
                        videoDirection.changed(function (newVal) {
                            // Set p2p remote isVideoOn when videoDirection becomes sendrecv or recvonly
                            if (!isConferencing() && participants.size() == 1) {
                                participants(0).video.channels(0)[Internal.sInternal].isVideoOn(newVal == Internal.MediaEnum.enumcastMediaConfig(3 /* BOTH */) ||
                                    newVal == Internal.MediaEnum.enumcastMediaConfig(2 /* RECEIVE */));
                                // Save the last video config before escalation so we can maintain that
                                // state in new session
                                preEscalationVideoConfig(Internal.MediaEnum.enumcastDirection(newVal));
                            }
                        });
                        participants.removed(function (p) {
                            var id = p[Internal.sInternal].audioSourceId();
                            if (Web.Media.isWebRtc()) {
                                if (dominantSpeaker && dominantSpeaker[Internal.sInternal].audioSourceId() == id)
                                    dominantSpeaker = null;
                            }
                            else {
                                delete activeSpeakers[id];
                                removeParticipantWithVideoToRender(p);
                            }
                        });
                        //#region self
                        extend(self, {
                            state: state.asReadOnly(),
                            audioState: audioState.asReadOnly(),
                            videoState: videoState.asReadOnly(),
                            start: async(start),
                            stop: async(stop),
                            cleanup: cleanup,
                            sendDtmf: sendDtmf,
                            escalated: escalated.observer,
                            errorOccured: errorOccured.observer,
                            muted: muted,
                            onHold: onHold,
                            selfVideoStream: selfVideoStream,
                            showParticipantVideo: showParticipantVideo,
                            removeParticipantVideo: removeParticipantVideo,
                            showActiveSpeakerVideo: showActiveSpeakerVideo,
                            removeActiveSpeakerVideo: removeActiveSpeakerVideo,
                            removeVideo: async(removeAllVideo),
                            escalationState: escalationState,
                            preEscalationVideoConfig: preEscalationVideoConfig,
                            isClean: isClean.asReadOnly()
                        });
                        if (invitation) {
                            // incoming call
                            extend(self, {
                                from: invitation.from,
                                accept: async(accept)
                            });
                        }
                        //#endregion
                        //#region private utilities
                        function initMediaAgent() {
                            // initialize the outgoing renegotiation task as resolved to avoid annoying
                            // existence checks
                            dfdOutRenego = new Task();
                            dfdOutRenego.resolve();
                            mediaSessionCb = {
                                onNegotiationRequired: function () {
                                    var descr = 'skipping outgoing renegotiation because of pending incoming renegotiation';
                                    var err = Exception(descr);
                                    var renegoHref = getRenegotiationsHref();
                                    var hasLocalOffer = false;
                                    if (renegoHref) {
                                        // A negotiated AudioVideoSession already exists, the client starts renegotiation -
                                        // expect an "audioVideoRenegotiation completed" event from UCWA after
                                        // sending renegotiation offer
                                        log('RENEGO REQUIRED');
                                        // completing/rejecting previous outgoing renegotiation may trigger this handler
                                        // before we actually resolve dfdOutRenego in the "audioVideoRenegotiation completed"
                                        // event handler, so we need to wait on that promise
                                        dfdOutRenego.promise.then(function () {
                                            if (isPendingInRenego)
                                                throw err;
                                            dfdOutRenego = new Task();
                                            return mediaSession.createOfferAsync();
                                        }).then(function (offer) {
                                            hasLocalOffer = true;
                                            if (isPendingInRenego)
                                                throw err;
                                            return sendRenegotiationOffer(offer.blob, renegoHref);
                                        }).catch(function (err) {
                                            log(err);
                                            stopTrackingSelfVideoToggle('reject', err);
                                            stopTrackingHoldResume('reject', err);
                                            Promise.resolve().then(function () {
                                                if (hasLocalOffer)
                                                    return mediaSession.rejectNegotiationAsync('local', false);
                                            }).finally(function () {
                                                if (dfdOutRenego.state() == 'pending')
                                                    dfdOutRenego.resolve();
                                            });
                                        });
                                    }
                                    else {
                                        // usually caused by the call to configureModalitiesAsync in avs.start() 
                                        // we don't create an offer here because it is created in the start method
                                        log('NEGO REQUIRED');
                                    }
                                },
                                onContributingSourcesChanged: updateActiveSpeakers,
                                onDominantSpeakerChanged: function (msis) { },
                                onSessionErrorOccurred: function (error) {
                                    tm && tm.record(Web.TelemetryEvent.Call, {
                                        action: 'mediaSessionError',
                                        type: isConferencing() ? 'conf' : 'p2p',
                                        modalities: activeModalities.video ? 'av' : 'audio',
                                        mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                        state: state(),
                                        reason: error,
                                        callId: callId
                                    });
                                    var e = error.type + ": " + error.detail;
                                    log('WebRtcAudioVideoSession(' + callId + ')::onSessionErrorOccured', e);
                                    errorOccured.fire(e);
                                }
                            };
                            return Web.Media.getMediaAgent(ucwa, tm);
                        }
                        function startTrackingSelfVideoToggle() {
                            dfdSelfVideo = new Task('selfVideo');
                            return dfdSelfVideo.promise;
                        }
                        function stopTrackingSelfVideoToggle(val, reason) {
                            if (dfdSelfVideo && dfdSelfVideo.state() == 'pending') {
                                if (val == 'resolve')
                                    dfdSelfVideo.resolve();
                                else if (val == 'reject')
                                    dfdSelfVideo.reject(reason);
                            }
                        }
                        function startTrackingHoldResume() {
                            dfdHold = new Task(holdValue ? 'hold' : 'resume');
                            return dfdHold.promise.then(function () { return holdValue; });
                        }
                        function stopTrackingHoldResume(val, reason) {
                            if (dfdHold && dfdHold.state() == 'pending') {
                                if (val == 'resolve')
                                    dfdHold.resolve(holdValue);
                                else if (val == 'reject')
                                    dfdHold.reject(reason);
                            }
                        }
                        function handleMeetingVideoOnHoldResume(val) {
                            var promises = [];
                            if (val) {
                                for (var id in participantsWithVideoToRender) {
                                    var dfd = removeParticipantVideo(participantsWithVideoToRender[id], true);
                                    promises.push(dfd);
                                }
                            }
                            else {
                                for (var id in participantsWithVideoToRender) {
                                    var dfd = showParticipantVideo(participantsWithVideoToRender[id], true);
                                    promises.push(dfd);
                                }
                            }
                            return Task.waitAll(promises);
                        }
                        function addParticipantWithVideoToRender(participant) {
                            assert(participant);
                            participantsWithVideoToRender[participant[Internal.sHref]] = participant;
                        }
                        function removeParticipantWithVideoToRender(participant) {
                            assert(participant);
                            delete participantsWithVideoToRender[participant[Internal.sHref]];
                        }
                        function stripEmptyModalities(modalities) {
                            function isModalityEmpty(modality) {
                                return modality !== '';
                            }
                            for (var key in modalities) {
                                if (!isModalityEmpty(modalities[key])) {
                                    delete modalities[key];
                                }
                            }
                            ;
                            return modalities;
                        }
                        function isConferencing() {
                            var convState = rConversation && rConversation.get('state', '');
                            // TODO: move Conversation.State to model.common.js and use enum here
                            return convState == 'Conferencing' || convState == 'Conferenced';
                        }
                        function getRenegotiationsHref() {
                            var renegoHref, negoSession, negotiated = filter(values(avSessions), function (session) {
                                return session.negotiated;
                            });
                            if (negotiated.length > 0) {
                                assert(negotiated.length == 1);
                                negoSession = negotiated[0];
                                renegoHref = negoSession.resumeAudioVideoUri || negoSession.resource.link('renegotiations').href;
                                assert(renegoHref);
                            }
                            return renegoHref;
                        }
                        function setNegotiatedSession(sctx) {
                            foreach(avSessions, function (session) {
                                if (session.resource.get('sessionContext') == sctx)
                                    session.negotiated = true;
                            });
                        }
                        // called when we stop 1:1 video (including escalation to a meeting)
                        function removeAllVideo(reason) {
                            log('WebRtcAudioVideoSession(' + callId + ')::removeAllVideo', reason);
                            removeVideo(mainVideoStream);
                            removeVideo(selfVideoStream);
                            if (reason !== Internal.sEscalation) {
                                selfParticipant[Internal.sInternal].setVideoStream(null);
                            }
                            if (participants.size() > 0) {
                                participants(0)[Internal.sInternal].setVideoStream(null);
                                participants(0)[Internal.sInternal].setVideoStarted(void 0);
                            }
                        }
                        function resetVideo(reason) {
                            log('WebRtcAudioVideoSession(' + callId + ')::resetVideo', reason);
                            participants.each(function (p) {
                                var stream = p.video.channels(0).stream;
                                removeVideo(stream);
                                // reset the participant video stream source to an empty stream
                                p[Internal.sInternal].setVideoStream(null);
                            });
                            videoStreams.empty();
                            if (reason !== Internal.sEscalation) {
                                selfParticipant[Internal.sInternal].setVideoStream(null);
                                selfParticipant[Internal.sInternal].videoState(Internal.Modality.State.Disconnected);
                                videoDirection('');
                            }
                            if (activeSpeaker && isConferencing()) {
                                activeSpeaker[Internal.sInternal].setVideoStream(null);
                                mainVideoStream._isAttached(false);
                                activeSpeaker[Internal.sInternal].setVideoStarted(false);
                            }
                        }
                        // Check if the SDP offer/answer contains a=inactive field,
                        // which indicates it is a renegotiation triggered when a
                        // participant holds a call.
                        function isHoldRequest(sdp) {
                            return /\ba=inactive\b/gmi.test(sdp);
                        }
                        function isAudioInvitation() {
                            return invitation && !invitation.hasVideo() ||
                                rInvitation && rInvitation.rel == 'onlineMeetingInvitation' &&
                                    conversation.meeting.availableModalities.audio() &&
                                    !conversation.meeting.availableModalities.video();
                        }
                        function isVideoInvitation() {
                            return invitation && invitation.hasVideo() ||
                                rInvitation && rInvitation.rel == 'onlineMeetingInvitation' &&
                                    conversation.meeting.availableModalities.video();
                        }
                        function postMediaDiagnosticsData(reason) {
                            var mediaStats;
                            Task.run(function () {
                                return mediaSession.getStatsAsync();
                            }).then(function (stats) {
                                mediaStats = stats && JSON.stringify(stats);
                                log('WebRtcAudioVideoSession(' + callId + ')::postMediaDiagnostics', reason, mediaStats);
                                if (mediaStats) {
                                    tm && tm.record(Web.TelemetryEvent.Call, {
                                        action: 'postMediaDiagnostics',
                                        type: isConferencing() ? 'conf' : 'p2p',
                                        modalities: activeModalities.video ? 'av' : 'audio',
                                        mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                        mediaStats: mediaStats,
                                        reason: reason,
                                        callId: callId
                                    });
                                }
                            }).catch(function (err) {
                                log('WebRtcAudioVideoSession(' + callId + ')::getStats failed', err);
                            });
                        }
                        // renders self video and the remote video in a 1:1 conversation depending on
                        // the negotiated direction
                        function renderVideo(vd) {
                            function turnVideoOnOff(video) {
                                video.local ? showVideo(selfVideoStream) :
                                    removeVideo(selfVideoStream);
                                if (!isConferencing()) {
                                    video.remote ? showVideo(mainVideoStream) :
                                        removeVideo(mainVideoStream);
                                }
                            }
                            switch (vd) {
                                case 'sendonly':
                                    turnVideoOnOff({ local: true, remote: false });
                                    break;
                                case 'recvonly':
                                    turnVideoOnOff({ local: false, remote: true });
                                    break;
                                case 'sendrecv':
                                    turnVideoOnOff({ local: true, remote: true });
                                    break;
                                case 'inactive':
                                case '':
                                    turnVideoOnOff({ local: false, remote: false });
                                    break;
                            }
                        }
                        function setVideoDirectionFromNegoResult(res) {
                            videoDirection(res.activeModalities.video || '');
                        }
                        // updates the list of active speakers by reconciling the new list
                        // received from MediaAgent with the activeSpeakers dictionary 
                        function updateActiveSpeakers(msis) {
                            var msisToDelete = [];
                            // detect who is still talking and who is not
                            for (var msi in activeSpeakers) {
                                var idx = msis.indexOf(+msi); // conversion: msi is string, msis is number[]
                                if (idx != -1)
                                    msis.splice(idx, 1);
                                else
                                    msisToDelete.push(msi);
                            }
                            // remove recent speakers who stopped talking
                            for (var _i = 0, msisToDelete_1 = msisToDelete; _i < msisToDelete_1.length; _i++) {
                                var msi = msisToDelete_1[_i];
                                activeSpeakers[msi][Internal.sInternal].isSpeaking(false);
                                delete activeSpeakers[msi];
                            }
                            // add new speakers
                            for (var _a = 0, msis_1 = msis; _a < msis_1.length; _a++) {
                                var msi = msis_1[_a];
                                var ps = void 0;
                                if (selfParticipant[Internal.sInternal].audioSourceId() == msi) {
                                    ps = selfParticipant;
                                }
                                else {
                                    for (var _b = 0, _d = participants(); _b < _d.length; _b++) {
                                        var p = _d[_b];
                                        if (p[Internal.sInternal].audioSourceId() == msi) {
                                            ps = p;
                                            break;
                                        }
                                    }
                                }
                                if (ps) {
                                    ps[Internal.sInternal].isSpeaking(true);
                                    activeSpeakers[msi] = ps;
                                }
                            }
                        }
                        /*
                         * If there is no specified device, completeNegotiationAsync-getUserMedia
                         * may throw an error. The error can be:
                         *      - Edge:    MediaStreamError: { name: "NotFoundError" }
                         *      - Firefox: MediaStreamError: { name: "NotFoundError", message: "The object can not be found here" }
                         *      - Chrome:  NavigatorUserMediaError: { name: "DevicesNotFoundError" }
                         *
                         * This error can be caught by sendOffer/start, or by "audioVideoInvitation completed"
                         * event handler. In either case, we need to confirm if rendering audio/video devices
                         * are missing and raise a more meaningful error so it can be tracked by the app as well
                         * as in telemetry.
                         */
                        function checkDevicesNotFoundError(error) {
                            if (error && /^(Devices)?NotFoundError$/.test(error.name) &&
                                (!devices.selectedMicrophone() || videoState() != "Disconnected" && !devices.selectedCamera()))
                                error = Exception.call('The requested media stream could not be found, check your camera or microphone devices', 'DeviceNotFound', { reason: error });
                            return error;
                        }
                        //#endregion
                        //#region public methods
                        //#region start
                        /**
                         * Starts an outgoing Audio/Video call
                         *
                         *  @param {String} remoteUri
                         *  @param {MediaEnum.MediaConfig} audioConfig
                         *  @param {MediaEnum.MediaConfig} mainVideoConfig
                         *  @param {Object} [video]
                         *
                         *  @returns {Promise}
                         *
                         *  Starting a P2P audio call
                         *  - Generates an SDP offer
                         *  - Sends a POST request to startAudioVideo link with the SDP offer.
                         *  - Gets an "audioVideoInvitation started" event from UCWA.
                         *  - Gets an "audioVideoNegotiation started" event from UCWA with a provisional SDP answer.
                         *  - Ignores the provisional answer
                         *  - Gets an "audioVideoSession added" event.
                         *  - Gets an "audioVideoNegotiation completed" event with a final SDP answer.
                         *  - Sets the final answer
                         *  - Gets a "audioVideoInvitation completed" event from UCWA.
                         *  - Completes negotiation.
                         *
                         *  Joining an audio conference call the client follows the same sequence with one exception:
                         *  there is no initial negotiation - all "audioVideoNegotiation" events are absent.
                         *
                         *  If the client calls an invalid sip uri, it receives a single "audioVideoInvitation
                         *  completed" event with failure status and appropriate error code.
                         */
                        function start(options) {
                            // prohibit start of audio or video when that modality is already started
                            if ((options.mainVideoConfig != 0 /* NOT_PRESENT */ && activeModalities.video) ||
                                (options.mainVideoConfig == 0 /* NOT_PRESENT */ &&
                                    options.audioConfig == 3 /* BOTH */ && activeModalities.audio))
                                throw Exception('AlreadyStarted');
                            log('WebRtcAudioVideoSession(' + callId + ')::start', options);
                            check.state(onHold(), false);
                            var audioConfig = options.audioConfig, previewContainer = options.video && options.video.previewContainer, videoContainer = options.video && options.video.container, startsVideo = options.mainVideoConfig != 0 /* NOT_PRESENT */, oldMainVideoConfig = mainVideoConfig;
                            mainVideoConfig = options.mainVideoConfig;
                            // start is allowed to be called twice only when the first call starts audio,
                            // and the second call adds video. So a different options.remoteUri for adding
                            // video does not make sense
                            remoteUri = remoteUri || options.remoteUri;
                            options = null;
                            check.state(state(), [
                                Internal.Modality.State.Disconnected,
                                Internal.Modality.State.Notified,
                                Internal.Modality.State.Connected
                            ]);
                            if (state() == Internal.Modality.State.Disconnected ||
                                state() == Internal.Modality.State.Notified) {
                                state(Internal.Modality.State.Connecting);
                            }
                            // to keep parity with Skype not only we need to set the local participant AV state
                            // in a 1:1 call but also to fake the remote participant AV state; and we always check
                            // for the remote participant existence because the call can be started with the
                            // empty participants collection by specifying the remote sip uri.
                            if (audioState() == Internal.Modality.State.Disconnected ||
                                audioState() == Internal.Modality.State.Notified) {
                                audioState(Internal.Modality.State.Connecting);
                                if (!isConferencing() && participants.size() > 0)
                                    participants(0)[Internal.sInternal].audioState(Internal.Modality.State.Connecting);
                            }
                            // reset videoState if user does not want to start video
                            if (!startsVideo)
                                videoState(Internal.Modality.State.Disconnected);
                            if (videoState() == Internal.Modality.State.Disconnected && startsVideo ||
                                videoState() == Internal.Modality.State.Notified) {
                                videoState(Internal.Modality.State.Connecting);
                                if (!isConferencing() && participants.size() > 0)
                                    participants(0)[Internal.sInternal].videoState(Internal.Modality.State.Connecting);
                            }
                            // this is a repeated invocation of this method that adds video to an existing audio call
                            if (audioState() == Internal.Modality.State.Connected &&
                                videoState() == Internal.Modality.State.Connecting) {
                                return Task.run(function () {
                                    return mediaSession.configureModalitiesAsync(stripEmptyModalities({
                                        audio: Internal.MediaEnum.enumcastMediaConfig(audioConfig),
                                        video: Internal.MediaEnum.enumcastMediaConfig(mainVideoConfig)
                                    }));
                                }).then(function () {
                                    return startTrackingSelfVideoToggle();
                                }).catch(function (err) {
                                    // reset video state
                                    mainVideoConfig = oldMainVideoConfig;
                                    if (!isConferencing() && participants.size() > 0 &&
                                        participants(0)[Internal.sInternal].videoState() == Internal.Modality.State.Connecting) {
                                        participants(0)[Internal.sInternal].videoState(Internal.Modality.State.Disconnected);
                                    }
                                    videoState(Internal.Modality.State.Disconnected);
                                    throw err;
                                });
                            }
                            dfdStart = new Task('starting a call');
                            var promise = Task.run(function () {
                                if (!mediaSession) {
                                    mediaSession = mediaAgent.createSession(mediaSessionCb, guid(), {
                                        isRemoteClientLync: true,
                                        isConference: isConferencing()
                                    });
                                    mainVideoStream._mediaSession(mediaSession);
                                    selfVideoStream._deviceManager(mediaAgent.getDeviceManager());
                                }
                                return mediaSession.configureModalitiesAsync(stripEmptyModalities({
                                    audio: Internal.MediaEnum.enumcastMediaConfig(audioConfig),
                                    video: Internal.MediaEnum.enumcastMediaConfig(mainVideoConfig)
                                }));
                            }).then(function () {
                                // hook up the preview video stream - this will retain the video container if it was set for
                                // self participant.
                                // NB: we need to do it even if it's just an audio call. If the video is added later we won't
                                // receive another invitation (it's a renegotiation of an established AV connection), so
                                // we won't have a chance to call accept method again.
                                selfParticipant[Internal.sInternal].setVideoStream(selfVideoStream);
                                if (videoContainer)
                                    mainVideoStream.source.sink.container(videoContainer);
                                if (previewContainer)
                                    selfVideoStream.source.sink.container(previewContainer);
                                if (audioState() == Internal.Modality.State.Connecting && !isConferencing() && participants.size() > 0)
                                    participants(0)[Internal.sInternal].audioState(Internal.Modality.State.Ringing);
                                return mediaSession.createOfferAsync();
                            }).then(function (offer) {
                                return sendOffer([{ sdp: offer.blob, id: 1 }]);
                            }).then(function () {
                                state(Internal.Modality.State.Connected);
                                // this will set the video state for WebRTC if there is no renegotiation
                                videoState(videoDirection() == '' ?
                                    Internal.Modality.State.Disconnected :
                                    Internal.Modality.State.Connected);
                                return dfdStart.resolve().promise;
                            }).catch(function (error) {
                                log('WebRtcAudioVideoSession(' + callId + ')::start failed', error);
                                error = checkDevicesNotFoundError(error);
                                if (error && !error.code && error.type)
                                    error.code = error.type;
                                postMediaDiagnosticsData(error);
                                // If the AV invitation was not sent we need not bother, but if it was we need to cancel the call.
                                // If the "audioVideoInvitation started" event was received we get the cancel link from it and we can 
                                // terminate the call here. If we have not received the "audioVideoInvitation started" event
                                // rAVinvitation contains the reply from the "send invitation" request that has a self link only.
                                // So we can't terminate the call here, and we have to wait till we receive the "audioVideoInvitation started"
                                // event. The event handler will check the modality state, see that it is disconnected and will terminate
                                // the call.
                                if (!rAVInvitation) {
                                    cleanup(error);
                                }
                                else {
                                    if (rAVInvitation.hasLink('cancel'))
                                        ucwa.send('POST', rAVInvitation.link('cancel').href, { nobatch: true });
                                    // if the invitation was sent to an invalid SIP uri, we won't receive 'audioVideoInvitation started' 
                                    // event, so we won't have cancel link, but we will have received "audioVideoInvitation completed" 
                                    // event so we just need to clean up.
                                    if (rAVInvitation['eventRecv'])
                                        cleanup();
                                }
                                // if the caller hangs up by canceling the promise returned by this method
                                if (dfdStart.state() == 'pending')
                                    dfdStart.reject(error);
                                state(Internal.Modality.State.Disconnected, error);
                                throw error;
                            });
                            return Task.waitAll([promise, dfdStart.promise]).then(function () { });
                        }
                        //#endregion
                        //#region accept
                        /**
                         * Accepts an incoming Audio/Video invitation.
                         *
                         * @param {Dictionary} [video] - The video window container holder.
                         * @param {HTMLElement} [video.container] - A DOM element that serves as the video window container for remote video.
                         *
                         * @returns {Promise}
                         *
                         * Accepting an incoming call invitation:
                         *
                         *  - Creates a media session and sets the SDP offer from the remote party.
                         *  - Generates an SDP answer.
                         *  - Sends a POST audioVideoInvitation/acceptWithAnswer with the generated SDP answer.
                         *  - Receives an "audioVideoinvitation completed" event from UCWA
                         *  - Completes negotiation.
                         *  - Receives an "audioVideoRenegotiation started" event with a new SDP offer from the remote party.
                         *  - Generates an SDP answer.
                         *  - Sends a POST audioVideoRenegotiation/answer with the SDP answer.
                         *  - Receives a "audioVideoRenegotiation completed" event from UCWA.
                         *  - Completes renegotiation.
                         */
                        function accept(options) {
                            assert(invitation, 'This is an outgoing call, so it cannot be "accepted"');
                            assert(!isConferencing(), 'This is a conference'); // accept is used in P2P only
                            assert(participants.size() == 1, 'The caller is not in participants');
                            log('WebRtcAudioVideoSession(' + callId + ')::accept', options);
                            var video = options && options.video, videoContainer = video && video.container, previewContainer = video && video.previewContainer;
                            mainVideoConfig = video ? Internal.MediaEnum.enumcastDirection(video.direction) :
                                settings && settings.supportsVideo == false ? 0 /* NOT_PRESENT */ : 2 /* RECEIVE */;
                            state(Internal.Modality.State.Connecting);
                            audioState(Internal.Modality.State.Connecting);
                            participants(0)[Internal.sInternal].audioState(Internal.Modality.State.Connecting);
                            if (invitation.hasVideo()) {
                                videoState(Internal.Modality.State.Connecting);
                                participants(0)[Internal.sInternal].videoState(Internal.Modality.State.Connecting);
                            }
                            dfdAccept = new Task('accepting a call');
                            var videoConfig;
                            var promise = Task.run(function () {
                                // the caller has already hung up
                                if (state() == Internal.Modality.State.Disconnected)
                                    throw Internal.EInvitationFailed(state.reason);
                                // hook up the preview video stream - this will retain the video container if it was set for
                                // self participant.
                                // NB: we need to do it even if it's just an audio call. If the video is added later we won't
                                // receive another invitation (it's a renegotiation of an established AV connection), so
                                // we won't have a chance to call accept method again.
                                selfParticipant[Internal.sInternal].setVideoStream(selfVideoStream);
                                if (videoContainer)
                                    mainVideoStream.source.sink.container(videoContainer);
                                if (previewContainer)
                                    selfVideoStream.source.sink.container(previewContainer);
                                mediaSession = mediaAgent.createSession(mediaSessionCb, guid(), {
                                    isRemoteClientLync: true,
                                    isConference: isConferencing()
                                });
                                mainVideoStream._mediaSession(mediaSession);
                                selfVideoStream._deviceManager(mediaAgent.getDeviceManager());
                                if (invitation.offers.length > 1)
                                    log('WebRtcAudioVideoSession(' + callId + ')::accept:number of offers:', invitation.offers.length);
                                // sort offers such that those with 'a=label' line are processed first
                                invitation.offers.sort(function (offer1, offer2) {
                                    var re = /\ba=label\b/gi;
                                    return re.test(offer1.sdp) ? -1 : re.test(offer2.sdp) ? 1 : 0;
                                });
                                return (function processOffer(i) {
                                    videoConfig = determineVideoConfig(invitation.offers[i].sdp);
                                    return mediaSession.processOfferAsync({ blob: invitation.offers[i].sdp }).catch(function (err) {
                                        // if there are more SDPs and the previous one was not processed
                                        // successfully, try the next SDP
                                        if (!(err && err.code == 'Canceled')) {
                                            // Note: the check of the cancel case is for unit test only
                                            // In production, the native promise will not throw such an exception
                                            tm && tm.record(Web.TelemetryEvent.Call, {
                                                action: 'processOfferAsync',
                                                type: isConferencing() ? 'conf' : 'p2p',
                                                modalities: activeModalities.video ? 'av' : 'audio',
                                                mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                                state: state(),
                                                reason: err,
                                                offerId: i,
                                                callId: callId
                                            });
                                            return mediaSession.rejectNegotiationAsync('local', false).then(function () {
                                                if (++i < invitation.offers.length)
                                                    return processOffer(i);
                                                throw err;
                                            }).catch(function (e) {
                                                throw e;
                                            });
                                        }
                                        throw err;
                                    });
                                })(0);
                            }).then(function (modalities) {
                                return mediaSession.configureModalitiesAsync(stripEmptyModalities(!modalities.video ?
                                    modalities :
                                    {
                                        audio: modalities.audio,
                                        video: Internal.MediaEnum.enumcastMediaConfig(videoConfig)
                                    }));
                            }).then(function () {
                                return mediaSession.createAnswerAsync(false);
                            }).then(function (answer) {
                                return invitation.acceptWithAnswer(answer.blob, sessionContext);
                            }).catch(function (error) {
                                log('WebRtcAudioVideoSession(' + callId + ')::accept failed', error);
                                if (error && !error.code && error.type)
                                    error.code = error.type;
                                state(Internal.Modality.State.Disconnected, error);
                                videoState(Internal.Modality.State.Disconnected);
                                postMediaDiagnosticsData(error);
                                cleanup(error);
                                if (dfdAccept.state() == 'pending')
                                    dfdAccept.reject(error);
                                throw error;
                            });
                            return Task.waitAll([promise, dfdAccept.promise]);
                        }
                        //#endregion
                        //#region stop
                        /**
                         * Stops Audio/Video session
                         *
                         * @param {String} [reason] - if equals 'video', only video is stopped, if omitted both audio and video are stopped.
                         */
                        function stop(reason) {
                            log('WebRtcAudioVideoSession(' + callId + ')::stop', reason);
                            // cancel start/accept if stop is called during connecting
                            if (state() == Internal.Modality.State.Connecting) {
                                var dfd = dfdStart || dfdAccept;
                                if (dfd) {
                                    dfd.promise.cancel();
                                    return Promise.resolve();
                                }
                                else {
                                    log('WebRtcAudioVideoSession(' + callId + ')::stop cannot be called in Connecting state without a pending start or accept');
                                    return Promise.reject(ENotSupported('stop cannot be called in Connecting state without a pending start or accept'));
                                }
                            }
                            var promise;
                            if (reason == 'video') {
                                if (isConferencing()) {
                                    participants.each(function (p) {
                                        p.video.channels(0).isStarted(false);
                                    });
                                }
                                var audioConfig_1 = onHold() ?
                                    4 /* NO_ACTIVE_MEDIA */ : 3 /* BOTH */;
                                mainVideoConfig = 0 /* NOT_PRESENT */;
                                promise = Task.run(function () { return mediaSession.configureModalitiesAsync(stripEmptyModalities({
                                    audio: Internal.MediaEnum.enumcastMediaConfig(audioConfig_1),
                                    video: Internal.MediaEnum.enumcastMediaConfig(mainVideoConfig)
                                })); });
                            }
                            else if (reason === Internal.sEscalation || (reason && reason.code == 'NotFound')) {
                                // if escalation or server error, do only cleanup
                                cleanup(reason);
                                promise = Promise.resolve();
                            }
                            else {
                                postMediaDiagnosticsData(reason);
                                // if not escalation then it is a call getting stopped explicitly 
                                promise = ucwa.send('GET', rConversation.link('audioVideo').href).then(function (r) {
                                    return ucwa.send('POST', r.link('stopAudioVideo').href, {
                                        query: { reason: reason || 'UserInitiatedAction' }
                                    });
                                }).catch(function (err) {
                                    log('WebRtcAudioVideoSession(' + callId + ')::stop', err);
                                    // any error during stopAudioVideo (e.g., no audioVideo link or POST failed
                                    // with 404 NotFound) should not be considered a failure of stop action, but
                                    // should be recorded in telemetry
                                    tm && tm.record(Web.TelemetryEvent.Call, {
                                        action: 'stopAudioVideo',
                                        type: isConferencing() ? 'conf' : 'p2p',
                                        modalities: activeModalities.video ? 'av' : 'audio',
                                        mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                        state: state(),
                                        reason: err,
                                        callId: callId
                                    });
                                }).finally(function () {
                                    return cleanup(reason);
                                });
                            }
                            return promise.then(function () { }); // the 'then' clause is to satisfy the Promise<void> return type contract
                        }
                        //#endregion
                        //#region sendDtmf
                        /**
                         * Sends a DTMF tone
                         *
                         * @param {String} tone - A DTMF tone from MediaEnum.DtmfTone enumeration
                         * @returns {Promise}
                         */
                        function sendDtmf(tone) {
                            if (isNotEmptyString(tone)) {
                                tone = tone.trim().toLowerCase();
                                tone = tone.substr(0, 1).toUpperCase() + tone.substr(1);
                                switch (tone) {
                                    case 'Star':
                                        tone = '*';
                                        break;
                                    case 'Pound':
                                        tone = '#';
                                        break;
                                }
                                if (Internal.MediaEnum.DtmfTone[tone] !== undefined) {
                                    return Task.run(function () { return mediaSession.sendDtmf(tone); });
                                }
                            }
                            throw EInvalidArgument('tone', 'out of range');
                        }
                        //#endregion
                        //#region showParticipantVideo
                        function showParticipantVideo(participant, whileOnHold) {
                            var p = new Promise(function (resolve) {
                                if (videoState() == Internal.Modality.State.Connecting) {
                                    var sub_2 = videoState.changed(function (newValue, reason, oldValue) {
                                        if (newValue != Internal.Modality.State.Connecting) {
                                            sub_2.dispose();
                                            resolve();
                                        }
                                    });
                                }
                                else
                                    resolve();
                            });
                            return p.then(function () {
                                var videoStream, dfd;
                                if (videoState() != Internal.Modality.State.Connected)
                                    throw EInvalidState(videoState(), Internal.Modality.State.Connected);
                                if (onHold() && !whileOnHold)
                                    throw Exception('OnHold');
                                log('WebRtcAudioVideoSession(' + callId + ')::showParticipantVideo', participant);
                                if (participant[Internal.sInternal].isLocal()) {
                                    // undefined means that we just started video, no need to renegotiate
                                    if (participant.video.channels(0).isStarted() === false) {
                                        // TODO: Should this take into account remote participant video state at all?
                                        mainVideoConfig = 3 /* BOTH */;
                                        return Task.run(function () { return mediaSession.configureModalitiesAsync(stripEmptyModalities({
                                            audio: Internal.MediaEnum.enumcastMediaConfig(3 /* BOTH */),
                                            video: Internal.MediaEnum.enumcastMediaConfig(mainVideoConfig)
                                        })); }).then(function () {
                                            return startTrackingSelfVideoToggle();
                                        });
                                    }
                                    return new Task().resolve().promise;
                                }
                                else if (isConferencing()) {
                                    // find available stream
                                    if (!mainVideoStream._isAttached()) {
                                        videoStream = mainVideoStream;
                                    }
                                    else {
                                        for (var _i = 0, _a = videoStreams(); _i < _a.length; _i++) {
                                            var vs = _a[_i];
                                            if (!vs._isAttached()) {
                                                videoStream = vs;
                                                break;
                                            }
                                        }
                                        ;
                                    }
                                    // In ORTC, we don't get 'CHANNEL_CREATED' plugin events to tell us
                                    // when to create a new media stream, so we create them on demand here.
                                    if (!videoStream) {
                                        // MainVideoStream isn't included in videoStreams.size but does count towards
                                        // the max number of video streams.
                                        if (videoStreams.size() < Web.Media.MaxVideoChannels - 1) {
                                            videoStream = new Internal.WebRtcRemoteMediaStream({
                                                mediaSession: mediaSession
                                            });
                                            videoStreams.add(videoStream);
                                        }
                                        else {
                                            log('Cannot find available stream');
                                            throw EDoesNotExist('No available stream');
                                        }
                                    }
                                    participant[Internal.sInternal].setVideoStream(videoStream);
                                    dfd = videoStream._id.set(participant[Internal.sInternal].videoSourceId())
                                        .then(function () { return videoStream._isAttached.set(true); })
                                        .then(function () { return showVideo(videoStream); })
                                        .then(function () { return addParticipantWithVideoToRender(participant); });
                                }
                                else {
                                    dfd = new Task().reject(ENotSupported('cannot start remote video in 1:1 conversation')).promise;
                                }
                                return dfd;
                            });
                        }
                        //#endregion showParticipantVideo
                        //#region removeParticipantVideo
                        function removeParticipantVideo(participant, whileOnHold) {
                            var dfd;
                            log('WebRtcAudioVideoSession(' + callId + ')::removeParticipantVideo', participant);
                            if (participant[Internal.sInternal].isLocal()) {
                                mainVideoConfig = 2 /* RECEIVE */;
                                // need to respect the current videoConfig of the remote party in a p2p call
                                // (participants does not contain the local participant in a conf call)
                                if (!isConferencing()) {
                                    var v = participants(0).video.channels(0);
                                    if (!v.isVideoOn()) {
                                        mainVideoConfig = 4 /* NO_ACTIVE_MEDIA */;
                                    }
                                }
                                dfd = Task.run(function () { return mediaSession.configureModalitiesAsync(stripEmptyModalities({
                                    audio: Internal.MediaEnum.enumcastMediaConfig(3 /* BOTH */),
                                    video: Internal.MediaEnum.enumcastMediaConfig(mainVideoConfig)
                                })); }).then(function () {
                                    return startTrackingSelfVideoToggle();
                                });
                            }
                            else if (isConferencing()) {
                                dfd = Task.wait(null, 'sync').then(function () {
                                    // NB: this is a sourced stream
                                    var videoStream = participant.video.channels(0).stream;
                                    var sink = videoStream.source.sink;
                                    if (sink._c()) {
                                        sink._c().dispose();
                                        sink._c(null);
                                    }
                                    if (!whileOnHold)
                                        removeParticipantWithVideoToRender(participant);
                                    if (videoStream._isAttached()) {
                                        return removeVideo(videoStream)
                                            .then(function () { return videoStream._isAttached.set(false); })
                                            .then(function () { return videoStream._id.set(-1); }) // distinguish this stream from an uninitialized stream
                                            .then(function () { return participant[Internal.sInternal].setVideoStream(null); });
                                    }
                                });
                            }
                            else {
                                // in 1:1 we can't remove remote video without stopping video altogether
                                dfd = new Task().reject(ENotSupported('cannot remove remote video in 1:1 conversation')).promise;
                            }
                            return dfd;
                        }
                        //#endregion removeParticipantVideo
                        function showActiveSpeakerVideo() {
                            // skipping all the checks because this function is called by AVM in a conference call 
                            // only and when videoState is Connected only
                            if (onHold())
                                throw Exception('OnHold');
                            assert(activeSpeaker);
                            assert(!mainVideoStream._isAttached());
                            activeSpeaker[Internal.sInternal].setVideoStream(mainVideoStream);
                            // NB: this is a sourced stream
                            var videoStream = activeSpeaker.channel.stream;
                            videoStream._id(-2); // doesn't really matter
                            videoStream._isAttached(true);
                            return showVideo(videoStream);
                        }
                        function removeActiveSpeakerVideo() {
                            // skipping all the checks because this function is called by AVM in a conference call 
                            // only and when videoState is Connected only
                            if (onHold())
                                throw Exception('OnHold');
                            assert(activeSpeaker);
                            return Task.wait(null, 'sync').then(function () {
                                // NB: this is a sourced stream
                                var videoStream = activeSpeaker.channel.stream;
                                var sink = videoStream.source.sink;
                                if (sink._c()) {
                                    sink._c().dispose();
                                    sink._c(null);
                                }
                                if (videoStream._isAttached()) {
                                    removeVideo(videoStream);
                                    videoStream._isAttached(false);
                                    videoStream._id(-2);
                                    activeSpeaker[Internal.sInternal].setVideoStream(null);
                                }
                            });
                        }
                        //#endregion public methods
                        //#region cleanup
                        // Unsubscribes from server and terminates the media session
                        function cleanup(reason) {
                            if (isClean()) {
                                log('WebRtcAudioVideoSession(' + callId + ')::already cleaned up', reason);
                                return;
                            }
                            tm && tm.record(Web.TelemetryEvent.Call, {
                                action: 'cleanup',
                                type: isConferencing() ? 'conf' : 'p2p',
                                modalities: activeModalities.video ? 'av' : 'audio',
                                mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                state: state(),
                                reason: reason,
                                callId: callId
                            });
                            var cDisconnected = Internal.Modality.State.Disconnected;
                            log('WebRtcAudioVideoSession(' + callId + ')::cleanup', reason);
                            var dfdUnmute = Promise.resolve();
                            if (isConferencing() && reason !== Internal.sEscalation)
                                muted._set(false);
                            else
                                dfdUnmute = muted.set(false, reason);
                            onHold._set(false);
                            dfdUnmute.finally(function () {
                                // These are both 'bottom-up' property changes; ie. selfParticipant.audio.isMuted 
                                // inherits from avm.muted which inherits from avs.muted.
                                // To reflect change in isMuted and isOnHold() must do a get() explicitly
                                selfParticipant.audio.isMuted.get();
                                selfParticipant.audio.isOnHold.get();
                                isClean(true);
                            });
                            // clean up the internal properties associated with call hold
                            selfParticipant[Internal.sInternal].audioOnHold(false);
                            selfParticipant[Internal.sInternal].videoStartedBeforeHold(undefined);
                            ucwa.event.off(onServerEvent);
                            removeAllVideo(reason);
                            resetVideo(reason);
                            if (mediaSession) {
                                mediaSession.terminate();
                                mediaSession = null;
                            }
                            participants.each(function (p) {
                                // reset the participant video stream source to an empty stream
                                p[Internal.sInternal].setVideoStream(null);
                                // note the reset of participant.[audio|video].state is done inside AVM.
                                if (reason !== Internal.sEscalation) {
                                    p.video.channels(0)[Internal.sInternal].isVideoOn(false);
                                    p[Internal.sInternal].setVideoStarted(false);
                                }
                            });
                            if (reason !== Internal.sEscalation) {
                                selfParticipant.video.channels(0)[Internal.sInternal].isVideoOn(false);
                                selfParticipant[Internal.sInternal].setVideoStarted(false);
                            }
                            audioState(cDisconnected /*, reason*/);
                            videoState(cDisconnected, reason);
                            videoDirection('');
                            // TODO:
                            // reportMediaDiagnosticsUrl = null;
                            // publishCallQualityFeedbackUrl = null;
                        }
                        //#endregion
                        //#region videoWindow
                        /**
                         * Creates a video element and anchors it in the parent DOM element.
                         * The whole area of the parent element will be occupied by the video.
                         */
                        function showVideo(vs) {
                            return vs._isRendering.set(true);
                        }
                        /**
                         * Removes the video element from the parent DOM element
                         */
                        function removeVideo(vs) {
                            return vs._isRendering.set(false);
                        }
                        //#endregion videoWindow
                        //#region server events
                        function onServerEvent(event) {
                            var id = event.target.rel + ' ' + event.type;
                            var handler = ucwaEventHandlers[id];
                            if (handler) {
                                // debugger; // this is to let debug the handler of the event
                                // use callId to check if events are picked up by old AVS event handlers
                                log('WebRtcAudioVideoSession(' + callId + ')::onServerEvent: ' + id);
                                handler(event.status, event.resource, event);
                            }
                        }
                        var ucwaEventHandlers = {
                            // this is the first event received in any AV call setup (except calling an invalid SIP uri,
                            // in which case UCWA sends the 'audioVideoInvitation completed' event only).
                            'audioVideoInvitation started': function (status, resource) {
                                // set the invitation resource for the outgoing AV session (for the incoming call
                                // audioVideoSession is initialized with the received invitation resource)
                                if (resource.get('direction') == 'Outgoing' &&
                                    resource.get('sessionContext') == sessionContext) {
                                    // if the user canceled the call before we received this event terminate the call
                                    // on the server and discard the media session. Note that this is the only case where
                                    // the cleanup of a failed outbound call is not done in the catch clause of the start()
                                    if (state() == Internal.Modality.State.Disconnected) {
                                        if (resource.hasLink('cancel')) {
                                            var dfd = ucwa.send('POST', resource.link('cancel').href, { nobatch: true });
                                            tm && tm.monitor(dfd, Web.TelemetryEvent.Call, {
                                                action: 'cancel',
                                                type: isConferencing() ? 'conf' : 'p2p',
                                                modalities: activeModalities.video ? 'av' : 'audio',
                                                mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                                state: state(),
                                                callId: callId
                                            });
                                        }
                                        cleanup();
                                    }
                                    else {
                                        rAVInvitation = resource;
                                        rAVInvitation['eventRecv'] = true;
                                        dfdStart.status('awaiting "audioVideoNegotiation started or completed" event from UCWA');
                                    }
                                }
                            },
                            // this event is received if we started an outgoing AV call as the first conversation modality
                            // using the global startAudioVideo link
                            'conversation added': function (status, resource) {
                                if (resource.get('threadId') == conversation.threadId())
                                    rConversation = resource;
                            },
                            // this event is received during outgoing P2P AV call setup (early media?)
                            'audioVideoNegotiation started': function (status, resource, event) {
                                if (rAVInvitation && event.sender.href == rAVInvitation.href) {
                                    tm && tm.record(Web.TelemetryEvent.Call, {
                                        action: 'audioVideoNegotiationStarted',
                                        type: isConferencing() ? 'conf' : 'p2p',
                                        modalities: activeModalities.video ? 'av' : 'audio',
                                        mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                        state: state(),
                                        hasAnswer: resource.hasLink('mediaProvisionalAnswer'),
                                        callId: callId
                                    });
                                    if (resource.hasLink('mediaProvisionalAnswer')) {
                                        setProvisionalAnswer(resource.link('mediaProvisionalAnswer').href).catch(function (err) {
                                            return log('Error setting provisional answer: ', err);
                                        });
                                        dfdStart.status('awaiting "audioVideoNegotiation completed" event from UCWA');
                                    }
                                }
                            },
                            // this event is received during outgoing P2P or conference call setup.
                            // If the negotiation completed successfully the event resource contains session context,
                            // a link to matching audioVideoSession and the remoteEndpoint of that session.
                            // If the call was declined or not answered we have negotiation href only.
                            'audioVideoNegotiation completed': function (status, resource, event) {
                                var href;
                                if (rAVInvitation && event.sender.href == rAVInvitation.href) {
                                    tm && tm.record(Web.TelemetryEvent.Call, {
                                        action: 'audioVideoNegotiationCompleted',
                                        type: isConferencing() ? 'conf' : 'p2p',
                                        modalities: activeModalities.video ? 'av' : 'audio',
                                        mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                        state: state(),
                                        status: status,
                                        reason: event.reason,
                                        hasAnswer: resource && resource.hasLink('mediaAnswer'),
                                        callId: callId
                                    });
                                    switch (status) {
                                        case 'Success':
                                            // "audioVideoNegotiation completed" may arrive before the corresponding
                                            // "audioVideoSession added" event when the call is forwarded to voice mail.
                                            // in this case we create an entry in avSessions and expect to fill it out
                                            // after the session added event arrives.
                                            href = resource.link('audioVideoSession').href;
                                            avSessions[href] = avSessions[href] || {};
                                            avSessions[href].negotiated = true;
                                            promiseFinalAnswer = setFinalAnswer(resource.link('mediaAnswer').href);
                                            dfdStart.status('awaiting "audioVideoInvitation completed" event from UCWA');
                                            break;
                                        case 'Failure':
                                            if (event.reason.subcode != 'Ended' && event.reason.subcode != 'ConnectedElsewhere' && dfdStart)
                                                dfdStart.status(event.reason && event.reason.message);
                                            break;
                                    }
                                }
                            },
                            // during an outgoing call the server may set up more than one audioVideoSession, because
                            // the remote sip uri that we are calling may be signed in on more than one endpoint.
                            // Also, if the remote party does not accept the call the UCWA server may redirect the
                            // client to a media server so that the client may leave a voice mail; during this process
                            // the UCWA server will create another audioVideoSession and delete the original session.
                            // The next two handlers keep track of audioVideoSessions.
                            'audioVideoSession added': function (status, resource) {
                                var href = resource.href;
                                if (resource.get('sessionContext') == sessionContext) {
                                    avSessions[href] = avSessions[href] || {};
                                    avSessions[href].resource = resource;
                                    tm && tm.record(Web.TelemetryEvent.Call, {
                                        action: 'audioVideoSessionAdded',
                                        type: isConferencing() ? 'conf' : 'p2p',
                                        mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                        callId: callId,
                                        href: href
                                    });
                                }
                            },
                            'audioVideoSession deleted': function (status, resource, event) {
                                // this event is the only indication of a failed escalation; we need to notify
                                // AudioVideoModality so it can force the cleanup of this session (technically there
                                // a "participantInvitation completed" event with code == ServiceFailure and
                                // subcode == EscalationFailed but it is received by the client that issued the
                                // invitation only).
                                //
                                // Note: for the client (which did not issue the escalation invitation), it can
                                // receive the 'audioVideoSession deleted' event (for the old session) before it
                                // receives the 'audioVideoSession added' event (for the new session); and that
                                // should not be treated as a failed escalation.
                                if (event.target.href in avSessions) {
                                    tm && tm.record(Web.TelemetryEvent.Call, {
                                        action: 'audioVideoSessionDeleted',
                                        type: isConferencing() ? 'conf' : 'p2p',
                                        modalities: activeModalities.video ? 'av' : 'audio',
                                        mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                        state: state(),
                                        status: status,
                                        reason: event.reason,
                                        callId: callId
                                    });
                                    delete avSessions[event.target.href];
                                    if (escalationState() == 2 /* To */ && isEmptyObject(avSessions)) {
                                        escalated.fire('failure');
                                        escalationState(0 /* None */);
                                    }
                                }
                            },
                            // this event is received during any AV call setup
                            'audioVideoInvitation completed': function (status, resource, event) {
                                // check for rAVInvitation is needed because this event may arrive before we
                                // even get a response to startAudioVideo post if we call an invalid SIP uri,
                                // so rAVInvitation may be undefined.
                                // Note that completion of an outgoing invitation is handled by sendOffer method
                                if (rAVInvitation && rAVInvitation.href == resource.href &&
                                    resource.get('direction') == 'Incoming') {
                                    tm && tm.record(Web.TelemetryEvent.Call, {
                                        action: 'audioVideoInvitationCompleted',
                                        type: isConferencing() ? 'conf' : 'p2p',
                                        modalities: activeModalities.video ? 'av' : 'audio',
                                        mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                        state: state(),
                                        status: status,
                                        reason: event.reason,
                                        sessionContext: resource.get('sessionContext', void 0),
                                        direction: 'Incoming',
                                        callId: callId
                                    });
                                    if (status == 'Success') {
                                        // there are no audioVideoNegotiation events in the incoming P2P call setup,
                                        // so we set negotiated flag for the cached audioVideoSession here
                                        setNegotiatedSession(resource.get('sessionContext'));
                                        mediaSession.completeNegotiationAsync().then(function (result) {
                                            setVideoDirectionFromNegoResult(result);
                                            // if AV is added by a remote participant in a 1:1 conversation which already
                                            // has another modality (messaging) then "participantAudio/Video added" events
                                            // arrive before "audioVideoInvitation started" event, i.e. before this
                                            // AudioVideoSession object exists. So we need to set the AV properties of the
                                            // remote participant here:
                                            assert(!isConferencing());
                                            var p = participants(0);
                                            if (p) {
                                                p[Internal.sInternal].audioState(Internal.Modality.State.Connected);
                                                // Check this because videoState() may not be set until the code below executes
                                                // and this is simpler than changing the order in which these properties change
                                                if (videoDirection() != '') {
                                                    p[Internal.sInternal].setVideoStream(mainVideoStream);
                                                    p[Internal.sInternal].videoState(Internal.Modality.State.Connected);
                                                }
                                            }
                                            dfdAccept.resolve();
                                            state(Internal.Modality.State.Connected);
                                            videoState(videoDirection() == '' ?
                                                Internal.Modality.State.Disconnected :
                                                Internal.Modality.State.Connected);
                                        }).catch(function (err) {
                                            if (dfdAccept) {
                                                err = checkDevicesNotFoundError(err);
                                                dfdAccept.reject(err);
                                            }
                                            cleanup();
                                            state(Internal.Modality.State.Disconnected, err);
                                        });
                                    }
                                    else {
                                        // the caller (remote party) hung up while the call setup was not completed.
                                        if (dfdAccept)
                                            dfdAccept.reject(event.reason);
                                        cleanup();
                                        state(Internal.Modality.State.Disconnected, event.reason);
                                    }
                                }
                            },
                            'audioVideoRenegotiation started': function (status, resource) {
                                if (resource.link('audioVideoSession').href in avSessions) {
                                    tm && tm.record(Web.TelemetryEvent.Call, {
                                        action: 'audioVideoRenegotiationStarted',
                                        type: isConferencing() ? 'conf' : 'p2p',
                                        modalities: activeModalities.video ? 'av' : 'audio',
                                        mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                        state: state(),
                                        status: status,
                                        hasOffer: resource.hasLink('mediaOffer'),
                                        direction: resource.get('direction', void 0),
                                        callId: callId
                                    });
                                    var waiting = 'Waiting for audioVideoRenegotiation completed event';
                                    if (resource.get('direction') == 'Incoming') {
                                        var sdp = DataUri(resource.link('mediaOffer').href).data;
                                        if (!isConferencing() && participants.size() > 0) {
                                            remoteHoldState = isHoldRequest(sdp) ?
                                                RemoteHoldState.HoldOffered : RemoteHoldState.ResumeOffered;
                                        }
                                        rAVRenegotiation = resource;
                                        isPendingInRenego = true;
                                        dfdOutRenego.promise.then(function () {
                                            return setRenegotiationOffer(sdp);
                                        }).catch(function (err) {
                                            log(err);
                                            cleanup(err);
                                            state(Internal.Modality.State.Disconnected, err);
                                            isPendingInRenego = false;
                                        });
                                    }
                                    else if (dfdStart && dfdStart.state() == 'pending') {
                                        // this is an outgoing renegotiation caused by the second start() call
                                        // to add video to an audio conversation
                                        dfdStart.status(waiting);
                                    }
                                    else if (dfdSelfVideo && dfdSelfVideo.state() == 'pending') {
                                        // this is an outgoing renegotiation caused by [show|remove]ParticipantVideo
                                        dfdSelfVideo.status(waiting);
                                    }
                                    else if (dfdHold && dfdHold.state() == 'pending') {
                                        // this is an outgoing renegotiation caused by hold/resume
                                        dfdHold.status(waiting);
                                    }
                                }
                            },
                            'audioVideoRenegotiation completed': function (status, resource, event) {
                                var href = resource.link('audioVideoSession').href;
                                if (href in avSessions) {
                                    tm && tm.record(Web.TelemetryEvent.Call, {
                                        action: 'audioVideoRenegotiationCompleted',
                                        type: isConferencing() ? 'conf' : 'p2p',
                                        modalities: activeModalities.video ? 'av' : 'audio',
                                        mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                        state: state(),
                                        status: status,
                                        reason: event.reason,
                                        hasAnswer: resource.hasLink('mediaAnswer'),
                                        operationId: resource.get('operationId', void 0),
                                        direction: resource.get('direction', void 0),
                                        callId: callId
                                    });
                                    var error, promise;
                                    if (resource.get('direction') == 'Outgoing') {
                                        assert(resource.get('operationId') in outAvRenegoOpIds);
                                        delete outAvRenegoOpIds[resource.get('operationId')];
                                        if (status == 'Success') {
                                            avSessions[href].renegotiated = true;
                                            promise = setFinalAnswer(resource.link('mediaAnswer').href).then(function () { return mediaSession.completeNegotiationAsync(); }).then(function (res) {
                                                setVideoDirectionFromNegoResult(res);
                                                videoState(videoDirection() == '' ?
                                                    Internal.Modality.State.Disconnected :
                                                    Internal.Modality.State.Connected);
                                                stopTrackingSelfVideoToggle('resolve');
                                                stopTrackingHoldResume('resolve');
                                            });
                                        }
                                        else {
                                            promise = Task.run(function () { return mediaSession.rejectNegotiationAsync('signaling', false); });
                                            error = event.reason;
                                            stopTrackingSelfVideoToggle('reject', error);
                                            stopTrackingHoldResume('reject', error);
                                        }
                                        promise.catch(function (err) {
                                            status = 'Failure';
                                            error = err;
                                            stopTrackingSelfVideoToggle('reject', error);
                                            stopTrackingHoldResume('reject', error);
                                        }).finally(function () {
                                            if (dfdStart && dfdStart.state() == 'pending') {
                                                // this is an outgoing renegotiation caused by the second start() call
                                                // to add video to an audio conversation
                                                status == 'Success' ?
                                                    dfdStart.resolve() :
                                                    dfdStart.reject(error || event.reason);
                                            }
                                            if (dfdOutRenego.state() == 'pending')
                                                dfdOutRenego.resolve();
                                        });
                                    }
                                    else {
                                        if (status == 'Success') {
                                            // the renegotiation may be in response to remote participant's hold/resume request
                                            if (!isConferencing()) {
                                                if (remoteHoldState == RemoteHoldState.HoldAnswered)
                                                    remoteHoldState = RemoteHoldState.HoldCompleted;
                                                else if (remoteHoldState == RemoteHoldState.ResumeAnswered)
                                                    remoteHoldState = RemoteHoldState.ResumeCompleted;
                                            }
                                            promise = Promise.resolve(null, 'sync').then(function () {
                                                return mediaSession.completeNegotiationAsync();
                                            }).then(function (result) {
                                                if (!isConferencing()) {
                                                    if (remoteHoldState == RemoteHoldState.HoldCompleted &&
                                                        result.activeModalities.audio == 'inactive') {
                                                        participants(0)[Internal.sInternal].audioOnHold(true);
                                                        participants(0).video.channels(0)[Internal.sInternal].isVideoOn(false);
                                                    }
                                                    else if (remoteHoldState == RemoteHoldState.ResumeCompleted) {
                                                        participants(0)[Internal.sInternal].audioOnHold(false);
                                                    }
                                                    remoteHoldState = RemoteHoldState.Unknown;
                                                }
                                                setVideoDirectionFromNegoResult(result);
                                                videoState(videoDirection() == '' ?
                                                    Internal.Modality.State.Disconnected :
                                                    Internal.Modality.State.Connected);
                                            });
                                        }
                                        else {
                                            promise = Promise.resolve(null, 'sync').then(function () { return mediaSession.rejectNegotiationAsync('signaling', false); });
                                        }
                                        promise.catch(log).finally(function () { return isPendingInRenego = false; });
                                    }
                                }
                            },
                            'audioVideo updated': function (status, resource, event) {
                                if (rAVInvitation && rAVInvitation.hasLink('audioVideo') &&
                                    resource.href == rAVInvitation.link('audioVideo').href) {
                                    // Initially in an outbound call rAVInvitation is assigned an empty resource constructed 
                                    // from the POST invitation response. 'audioVideo updated' may arrive before 
                                    // 'audioVideoInvitation started', so to avoid an exception about the missing audioVideo link
                                    // we need to check for 'audioVideo' link above. Skipping the event processing is not a
                                    // a problem, because it is a 'Connecting' event, which we need not handle. 
                                    tm && tm.record(Web.TelemetryEvent.Call, {
                                        action: 'audioVideoUpdated',
                                        type: isConferencing() ? 'conf' : 'p2p',
                                        modalities: activeModalities.video ? 'av' : 'audio',
                                        mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                        state: resource.get('state', void 0),
                                        status: status,
                                        reason: event.reason,
                                        callId: callId
                                    });
                                    if (resource.get('state') == 'Disconnected') {
                                        postMediaDiagnosticsData(event.reason);
                                        if (rAVInvitation.get('state') == 'Connected') {
                                            // This is our chance to clean up the established call that is terminated by
                                            // the remote party. The local party terminates the established call via modality.stop()
                                            // and hang-ups by either party during call setup are processed by audioVideoInvitation
                                            // started/completed event handlers.
                                            cleanup();
                                            // setting this modality state to disconnected will cause its removal from
                                            // the conversation
                                            state(Internal.Modality.State.Disconnected);
                                        }
                                    }
                                    else if (resource.get('state') == 'Connected' &&
                                        event.reason && event.reason.subcode == 'SessionSwitched' &&
                                        resource.link('audioVideoSession').href in avSessions) {
                                        // this is the escalation confirmation, i.e. this AV session replaced the
                                        // original P2P AV session
                                        escalated.fire('success');
                                        escalationState(0 /* None */);
                                    }
                                }
                            },
                            // participantAudio/Video added/deleted events for a localParticipant are used to
                            // track active modalities of this client
                            'participantAudio added': onParticipantAudio,
                            'participantAudio updated': onParticipantAudio,
                            'participantAudio deleted': onParticipantAudio,
                            'participantVideo added': onParticipantVideo,
                            'participantVideo updated': onParticipantVideo,
                            'participantVideo deleted': onParticipantVideo,
                            'escalateAudio deleted': function (status, resource, event) {
                                if (event.target.href == escalateAudioVideoUri)
                                    escalateAudioVideoUri = null;
                            },
                            // these events are fired in the later phase of the escalation when the setup of our inactive AV call
                            // to a conference is finished and we may activate (resume) it.
                            'resumeAudio added': onResumeAudioVideoAdded,
                            'resumeAudioVideo added': onResumeAudioVideoAdded,
                            'resumeAudio deleted': onResumeAudioVideoDeleted,
                            'resumeAudioVideo deleted': onResumeAudioVideoDeleted,
                            'dominantSpeakers added': onDominantSpeakers,
                            'dominantSpeakers updated': onDominantSpeakers,
                            'currentVideo added': onCurrentVideo,
                            'currentVideo updated': onCurrentVideo
                        };
                        // returns a participant object from a participants collection
                        function getParticipant(href) {
                            var participant = find(participants(), function (p) { return p[Internal.sHref] == href; });
                            if (participant)
                                return participant;
                            // shortcut for a 1:1 conversation with a participant added to the conversation beforehand
                            //
                            // The check for participant size is needed because if the AV conversation is started not with the
                            // participant from a person model but using the sip uri as a parameter, we would have to rely on
                            // "participant added" event for the remote guy to become a member of participants collection.
                            // If miraculously this event arrives after "participantAudio/Video added" we would have an empty
                            // participants collection here.
                            if (!isConferencing() && participants.size() == 1)
                                return participants(0);
                            // "participantAudio/Video added" event arrives right after "participant added" event. If the
                            // participant was added to the conversation's participant collection using its contact href,
                            // the "participant added" event handler is doing another server lookup to match that contact href
                            // to the participant href. So we can't find that participant here either and we need to do the
                            // same lookup.
                            return ucwa.send('GET', href).then(function (r) {
                                return getParticipant(r.link('contact').href);
                            });
                        }
                        // event handler for "participantAudio added/updated/deleted in participant|localParticipant" events
                        //  - tracks session audio state (on/off) and participant audio state.
                        function onParticipantAudio(status, resource, event) {
                            var scope = event['in'];
                            if (rConversation && event.sender.href == rConversation.href && scope) {
                                if (scope.rel == 'localParticipant') {
                                    switch (event.type) {
                                        case 'added': // signal for the initial AV session
                                        case 'updated':
                                            if (isConferencing() && escalationState() != 1 /* From */) {
                                                selfParticipant[Internal.sInternal].setMediaSourceId(event);
                                                if (resource.has('audioDirection')) {
                                                }
                                                if (resource.has('audioMuted')) {
                                                    var mute_1 = resource.get('audioMuted');
                                                    muted.get().then(function () {
                                                        // Remote requests mute after requesting unmute
                                                        if (mute_1 && muted() && isUnmuteRequested()) {
                                                            isUnmuteRequested(false);
                                                            // Undo force mute now that conference mute is true
                                                            hardMuteUnmute(false);
                                                        }
                                                        // Mute requested by remote
                                                        if (mute_1 && !muted()) {
                                                            muted._set(mute_1);
                                                        }
                                                        // Unmute requested by remote
                                                        if (!mute_1 && muted()) {
                                                            isUnmuteRequested(true);
                                                            // Force mute self since we're automatically unmuted according to ucwa resource
                                                            hardMuteUnmute(true);
                                                        }
                                                        // to reflect change at api layer must do a get() explicitly
                                                        // harmless since this triggers a get which always returns muted()
                                                        selfParticipant.audio.isMuted.get();
                                                    });
                                                }
                                                // check participants that are already in the conference - we need their msis
                                                // because we won't receive "participantAudio added" events for them.
                                                for (var _i = 0, _a = participants(); _i < _a.length; _i++) {
                                                    var p = _a[_i];
                                                    if (p[Internal.sInternal].audioSourceId() == -1)
                                                        getAudioSourceId(p);
                                                }
                                            }
                                            activeModalities.audio = true;
                                            break;
                                        case 'deleted':
                                            activeModalities.audio = false;
                                            break;
                                        default:
                                            assert(false, 'unexpected event type');
                                    }
                                }
                                else if (scope.rel == 'participant') {
                                    Task.wait(getParticipant(scope.href)).then(function (participant) {
                                        switch (event.type) {
                                            case 'added':
                                            case 'updated':
                                                if (isConferencing()) {
                                                    participant[Internal.sInternal].setMediaSourceId(event);
                                                    // In conference mode, the indication of a remote
                                                    // participant hold/resume or mute/unmute is
                                                    // "participantAudio added/updated" event. We need to
                                                    // reload "participantAudio" resource and set the
                                                    // properties accordingly
                                                    ucwa.send('GET', event.target.href).then(function (r) {
                                                        if (r.has('audioDirection')) {
                                                            participant[Internal.sInternal].audioOnHold(r.get('audioDirection') ==
                                                                AudioVideoDirection.Inactive);
                                                        }
                                                        if (r.has('audioMuted'))
                                                            participant[Internal.sInternal].audioMuted(r.get('audioMuted'));
                                                        if (r.has('audioSourceId'))
                                                            participant[Internal.sInternal].audioSourceId(+r.get('audioSourceId'));
                                                    });
                                                }
                                                participant[Internal.sInternal].audioState(Internal.Modality.State.Connected);
                                                break;
                                            case 'deleted':
                                                participant[Internal.sInternal].audioState(Internal.Modality.State.Disconnected);
                                                break;
                                            default:
                                                assert(false, 'unexpected event type');
                                        }
                                    });
                                }
                            }
                        }
                        // event handler for "participantVideo added/updated/deleted in participant|localParticipant" events
                        //  - tracks session video state (on/off), participant video state and shows/removes video
                        //    when video modality is activated/deactivated.
                        function onParticipantVideo(status, resource, event) {
                            var scope = event['in'];
                            if (rConversation && event.sender.href == rConversation.href && scope) {
                                if (scope.rel == 'localParticipant') {
                                    switch (event.type) {
                                        case 'added':
                                        case 'updated':
                                            activeModalities.video = true;
                                            // In p2p case, we determine videoState is connected based on renegotiation succeeding
                                            if (isConferencing()) {
                                                selfParticipant[Internal.sInternal].setMediaSourceId(event);
                                                var _loop_5 = function (p) {
                                                    getAudioSourceId(p).then(function (id) {
                                                        if (id != -1) {
                                                            if (!p.video.channels(0)[Internal.sInternal].isVideoOn()) {
                                                                getAudioVideoHref(p, 'Video').then(function (href) {
                                                                    href && ucwa.send('GET', href).then(function (rVideo) {
                                                                        updateVideoState(p, { resource: rVideo }, false);
                                                                    });
                                                                });
                                                            }
                                                        }
                                                    });
                                                };
                                                // check participants that are already in the conference - we need their msis
                                                // because we won't receive "participantVideo added" events for them. We also
                                                // need to turn on isVideoOn if the participant is already streaming video
                                                for (var _i = 0, _a = participants(); _i < _a.length; _i++) {
                                                    var p = _a[_i];
                                                    _loop_5(p);
                                                }
                                            }
                                            break;
                                        case 'deleted':
                                            removeVideo(selfVideoStream);
                                            activeModalities.video = false;
                                            if (isConferencing())
                                                selfParticipant[Internal.sInternal].setMediaSourceId(event);
                                            selfParticipant.video.channels(0)[Internal.sInternal].isVideoOn(false);
                                            selfParticipant[Internal.sInternal].setVideoStarted(false);
                                            videoState(Internal.Modality.State.Disconnected);
                                            selfParticipant[Internal.sInternal].videoState(Internal.Modality.State.Disconnected);
                                            break;
                                        default:
                                            assert(false, 'unexpected event type');
                                    }
                                }
                                else if (scope.rel == 'participant') {
                                    Task.wait(getParticipant(scope.href)).then(function (participant) {
                                        switch (event.type) {
                                            case 'added':
                                            case 'updated':
                                                if (isConferencing()) {
                                                    participant[Internal.sInternal].setMediaSourceId(event);
                                                    updateVideoState(participant, event).then(function () {
                                                        if (onHold() && !participant.video.channels(0).isVideoOn())
                                                            removeParticipantWithVideoToRender(participant);
                                                    });
                                                }
                                                else {
                                                    participant[Internal.sInternal].setVideoStream(mainVideoStream);
                                                    participant[Internal.sInternal].videoState(Internal.Modality.State.Connected);
                                                }
                                                // updateVideoState(participant, event); TODO: see VSO 638309                        
                                                break;
                                            case 'deleted':
                                                if (isConferencing()) {
                                                    participant[Internal.sInternal].setMediaSourceId(event);
                                                    removeParticipantVideo(participant);
                                                }
                                                else {
                                                    participant[Internal.sInternal].setVideoStream(null);
                                                }
                                                // if participant video is deleted not because we stopped video
                                                // subscription explicitly (via isStarted(false)) but because 
                                                // participant left the AV call then we need to reset isStarted.
                                                participant.video.channels(0)[Internal.sInternal].isVideoOn(false);
                                                participant[Internal.sInternal].setVideoStarted(false);
                                                participant[Internal.sInternal].videoState(Internal.Modality.State.Disconnected);
                                                break;
                                            default:
                                                assert(false, 'unexpected event type');
                                        }
                                    });
                                }
                            }
                        }
                        // event handler for "participant deleted" events
                        // - if video is on, a 'participant deleted' event should be handled
                        //   to stop participant video
                        function onParticipantDeleted(event) {
                            var target = event.target;
                            if (rConversation && event.sender.href == rConversation.href &&
                                target.rel == 'participant' && event.type == 'deleted' && !event['in']) {
                                return Task.wait(getParticipant(target.href)).then(function (participant) {
                                    if (isConferencing()) {
                                        participant[Internal.sInternal].setMediaSourceId(event);
                                        participant.video.channels(0)[Internal.sInternal].isVideoOn(false);
                                        participant[Internal.sInternal].setVideoStarted(false);
                                        participant[Internal.sInternal].videoState(Internal.Modality.State.Disconnected);
                                        return removeParticipantVideo(participant);
                                    }
                                    else {
                                        participant[Internal.sInternal].setVideoStream(null);
                                    }
                                });
                            }
                        }
                        // get Href of participantAudio/participantVideo
                        // m is 'Audio' or 'Video'
                        function getAudioVideoHref(p, m) {
                            // 'audioLink' or 'videoLink'
                            var mLink = m.toLowerCase() + 'Link';
                            if (p[Internal.sInternal][mLink])
                                return Promise.resolve(p[Internal.sInternal][mLink]);
                            if (p[Internal.sHref]) {
                                return ucwa.send('GET', p[Internal.sHref]).then(function (res) {
                                    // participantAudio or participantVideo
                                    var pMod = 'participant' + m;
                                    if (res.hasLink(pMod))
                                        return res.link(pMod).href;
                                });
                            }
                            else {
                                tm && tm.record(Web.TelemetryEvent.Call, {
                                    action: 'getAudioVideoHref',
                                    type: isConferencing() ? 'conf' : 'p2p',
                                    modalities: activeModalities.video ? 'av' : 'audio',
                                    mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                    state: state(),
                                    result: 'failed',
                                    reason: 'no href for participant',
                                    callId: callId
                                });
                                return Promise.resolve();
                            }
                        }
                        function getAudioSourceId(p) {
                            var dfd = p[Internal.sInternal].audioSourceId() != -1 ? Promise.resolve() : getAudioVideoHref(p, 'Audio').then(function (href) {
                                return href && ucwa.send('GET', href);
                            }).then(function (res) {
                                return res && res.has('audioSourceId') && p[Internal.sInternal].audioSourceId.set(+res.get('audioSourceId'));
                            });
                            return dfd.then(function () { return p[Internal.sInternal].audioSourceId(); });
                        }
                        /**
                         * Do a GET on participantVideo and connect the video state if the
                         * resource has active videoDirection.
                         */
                        function updateVideoState(participant, event, isSelf) {
                            if (isSelf === void 0) { isSelf = false; }
                            var resource = event.resource;
                            var target = event.target;
                            return Task.run(function () {
                                return resource && resource.has('videoDirection') ? resource : target && ucwa.send('GET', target.href);
                            }).then(function (res) {
                                var rVideoSourceId, rVideoDirection;
                                if (res && res.has('videoSourceId')) {
                                    rVideoSourceId = +res.get('videoSourceId');
                                    participant[Internal.sInternal].videoSourceId(rVideoSourceId);
                                }
                                if (res && res.has('videoDirection')) {
                                    rVideoDirection = res.get('videoDirection');
                                    participant.video.channels(0)[Internal.sInternal].isVideoOn(rVideoDirection === AudioVideoDirection.SendOnly
                                        || rVideoDirection === AudioVideoDirection.SendReceive);
                                    if (!(rVideoDirection == AudioVideoDirection.Inactive || rVideoDirection == AudioVideoDirection.Unknown)) {
                                        if (isSelf)
                                            videoState(Internal.Modality.State.Connected); // TODO: this code path is never triggered
                                        participant[Internal.sInternal].videoState(Internal.Modality.State.Connected);
                                        participant[Internal.sInternal].audioState(Internal.Modality.State.Connected);
                                    }
                                }
                                log('WebRtcAudioVideoSession(' + callId + '):updateVideoState: ', participant.displayName(), rVideoSourceId, rVideoDirection);
                            });
                        }
                        // event handler for 'resumeAudio/resumeAudioVideo added' event
                        //   - activates the inactive conference session created during escalation
                        function onResumeAudioVideoAdded(status, resource, event) {
                            var scope = event['in'], href;
                            if (scope && scope.rel == 'audioVideoSession' && scope.href in avSessions) {
                                href = scope.href;
                                // Currently UCWA returns the 'renegotiations' link of the audioVideoSession as resumeAudio uri,
                                // i.e. avSessions[event.in.href].resource.link('renegotiations').href == event.target.href,
                                // but we cache it separately just in case
                                avSessions[href].resumeAudioVideoUri = event.target.href;
                                Task.run(function () {
                                    if (!avSessions[href].renegotiated) {
                                        return ucwa.wait({
                                            type: 'completed',
                                            target: { rel: 'audioVideoRenegotiation' },
                                            resource: function (r) {
                                                // r.get('operationId') in outAvRenegoOpIds;
                                                return r.get('direction') == 'Outgoing' && r.link('audioVideoSession').href in avSessions;
                                            }
                                        });
                                    }
                                }).then(resumeAudioVideo).catch(log);
                            }
                        }
                        function onResumeAudioVideoDeleted(status, resource, event) {
                            var scope = event['in'];
                            if (scope && scope.rel == 'audioVideoSession' && scope.href in avSessions &&
                                event.target.href == avSessions[scope.href].resumeAudioVideoUri) {
                                delete avSessions[scope.href].resumeAudioVideoUri;
                            }
                        }
                        // event handler for 'current video' event - sets the participant property of the 
                        // videoService.activeSpeaker thus allowing matching of the video in the activeSpeaker channel 
                        // with the participant info (name specifically) 
                        function onCurrentVideo(status, resource, event) {
                            if (!Web.Media.isWebRtc())
                                return;
                            var scope = event['in'];
                            if (scope && rConversation && event.sender.href == rConversation.href &&
                                scope.href == rConversation.link('audioVideo').href) {
                                var cp = void 0;
                                var aspeaker = conversation.videoService.activeSpeaker;
                                var videoId = resource.get('currentVideoId');
                                if (selfParticipant[Internal.sInternal].videoSourceId() == videoId)
                                    cp = selfParticipant;
                                else {
                                    for (var _i = 0, _a = participants(); _i < _a.length; _i++) {
                                        var p = _a[_i];
                                        if (p[Internal.sInternal].videoSourceId() == videoId) {
                                            cp = p;
                                            aspeaker.channel[Internal.sInternal].isVideoOn(true);
                                            break;
                                        }
                                    }
                                }
                                aspeaker[Internal.sInternal].participant(cp);
                            }
                        }
                        // event handler for 'dominantSpeakers' event - manages isSpeaking property of the former and the
                        // current dominant speaker participant
                        function onDominantSpeakers(status, resource, event) {
                            if (!Web.Media.isWebRtc())
                                return;
                            var scope = event['in'];
                            if (scope && rConversation && event.sender.href == rConversation.href &&
                                scope.href == rConversation.link('audioVideo').href) {
                                var dsp = void 0;
                                var audioId = resource.get('dominantSpeakerId');
                                if (selfParticipant[Internal.sInternal].audioSourceId() == audioId)
                                    dsp = selfParticipant;
                                else {
                                    for (var _i = 0, _a = participants(); _i < _a.length; _i++) {
                                        var p = _a[_i];
                                        if (p[Internal.sInternal].audioSourceId() == audioId) {
                                            dsp = p;
                                            break;
                                        }
                                    }
                                }
                                dominantSpeaker && dominantSpeaker[Internal.sInternal].isSpeaking(false);
                                if (dsp) {
                                    dominantSpeaker = dsp;
                                    dominantSpeaker[Internal.sInternal].isSpeaking(true);
                                }
                            }
                        }
                        //#endregion server events
                        //#region sendOffer
                        /**
                        * Composes an SDP offer message from the offer generated by the media agent and
                        * sends it to the server to start an AV session.
                        *
                        * The returned promise is resolved only when we get a reply to the post
                        * and audioVideoInvitation completed event
                        */
                        function sendOffer(offers) {
                            assert(offers.length > 0);
                            // construct content that contains all offers given by the media plugin
                            function createOfferOptions(context, contextType, isAddingAVToExistingConv) {
                                var boundary = '9BCE36B8-2C70-44CA-AAA6-D3D332ADBD3F', mediaOffer, options = { nobatch: true };
                                if (isConferencing()) {
                                    if (escalateAudioVideoUri) {
                                        mediaOffer = Internal.multipartSDP(offers, boundary);
                                        options = {
                                            headers: {
                                                'Content-Type': 'multipart/alternative;boundary=' + boundary +
                                                    ';type="application/sdp"',
                                                'Content-Length': '' + mediaOffer.length
                                            },
                                            query: {
                                                operationId: operationId,
                                                sessionContext: sessionContext
                                            },
                                            data: mediaOffer,
                                            nobatch: true
                                        };
                                    }
                                    else {
                                        options.data = Internal.multipartJsonAndSDP({
                                            offers: offers,
                                            boundary: boundary,
                                            operationId: operationId,
                                            sessionContext: sessionContext,
                                            threadId: conversation.threadId(),
                                            context: context,
                                            contextType: contextType
                                        });
                                        options.headers = {
                                            'Content-Type': 'multipart/related;boundary=' + boundary +
                                                ';type="application/vnd.microsoft.com.ucwa+json"'
                                        };
                                    }
                                }
                                else {
                                    // P2P mode
                                    options.data = Internal.multipartJsonAndSDP({
                                        to: isAddingAVToExistingConv ? void 0 : remoteUri,
                                        offers: offers,
                                        boundary: boundary,
                                        subject: conversation.topic(),
                                        importance: conversation.priority(),
                                        operationId: operationId,
                                        sessionContext: sessionContext,
                                        threadId: conversation.threadId(),
                                        context: context,
                                        contextType: contextType
                                    });
                                    options.headers = {
                                        'Content-Type': 'multipart/related;boundary=' + boundary +
                                            ';type="application/vnd.microsoft.com.ucwa+json"'
                                    };
                                }
                                if (context !== void 0)
                                    extend(options.headers, { 'X-MS-RequiresMinResourceVersion': 2 });
                                return options;
                            }
                            return async(getStartAudioVideoLink).call(null).then(function (link) {
                                var options = createOfferOptions(link.revision >= 2 ? context : void 0, contextType, link.rel == 'addAudioVideo'), dfdPost, dfdCompleted;
                                dfdPost = ucwa.send('POST', link.href, options).then(function (r) {
                                    // POST to startAudioVideo/addAudioVideo returns an empty response with an AV invitation
                                    // URI in the Location header. The UCWA stack constructs and returns an empty resource
                                    // with href set to that URI.
                                    if (!rAVInvitation)
                                        rAVInvitation = r;
                                }).catch(function (err) {
                                    log('WebRtcAudioVideoSession(' + callId + '):sendOffer: startAudioVideo failed', err);
                                    // If threadId is too long, UCWA will reject it with a 400 'badRequest.' 
                                    // In this case, reset the threadId and resend the request.
                                    if (conversation.isThreadIdRejectedError(err)) {
                                        conversation.resetThreadId();
                                        options = createOfferOptions(link.revision >= 2 ? context : void 0, contextType, link.rel == 'addAudioVideo');
                                        return ucwa.send('POST', link.href, options);
                                    }
                                    throw err;
                                });
                                // wait for the "audioVideoInvitation completed" event that corresponds to the given conversation
                                dfdCompleted = ucwa.wait({
                                    type: 'completed',
                                    target: { rel: 'audioVideoInvitation' },
                                    resource: {
                                        direction: 'Outgoing',
                                        threadId: conversation.threadId(),
                                        operationId: operationId,
                                        sessionContext: sessionContext
                                    }
                                }).then(function (event) {
                                    log('WebRtcAudioVideoSession(' + callId + '):sendOffer: audioVideoInvitation completed', event);
                                    tm && tm.record(Web.TelemetryEvent.Call, {
                                        action: 'audioVideoInvitationCompleted',
                                        type: isConferencing() ? 'conf' : 'p2p',
                                        modalities: activeModalities.video ? 'av' : 'audio',
                                        mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                        state: state(),
                                        status: event.status,
                                        reason: event.reason,
                                        direction: 'Outgoing',
                                        callId: callId
                                    });
                                    if (event.status == 'Failure') {
                                        // if remote SIP uri is invalid we won't receive "audioVideoInvitation started" event,
                                        // thus we won't have a full rAVInvitation resource cached. It will be either undefined or
                                        // just an empty resource with an href returned by a response to startAudioVideo POST (if
                                        // that response arrived before this event). So we cache the invitation resource here,
                                        // since it may be used by other event handlers.
                                        rAVInvitation = event.resource;
                                        rAVInvitation['eventRecv'] = true;
                                        throw Internal.EInvitationFailed(event.reason);
                                    }
                                    else {
                                        return promiseFinalAnswer.then(function () {
                                            return mediaSession.completeNegotiationAsync();
                                        }).catch(function (err) {
                                            log('Error setting final answer: ', err);
                                            return Promise.resolve(null, 'sync').then(function () {
                                                return mediaSession.rejectNegotiationAsync('local', false);
                                            }).finally(function () {
                                                throw err;
                                            });
                                        }).then(setVideoDirectionFromNegoResult);
                                    }
                                });
                                return Task.waitAll([dfdPost, dfdCompleted]);
                            });
                        }
                        //#endregion
                        //#region sendRenegotiationOffer
                        /**
                         * Composes an SDP offer from the OFFER_READY media plugin event data and
                         * sends it to the server to renegotiate the AV session.
                         */
                        function sendRenegotiationOffer(sdp, url) {
                            log('Renegotiation SDP offer:\n', sdp);
                            // cache operation id
                            var operationId = guid();
                            outAvRenegoOpIds[operationId] = "";
                            return ucwa.send('POST', url, {
                                headers: { 'Content-Type': 'application/sdp' },
                                query: { operationId: operationId },
                                data: sdp,
                                nobatch: true
                            });
                        }
                        //#endregion
                        //#region resumeAudioVideo
                        /**
                         * Activates (resumes) the AV conference call created in inactive state
                         * when a p2p call is escalated to a conference.
                         */
                        function resumeAudioVideo() {
                            var audioConfig = onHold() ? 4 /* NO_ACTIVE_MEDIA */ : 3 /* BOTH */;
                            // can't configure inactive when resuming. If it was inactive before escalation, just do recvonly.
                            var pevc = preEscalationVideoConfig() == 4 /* NO_ACTIVE_MEDIA */ ?
                                2 /* RECEIVE */ : preEscalationVideoConfig();
                            mainVideoConfig = activeModalities.video ?
                                (onHold() ? 4 /* NO_ACTIVE_MEDIA */ :
                                    (pevc != null ? pevc : 2 /* RECEIVE */)) :
                                0 /* NOT_PRESENT */;
                            return mediaSession.configureModalitiesAsync(stripEmptyModalities({
                                audio: Internal.MediaEnum.enumcastMediaConfig(audioConfig),
                                video: Internal.MediaEnum.enumcastMediaConfig(mainVideoConfig)
                            }));
                        }
                        //#endregion
                        //#region setRenegotiationOffer
                        function setRenegotiationOffer(sdp) {
                            var videoConfig = determineVideoConfig(sdp);
                            log('Incoming SDP offer:\n' + sdp);
                            return mediaSession.processOfferAsync({
                                blob: sdp
                            }).then(function (modalities) {
                                // Don't trust the modalities.video returned by 'processOfferAsync' because
                                // it can cause us to start streaming self or stop remote
                                // NB: in remote-triggered hold scenario, video config doesn't seem to matter; if
                                //     audio is inactive, video will also be inactive in answer to remote 
                                return mediaSession.configureModalitiesAsync(stripEmptyModalities(!modalities.video ?
                                    modalities : {
                                    audio: modalities.audio,
                                    video: Internal.MediaEnum.enumcastMediaConfig(videoConfig)
                                }));
                            }).then(function () {
                                return mediaSession.createAnswerAsync(false);
                            }).then(function (answer) {
                                if (!isConferencing()) {
                                    if (remoteHoldState == RemoteHoldState.HoldOffered)
                                        remoteHoldState = RemoteHoldState.HoldAnswered;
                                    else if (remoteHoldState == RemoteHoldState.ResumeOffered)
                                        remoteHoldState = RemoteHoldState.ResumeAnswered;
                                }
                                return ucwa.send('POST', rAVRenegotiation.link('answer').href, {
                                    headers: { 'Content-Type': 'application/sdp' },
                                    data: answer.blob,
                                    nobatch: true
                                });
                            });
                        }
                        //#endregion
                        //#region determineVideoConfig
                        /**
                         * Determines the correct video direction to configure for negotiation based
                         * on mainVideoConfig, videoState, and the sdp offer. This is necessary because
                         * processOfferAsync only takes into account the remote offer, not our client's
                         * video preferences. Without overriding the logic of processOfferAsync it is
                         * easy to accidentally start our video against the user's will.
                         */
                        function determineVideoConfig(sdp) {
                            var videoConfig;
                            if (onHold() || !/\bm=video\b/gmi.test(sdp)) {
                                // call onHold or no video in offer
                                videoConfig = 4 /* NO_ACTIVE_MEDIA */;
                            }
                            else if ((videoState() == Internal.Modality.State.Connected ||
                                videoState() == Internal.Modality.State.Connecting) &&
                                (mainVideoConfig == 1 /* SEND */ ||
                                    mainVideoConfig == 3 /* BOTH */)) {
                                // remote participant starts/stops video: isStarted(true|false):
                                // videoConfig will default to RECEIVE plus existing config
                                // about whether to send video or not. In other words, if self
                                // is already sending video, then videoConfig will be BOTH;
                                // otherwise it will be RECEIVE. Subsequent 'SetOffer' call will
                                // determine the proper value in ANSWER based on this videoConfig
                                // setting and the actual OFFER from the remote participant.
                                videoConfig = 3 /* BOTH */;
                            }
                            else {
                                // adding video to an audio conversation (video was not Connected),
                                // we auto-accept incoming video only. The local participant can turn
                                // their video on later via video.channels(0).isStarted(true).
                                videoConfig = settings && settings.supportsVideo == false ?
                                    0 /* NOT_PRESENT */ :
                                    2 /* RECEIVE */;
                            }
                            return videoConfig;
                        }
                        //#endregion
                        //#region setProvisionalAnswer
                        /**
                         * Sets the provisional SDP answer from the remote party
                         */
                        function setProvisionalAnswer(mediaAnswer) {
                            var sdp = DataUri(mediaAnswer).data;
                            log('Provisional answer from the remote party:\n' + sdp);
                            // convert native ES6 promise to our promise
                            return Task.run(function () { return mediaSession.processAnswerAsync({
                                blob: sdp
                            }, true); });
                        }
                        //#endregion
                        //#region setFinalAnswer
                        /**
                         * Sets the final SDP answer from the remote party
                         */
                        function setFinalAnswer(mediaAnswer) {
                            var sdp = DataUri(mediaAnswer).data;
                            log('Final answer from the remote party:\n' + sdp);
                            // convert native ES6 promise to our promise
                            return Task.run(function () { return mediaSession.processAnswerAsync({
                                blob: sdp
                            }, false); });
                        }
                        //#endregion
                        //#region getStartAudioVideoUri
                        /**
                         * The first SDP offer is sent to the link given by this function.
                         */
                        function getStartAudioVideoLink() {
                            // if the AV modality is the 1-st modality in the conversation,
                            // send a request to the global startAudioVideo link
                            if (!rConversation) {
                                var link = ucwa.get(ucwa.app.relatedHref('communication')).link('startAudioVideo');
                                link.rel = 'startAudioVideo';
                                return link;
                            }
                            // if this is an escalation from P2P to a conference, send the
                            // request to the escalation link
                            if (escalateAudioVideoUri)
                                return ucwa.get(escalateAudioVideoUri); // TODO: .link('self')?
                            // if the AV modality gets added to an existing conversation,
                            // send the request to its addAudioVideo link
                            return ucwa.send('GET', rConversation.link('audioVideo').href).then(function (rAV) {
                                var link = rAV.link('addAudioVideo');
                                link.rel = 'addAudioVideo';
                                return link;
                            });
                        }
                        //#endregion
                        setHiddenProperty(self, Internal.sInternal, {
                            callId: callId,
                            onParticipantDeleted: onParticipantDeleted
                        });
                        log('WebRtcAudioVideoSession(' + callId + ') created');
                        return self;
                    }
                    return WebRtcAudioVideoSession;
                }());
                Internal.WebRtcAudioVideoSession = WebRtcAudioVideoSession;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="AudioVideoSession.ts" />
/// <reference path="AudioVideoInvitation.ts" />
/// <reference path="WebRtcAudioVideoSession.ts" />
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_6) {
            var Internal;
            (function (Internal) {
                'use strict';
                var find = Web.Utils.find;
                var check = Web.Utils.check;
                var async = Web.Utils.async;
                var assert = Web.Utils.assert;
                var extend = Web.Utils.extend;
                var random = Web.Utils.random;
                var isArray = Web.Utils.isArray;
                var contains = Web.Utils.contains;
                var isPrimitive = Web.Utils.isPrimitive;
                var setHiddenProperty = Web.Utils.setHiddenProperty;
                var Task = Web.Utils.Task;
                var Model = Web.Utils.Model;
                var Command = Web.Utils.Command;
                var Promise = Web.Utils.Promise;
                var Property = Web.Utils.Property;
                var Exception = Web.Utils.Exception;
                var EInvalidArgument = Web.Utils.EInvalidArgument;
                var log = Web.Media.log;
                var watch = Web.Media.watch;
                /**
                 * AudioVideo part of a multi-modal conversation.
                 *
                 */
                var AudioVideoModality = (function () {
                    //#endregion
                    function AudioVideoModality(options) {
                        var self = Model(), ucwa = options.ucwa, participants = options.participants, guestName = options.guestName, selfParticipant = options.selfParticipant, settings = options.settings, 
                        // prod online scenario: users don't have me resource so we dont get user sipuri
                        // mediastack requires this parameter, and an empty string is sufficient for the above case.
                        localUri = options.me.id() || '', // SIP URI of the signed-in user
                        mediaPlugin = options.mediaPlugin, // MediaPlugin
                        devices = options.devices, // DevicesManager
                        tm = options.tm, conversation = options.conversation, AVS = Web.Media.useBrowserMedia() ? Internal.WebRtcAudioVideoSession : Internal.AudioVideoSession;
                        var rInvitation = options.rInvitation, // Invitation resource
                        rConversation = options.rConversation, // conversation resource
                        remoteUri, // SIP URI of the remote party in a P2P conversation
                        avs, // the active AudioVideoSession in this conversation
                        avsOld, // the old AudioVideoSession that might not have been cleaned up
                        avsEsc, // AudioVideoSession created when a P2P conversation is escalated to a
                        // multi-party conference
                        // a unique id of this modality - handy for debugging this modality's
                        // server event subscription
                        thisModalityId = random(), sStartingAV = {}, // serves as state.reason when state=Notified
                        isAVInvitation, isMeetingInvitation, isAudioMeetingInvitation, isVideoMeetingInvitation, invitation, rAVInvitation, dfdStop;
                        initInvitationState();
                        var state = Property({
                            value: invitation || isMeetingInvitation ?
                                Internal.Modality.State.Notified :
                                Internal.Modality.State.Disconnected
                        }), audioState = Property({
                            value: invitation || isAudioMeetingInvitation ?
                                Internal.Modality.State.Notified :
                                Internal.Modality.State.Disconnected
                        }), videoState = Property({
                            value: invitation && invitation.hasVideo() || isVideoMeetingInvitation ?
                                Internal.Modality.State.Notified :
                                Internal.Modality.State.Disconnected
                        });
                        assert(conversation);
                        // remove rInvitation if we are ignoring the AV part of the meeting invitation
                        if (!invitation && !isMeetingInvitation)
                            rInvitation = null;
                        options = null;
                        //#region public properties
                        var dfdMute, dfdUnmute;
                        // mutes/unmutes the audio channel or returns the mute status
                        var muted = Property({
                            value: false,
                            get: function () { return avs ? avs.muted.get() : muted(); },
                            set: function (val) {
                                // serialize and debounce mute/unmute calls
                                var dfdRet;
                                if (val) {
                                    dfdRet = dfdMute;
                                    if (!dfdRet) {
                                        var promise = dfdUnmute ? dfdUnmute : Promise.resolve();
                                        dfdRet = dfdMute = promise.then(function () { return avs.muted.set(val); }).then(function () { return val; });
                                        dfdMute.finally(function () {
                                            dfdMute = null;
                                        });
                                    }
                                }
                                else {
                                    dfdRet = dfdUnmute;
                                    if (!dfdRet) {
                                        var promise = dfdMute ? dfdMute : Promise.resolve();
                                        dfdRet = dfdUnmute = promise.then(function () { return avs.muted.set(val); }).then(function () { return val; });
                                        dfdUnmute.finally(function () {
                                            dfdUnmute = null;
                                        });
                                    }
                                }
                                tm && tm.monitor(dfdRet, Web.TelemetryEvent.Call, {
                                    action: val ? 'muteAudio' : 'unmuteAudio',
                                    type: isConferencing() ? 'conf' : 'p2p',
                                    modalities: conversation.activeModalities.video() ? 'av' : 'audio',
                                    mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                    callId: avs[Internal.sInternal].callId
                                });
                                return dfdRet;
                            }
                        });
                        var dfdHold, dfdResume;
                        // holds/resumes audio/video or returns the onHold status
                        var onHold = Property({
                            value: false,
                            get: function () { return avs.onHold.get(); },
                            set: function (val) {
                                // serialize and debounce mute/unmute calls
                                var dfdRet;
                                if (val) {
                                    dfdRet = dfdHold;
                                    if (!dfdRet) {
                                        var promise = dfdResume ? dfdResume : Promise.resolve();
                                        dfdRet = dfdHold = promise.then(function () { return avs.onHold.set(val); }).then(function () { return val; });
                                        dfdHold.finally(function () {
                                            dfdHold = null;
                                        });
                                    }
                                }
                                else {
                                    dfdRet = dfdResume;
                                    if (!dfdRet) {
                                        var promise = dfdHold ? dfdHold : Promise.resolve();
                                        dfdRet = dfdResume = promise.then(function () { return avs.onHold.set(val); }).then(function () { return val; });
                                        dfdResume.finally(function () {
                                            dfdResume = null;
                                        });
                                    }
                                }
                                tm && tm.monitor(dfdRet, Web.TelemetryEvent.Call, {
                                    action: val ? 'hold' : 'resume',
                                    type: isConferencing() ? 'conf' : 'p2p',
                                    modalities: conversation.activeModalities.video() ? 'av' : 'audio',
                                    mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                    callId: avs[Internal.sInternal].callId
                                });
                                return dfdRet;
                            }
                        });
                        var connectedAt = Property({ value: null });
                        // TODO: don't create Active Speaker on a WebRTC platform when Electron-based
                        // media agent is used
                        var activeSpeaker = Web.Media.isWebRtc() ? createWebRtcActiveSpeaker() : void 0;
                        var videoMode = Property.readonly((Web.Media.isWebRtc() ? 'ActiveSpeaker' : 'MultiView'));
                        //#endregion
                        function createWebRtcActiveSpeaker() {
                            function video(val) {
                                var promise = val ?
                                    avs.showActiveSpeakerVideo() :
                                    avs.removeActiveSpeakerVideo();
                                return promise.then(function () { return val; });
                            }
                            var enabled = Property();
                            var activeSpeaker = new Internal.WebRtcActiveSpeaker;
                            activeSpeaker.channel.isStarted = Property({
                                value: false,
                                set: Command(video, enabled)
                            });
                            var isConferenced = conversation.state.equalsAny(Internal.Conversation.State.Conferenced, Internal.Conversation.State.Conferencing);
                            var videoSubs = {};
                            var numVideos = Property.numeric(0);
                            function removeVideoIfActiveSpeaker(p) {
                                var asp = activeSpeaker.participant();
                                if (asp && asp[Internal.sHref] == p[Internal.sHref]) {
                                    activeSpeaker.channel.isStarted(false);
                                    activeSpeaker.channel[Internal.sInternal].isVideoOn(false);
                                    activeSpeaker[Internal.sInternal].participant(void 0);
                                }
                            }
                            Property.observe([videoState, isConferenced, numVideos], function (vs, isConf, n) {
                                var val = vs == Internal.Modality.State.Connected && isConf && n > 0;
                                if (!val && activeSpeaker.channel.isStarted())
                                    activeSpeaker.channel.isStarted(false);
                                enabled(val);
                                activeSpeaker.channel[Internal.sInternal].isVideoOn(val);
                            });
                            participants.added(function (p) {
                                videoSubs[p[Internal.sHref]] = p.video.channels(0).isVideoOn.changed(function (newVal, reason, oldVal) {
                                    // skip the initial value - wait for a meaningful value change
                                    if (oldVal !== void 0) {
                                        newVal ? numVideos.inc() : numVideos.dec();
                                        if (!newVal)
                                            removeVideoIfActiveSpeaker(p);
                                    }
                                });
                            });
                            participants.removed(function (p) {
                                var sub = videoSubs[p[Internal.sHref]];
                                sub && sub.dispose();
                                delete videoSubs[p[Internal.sHref]];
                                removeVideoIfActiveSpeaker(p);
                            });
                            return activeSpeaker;
                        }
                        function init() {
                            watch('AudioVideoModality(' + thisModalityId + ')::state:', state);
                            watch('AudioVideoModality(' + thisModalityId + ')::audioState:', audioState);
                            watch('AudioVideoModality(' + thisModalityId + ')::videoState:', videoState);
                            state.when(Internal.Modality.State.Disconnected, function (reason, oldState) {
                                // current property model will fire the event if state value
                                // remains the same but the reason code is different (e.g.,
                                // old reason was "Canceled" and new reason is undefined).
                                // We need to avoid reset again in such cases.
                                if (oldState != Internal.Modality.State.Disconnected)
                                    reset(reason);
                            });
                            // In case conversation becomes disconnected from server without receiving expected events
                            conversation.state.when(Internal.Conversation.State.Disconnected, function (reason) {
                                if (reason && reason.code == 'NotFound')
                                    rConversation = null;
                                // Disconnecting modality triggers a broader reset
                                state(Internal.Modality.State.Disconnected, reason);
                            });
                            // notify the user when audio/video becomes active in a meeting
                            conversation.activeModalities.audio.when(true, remoteAudioVideoAdded);
                            conversation.activeModalities.video.when(true, remoteAudioVideoAdded);
                            // set audio start timestamp
                            audioState.when(Internal.Modality.State.Connected, function () {
                                connectedAt(new Web.Date);
                                log('%c Call connected ' + connectedAt(), 'color:green;font-weight:bold');
                            });
                            // permanent audio/video state subscription to ensure that self-participant's
                            // audio/video state is in fact AVM's audio/video state.
                            // TODO: alternatively selfParticipant's audioState/videoState can be a sourced
                            // property of AVM.audioState / videoState.
                            audioState.changed(selfParticipant[Internal.sInternal].audioState);
                            videoState.changed(selfParticipant[Internal.sInternal].videoState);
                            extend(self, {
                                state: state.asReadOnly(),
                                audioState: audioState.asReadOnly(),
                                videoState: videoState.asReadOnly(),
                                connectedAt: connectedAt.asReadOnly(),
                                videoMode: videoMode,
                                activeSpeaker: activeSpeaker,
                                muted: muted,
                                onHold: onHold,
                                showParticipantVideo: showParticipantVideo,
                                removeParticipantVideo: removeParticipantVideo
                            });
                            if (invitation) {
                                self.from = invitation.from;
                                tm && tm.record(Web.TelemetryEvent.Call, {
                                    action: 'audioVideoInvitation',
                                    type: conversation.isGroupConversation() ? 'conf' : 'p2p',
                                    hasVideo: invitation.hasVideo(),
                                    mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                    pluginVersion: getPluginVersion()
                                });
                            }
                            ucwa.event(onServerEvent);
                            log('AudioVideoModality(' + thisModalityId + ') created');
                        }
                        function reset(reason) {
                            var id = thisModalityId + (avs ? ':' + avs[Internal.sInternal].callId : '');
                            log('AudioVideoModality(' + id + ')::reset', reason);
                            assert(state() == Internal.Modality.State.Disconnected, 'reset should be called with Disconnected state');
                            if (avs) {
                                avs.state.changed.off(state);
                                avs.audioState.changed.off(audioState);
                                avs.videoState.changed.off(videoState);
                                if (avs._onSessionError) {
                                    avs._onSessionError.dispose();
                                    avs._onSessionError = null;
                                }
                                // in case conversation becomes disconnected from server without receiving expected events
                                if (reason && reason.code == 'NotFound')
                                    avs.stop(reason);
                                else {
                                    // this avs might become a zombie
                                    avsOld = avs;
                                }
                            }
                            audioState(Internal.Modality.State.Disconnected, reason);
                            videoState(Internal.Modality.State.Disconnected, reason);
                            // Delayed reset of participant audioState/videoState.
                            // These states of remote participant were previously reset inside
                            // AVS, but they are not supposed to become Disconnected before
                            // AVM.audioState becomes Disconnected, otherwise the user might be
                            // able to call AVM.stop during the cleanup process.
                            if (!isConferencing() && participants(0)) {
                                participants(0)[Internal.sInternal].audioState(Internal.Modality.State.Disconnected);
                                participants(0)[Internal.sInternal].videoState(Internal.Modality.State.Disconnected);
                            }
                            rInvitation = null;
                            initInvitationState();
                            avs && avs.isClean.once(true, function () { avs = null; });
                        }
                        //#region private utils and event handlers
                        function defineAsyncCommand(name, states, method) {
                            var enabled = Property();
                            self[name] = Command(async(method), enabled);
                            state.changed(function (value) {
                                var isEnabled = contains(states, function (s) {
                                    return isArray(s) ?
                                        value == s[0] && state.reason === s[1] :
                                        value == s;
                                });
                                enabled(isEnabled);
                            });
                        }
                        function isConferencing() {
                            var convState = rConversation && rConversation.get('state', '');
                            return convState == 'Conferencing' || convState == 'Conferenced';
                        }
                        /**
                         * Set variables related to the invitation specified when creating this modality.
                         * Should be invoked when rInvitation is set to null to keep state consistent
                         */
                        function initInvitationState() {
                            isAVInvitation = rInvitation && rInvitation.rel == 'audioVideoInvitation';
                            // we are ignoring the AV part of the meeting invitation because we are
                            // using the messaging part of the meeting invitation to accept/decline
                            isMeetingInvitation = rInvitation && rInvitation.rel == 'onlineMeetingInvitation' &&
                                conversation.meeting &&
                                conversation.meeting.state() == 'Notified' &&
                                (conversation.meeting.availableModalities.audio() ||
                                    conversation.meeting.availableModalities.video());
                            isAudioMeetingInvitation = settings && settings.supportsAudio == false ? false :
                                isMeetingInvitation && conversation.meeting.availableModalities.audio();
                            isVideoMeetingInvitation = settings && settings.supportsVideo == false ? false :
                                isMeetingInvitation && conversation.meeting.availableModalities.video();
                            // AudioVideoInvitation (for P2P incoming calls)
                            invitation = isAVInvitation && Internal.AudioVideoInvitation({
                                resource: rInvitation,
                                ucwa: ucwa,
                                from: getFrom(rInvitation)
                            });
                            rAVInvitation = isAVInvitation && rInvitation; // audioVideoInvitation resource
                        }
                        // AudioVideoSession 'escalated' event handler
                        //   replaces the p2p session with the conference session if escalation succeeded;
                        //   destroys the conference session if escalation failed.
                        function onAVSessionEscalated(status) {
                            var fMuted;
                            if (status == 'success') {
                                fMuted = avs.muted();
                                log('AudioVideoModality(' + thisModalityId + ') escalation success: old AVS(' +
                                    avs[Internal.sInternal].callId + '), new AVS(' + avsEsc[Internal.sInternal].callId + ')');
                                // replace the old P2P AV session with the new AV conference session and
                                // delete the old session
                                avs.state.changed.off(state);
                                avs.audioState.changed.off(audioState);
                                avs.videoState.changed.off(videoState);
                                if (avs._onSessionError) {
                                    avs._onSessionError.dispose();
                                    avs._onSessionError = null;
                                }
                                avs.stop(Internal.sEscalation);
                                avs = avsEsc;
                                if (avsEsc._onSessionError) {
                                    avsEsc._onSessionError.dispose();
                                    avsEsc._onSessionError = null;
                                }
                                avsEsc.escalated.off(onAVSessionEscalated);
                                avs.state.changed(state);
                                avs.audioState.changed(audioState);
                                avs.videoState.changed(videoState);
                                avs._onSessionError = avs.errorOccured(function (e) {
                                    avs.stop(e).finally(function () { return state(Internal.Modality.State.Disconnected); });
                                });
                                avsEsc = null;
                                if (fMuted)
                                    avs.muted(fMuted);
                            }
                            else if (status == 'failure') {
                                log('AudioVideoModality(' + thisModalityId + ') escalation failure: old AVS(' +
                                    avs[Internal.sInternal].callId + '), new AVS(' + avsEsc[Internal.sInternal].callId + ')');
                                avsEsc.escalated.off(onAVSessionEscalated);
                                if (avsEsc._onSessionError) {
                                    avsEsc._onSessionError.dispose();
                                    avsEsc._onSessionError = null;
                                }
                                avsEsc.stop();
                                avsEsc = null;
                            }
                            else {
                                assert(false);
                            }
                        }
                        // UCWA events handler
                        function onServerEvent(event) {
                            var id = event.target.rel + ' ' + event.type;
                            var r = event.resource;
                            switch (id) {
                                // when a new AV conversation is started (using rel=startAudioVideo)
                                // the conversation is added after this object is created.
                                case 'conversation added':
                                    if (r.get('threadId') == conversation.threadId())
                                        rConversation = r;
                                    break;
                                case 'conversation deleted':
                                    if (rConversation && rConversation.href == event.target.href)
                                        rConversation = null;
                                    break;
                                case 'escalateAudio added':
                                    if (rConversation && event.sender.href == rConversation.href)
                                        startEscalation({
                                            uri: event.target.href
                                        });
                                    break;
                                case 'escalateAudioVideo added':
                                    if (rConversation && event.sender.href == rConversation.href)
                                        startEscalation({
                                            uri: event.target.href,
                                            video: true // video container will be retained by the selfParticipant
                                        });
                                    break;
                                case 'audioVideoInvitation completed':
                                    // incoming invitation was canceled or timed out while this client ignored
                                    // the invitation (neither accepted nor declined)
                                    if (!avs && rAVInvitation && rAVInvitation.href == r.href &&
                                        r.get('direction') == 'Incoming') {
                                        if (event.status == 'Failure')
                                            state(Internal.Modality.State.Disconnected, event.reason);
                                        // for p2p incoming calls accepted by another tab (not endpoint) we get
                                        // a successful completion on this tab.
                                        // Local state is Notified but has no reason so we know this tab did not accept.
                                        if (event.status == 'Success' &&
                                            state() == Internal.Modality.State.Notified &&
                                            !state.reason)
                                            state(Internal.Modality.State.Disconnected, 'AcceptedByOtherInstance'); // note: this is not a ucwa code
                                    }
                                    break;
                                case 'audioVideoInvitation started':
                                    // audioVideo can be added to an existing 1:1 conversation by the remote participant
                                    if (r.has('direction') && r.get('direction') == 'Incoming') {
                                        rConversation = getConversationResource();
                                        if (rConversation && rConversation.href == r.link('conversation').href) {
                                            rAVInvitation = r;
                                            invitation = Internal.AudioVideoInvitation({
                                                resource: r,
                                                ucwa: ucwa,
                                                from: getFrom(r)
                                            });
                                            state(Internal.Modality.State.Notified);
                                            // Notify videoService first if applicable so option to accept
                                            // call with video appears before option to accept video call with audio.
                                            if (invitation.hasVideo())
                                                videoState(Internal.Modality.State.Notified);
                                            audioState(Internal.Modality.State.Notified);
                                        }
                                    }
                                    break;
                                case 'onlineMeetingInvitation started':
                                    // Incoming meeting invites are usually handled by creation of a new conversation, and ctor
                                    // of AVM doing the work of setting things up.
                                    // This code path is triggered only for reinvite to a meeting in a conversation that was
                                    // previously completed or declined.
                                    if (r.get('direction', '') == 'Incoming') {
                                        rConversation = getConversationResource();
                                        if (rConversation && rConversation.href == r.link('conversation').href) {
                                            rInvitation = r;
                                            initInvitationState();
                                            state(Internal.Modality.State.Notified);
                                            isVideoMeetingInvitation && videoState(Internal.Modality.State.Notified);
                                            isAudioMeetingInvitation && audioState(Internal.Modality.State.Notified);
                                        }
                                    }
                                    break;
                                case 'onlineMeetingInvitation completed':
                                    if (r.get('direction', '') == 'Incoming') {
                                        rConversation = getConversationResource();
                                        // for audio meeting invites accepted by another tab (not endpoint) we get
                                        // a successful completion on this tab.
                                        // Local state is Notified but has no reason so we know this tab did not accept.
                                        if (!avs &&
                                            rConversation &&
                                            rConversation.href == r.link('conversation').href &&
                                            state() == Internal.Modality.State.Notified &&
                                            !state.reason) {
                                            if (event.status == 'Success') {
                                                state(Internal.Modality.State.Disconnected, 'AcceptedByOtherInstance'); // note: this is not a ucwa code
                                            }
                                            else if (event.reason && event.reason.subcode == 'ConnectedElsewhere') {
                                                state(Internal.Modality.State.Disconnected, event.reason);
                                            }
                                        }
                                    }
                                    break;
                            }
                        }
                        function getConversationResource() {
                            var href = conversation[Internal.sHref];
                            return href ? ucwa.get(href) : null;
                        }
                        // Finds a participant object that represents the inviter in the incoming call
                        //   The participant key in the participants collection can be either the participant href or the contact href.
                        //   The "from" participant resource embedded in the invitation has the participant href and the uri, so
                        //   we use either one to match the inviter.
                        function getFrom(rInvitation) {
                            var from = find(participants(), function (p) { return p[Internal.sHref] == rInvitation.link('from').href; }), rFrom, fromUri;
                            if (!from) {
                                rFrom = ucwa.get(rInvitation.link('from').href);
                                fromUri = rFrom.get('uri');
                                participants.each(function (p) {
                                    if (p.person.id() == fromUri)
                                        from = p;
                                });
                            }
                            return from;
                        }
                        function onParticipantDeleted(event) {
                            return avs && avs[Internal.sInternal].onParticipantDeleted(event);
                        }
                        function getPluginVersion() {
                            return !Web.Media.useBrowserMedia() ? devices && devices.mediaCapabilities.installedVersion() : void 0;
                        }
                        /* When a remote participant adds audio/video to an IM meeting,
                         * there will not be any audioVideoInvitation from the server, but
                         * conversation.activeModalities.audio|video will become true.
                         * What is done here is to bring audioState/videoState to Notified
                         * such that the application can use a consistent logic (by listening
                         * to audioState/videoState) to inform the user of added audio/video
                         * modalities.
                         */
                        function remoteAudioVideoAdded() {
                            if (isConferencing() && self.start.enabled() &&
                                conversation.chatService.state() != Internal.Modality.State.Disconnected &&
                                conversation.meeting.state() == Internal.OnlineMeeting.State.Connected) {
                                if (conversation.activeModalities.video() && videoState() == Internal.Modality.State.Disconnected &&
                                    audioState() != Internal.Modality.State.Connected) {
                                    state(Internal.Modality.State.Notified, sStartingAV);
                                    videoState(Internal.Modality.State.Notified);
                                    audioState(Internal.Modality.State.Notified);
                                    // this invitation will be passed to AVS so that AVS state can
                                    // be initialized to Notified properly (otherwise, the Disconnected
                                    // initial state of AVS can cause AVM state to become Disconnected
                                    // and reset AVM)
                                    if (!invitation)
                                        invitation = { hasVideo: function () { return true; } };
                                }
                                else if (conversation.activeModalities.audio() && audioState() == Internal.Modality.State.Disconnected) {
                                    state(Internal.Modality.State.Notified, sStartingAV);
                                    audioState(Internal.Modality.State.Notified);
                                    if (!invitation)
                                        invitation = { hasVideo: function () { return false; } };
                                }
                            }
                        }
                        // Note: devices must be initialized before calling this function
                        // Explicitly specifies what video direction user wants to configure when
                        // starting video. By default, this will be 'sendrecv', but if the user has no
                        // camera, it must be 'recvonly'
                        function determineVideoDirection(videoOptions) {
                            // No video
                            if (!videoOptions)
                                return;
                            // If just 'true,' default to 'sendrecv.' Otherwise use provided direction
                            videoOptions = videoOptions === true ? { direction: 'sendrecv' } : videoOptions;
                            // If options is object like { container: 'container' }, add default direction
                            if (!videoOptions.direction)
                                extend(videoOptions, { direction: 'sendrecv' });
                            // If no camera is available, must not attempt to send video
                            if (videoOptions && devices && devices.cameras().length == 0) {
                                if (conversation.isGroupConversation()) {
                                    switch (videoOptions.direction) {
                                        case 'sendonly':
                                            videoOptions.direction = '';
                                            break;
                                        case 'inactive':
                                            break;
                                        default:
                                            videoOptions.direction = 'recvonly';
                                    }
                                }
                                else {
                                    videoOptions.direction = 'recvonly';
                                }
                            }
                            return videoOptions;
                        }
                        //#endregion
                        //#region public methods
                        //#region start
                        /**
                         * Starts an outgoing audio/video call
                         *
                         * @param {String} to - SIP URI of the remote participant.
                         * @param {Dictionary|Boolean} [video] - If present, start both audio and video, otherwise only audio is started,
                         *                                       e.g. av.start({video: true});
                         * @param {HTMLElement} video.container - A DOM element that serves as the video window container for remote video,
                         *                                        e.g. av.start({video: {container: myElement}});
                         * @param {Object} [context] - An invitation context can accompany the generated audiovideo invitation.
                         *
                         * @returns {Promise}
                         */
                        defineAsyncCommand('start', [Internal.Modality.State.Connected, [Internal.Modality.State.Notified, sStartingAV], Internal.Modality.State.Disconnected], function (options) {
                            var isMeeting = conversation.isGroupConversation();
                            var dfdStart;
                            options = options || {};
                            remoteUri = options.to;
                            log('AudioVideoModality(' + thisModalityId + ')::start', options);
                            var contextType = (options.context === void 0) ?
                                void 0 : isPrimitive(options.context) ? (options.contextType || 'text/plain') : 'text/json';
                            var context = isPrimitive(options.context) ? options.context : JSON.stringify(options.context);
                            // in p2p mode take URI of the remote participant
                            if (!isMeeting) {
                                if (!remoteUri)
                                    remoteUri = participants(0).uri();
                                else
                                    check(participants.size() == 0, 'ambiguous remote party in 1:1 call');
                                check(remoteUri, 'the remote participant URI is not specified');
                            }
                            if (!avs) {
                                if (avsOld) {
                                    log('AudioVideoModality(' + thisModalityId + ')::cleanup session:' + avsOld[Internal.sInternal].callId);
                                    avsOld.cleanup();
                                    avsOld = null;
                                }
                                avs = new AVS({
                                    ucwa: ucwa,
                                    mediaPlugin: mediaPlugin,
                                    devices: devices,
                                    tm: tm,
                                    localUri: localUri,
                                    context: context,
                                    contextType: contextType,
                                    invitation: invitation,
                                    rInvitation: rInvitation,
                                    conversation: conversation,
                                    rConversation: rConversation,
                                    participants: participants,
                                    selfParticipant: selfParticipant,
                                    activeSpeaker: activeSpeaker,
                                    settings: settings,
                                    callId: options.callId,
                                    // these are given by unit tests:
                                    operationId: options.operationId,
                                    sessionContext: options.sessionContext
                                });
                                avs.state.changed(state);
                                avs.audioState.changed(audioState);
                                avs.videoState.changed(videoState);
                                avs._onSessionError = avs.errorOccured(function (e) {
                                    avs.stop(e).finally(function () { return state(Internal.Modality.State.Disconnected); });
                                });
                            }
                            dfdStart = Task.wait(null).then(function () {
                                if (conversation.meeting) {
                                    if (conversation.meeting.state() == Internal.Modality.State.Created) {
                                        return conversation.meeting.start({
                                            name: guestName && guestName(),
                                            uri: conversation.uri()
                                        });
                                    }
                                }
                                else if (isMeeting) {
                                    return conversation.addMeeting().start({
                                        name: guestName && guestName(),
                                        uri: conversation.uri()
                                    });
                                }
                            }).then(function () {
                                // Need to enumerate devices here, both because if devices are enumerated
                                // after the call is established, the Chrome client does not stream its own video -
                                // (what adds to this mystery is that it happens only when we answer the video meeting
                                // invitation; starting a video meeting works just fine) -
                                // and because we need to check whether the user has a camera before allowing them
                                // to configure video sendonly or sendrecv.
                                return devices && devices.init().catch();
                            }).then(function () {
                                options.video = determineVideoDirection(options.video);
                                var videoConfig = options.video && Internal.MediaEnum.enumcastDirection(options.video.direction);
                                return avs.start({
                                    remoteUri: remoteUri,
                                    audioConfig: 3 /* BOTH */,
                                    mainVideoConfig: videoConfig || 0 /* NOT_PRESENT */,
                                    video: options.video
                                });
                            }).then(function () {
                                // add participants to a meeting created by this modality's start().
                                if (isConferencing() && rConversation.hasLink('addParticipant'))
                                    conversation[Internal.sInternal].inviteParticipants();
                            });
                            if (state() !== Internal.Modality.State.Notified)
                                tm && tm.monitor(dfdStart, Web.TelemetryEvent.Call, {
                                    action: audioState() === 'Disconnected' ? 'start' : 'addVideo',
                                    modalities: options.video ? 'av' : 'audio',
                                    type: conversation.isGroupConversation() ? 'conf' : 'p2p',
                                    mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                    pluginVersion: getPluginVersion(),
                                    joinType: conversation.isGroupConversation() && guestName && guestName() ? 'anon' : undefined,
                                    callId: avs[Internal.sInternal].callId,
                                    contextType: contextType
                                });
                            return dfdStart;
                        });
                        //#endregion
                        //#region stop
                        /**
                         * Stops audio/video call
                         *
                         * @param {String} [modality] - if equals 'video', stops only video, if omitted both audio and video are stopped.
                         * @returns {Promise}
                         */
                        defineAsyncCommand('stop', [Internal.Modality.State.Connected, Internal.Modality.State.Connecting], function (modality) {
                            if (!avs)
                                return;
                            if (dfdStop)
                                return dfdStop;
                            var tasks = [], action = 'stop';
                            var callId = avs[Internal.sInternal].callId;
                            log('AudioVideoModality(' + thisModalityId + ')::stop', modality);
                            if (state() == Internal.Modality.State.Connecting) {
                                dfdStop = avs.stop();
                            }
                            else if (modality == 'video') {
                                action = 'stopVideo';
                                tasks.push(avs.stop(modality));
                                if (avsEsc)
                                    tasks.push(avsEsc.stop(modality));
                                dfdStop = Task.waitAll(tasks);
                            }
                            else if (!modality) {
                                tasks.push(avs.stop());
                                if (avsEsc) {
                                    avsEsc.escalated.off(onAVSessionEscalated);
                                    tasks.push(avsEsc.stop());
                                }
                                dfdStop = Task.waitAll(tasks).finally(function () { return state(Internal.Modality.State.Disconnected); });
                            }
                            else {
                                throw EInvalidArgument('modality', 'must be omitted or contain `video`');
                            }
                            tm && tm.monitor(dfdStop, Web.TelemetryEvent.Call, {
                                action: action,
                                type: conversation.isGroupConversation() ? 'conf' : 'p2p',
                                mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                pluginVersion: getPluginVersion(),
                                joinType: conversation.isGroupConversation() && guestName && guestName() ? 'anon' : undefined,
                                callId: callId,
                                callState: state()
                            });
                            dfdStop.finally(function () {
                                dfdStop = null;
                            });
                            return dfdStop;
                        });
                        //#endregion
                        //#region accept
                        /**
                         * Accepts an incoming audio/video invitation.
                         *
                         * @param {Dictionary} [video] - The video window container holder.
                         * @param {HTMLElement} [video.container] - A DOM element that serves as the video window container for remote video.
                         *
                         * @returns {Promise}
                         */
                        defineAsyncCommand('accept', [Internal.Modality.State.Notified], function (options) {
                            var dfdAccept;
                            options = options || {};
                            // AVM state remains Notified until AV session sets it to Connecting.
                            // The sStartingAV reason is set so that AVM can detect in other locations
                            // that the incoming call was accepted by this tab.
                            state(Internal.Modality.State.Notified, sStartingAV);
                            log('AudioVideoModality(' + thisModalityId + ')::accept', options);
                            if (isMeetingInvitation) {
                                // AVS is created inside start() and callId is usually created by AVS.
                                // However, we need a callId here for telemetry so create one and pass that in to AVS.
                                options.callId = random();
                                dfdAccept = conversation.meeting.accept().then(function () {
                                    return self.start(options);
                                });
                            }
                            else if (conversation.meeting && conversation.meeting.state() == 'Connected') {
                                // user chose to start audio/video when a remote participant
                                // adds audio/video in an IM meeting
                                return self.start(options);
                            }
                            else {
                                assert(!avs);
                                if (avsOld) {
                                    log('AudioVideoModality(' + thisModalityId + ')::cleanup session:' + avsOld[Internal.sInternal].callId);
                                    avsOld.cleanup();
                                    avsOld = null;
                                }
                                avs = new AVS({
                                    ucwa: ucwa,
                                    mediaPlugin: mediaPlugin,
                                    devices: devices,
                                    tm: tm,
                                    localUri: localUri,
                                    rAVInvitation: rAVInvitation,
                                    conversation: conversation,
                                    rConversation: rConversation,
                                    participants: participants,
                                    selfParticipant: selfParticipant,
                                    activeSpeaker: activeSpeaker,
                                    invitation: invitation,
                                    settings: settings
                                });
                                avs.state.changed(state);
                                avs.audioState.changed(audioState);
                                avs.videoState.changed(videoState);
                                avs._onSessionError = avs.errorOccured(function (e) {
                                    avs.stop(e).finally(function () { return state(Internal.Modality.State.Disconnected); });
                                });
                                // the UI has a reasonable expectation that
                                // once AV is used, all AV stuff is properly
                                // initialized: the list of cams, mics and so on
                                var dfdInit = devices ? devices.init().catch() : Promise.resolve();
                                dfdAccept = dfdInit.then(function () {
                                    options.video = determineVideoDirection(options.video);
                                    return avs.accept(options);
                                });
                            }
                            tm && tm.monitor(dfdAccept, Web.TelemetryEvent.Call, {
                                action: 'accept',
                                type: conversation.isGroupConversation() ? 'conf' : 'p2p',
                                modalities: options.video ? 'av' : 'audio',
                                mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                pluginVersion: getPluginVersion(),
                                hasVideo: invitation.hasVideo ? invitation.hasVideo() : void 0,
                                sdpCount: invitation.offers && invitation.offers.length,
                                callId: options.callId || avs && avs[Internal.sInternal].callId
                            });
                            return dfdAccept;
                        });
                        //#endregion
                        //#region decline
                        /**
                         * Declines an incoming audio/video invitation.
                         * reason: 'Local' - reject just on this endpoint, 'Global' (default) - reject on all.
                         * @returns {Promise}
                         */
                        defineAsyncCommand('decline', [Internal.Modality.State.Notified], function (reason) {
                            if (reason === void 0) { reason = 'Global'; }
                            if (conversation.meeting && conversation.meeting.state() == 'Connected') {
                                // user declined to start audio/video when a remote participant
                                // adds audio/video in an IM meeting
                                state(Internal.Modality.State.Disconnected);
                                return;
                            }
                            var dfdDecline = isMeetingInvitation ?
                                conversation.meeting.decline(reason) :
                                invitation.decline(reason);
                            log('AudioVideoModality(' + thisModalityId + ')::decline', options);
                            dfdDecline.then(function () {
                                state(Internal.Modality.State.Disconnected);
                            });
                            tm && tm.monitor(dfdDecline, Web.TelemetryEvent.Call, {
                                action: 'decline',
                                type: conversation.isGroupConversation() ? 'conf' : 'p2p',
                                modalities: invitation.hasVideo() ? 'av' : 'audio',
                                mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                pluginVersion: getPluginVersion(),
                                callId: avs && avs[Internal.sInternal].callId
                            });
                            return dfdDecline;
                        });
                        //#endregion
                        //#region sendDtmf
                        /**
                         * Sends a DTMF tone
                         *
                         * @param {String} tone - a DTMF tone from MediaEnum.DtmfTone enumeration
                         * @returns {Promise}
                         */
                        defineAsyncCommand('sendDtmf', [Internal.Modality.State.Connected], function (tone) {
                            // if avs is null the thrown exception will lead to promise rejection.
                            var dfd = avs.sendDtmf(tone);
                            tm && tm.monitor(dfd, Web.TelemetryEvent.Call, {
                                action: 'sendDtmf',
                                type: conversation.isGroupConversation() ? 'conf' : 'p2p',
                                mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                pluginVersion: getPluginVersion(),
                                callId: avs[Internal.sInternal].callId
                            });
                            return dfd;
                        });
                        //#endregion
                        //#region transfer
                        /**
                         * Transferring a call makes the remote participant connect with
                         * the specified SIP URI or TEL URI, and then disconnects this
                         * endpoint from the call: UCWA ends the conversation and so on.
                         *
                         *  POST /transfer
                         *  transfer started
                         *  audioVideo updated, state=Transferring
                         *  audioVideoRenegotiation started, mediaOffer=<...>, direction=Incoming
                         *  POST /renegotiations/.../answer
                         *  audioVideoRenegotiation completed
                         *  > UCWA calls the specified sipuri/teluri
                         *  > the call gets accepted
                         *  transfer completed
                         *  audioVideoSession deleted
                         *  conversation deleted
                         *  missedItems updated
                         *
                         * If the specified sipuri/teluri declines the call, then
                         *
                         *  transfer completed, code=RemoteFailure subcode=TransferTargetDeclined
                         *  audioVideoRenegotiation started
                         *  POST /renegotiations/.../answer
                         *  audioVideoRenegotiation completed
                         */
                        defineAsyncCommand('transfer', [Internal.Modality.State.Connected], function (sipuri) {
                            var rcv = ucwa.get(conversation[Internal.sHref]);
                            var rav = ucwa.get(rcv.link('audioVideo').href);
                            var opid = random();
                            var dfd = ucwa.send('POST', rav.link('transfer').href, {
                                revision: 2,
                                data: {
                                    to: sipuri,
                                    operationId: opid
                                }
                            }).then(function () {
                                return ucwa.wait({
                                    type: 'completed',
                                    target: { rel: 'transfer' },
                                    resource: function (r) { return r.get('operationId', null) == opid; }
                                }).then(function (e) {
                                    if (e.status != 'Success')
                                        throw Exception('TransferFailed', { reason: e.reason });
                                });
                            });
                            tm && tm.monitor(dfd, Web.TelemetryEvent.Call, {
                                action: 'transfer',
                                type: conversation.isGroupConversation() ? 'conf' : 'p2p',
                                mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                pluginVersion: getPluginVersion(),
                                callId: avs[Internal.sInternal].callId
                            });
                            return dfd;
                        });
                        //#endregion
                        /**
                         * Shows participant's video
                         *
                         * @param {Participant} participant
                         * @returns {Promise}
                         */
                        function showParticipantVideo(participant) {
                            var dfd = avs.showParticipantVideo(participant);
                            tm && tm.monitor(dfd, Web.TelemetryEvent.Call, {
                                action: 'showParticipantVideo',
                                isLocal: participant[Internal.sInternal].isLocal(),
                                type: conversation.isGroupConversation() ? 'conf' : 'p2p',
                                mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                pluginVersion: getPluginVersion(),
                                callId: avs[Internal.sInternal].callId
                            });
                            return dfd;
                        }
                        /**
                         * Removes participant's video
                         *
                         * @param {Participant} participant
                         * @returns {Promise}
                         */
                        function removeParticipantVideo(participant) {
                            var dfd = avs.removeParticipantVideo(participant);
                            tm && tm.monitor(dfd, Web.TelemetryEvent.Call, {
                                action: 'removeParticipantVideo',
                                isLocal: participant[Internal.sInternal].isLocal(),
                                type: conversation.isGroupConversation() ? 'conf' : 'p2p',
                                mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                pluginVersion: getPluginVersion(),
                                callId: avs[Internal.sInternal].callId
                            });
                            return dfd;
                        }
                        //#endregion public methods
                        //#region private methods
                        /**
                         * Starts a new AudioVideoSession that joins an online meeting.
                         *
                         * @param {String} uri - the uri to which the first SDP offer should be sent ('escalateAudio' or 'escalateAudioVideo uri).
                         * @param {Dictionary} [video] - The video window container holder.
                         * @param {HTMLElement} [video.container] - A DOM element that serves as the video window container for remote video.
                         *
                         * @returns {Promise}
                         */
                        function startEscalation(options) {
                            var dfdEscalate;
                            assert(!avsEsc);
                            assert(isConferencing());
                            log('AudioVideoModality(' + thisModalityId + ')::startEscalation');
                            avsEsc = new AVS({
                                ucwa: ucwa,
                                mediaPlugin: mediaPlugin,
                                devices: devices,
                                tm: tm,
                                localUri: localUri,
                                conversation: conversation,
                                rConversation: rConversation,
                                participants: participants,
                                selfParticipant: selfParticipant,
                                activeSpeaker: activeSpeaker,
                                escalateAudioVideoUri: options.uri,
                                settings: settings
                            });
                            avsEsc.escalated(onAVSessionEscalated);
                            avs.escalationState(1 /* From */);
                            avsEsc.preEscalationVideoConfig(avs.preEscalationVideoConfig());
                            avsEsc._onSessionError = avsEsc.errorOccured(function (e) {
                                avsEsc.stop(e);
                            });
                            if (options.video)
                                avs.removeVideo();
                            dfdEscalate = avsEsc.start({
                                remoteUri: remoteUri,
                                audioConfig: 4 /* NO_ACTIVE_MEDIA */,
                                mainVideoConfig: options.video ?
                                    4 /* NO_ACTIVE_MEDIA */ : 0 /* NOT_PRESENT */,
                                video: options.video
                            });
                            tm && tm.monitor(dfdEscalate, Web.TelemetryEvent.Call, {
                                action: 'escalate',
                                type: 'conf',
                                modalities: options.video ? 'av' : 'audio',
                                mediaType: Web.Media.useBrowserMedia() ? 'pluginless' : 'plugin',
                                pluginVersion: getPluginVersion(),
                                oldCallId: avs[Internal.sInternal].callId,
                                callId: avsEsc[Internal.sInternal].callId
                            });
                            return dfdEscalate;
                        }
                        //#endregion
                        init();
                        setHiddenProperty(self, Internal.sInternal, {
                            onParticipantDeleted: onParticipantDeleted
                        });
                        return self;
                    }
                    return AudioVideoModality;
                }());
                Internal.AudioVideoModality = AudioVideoModality;
                ;
            })(Internal = Model_6.Internal || (Model_6.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_7) {
            var Internal;
            (function (Internal) {
                var guid = Web.Utils.guid;
                var Model = Web.Utils.Model;
                var Command = Web.Utils.Command;
                var Promise = Web.Utils.Promise;
                var Property = Web.Utils.Property;
                var DisabledAsyncCommand = Web.Utils.DisabledAsyncCommand;
                /**
                 * Unlike the AV modality, PSTN doesn't deal with media SDP offers
                 * and the plugin in particular. All it does is it tells UCWA to
                 * set up a call with a phone number of the current user. This is
                 * why this modality doesn't have a WebRTC/ORTC counterpart.
                 *
                 * The idea of PSTN is to use the user's phone instead of the AV modality:
                 * if the user wants to join a conference, it can either the AV modality
                 * and use a headset, or it can use a phone and let UCWA connect it with
                 * the conference MCU; if the user wants to make a p2p call, it can again
                 * use the AV modality with a headset, or can use a phone and let UCWA
                 * connect the remote participant with the user's phone. In either case,
                 * all the media goes thru UCWA and cannot be observed on the SDK side:
                 * the SDK only gets notifications about when the call started, ended
                 * and so on.
                 *
                 */
                var PhoneAudio = (function () {
                    function PhoneAudio(_a) {
                        var tm = _a.tm, ucwa = _a.ucwa, name = _a.name, invitation = _a.invitation, conversation = _a.conversation;
                        var state = Property.just(invitation ?
                            Internal.Modality.State.Notified :
                            Internal.Modality.State.Disconnected);
                        // The sequence of events is this:
                        //
                        //  POST rel=startPhoneAudio/rel=addPhoneAudio
                        //  phoneAudioInvitation started
                        //  UCWA calls the user's phone
                        //  The user accepts the call
                        //  phoneAudioInvitation completed
                        //  UCWA calls the other user or the MCU
                        //
                        function start(args) {
                            state(Internal.Modality.State.Connecting);
                            var operationId = guid();
                            return Promise.resolve().then(function () {
                                if (conversation.meeting && conversation.meeting.state() == Internal.OnlineMeeting.State.Created) {
                                    return conversation.meeting.start({
                                        name: name(),
                                        uri: conversation.uri()
                                    });
                                }
                                if (conversation.isGroupConversation() && !conversation.meeting) {
                                    return conversation.addMeeting().start({
                                        name: name(),
                                        uri: conversation.uri()
                                    });
                                }
                            }).then(function () {
                                var href = conversation[Internal.sHref];
                                if (href) {
                                    var link = getPhoneAudio().link('addPhoneAudio');
                                    link.rel = 'addPhoneAudio';
                                    return link;
                                }
                                else {
                                    var link = ucwa.get(ucwa.app.relatedHref('communication')).link('startPhoneAudio'); // starts a new p2p call
                                    link.rel = 'startPhoneAudio';
                                    return link;
                                }
                            }).then(function (link) {
                                return ucwa.send('POST', link.href, {
                                    data: {
                                        operationId: operationId,
                                        threadId: conversation.threadId(),
                                        phoneNumber: args && args.teluri || conversation.selfParticipant.person.workPhone(),
                                        // in a conference, the call is set up between the MCU and the user's phone
                                        to: conversation.isGroupConversation() ? void 0 :
                                            (link.rel == 'addPhoneAudio' ? void 0 : conversation.participants(0).person.id())
                                    }
                                });
                            }).then(function () {
                                return ucwa.wait({
                                    type: 'completed',
                                    target: { rel: 'phoneAudioInvitation' },
                                    resource: function (r) { return r.get('operationId', null) == operationId; }
                                }).then(function (e) {
                                    // code=LocalFailure subcode=PstnCallFailed if the user rejects the incoming call on their phone
                                    // code=RemoteFailure subcode=Declined if the remote participant specified by the SIP URI declines the invitation
                                    if (e.status != 'Success')
                                        throw Internal.EInvitationFailed(e.reason);
                                });
                            }).then(function () {
                                state(Internal.Modality.State.Connected);
                            }, function (err) {
                                state(Internal.Modality.State.Disconnected, err);
                                throw err;
                            });
                        }
                        function stop() {
                            state(Internal.Modality.State.Disconnecting);
                            return Promise.resolve().then(function () {
                                var href = getPhoneAudio().link('stopPhoneAudio').href;
                                return ucwa.send('POST', href);
                            }).then(function () {
                                state(Internal.Modality.State.Disconnected);
                            }, function (err) {
                                state(Internal.Modality.State.Disconnected, err);
                                throw err;
                            });
                        }
                        function reject(reason) {
                            if (reason === void 0) { reason = 'Global'; }
                            state(Internal.Modality.State.Disconnecting);
                            return Promise.resolve().then(function () {
                                var href = invitation.link('decline').href;
                                return ucwa.send('POST', href, {
                                    data: { reason: reason }
                                });
                            }).then(function () {
                                state(Internal.Modality.State.Disconnected);
                            }, function (err) {
                                state(Internal.Modality.State.Disconnected, err);
                                throw err;
                            });
                        }
                        // returns /conversation/phoneAudio
                        function getPhoneAudio() {
                            var href = conversation[Internal.sHref];
                            if (!href)
                                throw Error('rel=conversation does not exist yet');
                            return ucwa.get(ucwa.get(href).link('phoneAudio').href);
                        }
                        function monitored(fn, action) {
                            return tm ? tm.monitored('pstn', { action: action })(fn) : fn;
                        }
                        ucwa.observe('phoneAudio updated', function (event) {
                            var sender = event.sender, resource = event.resource;
                            if (sender.href == conversation[Internal.sHref] && resource.get('state') == 'Disconnected' && state() == Internal.Modality.State.Connected) {
                                // looks like the user has dropped the call
                                state(Internal.Modality.State.Disconnected);
                            }
                        });
                        return Model({
                            state: state.asReadOnly(),
                            start: Command.async(monitored(start, 'start'), state.equals(Internal.Modality.State.Disconnected)),
                            stop: Command.async(monitored(stop, 'stop'), state.equals(Internal.Modality.State.Connected)),
                            accept: DisabledAsyncCommand(),
                            reject: Command.async(monitored(reject, 'reject'), state.equals(Internal.Modality.State.Notified))
                        });
                    }
                    return PhoneAudio;
                }());
                Internal.PhoneAudio = PhoneAudio;
            })(Internal = Model_7.Internal || (Model_7.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                var PhoneDialInInformation = (function () {
                    function PhoneDialInInformation(ucwa, href) {
                        return Internal.ObservableResource(ucwa, href, function ($) {
                            $.property('conferenceId');
                            $.property('externalDirectoryUri');
                            $.property('internalDirectoryUri');
                            $.property('isAudioConferenceProviderEnabled');
                            $.property('participantPassCode');
                            $.property('tollNumber');
                            $.property('tollFreeNumbers');
                            $.member('defaultRegion', function ($) {
                                $.property('name');
                                $.property('number');
                                $.property('languages');
                            });
                        });
                    }
                    return PhoneDialInInformation;
                }());
                Internal.PhoneDialInInformation = PhoneDialInInformation;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var guid = Web.Utils.guid;
                var assert = Web.Utils.assert;
                var extend = Web.Utils.extend;
                //#region multipartJsonAndSDP
                /**
                 * This function constructs the message body of the audioVideoInvitation
                 * HTTP POST used in the multiparty conference situation. The multiparty
                 * SDP offer message body will contain all the SDP offers separated by
                 * some boundary mark.
                 *
                 * This is an example of the multiparty SDP offer message body:
                 *
                 * --09B8DAEF
                 * Content-Type: application/vnd.microsoft.com.ucwa+json
                 * Content-Length: 274
                 *
                 * {"operationId":"0D1DBA19","sessionContext":"6A6A17C9","mediaOffer":"cid:BC4833B8",
                 * "telemetryId":"c380da57","joinAudioMuted":true,"joinVideoMuted":false}
                 * --09B8DAEF
                 * Content-ID: BC4833B8
                 * Content-Type: multipart/alternative;boundary=CA93AA8F;type="application/sdp"
                 * Content-Length: 12464
                 *
                 *
                 * --CA93AA8F
                 * Content-Type: application/sdp
                 * Content-ID: <b4511a64f3e11159b46a38d4c54771c2@6485c71fa8ec29075dcec063a43a27ea>
                 * Content-Length: 3897
                 *
                 * ...(sdp offer 1 content start)...
                 * v=0
                 * o=- 0 0 IN IP4 131.107.255.94
                 * ...(sdp content end)...
                 *
                 * --CA93AA8F
                 * Content-Type: application/sdp
                 * Content-ID: <f8bea11cdb9fc648b471381edb8c1587@5215feaa2950a58d4a3749e7a071b402>
                 * Content-Length: 8167
                 *
                 * ...(sdp offer 2 content start)...
                 * v=0
                 * o=- 0 1 IN IP4 131.107.255.94
                 * ...(sdp content end)...
                 *
                 * --CA93AA8F
                 *
                 * --09B8DAEF
                 *
                 * Note: wherever Content-Length is needed in the header section, the
                 * content needs to be established beforehand in order to calculate the
                 * Content-Length.
                 *
                 * The caller of this function needs to generate the boundary mark, which
                 * needs to be inserted into the "Content-Type" header field of the HTTP
                 * POST message like this:
                 *      multipart/related;boundary=09B8DAEF;type="application/vnd.microsoft.com.ucwa+json"
                 *
                 * @param {Object[]} offers - An array of media offers.
                 *     - offers[i].sdp - SDP of the i-th offer.
                 *     - offers[i].id - Content ID of the i-th offer.
                 *
                 * @param {String} boundary - a guid that separates multiple SDP offers
                 * @param {String} operationId - a guid that represents the current operation
                 * @param {String} threadId - a guid that represents the current thread
                 * @param {String} sessionContext - a session-specific guid
                 * @param {String} [to] - remote uri if this method is called for a 1:1 conversation
                 * @param {String} [context] - Some contextual data that is included in the
                 *                             http request for sending audiovideo invitation.
                 * @param {String} [contextType] - contentType of the context data
                 *
                 */
                function multipartJsonAndSDP(options) {
                    var offers = options.offers, boundary = options.boundary, subject = options.subject, importance = options.importance, operationId = options.operationId, threadId = options.threadId, sessionContext = options.sessionContext || guid(), context = options.context, contextType = options.contextType, sdpBoundary = 'D63E5F1E-56D8-4EC4-B51B-02762CEA97D9', mediaCid = '4EFFF0D8-65D2-4E52-9A1B-0FA835D4B478', contextCid = '2CAE7DF5 -0185-4FB8-84E7-AA6C57F10432', multipartBLine = '--' + boundary + '\r\n', // will be used multiple times
                    msg = multipartBLine, // msg to be constructed starts with a boundary line
                    params, strParams, sdps;
                    // construct the JSON part containing parameters
                    params = {
                        operationId: operationId,
                        threadId: threadId,
                        subject: subject,
                        importance: importance,
                        sessionContext: sessionContext,
                        mediaOffer: 'cid:' + mediaCid
                    };
                    if (context !== void 0)
                        extend(params, { customContent: 'cid:' + contextCid });
                    if (options.to) {
                        params.to = options.to;
                    }
                    else {
                        params.telemetryId = guid();
                        params.joinAudioMuted = false;
                        params.joinVideoMuted = false;
                    }
                    strParams = JSON.stringify(params);
                    msg += 'Content-Type: application/vnd.microsoft.com.ucwa+json\r\n' +
                        'Content-Length: ' + strParams.length + '\r\n' +
                        '\r\n' +
                        strParams +
                        '\r\n';
                    // a boundary line
                    msg += multipartBLine;
                    // construct the multipart SDP part
                    sdps = multipartSDP(offers, sdpBoundary);
                    msg += 'Content-ID: ' + mediaCid + '\r\n' +
                        'Content-Type: multipart/alternative;boundary=' + sdpBoundary + ';type="application/sdp"\r\n' +
                        'Content-Length: ' + sdps.length + '\r\n' +
                        sdps;
                    if (context !== void 0) {
                        msg += '\r\n';
                        // a boundary line
                        msg += multipartBLine;
                        // the specified Content-Disposition header allows this multipart content always
                        // processed to the end point, which may not register 'text/json' as its supported format.
                        msg += 'Content-ID: ' + contextCid + '\r\n' +
                            'Content-Type:' + contextType + '\r\n' +
                            'Content-Disposition: render; handling=optional' + '\r\n' +
                            '\r\n' +
                            context;
                    }
                    // message is ended with a boundary ending line
                    return msg + '\r\n--' + boundary + '--\r\n';
                }
                Internal.multipartJsonAndSDP = multipartJsonAndSDP;
                //#endregion
                //#region multipartSDP
                /**
                 * Constructs the body of a multipart SDP message
                 *
                 * @param {Object} offers - SDP media offers.
                 *     - offer.sdp - SDP content of the offer.
                 *     - offer.id - Content ID of offer.
                 * @param {String} boundary - a boundary separating the parts.
                 *
                 */
                function multipartSDP(offers, boundary) {
                    var s = '\r\n', i;
                    for (i = 0; i < offers.length; ++i)
                        s += constructSDP(offers[i], boundary);
                    s += ('\r\n--' + boundary + '--\r\n');
                    return s;
                }
                Internal.multipartSDP = multipartSDP;
                //#endregion
                //#region constructSDP
                /**
                 * This function constructs one SDP offer message to be embedded into
                 * the multipart SDP offer message body.
                 *
                 * The SDP offer message needs to follow the following format:
                 *
                 *      empty line
                 *      SDP section boundary line
                 *      header
                 *          Content-Type
                 *          Content-ID
                 *          Content-Length
                 *      SDP content
                 *
                 * @param {Object} offer - An SDP media offer.
                 *     - offer.sdp - SDP content of the offer.
                 *     - offer.id - Content ID of offer.
                 *
                 * @param {String} boundary - a guid that separates multiple SDP offers
                 *
                 */
                function constructSDP(offer, boundary) {
                    assert(offer && offer.sdp && offer.id && boundary);
                    return '\r\n' +
                        '--' + boundary + '\r\n' +
                        'Content-Type: application/sdp\r\n' +
                        'Content-ID: ' + offer.id + '\r\n' +
                        'Content-Length: ' + offer.sdp.length + '\r\n' +
                        '\r\n' +
                        offer.sdp;
                }
                //#endregion
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var async = Web.Utils.async;
                var assert = Web.Utils.assert;
                var extend = Web.Utils.extend;
                var Event = Web.Utils.Event;
                var Property = Web.Utils.Property;
                var log = Web.Media.log;
                var PluginComponent = Web.Media.PluginComponent;
                /**
                 * UI can listen to channel state changes. When channel becomes active UI can call container(parent)
                 * to set the parent DOM element for the video window of this channel, for example:
                 *
                 *   videoChannel.state.when("Active", () => {
                 *       videoChannel.container(document.getElementById("myVideoWindow"));
                 *   });
                 *
                 * Alternatively, UI can set the video channel container ad-hoc to display the video window, and
                 * set it to null to remove the video window.
                 *
                 */
                var LocalVideoChannel = (function () {
                    //#endregion
                    function LocalVideoChannel(options) {
                        var id = options.channelId, mediaPlugin = options.mediaPlugin, container = options.container || Property(), windowState = Property({ value: PluginComponent.State.Unloaded }), resized = new Event(), pcVideoUI = null, // "VideoUI" plugin component
                        hRenderWindow = null, // render window handle (as BigInt)
                        channel = new Internal.VideoChannel({ name: 'local' });
                        function channelId(cid) {
                            if (arguments.length == 0) {
                                return id;
                            }
                            else {
                                id = cid;
                                return this;
                            }
                        }
                        /**
                         *  Creates a video window to render incoming video and places it in the parent DOM element
                         */
                        function createVideoWindow(parent) {
                            assert(!pcVideoUI);
                            parent = parent || container();
                            assert(parent);
                            pcVideoUI = mediaPlugin.createComponent({
                                type: 'VideoUI',
                                hide: false
                            });
                            pcVideoUI.state.changed(onPluginComponentState);
                            pcVideoUI.event(onPluginComponentEvent, 'async');
                            pcVideoUI.setContainer(parent);
                            return pcVideoUI.load().then(function () {
                                pcVideoUI.invoke('CreateVideoUI', false); // false == no preview window
                                hRenderWindow = getWindow('GetRenderWindow');
                            });
                        }
                        function destroyVideoWindow() {
                            if (pcVideoUI) {
                                pcVideoUI.invoke('DestroyVideoWindows');
                                pcVideoUI.unload();
                                pcVideoUI.event.off(onPluginComponentEvent);
                                pcVideoUI.state.changed.off(onPluginComponentState);
                                windowState(PluginComponent.State.Unloaded);
                                pcVideoUI = null;
                                hRenderWindow = null;
                            }
                        }
                        /**
                         * VideoUI component event listener - re-fires 'video size changed' event upon receiving
                         * it from the plugin component
                         */
                        function onPluginComponentEvent(ev) {
                            if (ev.type == 'VIDEO_SIZE_CHANGED') {
                                resized.fire({
                                    width: ev.args[0],
                                    height: ev.args[1]
                                });
                            }
                        }
                        /**
                         * Returns the window for rendering incoming video
                         */
                        function videoWindow() {
                            return hRenderWindow = hRenderWindow || getWindow('GetRenderWindow');
                        }
                        function getWindow(method) {
                            assert(method == 'GetRenderWindow');
                            if (pcVideoUI) {
                                var res = pcVideoUI.invoke(method);
                                if (res.succeeded)
                                    return res[1];
                            }
                            return null;
                        }
                        /**
                         * Resizes the video window so that it fits the parent DOM element
                         */
                        function resizeVideoWindow(parent) {
                            if (parent === void 0) { parent = container(); }
                            assert(parent);
                            pcVideoUI.invoke('ResizeWindow', parent.clientWidth, parent.clientHeight);
                        }
                        function onPluginComponentState(state) {
                            log('Video channel ' + id + ' ' + pcVideoUI.id() + ' pcVideoUI.state = ' + state);
                            // in destroyVideoWindow() we unsubscribe from the plugin component events right after
                            // we called unload(), so the last component state we see is Unloading. We make it
                            // the Unloaded state to enable the single check for the uninitialized (Unloaded) state
                            if (state == PluginComponent.State.Unloading)
                                state = PluginComponent.State.Unloaded;
                            windowState(state);
                        }
                        return {
                            container: container,
                            channelId: channelId,
                            createVideoWindow: async(createVideoWindow),
                            destroyVideoWindow: destroyVideoWindow,
                            videoWindow: videoWindow,
                            resizeVideoWindow: resizeVideoWindow,
                            videoWindowState: windowState.asReadOnly(),
                            resized: resized.observer,
                            channel: extend(channel, {
                                // TODO: overriding an existing member this way isn't nice
                                isStarted: Property({
                                    value: false,
                                    // .set(true) starts streaming the local video:
                                    //
                                    //  1. it takes the rendering element from the stream where it's supposed to have been already set
                                    //  2. then it invokes container.set that knows how to start streaming the local video
                                    //
                                    // .set(false) stops streaming the video:
                                    //
                                    //  1. it invokes container.set(null) that knows how to stop streaming
                                    //  2. and leaves the rendering element in the media stream untouched
                                    //
                                    set: function (x) { return container.set(x ? channel.stream.source.sink.container() : null).then(function () { return x; }); }
                                })
                            })
                        };
                    }
                    return LocalVideoChannel;
                }());
                Internal.LocalVideoChannel = LocalVideoChannel;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="LocalVideoChannel.ts" />
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_8) {
            var Internal;
            (function (Internal) {
                'use strict';
                var async = Web.Utils.async;
                var check = Web.Utils.check;
                var assert = Web.Utils.assert;
                var foreach = Web.Utils.foreach;
                var Model = Web.Utils.Model;
                var Property = Web.Utils.Property;
                var Collection = Web.Utils.Collection;
                var ConstProperty = Web.Utils.ConstProperty;
                var PluginManager = Web.Media.PluginManager;
                /**
                 * Holds collections of audio and video devices.
                 *
                 */
                var PluginDevicesManager = (function () {
                    //#endregion
                    function PluginDevicesManager(_a) {
                        var mediaPlugin = _a.mediaPlugin, msi = _a.msi, pkg = _a.pkg, dmg = _a.dmg, tm = _a.tm;
                        var pcTW = null; // "TuningWizard" plugin component
                        var state = PluginManager.State.Uninitialized;
                        var pluginStateSub;
                        var dfdInit;
                        var microphones = Collection({ subscribed: init, get: init });
                        var speakers = Collection({ subscribed: init, get: init });
                        var cameras = Collection({ subscribed: init, get: init });
                        var selectedMicrophone = Property({
                            set: function (mic) {
                                selectAudioDevices(selectedSpeaker(), mic);
                                return mic;
                            }
                        });
                        var selectedSpeaker = Property({
                            set: function (spk) {
                                selectAudioDevices(spk, selectedMicrophone());
                                return spk;
                            }
                        });
                        var selectedCamera = Property({
                            set: function (cam) {
                                if (cam)
                                    pcTW.invoke('SetSelectedVideoDevice', cam.id());
                                return cam;
                            }
                        });
                        var isBrowserMediaSupported = Property({
                            // this value should stay once initialized 
                            value: !!Web.Media.MediaAgent.isPlatformSupported()
                        });
                        // populate plugin download links from ecs settings
                        var pluginDownloadLinks = Collection();
                        if (msi)
                            pluginDownloadLinks.add(msi, 'msi');
                        if (pkg)
                            pluginDownloadLinks.add(pkg, 'pkg');
                        if (dmg)
                            pluginDownloadLinks.add(dmg, 'dmg');
                        var isMicrophoneEnabled = Property.bool(true);
                        var isCameraEnabled = Property.bool(true);
                        var mediaCapabilities = {
                            isPluginInstalled: PluginManager().isPluginInstalled,
                            installedVersion: PluginManager().installedVersion,
                            isBrowserMediaSupported: isBrowserMediaSupported.asReadOnly(),
                            // if plugin download links are not specified in ecs, link
                            // to default values in PluginManager
                            pluginDownloadLinks: pluginDownloadLinks.size() ?
                                pluginDownloadLinks.asReadOnly() : PluginManager().pluginDownloadLinks,
                            isMicrophoneEnabled: isMicrophoneEnabled.asReadOnly(),
                            isCameraEnabled: isCameraEnabled.asReadOnly()
                        };
                        var localVideoChannel = new Internal.LocalVideoChannel({
                            mediaPlugin: mediaPlugin,
                            container: Property({
                                value: null,
                                set: function (parentElem) {
                                    // setting this to null while devices are not initialized should not
                                    // trigger plugin component initialization
                                    if (state != PluginManager.State.Initialized && !parentElem) {
                                        assert(this() === null);
                                        return this();
                                    }
                                    return init().then(function () {
                                        if (!localVideoChannel.videoWindow() && parentElem)
                                            return localVideoChannel.createVideoWindow(parentElem);
                                    }).then(function () {
                                        if (parentElem) {
                                            check(selectedCamera(), 'No video camera');
                                            pcTW.invoke('StartVideoPreview', localVideoChannel.videoWindow(), selectedCamera().name());
                                            localVideoChannel.resized(onLocalVideoResized);
                                        }
                                        else {
                                            pcTW.invoke('StopVideoPreview');
                                            localVideoChannel.destroyVideoWindow();
                                            localVideoChannel.resized.off(onLocalVideoResized);
                                        }
                                        return parentElem;
                                    });
                                }
                            })
                        });
                        /**
                         * Initializes the object by loading TuningWizard plugin component
                         * and enumerating available audio and video devices.
                         */
                        function init() {
                            tm && tm.record(Web.TelemetryEvent.DevicesInit, {
                                action: 'init',
                                state: state
                            });
                            pluginStateSub = pluginStateSub || PluginManager().state.changed(function (newVal, reason, oldVal) {
                                if (newVal == PluginManager.State.Uninitialized) {
                                    uninit();
                                }
                            });
                            if (state == PluginManager.State.Uninitialized) {
                                state = PluginManager.State.Initializing;
                                dfdInit = mediaPlugin.initMedia().then(function () {
                                    pcTW = mediaPlugin.createComponent({
                                        type: 'TuningWizard',
                                        hide: true
                                    });
                                    pcTW.event(onPluginComponentEvent, 'async');
                                    return pcTW.load().then(function () {
                                        updateAudioRenderDevices(pcTW.invoke('GetAudioRenderDevicesDescription'));
                                        updateAudioCaptureDevices(pcTW.invoke('GetAudioCaptureDevicesDescription'));
                                        updateVideoDevices(pcTW.invoke('GetVideoDevicesDescription'));
                                        // the plugin is extremely chatty - it fires a lot of TEL_DEVICES_CHANGED
                                        // events, so we postpone event handling until after we load the plugin
                                        // and get the initial device collection snapshot
                                        state = PluginManager.State.Initialized;
                                    });
                                }).catch(function (err) {
                                    tm && tm.record(Web.TelemetryEvent.DevicesInit, {
                                        action: 'initDevicesMgrFailed',
                                        state: state,
                                        reason: err
                                    });
                                    uninit();
                                });
                                tm && tm.monitor(dfdInit, Web.TelemetryEvent.DevicesInit, {
                                    action: 'initDevicesMgr',
                                    state: state
                                });
                            }
                            return dfdInit;
                        }
                        function uninit() {
                            if (pcTW) {
                                pcTW.event.off(onPluginComponentEvent);
                                pcTW = null;
                            }
                            if (pluginStateSub) {
                                pluginStateSub.dispose();
                                pluginStateSub = null;
                            }
                            localVideoChannel.destroyVideoWindow();
                            localVideoChannel.resized.off(onLocalVideoResized);
                            state = PluginManager.State.Uninitialized;
                        }
                        function onPluginComponentEvent(ev) {
                            if (state != PluginManager.State.Initialized)
                                return;
                            if (ev.type == 'AUDIO_DEVICES_CHANGED') {
                                updateAudioRenderDevices(pcTW.invoke('GetAudioRenderDevicesDescription'));
                                updateAudioCaptureDevices(pcTW.invoke('GetAudioCaptureDevicesDescription'));
                            }
                            else if (ev.type == 'VIDEO_DEVICES_CHANGED') {
                                updateVideoDevices(pcTW.invoke('GetVideoDevicesDescription'));
                            }
                        }
                        function onLocalVideoResized(size) {
                            // notify the TuningWizard component that the video window size has changed
                            pcTW.invoke('ResizeWindow', localVideoChannel.videoWindow(), size.width, size.height);
                        }
                        function selectAudioDevices(spk, mic) {
                            if (spk && mic)
                                pcTW.invoke('SetSelectedAudioDevices', spk.id(), mic.id());
                        }
                        /**
                         * Updates the speakers collection after calling GetAudioRenderDevicesDescription
                         * This method returns the results array that enumerates all audio render devices;
                         * each array element is a string that describes a single device. The last array element
                         * is the index of the currently selected device.
                         */
                        function updateAudioRenderDevices(res) {
                            assert(res.succeeded);
                            var i, sspk, spks = [], spk;
                            // build the current device list
                            for (i = 1; i < res.length - 1; i++) {
                                spk = Model({
                                    // the media plugin doesn't give a unique id for every
                                    // speaker, so name is used as a reasonably unique id
                                    id: ConstProperty(res[i]),
                                    name: ConstProperty(res[i]),
                                    type: ConstProperty('Speaker')
                                });
                                spks.push(spk);
                            }
                            // newly selected device (if there are no devices res = [0, -1])
                            sspk = spks[res[res.length - 1]];
                            // replace the device collection with the new device list
                            updateDeviceCollection(speakers, spks);
                            // TODO: note, that in some cases selectedSpeaker() != speakers(i) for any i
                            selectedSpeaker(sspk || null, Property.sUpdated);
                        }
                        /**
                         * Updates the microphones collection after calling GetAudioCaptureDevicesDescription
                         * This method returns the results array that enumerates all audio capture devices;
                         * each array element is a string that describes a single device. The last array element
                         * is the index of the currently selected device.
                         */
                        function updateAudioCaptureDevices(res) {
                            assert(res.succeeded);
                            var i, smic, mics = [], mic;
                            // build the current device list
                            for (i = 1; i < res.length - 1; i++) {
                                mic = Model({
                                    // the media plugin doesn't give a unique id for every
                                    // microphone, so name is used as a reasonably unique id
                                    id: ConstProperty(res[i]),
                                    name: ConstProperty(res[i]),
                                    type: ConstProperty('Microphone')
                                });
                                mics.push(mic);
                            }
                            // newly selected device (if there are no devices res = [0, -1])
                            smic = mics[res[res.length - 1]];
                            // replace the device collection with the new device list
                            updateDeviceCollection(microphones, mics);
                            // TODO: note, that in some cases selectedMicrophone() != microphones(i) for any i
                            selectedMicrophone(smic || null, Property.sUpdated);
                        }
                        /**
                         * Updates the cameras collection after calling GetVideoDevicesDescription
                         * This method returns the results array that enumerates all video devices;
                         * each array element is a string that describes a single device. The last array element
                         * is the index of the currently selected device.
                         */
                        function updateVideoDevices(res) {
                            assert(res.succeeded);
                            var i, scmr, cams = [], cam;
                            // build the current device list
                            for (i = 1; i < res.length - 1; i++) {
                                cam = Model({
                                    // the media plugin doesn't give a unique id for every
                                    // camera, so name is used as a reasonably unique id
                                    id: ConstProperty(res[i]),
                                    name: ConstProperty(res[i]),
                                    type: ConstProperty('Camera'),
                                    // TODO: this associates every camera with the same video channel,
                                    // while there should be multiple video channels
                                    localVideoChannel: localVideoChannel.channel
                                });
                                cams.push(cam);
                            }
                            // newly selected device (if there are no devices res = [0, -1])
                            scmr = cams[res[res.length - 1]];
                            // replace the device collection with the new device list
                            updateDeviceCollection(cameras, cams);
                            // TODO: note, that in some cases selectedCamera() != cameras(i) for any i
                            selectedCamera(scmr || null, Property.sUpdated);
                        }
                        /**
                         * Replaces the contents of devices collection with the new device list minimizing the number
                         * of collection events fired during the update. This is achieved by adding new devices and
                         * deleting removed devices (vs. emptying the collection and filling it up from scratch).
                         */
                        function updateDeviceCollection(collDevices, devices) {
                            var keysToDelete = [];
                            // compare current device collection with the newly built set;
                            // after this array devices should contain only new devices to be
                            // added to the devices collection and keysToDelete
                            // should contain keys of the devices to be deleted from the
                            // device collection
                            collDevices.each(function (device, key) {
                                var isPresent = false, i;
                                for (i = 0; i < devices.length; i++) {
                                    if (device.id() == devices[i].id()) {
                                        isPresent = true;
                                        devices.splice(i, 1);
                                        break;
                                    }
                                }
                                if (!isPresent)
                                    keysToDelete.push(key);
                            });
                            // remove deleted devices
                            foreach(keysToDelete, function (key) {
                                collDevices.remove(key);
                            });
                            // add new devices
                            foreach(devices, function (device) {
                                collDevices.add(device);
                            });
                        }
                        return Model({
                            init: async(init),
                            uninit: async(uninit),
                            speakers: speakers.asReadOnly(),
                            microphones: microphones.asReadOnly(),
                            cameras: cameras.asReadOnly(),
                            selectedSpeaker: selectedSpeaker,
                            selectedMicrophone: selectedMicrophone,
                            selectedCamera: selectedCamera,
                            mediaCapabilities: mediaCapabilities,
                            localVideoChannel: localVideoChannel.channel
                        });
                    }
                    return PluginDevicesManager;
                }());
                Internal.PluginDevicesManager = PluginDevicesManager;
            })(Internal = Model_8.Internal || (Model_8.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_9) {
            var Internal;
            (function (Internal) {
                'use strict';
                var Model = Web.Utils.Model;
                var Property = Web.Utils.Property;
                var SourcedModel = Web.Utils.SourcedModel;
                var ConstProperty = Web.Utils.ConstProperty;
                var setHiddenProperty = Web.Utils.setHiddenProperty;
                var log = Web.Media.log;
                ;
                /**
                 * Video channel - represents a unidirectional participant's video channel
                 * used by both plugin and Ortc/webRtc media
                 *
                 */
                var VideoChannel = (function () {
                    //#endregion
                    function VideoChannel(options) {
                        if (options === void 0) { options = {}; }
                        var name = options.name, isLocal = options.isLocal, isStarted = Property(), isOnHold = Property(), isVideoOn = Property({ value: false }), streamEmpty = Web.Media.useBrowserMedia() ?
                            isLocal ? new Internal.WebRtcLocalMediaStream : new Internal.WebRtcRemoteMediaStream :
                            new Internal.MediaStream, stream = SourcedModel(streamEmpty);
                        // NB: if a property of this model may be replaced after construction by another property object, 
                        // use self object to refer to this property (for example: self.isStarted)
                        var self = Model({
                            camera: ConstProperty('unknown'),
                            stream: stream,
                            isStarted: isStarted,
                            isVideoOn: isVideoOn.asReadOnly(),
                            isOnHold: isOnHold
                        });
                        stream.setSource(streamEmpty);
                        stream.state.changed(function (newState, reason, oldState) {
                            log('VideoChannel ' + name + ' (' +
                                '): stream state: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                            if (Web.Media.useBrowserMedia()) {
                                // isStarted property may be replaced by a property with a custom setter in 
                                // Conversation#createParticipant, so we need to use _set to avoid that custom 
                                // setter invocation
                                switch (newState) {
                                    case Internal.MediaEnum.StreamState.Active:
                                        self.isStarted._set(true);
                                        break;
                                    case Internal.MediaEnum.StreamState.Stopped:
                                        self.isStarted._set(false);
                                        break;
                                }
                                if (isLocal)
                                    isVideoOn(newState == Internal.MediaEnum.StreamState.Active ||
                                        newState == Internal.MediaEnum.StreamState.Inactive);
                            }
                        });
                        setHiddenProperty(self, Internal.sInternal, {
                            isVideoOn: isVideoOn
                        });
                        return self;
                    }
                    return VideoChannel;
                }());
                Internal.VideoChannel = VideoChannel;
            })(Internal = Model_9.Internal || (Model_9.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_10) {
            var Internal;
            (function (Internal) {
                'use strict';
                var async = Web.Utils.async;
                var assert = Web.Utils.assert;
                var Model = Web.Utils.Model;
                var Command = Web.Utils.Command;
                var Property = Web.Utils.Property;
                var EnabledCommand = Web.Utils.EnabledCommand;
                var EInvalidArgument = Web.Utils.EInvalidArgument;
                var log = Web.Media.log;
                var PluginComponent = Web.Media.PluginComponent;
                /**
                 * Represents a video window used to render a video stream in a parent DOM element
                 *
                 */
                var VideoSink = (function () {
                    //#endregion
                    // args are omitted to create dummy sink models
                    function VideoSink(options) {
                        if (options === void 0) { options = {}; }
                        var mediaPlugin = options.mediaPlugin, 
                        // video window plugin component state
                        pcState = Property({ value: PluginComponent.State.Unloaded }), 
                        // the DOM element that will host the video window
                        container = Property({
                            value: options.container,
                            set: Command(function (x) { return x; }, pcState.equalsAny(PluginComponent.State.Unloaded, PluginComponent.State.Loaded))
                        }), videoFormat = Property({
                            value: Internal.MediaEnum.VideoFormat.Fit,
                            set: Command(function (x) { return x; }, pcState.equalsAny(PluginComponent.State.Unloaded, PluginComponent.State.Loaded)),
                            check: function (v) {
                                if (!(v in Internal.MediaEnum.VideoFormat))
                                    throw EInvalidArgument('format', '`format` value is Fit, Crop or Stretch.');
                            }
                        }), windowSize = Property({ value: {} }), // video window size: { width, height }
                        hRenderWindow = Property(), // render window handle (as BigInt)
                        pcVideoUI = null; // "VideoUI" plugin component
                        options = null;
                        //#region semi-public methods
                        // converts API video format enum to the plugin enum
                        function enumcastVideoFormat(vf) {
                            // match keys are MediaEnum.VideoFormat values
                            return {
                                Fit: 0 /* LetterBoxing */,
                                Crop: 1 /* Cropping */,
                                Stretch: 2 /* Stretch */
                            }[vf];
                        }
                        // Creates a video window to render incoming video and places it in the parent DOM element
                        function createVideoWindow() {
                            assert(!pcVideoUI);
                            assert(container());
                            pcVideoUI = mediaPlugin.createComponent({
                                type: 'VideoUI',
                                hide: false
                            });
                            pcVideoUI.state.changed(onPluginComponentState);
                            pcVideoUI.event(onPluginComponentEvent, 'async');
                            pcVideoUI.setContainer(container());
                            return pcVideoUI.load().then(function () {
                                var res;
                                pcVideoUI.invoke('CreateVideoUI', false); // false == no preview window
                                res = pcVideoUI.invoke('GetRenderWindow');
                                hRenderWindow(res[1]);
                            });
                        }
                        // Destroys the rendering video window thus returning the sink to the uninitialized state
                        function destroyVideoWindow() {
                            if (pcVideoUI) {
                                pcVideoUI.invoke('DestroyVideoWindows');
                                pcVideoUI.unload();
                                // Check whether you need to perform cleanup as the above line triggers the PluginComponent state change event,
                                // within which we may have already performed cleanup 
                                if (pcVideoUI) {
                                    cleanup();
                                }
                            }
                        }
                        // Resizes the video window so that it fits the parent DOM element
                        function resizeVideoWindow() {
                            assert(container());
                            pcVideoUI.invoke('ResizeWindow', container().clientWidth, container().clientHeight);
                        }
                        function cleanup() {
                            pcVideoUI.event.off(onPluginComponentEvent);
                            pcVideoUI.state.changed.off(onPluginComponentState);
                            pcState(PluginComponent.State.Unloaded);
                            pcVideoUI = null;
                            hRenderWindow(null);
                        }
                        //#endregion
                        //#region plugin event handlers
                        function onPluginComponentEvent(ev) {
                            if (ev.type == 'VIDEO_SIZE_CHANGED') {
                                windowSize({
                                    width: ev.args[0],
                                    height: ev.args[1]
                                });
                            }
                        }
                        function onPluginComponentState(state) {
                            log('Video sink ' + pcVideoUI.id() + ' pcVideoUI.state = ' + state);
                            // in destroyVideoWindow() we unsubscribe from the plugin component events right after
                            // we called unload(), so the last component state we see is Unloading. We make it
                            // the Unloaded state to enable the single check for the uninitialized (Unloaded) state
                            if (state == PluginComponent.State.Unloading)
                                state = PluginComponent.State.Unloaded;
                            // Handling of both, automatic PluginComponent unloading (Safari) and explicit unloading triggered by destroyVideoWindow (IE)
                            if (state === PluginComponent.State.Unloaded &&
                                pcState() !== PluginComponent.State.Unloaded &&
                                pcVideoUI) {
                                cleanup();
                            }
                            else {
                                pcState(state);
                            }
                        }
                        //#endregion
                        return Model({
                            container: container,
                            format: videoFormat,
                            _format: videoFormat.map(enumcastVideoFormat),
                            _init: EnabledCommand(async(createVideoWindow)),
                            _uninit: EnabledCommand(destroyVideoWindow),
                            _resize: EnabledCommand(resizeVideoWindow),
                            _videoWindow: hRenderWindow.asReadOnly(),
                            _state: pcState.asReadOnly(),
                            _size: windowSize.asReadOnly(),
                            _c: Property({ value: null }),
                            _f: Property({ value: null }) // a placeholder for format subscription
                        });
                    }
                    return VideoSink;
                }());
                Internal.VideoSink = VideoSink;
            })(Internal = Model_10.Internal || (Model_10.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="VideoSink.ts" />
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_11) {
            var Internal;
            (function (Internal) {
                'use strict';
                var setHiddenProperty = Web.Utils.setHiddenProperty;
                var Model = Web.Utils.Model;
                var Property = Web.Utils.Property;
                var BoolProperty = Web.Utils.BoolProperty;
                var log = Web.Media.log;
                /**
                 * Represents the video stream.
                 *
                 */
                var MediaStream = (function () {
                    //#endregion
                    // args are omitted when creating dummy stream models
                    function MediaStream(options) {
                        if (options === void 0) { options = {}; }
                        var state = Property({ value: Internal.MediaEnum.StreamState.Stopped }), source = Model({ sink: new Internal.VideoSink(options) }), width = Property({ value: 0 }), height = Property({ value: 0 }), 
                        // is media flowing
                        isFlowing = BoolProperty(false), 
                        // media manager channel id
                        id = Property({ value: options.id }), 
                        // is this stream attached to a participant video source
                        isAttached = Property({ value: false });
                        var self = Model({
                            state: state.asReadOnly(),
                            source: source,
                            width: width.asReadOnly(),
                            height: height.asReadOnly(),
                            _id: id,
                            _isAttached: isAttached
                        });
                        setHiddenProperty(self, '_state', state);
                        setHiddenProperty(self, '_isFlowing', isFlowing);
                        setHiddenProperty(self, '_setResolution', function (w, h) {
                            // The plugin is sending some values that is causing SWX to show stretched video
                            // So disabling this for now
                            // width(w);
                            // height(h);
                        });
                        state.changed(function (newState, reason, oldState) {
                            log('MediaStream (' + id() + '): stream state: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                        });
                        return self;
                    }
                    return MediaStream;
                }());
                Internal.MediaStream = MediaStream;
            })(Internal = Model_11.Internal || (Model_11.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                var MediaEnum;
                (function (MediaEnum) {
                    'use strict';
                    var Enum = Web.Utils.Enum;
                    var StringEnum = Web.Utils.StringEnum;
                    MediaEnum.PreferredMediaAddressType = Enum('None', 'Direct', 'Relay');
                    MediaEnum.MediaDeviceType = Enum('MIC', 'SPEAKER', 'PREVIEW', 'RENDER');
                    MediaEnum.VideoFormat = StringEnum('Fit', 'Crop', 'Stretch');
                    MediaEnum.NegotiationStatus = Enum('NS_SUCCESS', 'NS_LOCAL_INTERNAL_ERROR', 'NS_REMOTE_INTERNAL_ERROR', 'NS_OFFER_NOT_ACCEPTABLE', 'NS_OFFER_DECLINED', 'NS_LOCAL_CANCEL', 'NS_REMOTE_CANCEL', 'NS_REMOTE_MIME_UNSPPORTED');
                    MediaEnum.MediaEvent = StringEnum('OFFER_READY', 'CHANNEL_CREATED', 'CHANNEL_DELETED', 'ANSWER_READY', 'CONNECTIVITY_CHECK_STATUS', 'MEDIA_CHANGED', 'INVALID_PROXY_CREDENTIAL');
                    MediaEnum.AVEvent = StringEnum('DEVICE_INTENSITY_CHANGED', 'VIDEO_SIZE_CHANGED', 'NEG_STATUS', 'CHANNEL_DIRECTION_CHANGED', 'CHANNEL_DISCONNECTED', 'QUALITY_CHANGED', 'AUDIO_DEVICE_CHANGED', 'VIDEO_DEVICE_CHANGED', 'DOMINANT_SPEKAER_CHANGED', // do not correct: plugin returns this typo
                    'SUBSCRIPTION_STATE_CHANGED', 'CONTRIBUTING_SOURCES_CHANGED', 'VIDEO_CAPABILITY_CHANGED');
                    MediaEnum.StreamState = StringEnum('Stopped', 'Started', 'Inactive', 'Active');
                    MediaEnum.StreamType = Enum('Preview', // self camera capture (video sent on the main video channel)
                    'MainRender', // video received on the main video channel
                    'Render' // video received on an additional video channel
                    );
                    MediaEnum.DtmfTone = Enum('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'Star', 'Pound', 'A', 'B', 'C', 'D', 'Flash', '*', '#');
                    function enumcastDirection(direction) {
                        // fortunately MediaConfig enumerates media in the same order:
                        // { NOT_PRESENT, SEND, RECEIVE, BOTH, NO_ACTIVE_MEDIA }
                        var e;
                        (function (e) {
                            e[e[""] = 0] = "";
                            e[e["sendonly"] = 1] = "sendonly";
                            e[e["recvonly"] = 2] = "recvonly";
                            e[e["sendrecv"] = 3] = "sendrecv";
                            e[e["inactive"] = 4] = "inactive";
                        })(e || (e = {}));
                        ;
                        return e[direction];
                    }
                    MediaEnum.enumcastDirection = enumcastDirection;
                    function enumcastMediaConfig(mc) {
                        // fortunately MediaConfig enumerates media in the same order:
                        // { NOT_PRESENT, SEND, RECEIVE, BOTH, NO_ACTIVE_MEDIA }
                        return ['', 'sendonly', 'recvonly', 'sendrecv', 'inactive'][mc];
                    }
                    MediaEnum.enumcastMediaConfig = enumcastMediaConfig;
                    function enumcastStreamState(meState) {
                        var ss = MediaEnum.StreamState, state;
                        switch (meState) {
                            case 1 /* STREAM_STARTED */:
                                state = ss.Started;
                                break;
                            case 2 /* STREAM_ACTIVE */:
                                state = ss.Active;
                                break;
                            case 3 /* STREAM_INACTIVE */:
                                state = ss.Inactive;
                                break;
                            case 4 /* STREAM_STOPPED */:
                                state = ss.Stopped;
                                break;
                        }
                        return state;
                    }
                    MediaEnum.enumcastStreamState = enumcastStreamState;
                })(MediaEnum = Internal.MediaEnum || (Internal.MediaEnum = {}));
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_12) {
            var Internal;
            (function (Internal) {
                'use strict';
                var setHiddenProperty = Web.Utils.setHiddenProperty;
                var Task = Web.Utils.Task;
                var Model = Web.Utils.Model;
                var Symbol = Web.Utils.Symbol;
                var Promise = Web.Utils.Promise;
                var Command = Web.Utils.Command;
                var Property = Web.Utils.Property;
                var log = Web.Media.log;
                // renderening temporarily stopped
                var sTmpStopped = Symbol('tmpStopped');
                /**
                 * Represents the letterboxed video stream sink
                 *
                 */
                var LetterboxedVideoSink = (function () {
                    function LetterboxedVideoSink(options) {
                        if (options === void 0) { options = {}; }
                        var container = Property({
                            value: options.container
                        });
                        var format = Property({
                            value: Internal.MediaEnum.VideoFormat.Fit,
                            set: function (v) { return Internal.MediaEnum.VideoFormat.Fit; }
                        });
                        return Model({
                            container: container,
                            format: format,
                            _c: Property({ value: null }) // a placeholder for container subscription                
                        });
                    }
                    return LetterboxedVideoSink;
                }());
                Internal.LetterboxedVideoSink = LetterboxedVideoSink;
                /**
                 * Represents the remote video stream.
                 *
                 */
                var WebRtcRemoteMediaStream = (function () {
                    // args are omitted when creating dummy stream models
                    function WebRtcRemoteMediaStream(options) {
                        if (options === void 0) { options = {}; }
                        var state = Property({ value: Internal.MediaEnum.StreamState.Stopped }), source = Model({ sink: new LetterboxedVideoSink }), width = Property({ value: 0 }), height = Property({ value: 0 }), mediaSession = Property({ value: options.mediaSession }), renderer, 
                        // stream id (msi)
                        id = Property({ value: -2 }), // subscribe any
                        // is this stream attached to a participant video source
                        isAttached = Property({ value: false }), 
                        // is rendering video
                        isRendering = Property({
                            value: false,
                            set: Command(render, mediaSession.map(function (v) { return !!v; }))
                        }), isPending = false;
                        var self = Model({
                            state: state.asReadOnly(),
                            source: source,
                            width: width.asReadOnly(),
                            height: height.asReadOnly(),
                            _id: id,
                            _isRendering: isRendering,
                            _isAttached: isAttached
                        });
                        var rendererCallback = {
                            onVideoSizeChanged: function (w, h) {
                                log('WebRtcRemoteMediaStream: onVideoSizeChanged ' + w + ' X ' + h);
                                if (w && h)
                                    state(Internal.MediaEnum.StreamState.Active);
                                width(w);
                                height(h);
                            }
                        };
                        setHiddenProperty(self, '_state', state);
                        setHiddenProperty(self, '_mediaSession', mediaSession);
                        state.changed(function (newState, reason, oldState) {
                            log('MediaStream (' + id() + '): stream state: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                        });
                        function idAndContainerChangeHandler(isSet) {
                            return function (newVal, reason, oldVal) {
                                if (isRendering() || isPending) {
                                    var promise = isSet(oldVal) ? isRendering.set(false, sTmpStopped) : Promise.resolve(false);
                                    if (isSet(newVal))
                                        promise.then(function () { return isRendering.set(true); });
                                    else
                                        promise.then(function () { return isPending = true; });
                                }
                            };
                        }
                        id.changed(idAndContainerChangeHandler(function (x) { return x > 0; }));
                        source.sink.container.changed(idAndContainerChangeHandler(function (x) { return !!x; }));
                        function render(val, reason) {
                            isPending = false;
                            if (val) {
                                // remember the value if the container and the stream id are not set
                                // the video will render once the container is set (see the container change listener above),
                                // and once the id is set (see the id change listener above)
                                // we check for id() === -1 as stream id of -1 represents a stream that was previously assigned to a participant's video channel,
                                // in a conference call. We do not check for id() === -2 as that represents a stream of a participant's video channel in P2P call 
                                if (!source.sink.container() || id() === -1) {
                                    isPending = true;
                                    return Promise.resolve(!val);
                                }
                                renderer = renderer || mediaSession().createRemoteRenderer(source.sink.container(), rendererCallback);
                                var element = renderer.getVideoElement();
                                element.style.width = '100%';
                                element.style.height = '100%';
                                return Task.run(function () {
                                    var promise = renderer.subscribeVideoAsync(id());
                                    if (state() == Internal.MediaEnum.StreamState.Stopped)
                                        state(Internal.MediaEnum.StreamState.Started);
                                    return promise;
                                }).then(function () {
                                    // Sometimes the callback 'onVideoSizeChanged' is triggered before subscribeVideoAsync
                                    // completes, which means this would set the mediaStream to inactive after it's already
                                    // been set to active                       
                                    if (state() != Internal.MediaEnum.StreamState.Active)
                                        state(Internal.MediaEnum.StreamState.Inactive);
                                    return val;
                                }).catch(function (err) {
                                    state(Internal.MediaEnum.StreamState.Stopped, err);
                                    return !val;
                                });
                            }
                            else {
                                renderer && renderer.dispose();
                                renderer = null;
                                state(reason === sTmpStopped ? Internal.MediaEnum.StreamState.Inactive : Internal.MediaEnum.StreamState.Stopped);
                                return Promise.resolve(val);
                            }
                        }
                        return self;
                    }
                    return WebRtcRemoteMediaStream;
                }());
                Internal.WebRtcRemoteMediaStream = WebRtcRemoteMediaStream;
                /**
                 * Represents the local video stream.
                 *
                 */
                var WebRtcLocalMediaStream = (function () {
                    // args are omitted when creating dummy stream models
                    function WebRtcLocalMediaStream(options) {
                        if (options === void 0) { options = {}; }
                        var state = Property({ value: Internal.MediaEnum.StreamState.Stopped }), source = Model({ sink: new LetterboxedVideoSink }), width = Property({ value: 0 }), height = Property({ value: 0 }), deviceManager = Property({ value: options.deviceManager }), renderer, 
                        // stream id (parent device id)
                        id = Property({ value: options.deviceId }), 
                        // is this stream attached to a participant video source
                        isAttached = Property({ value: false }), 
                        // is rendering video
                        isRendering = Property({
                            value: false,
                            set: Command(render, deviceManager.map(function (v) { return !!v; }))
                        }), isPending = false;
                        var self = Model({
                            state: state.asReadOnly(),
                            source: source,
                            width: width.asReadOnly(),
                            height: height.asReadOnly(),
                            _id: id,
                            _isRendering: isRendering,
                            _isAttached: isAttached
                        });
                        var rendererCallback = {
                            onVideoSizeChanged: function (w, h) {
                                log('WebRtcLocalMediaStream: onVideoSizeChanged ' + w + ' X ' + h);
                                if (w && h)
                                    state(Internal.MediaEnum.StreamState.Active);
                                width(w);
                                height(h);
                            }
                        };
                        setHiddenProperty(self, '_state', state);
                        setHiddenProperty(self, '_deviceManager', deviceManager);
                        state.changed(function (newState, reason, oldState) {
                            log('MediaStream (' + id() + '): stream state: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                        });
                        source.sink.container.changed(function (newVal, reason, oldVal) {
                            if (isRendering() || isPending) {
                                var promise = oldVal ? isRendering.set(false, sTmpStopped) : Promise.resolve(false);
                                if (newVal)
                                    promise.then(function () { return isRendering.set(true); });
                                else
                                    promise.then(function () { return isPending = true; });
                            }
                        });
                        function render(val, reason) {
                            isPending = false;
                            if (val) {
                                // remember the value if the container is not set - the video will render  
                                // once the container is set (see the container change listener above)
                                if (!source.sink.container()) {
                                    isPending = true;
                                    return Promise.resolve(!val);
                                }
                                renderer = renderer || deviceManager().createPreviewRenderer(source.sink.container(), rendererCallback);
                                var element = renderer.getVideoElement();
                                element.style.width = '100%';
                                element.style.height = '100%';
                                return Task.run(function () {
                                    var promise = renderer.startVideoAsync();
                                    if (state() == Internal.MediaEnum.StreamState.Stopped)
                                        state(Internal.MediaEnum.StreamState.Started);
                                    return promise;
                                }).then(function () {
                                    // Sometimes the callback 'onVideoSizeChanged' is triggered before startVideoAsync
                                    // completes, which means this would set the mediaStream to inactive after it's already
                                    // been set to active
                                    if (state() != Internal.MediaEnum.StreamState.Active)
                                        state(Internal.MediaEnum.StreamState.Inactive);
                                    return val;
                                }).catch(function (err) {
                                    state(Internal.MediaEnum.StreamState.Stopped, err);
                                    return !val;
                                });
                            }
                            else {
                                renderer && renderer.dispose();
                                renderer = null;
                                state(reason === sTmpStopped ? Internal.MediaEnum.StreamState.Inactive : Internal.MediaEnum.StreamState.Stopped);
                                return Promise.resolve(val);
                            }
                        }
                        return self;
                    }
                    return WebRtcLocalMediaStream;
                }());
                Internal.WebRtcLocalMediaStream = WebRtcLocalMediaStream;
            })(Internal = Model_12.Internal || (Model_12.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="WebRtcMediaStream.ts" />
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_13) {
            var Internal;
            (function (Internal) {
                'use strict';
                var assert = Web.Utils.assert;
                var Model = Web.Utils.Model;
                var Property = Web.Utils.Property;
                var log = Web.Media.log;
                /**
                 * Local video channel - used to render local video
                 *
                 * Used for camera video preview in DevicesManager
                 *
                 */
                var WebRtcLocalVideoChannel = (function () {
                    //#endregion
                    function WebRtcLocalVideoChannel(options) {
                        var devicesManager = options.devicesManager, parentDevice = options.parentDevice, cameraName = Property({
                            value: parentDevice.name() || parentDevice.id()
                        }), isStarted = Property({
                            value: false,
                            set: localVideoSetter
                        }), isOnHold = Property(), stream = new Internal.WebRtcLocalMediaStream({ deviceId: parentDevice.id() });
                        // NB: if a property of this model may be replaced after construction by another property object, 
                        // use self object to refer to this property (for example: self.isStarted)
                        var self = Model({
                            camera: cameraName.asReadOnly(),
                            stream: stream,
                            isStarted: isStarted,
                            isVideoOn: isStarted.asReadOnly(),
                            isOnHold: isOnHold
                        });
                        assert(devicesManager);
                        stream.state.changed(function (newState, reason, oldState) {
                            log('VideoChannel ' + cameraName() + ' (' + stream['_id']() +
                                '): stream state: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                        });
                        function localVideoSetter(val) {
                            if (val) {
                                // if the parent camera is not the selected camera, make it the new selected camera 
                                var selectedCamera = devicesManager.selectedCamera();
                                if (selectedCamera && selectedCamera.id() != parentDevice.id()) {
                                    var parents = devicesManager.cameras.filter(function (cam) { return cam.id() == parentDevice.id(); });
                                    assert(parents.size() == 1);
                                    devicesManager.selectedCamera(parents(0));
                                }
                                stream._deviceManager(devicesManager['_dm']());
                            }
                            return stream._isRendering.set(val);
                        }
                        return self;
                    }
                    return WebRtcLocalVideoChannel;
                }());
                Internal.WebRtcLocalVideoChannel = WebRtcLocalVideoChannel;
            })(Internal = Model_13.Internal || (Model_13.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="WebRtcLocalVideoChannel.ts" />
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_14) {
            var Internal;
            (function (Internal) {
                'use strict';
                var find = Web.Utils.find;
                var async = Web.Utils.async;
                var inherit = Web.Utils.inherit;
                var foreach = Web.Utils.foreach;
                var Task = Web.Utils.Task;
                var Model = Web.Utils.Model;
                var Promise = Web.Utils.Promise;
                var Property = Web.Utils.Property;
                var Collection = Web.Utils.Collection;
                var ConstProperty = Web.Utils.ConstProperty;
                var setHiddenProperty = Web.Utils.setHiddenProperty;
                var log = Web.Media.log;
                /**
                 * Represents an audio or video device.
                 *
                 */
                var WebRtcDevice = (function () {
                    function WebRtcDevice(device, pname) {
                        var name = Property({ value: device.label });
                        function capitalize(w) {
                            return w[0].toUpperCase() + w.substr(1).toLowerCase();
                        }
                        pname.then(function (val) { return name(val); });
                        return Model({
                            id: ConstProperty(device.id),
                            name: name.asReadOnly(),
                            type: ConstProperty(capitalize(device.kind))
                        });
                    }
                    return WebRtcDevice;
                }());
                Internal.WebRtcDevice = WebRtcDevice;
                /**
                 * Holds collections of audio and video devices.
                 *
                 */
                var WebRtcDevicesManager = (function () {
                    //#endregion
                    function WebRtcDevicesManager(ucwa) {
                        var microphones = Collection({ subscribed: init, get: init });
                        var speakers = Collection({ subscribed: init, get: init });
                        var cameras = Collection({ subscribed: init, get: init });
                        var selectedMicrophone = Property({
                            set: function (mic) {
                                selectMediaDevices(mic, selectedCamera());
                                return mic;
                            }
                        });
                        var selectedCamera = Property({
                            set: function (cam) {
                                selectMediaDevices(selectedMicrophone(), cam);
                                return cam;
                            }
                        });
                        // Browser media does not allow speaker selection, so we always show a fake
                        // default speaker
                        var selectedSpeaker = ConstProperty({
                            id: ConstProperty('default_speaker'),
                            name: ConstProperty('Default Speaker'),
                            type: ConstProperty('Speaker'),
                            readOnly: true
                        });
                        speakers.add(Model({
                            id: ConstProperty('default_speaker'),
                            name: ConstProperty('Default Speaker'),
                            type: ConstProperty('Speaker')
                        }));
                        var mediaAgent;
                        var deviceManager;
                        var devicesSub;
                        var permissionsSub;
                        var selectedMicId = Property();
                        var selectedCameraId = Property();
                        var isBrowserMediaSupported = Property({
                            // this value should stay once initialized 
                            value: !!Web.Media.MediaAgent.isPlatformSupported()
                        });
                        // stays undefined for WebRTC
                        var isPluginInstalled = Property({
                            value: void 0,
                            reason: 'NotNeeded'
                        });
                        // stays undefined for WebRTC
                        var installedVersion = Property({
                            value: void 0,
                            reason: 'NotNeeded'
                        });
                        var isMicrophoneEnabled = Property.bool(false);
                        var isCameraEnabled = Property.bool(false);
                        // stays empty for WebRTC
                        var pluginDownloadLinks = Collection();
                        var mediaCapabilities = {
                            isBrowserMediaSupported: isBrowserMediaSupported.asReadOnly(),
                            isPluginInstalled: isPluginInstalled.asReadOnly(),
                            installedVersion: installedVersion.asReadOnly(),
                            pluginDownloadLinks: pluginDownloadLinks.asReadOnly(),
                            isMicrophoneEnabled: isMicrophoneEnabled.asReadOnly(),
                            isCameraEnabled: isCameraEnabled.asReadOnly()
                        };
                        // placeholder for the JAMA's DeviceManager; exposed as a hidden property
                        // to be used by other media objects.
                        var _dm = Property();
                        var self;
                        /** initializes devices manager - fills out devices collections */
                        function init() {
                            if (!mediaAgent) {
                                mediaAgent = Web.Media.getMediaAgent(ucwa);
                                deviceManager = mediaAgent.getDeviceManager();
                                _dm(deviceManager);
                                if (!devicesSub) {
                                    devicesSub = mediaAgent.devicesChanged(function (devices) { return updateDevices(devices); });
                                }
                                if (!permissionsSub) {
                                    permissionsSub = mediaAgent.permissionsChanged(function (permissions) {
                                        permissions && isMicrophoneEnabled(permissions.hasMicrophonePermission);
                                        permissions && isCameraEnabled(permissions.hasCameraPermission);
                                    });
                                }
                                return Promise.resolve().then(function () {
                                    return deviceManager.getDefaultDevices();
                                }).then(function (devices) {
                                    var mic = find(devices, function (device) { return device.kind == 'microphone'; });
                                    var cam = find(devices, function (device) { return device.kind == 'camera'; });
                                    if (!mic || !cam)
                                        throw 'No default device found';
                                    var micid = mic.id;
                                    var camid = cam.id;
                                    deviceManager.selectDevices({
                                        microphone: micid,
                                        camera: camid
                                    });
                                    if (micid != 'default' && micid != 'default_audio_device')
                                        selectedMicId(micid);
                                    if (camid != 'default' && camid != 'default_video_device')
                                        selectedCameraId(camid);
                                }).catch(function (err) {
                                    return log('Cannot get device ID from track!', err);
                                }).then(function () { return deviceManager.enumerateDevicesAsync(); }).then(function (devices) { return updateDevices(devices); }).then(function () {
                                    // the empty then clause is needed to return void rather than the devices dictionary
                                });
                            }
                        }
                        function uninit() {
                            for (var _i = 0, _a = cameras(); _i < _a.length; _i++) {
                                var cam = _a[_i];
                                cam.localVideoChannel.isStarted(false);
                            }
                            if (devicesSub) {
                                devicesSub.dispose();
                                devicesSub = null;
                            }
                            if (permissionsSub) {
                                permissionsSub.dispose();
                                permissionsSub = null;
                            }
                            mediaAgent = null;
                            deviceManager = null;
                            return _dm.set(null);
                        }
                        function selectMediaDevices(mic, camera) {
                            if (mic && camera) {
                                deviceManager.selectDevices({
                                    microphone: mic.id(),
                                    camera: camera.id()
                                });
                                selectedMicId(mic.id());
                                selectedCameraId(camera.id());
                            }
                        }
                        function updateDevices(devices) {
                            var mics = [], cams = [], promises = [];
                            var _loop_6 = function (device) {
                                var promise = Task.run(function () { return deviceManager.getDeviceNameAsync(device.id); });
                                var dm = new WebRtcDevice(device, promise);
                                promises.push(promise);
                                if (dm.type() == 'Camera' &&
                                    dm.id() != 'default_video_device' &&
                                    dm.id() != 'default') {
                                    var camera = inherit(dm, {
                                        localVideoChannel: new Internal.WebRtcLocalVideoChannel({
                                            devicesManager: self,
                                            parentDevice: dm
                                        })
                                    });
                                    cams.push(camera);
                                }
                                else if (dm.type() == 'Microphone' &&
                                    dm.id() != 'communications' &&
                                    dm.id() != 'default_audio_device' &&
                                    dm.id() != 'default') {
                                    // The check above is needed because Chrome adds a mic designated as 
                                    // the communications device once again with id = 'communications'
                                    mics.push(dm);
                                }
                            };
                            // build the current device list
                            for (var _i = 0, devices_1 = devices; _i < devices_1.length; _i++) {
                                var device = devices_1[_i];
                                _loop_6(device);
                            }
                            return Promise.all(promises).then(function () {
                                // replace device collections with new device lists
                                updateDeviceCollection(microphones, mics);
                                updateDeviceCollection(cameras, cams);
                                // replace selected devices if needed. Note, that selected devices may be undefined 
                                updateSelectedDevice(microphones, selectedMicrophone, selectedMicId);
                                updateSelectedDevice(cameras, selectedCamera, selectedCameraId);
                            });
                        }
                        function updateSelectedDevice(collDevices, selectedDevice, selectedDeviceId) {
                            var selected;
                            if (selectedDeviceId()) {
                                // ...try to find the device with that id in the devices collection
                                collDevices.each(function (device, key) {
                                    if (device.id() == selectedDeviceId()) {
                                        selected = device;
                                    }
                                });
                                if (!selected) {
                                    // undefine if the selected device was removed
                                    selectedDevice(void 0, Property.sUpdated);
                                    selectedDeviceId(void 0);
                                }
                                else if (!selectedDevice() || selectedDevice().id() != selected.id()) {
                                    // set new selected device if it was not previously set, or if a new device was selected
                                    selectedDevice(selected, Property.sUpdated);
                                }
                            }
                            else if (collDevices.size() == 1) {
                                // ...then it is the selected device 
                                selectedDevice(collDevices(0), Property.sUpdated);
                                selectedDeviceId(collDevices(0).id());
                            }
                        }
                        /**
                         * Replaces the contents of devices collection with the new device list minimizing the number
                         * of collection events fired during the update. This is achieved by adding new devices and
                         * deleting removed devices (vs. emptying the collection and filling it up from scratch).
                         */
                        function updateDeviceCollection(collDevices, devices) {
                            var keysToDelete = [];
                            // compare current device collection with the newly built set;
                            // after this, array devices should contain only new devices to be
                            // added to the devices collection and keysToDelete
                            // should contain keys of the devices to be deleted from the
                            // devices collection
                            collDevices.each(function (device, key) {
                                var isPresent = false;
                                for (var i = 0; i < devices.length; i++) {
                                    if (device.id() == devices[i].id()) {
                                        isPresent = true;
                                        devices.splice(i, 1);
                                        break;
                                    }
                                }
                                if (!isPresent)
                                    keysToDelete.push(key);
                            });
                            // remove deleted devices
                            foreach(keysToDelete, function (key) { return collDevices.remove(key); });
                            // add new devices
                            foreach(devices, function (device) { return collDevices.add(device); });
                        }
                        self = Model({
                            init: async(init),
                            uninit: async(uninit),
                            speakers: speakers.asReadOnly(),
                            microphones: microphones.asReadOnly(),
                            cameras: cameras.asReadOnly(),
                            selectedSpeaker: selectedSpeaker,
                            selectedMicrophone: selectedMicrophone,
                            selectedCamera: selectedCamera,
                            mediaCapabilities: mediaCapabilities
                        });
                        setHiddenProperty(self, '_dm', _dm);
                        return self;
                    }
                    return WebRtcDevicesManager;
                }());
                Internal.WebRtcDevicesManager = WebRtcDevicesManager;
            })(Internal = Model_14.Internal || (Model_14.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="ucwa.ts" />
/// <reference path="media.ts" />
/// <reference path="model/MediaPolicies.ts" />
/// <reference path="model/MediaPlugin.ts" />
/// <reference path="model/MediaConfig.ts" />
/// <reference path="model/as/AppSharingModality.ts" />
/// <reference path="model/as/Window.ts" />
/// <reference path="model/as/Monitor.ts" />
/// <reference path="model/as/SharedResources.ts" />
/// <reference path="model/as/Invitation.ts" />
/// <reference path="model/as/AppSharing.ts" />
/// <reference path="model/av/AudioVideoModality.ts" />
/// <reference path="model/av/PhoneAudio.ts" />
/// <reference path="model/av/PhoneDialInInformation.ts" />
/// <reference path="model/av/SDP.ts" />
/// <reference path="model/av/DevicesManager.ts" />
/// <reference path="model/av/VideoChannel.ts" />
/// <reference path="model/av/MediaStream.ts" />
/// <reference path="model/av/MediaEnum.ts" />
/// <reference path="model/av/WebRtcDevicesManager.ts" />
"use strict";
"use strict";
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_15) {
            var Internal;
            (function (Internal) {
                var foreach = Web.Utils.foreach;
                var batched = Web.Utils.batched;
                var deepEqual = Web.Utils.deepEqual;
                var isArray = Web.Utils.isArray;
                var isFunction = Web.Utils.isFunction;
                var isProperty = Web.Utils.isProperty;
                var setHiddenProperty = Web.Utils.setHiddenProperty;
                var Model = Web.Utils.Model;
                var Symbol = Web.Utils.Symbol;
                var Command = Web.Utils.Command;
                var Property = Web.Utils.Property;
                var Exception = Web.Utils.Exception;
                var Collection = Web.Utils.Collection;
                var ConstProperty = Web.Utils.ConstProperty;
                var ENotSupported = Web.Utils.ENotSupported;
                var Resource = Web.Stack.Resource;
                /** It's used to distinguish the case when a property is updated
                    after an event from UCWA from the case when someone invokes
                    Property::set. */
                var sUpdated = Symbol('updated');
                /** Used to attach hidden fields to created properties and collections.
                    Essentially, it's a simulation of WeakMap from ES6. */
                var sDescriptor = Symbol('hidden');
                var Descriptor = (function () {
                    function Descriptor(describe) {
                        var _this = this;
                        /**
                         * Properties that need to be exposed in the model.
                         *
                         *  This is a mapping from a property name to a parsing function which is,
                         *  in most cases, the identity function that returns whatever it's given:
                         *
                         *      properties: {
                         *          name: function (value) { return value },
                         *          uri: function (value) { return value },
                         *          id: function (value) { return +value }
                         *      }
                         *
                         *  Each property can provide the following additional information:
                         *
                         *      parse - method to change resource value to property representation
                         *      convert - method to change property value to resource value
                         *      prepare - method to change value prior to sending PUT
                         *      readOnly - the property is read-only even if other properties are not
                         *
                         *  Example:
                         *
                         *      expirationTime: {
                         *          parse: timeStampToDate,
                         *          convert: dateToTimeStamp,
                         *          prepare: function (val) {
                         *              return val.toJSON();
                         *          }
                         *      }
                         *
                         *  The property may be set using a Date object which will need to be compared against the
                         *  resource representation and modified to properly send in the PUT request.
                         */
                        this.properties = {};
                        /**
                         * Commands that need to be exposed in the model.
                         *
                         *  In the current version, only the 'enabled' property in each exposed command
                         *  is implemented. This read-only property is associated with whether the
                         *  resource contains the corresponding link.
                         */
                        this.commands = {};
                        /**
                         * Some resources contain a collection of links to other resources.
                         * For instance, the contact list is represented by UCWA this way:
                         *
                         *      /myContacts
                         *          /contact[x]
                         *              displayName
                         *              uri
                         *
                         * Such collections of links can be mapped to collections of models.
                         */
                        this.collections = {};
                        /**
                         * Some resources contain other resources.
                         * A good example is /application/communication.
                         */
                        this.members = {};
                        // note how arrow functions capture the outer `this` value
                        describe({
                            member: function (name, describe) {
                                _this.members[name] = new Descriptor(describe);
                            },
                            command: function (name) {
                                _this.commands[name] = {};
                            },
                            property: function (name, desc) {
                                _this.properties[name] = desc || {};
                            },
                            collection: function (name, describe) {
                                _this.collections[name] = isArray(describe) ? describe[0] : new Descriptor(describe);
                            }
                        });
                    }
                    return Descriptor;
                }());
                /**
                 * Wraps a UCWA resource into an observable model by mapping properties of the
                 * resource to observable properties of the model.
                 *
                 *      ObservableResource(ucwa, "/contacts/johndoe", $ => {
                 *          $.property('uri');
                 *          $.property('name');
                 *          $.member('contactPresence', $ => {
                 *              $.property('availability');
                 *              $.property('activity');
                 *              $.property('activeSince', s => new Date(/\d+/.exec(s)[0]));
                 *          });
                 *      });
                 *
                 * Resources that contain an `etag` can be updated by the supplied properties
                 * (that are not marked as read-only) which will create a PUT request to send
                 * an aggregated update.
                 *
                 */
                function ObservableResource(ucwa, source, describe) {
                    var dfdget;
                    var self = Model();
                    var collections = {}; // collections are indexed by hrefs
                    var properties = {};
                    var commands = {};
                    var members = {}; // hrefs
                    var writable = Property({ value: false, reason: Exception('Disconnected') });
                    var descriptor = isFunction(describe) ?
                        new Descriptor(describe) :
                        describe; // unit tests can pass raw descriptors
                    /** When one observable creates a nested observable resource,
                        it gives to the latter a Property<string> which is able
                        to fetch the href on demand. So if there's a chain of
                        nested resources, a request from the last resource will
                        be nicely chained up to the root resource. */
                    var resource = Property({
                        value: null,
                        // the app may not be signed in at the moment
                        get: function () { return resource() || ucwa.init()
                            .then(function () { return isProperty(source) ? source.get() : source; })
                            .then(function (href) { return ucwa.get(href); }); } // the .get() should fail if the resource isn't available
                    });
                    var changeProperty = batched(function (requests) {
                        var r = resource(); // by this moment the resource should be available
                        var snapshot = r.getSnapshot();
                        var data = {}; // this is what will be sent in the PUT request
                        var changed = false;
                        for (var _i = 0, requests_3 = requests; _i < requests_3.length; _i++) {
                            var _a = requests_3[_i], name_9 = _a[0], value = _a[1];
                            var p = properties[name_9];
                            var $ = p[sDescriptor];
                            var oldVal = snapshot[name_9];
                            var newVal = $.convert ? $.convert(value) : value; // new Date(123) => "/Date(123)/"
                            // TODO: if the user changes a property value multiple times:
                            // model.prop(1), model.prop(2), model.prop(1) then this code
                            // will send the PUT request anyway, despite it's not needed
                            if (!deepEqual(newVal, oldVal)) {
                                changed = true;
                                snapshot[name_9] = newVal;
                            }
                        }
                        if (changed) {
                            foreach(snapshot, function (value, name) {
                                var p = properties[name];
                                var $ = p && p[sDescriptor];
                                data[name] = $ && $.prepare ?
                                    $.prepare($.parse(value)) :
                                    value;
                            });
                            return ucwa.send('PUT', r.href, { data: data });
                        }
                    }, Infinity);
                    function fetch() {
                        var promise = dfdget || resource.get().then(function (r) { return ucwa.send('GET', r.href); });
                        dfdget = promise;
                        // if GET fails, allow further attempts to send it again;
                        // note, that in unit tests .then(...) doesn't add a delay
                        dfdget.then(null, function () { dfdget = null; });
                        return promise;
                    }
                    foreach(descriptor.collections, function (desc, name) {
                        var items = Collection({
                            subscribed: fetch,
                            // it might be temping to check if the links are there
                            // and skip the ucwa.send call, but this would be a mistake
                            // because the list of links may change without a notice;
                            // for instance, /conversationLogs/conversationLog[i] links
                            // may change and in some cases there will be a "missedItems updated"
                            // event with a new number of conversation logs, but there will
                            // be no events directly related to /conversationLogs resource
                            get: function () { return resource.get()
                                .then(function (r) { return fetch(); })
                                .then(function (r) { return null; }); }
                        });
                        items[sDescriptor] = desc;
                        collections[name] = items;
                        self[name] = items.asReadOnly();
                    });
                    foreach(descriptor.properties, function (_data, name) {
                        var data = (isFunction(_data) ? { parse: _data } : _data);
                        if (!data.parse)
                            data.parse = function (x) { return x; };
                        var p = Property({
                            subscribed: fetch,
                            get: function () { return resource.get().then(function (r) {
                                return r.has(name) ? p() : fetch().then(function () { return p(); });
                            }); }
                        });
                        // if the property isn't there, it cannot be changed
                        var set = function (value) { return !resource() ? value : resource.get()
                            .then(function (r) { return changeProperty([name, value], 0); })
                            .then(function () { return p(); }); };
                        p[sDescriptor] = data;
                        properties[name] = p;
                        var canWrite = data.readOnly ? ConstProperty(false) :
                            data.canInit ? Property.computed([resource, writable], function (r, w) { return !r || w; }) :
                                writable;
                        self[name] = p.fork(Command(set, canWrite));
                    });
                    foreach(descriptor.commands, function (data, name) {
                        var enabled = Property({
                            get: function () { return resource.get()
                                .then(function (r) { return !r.hasLink(name) && fetch(); })
                                .then(function (r) { return r.hasLink(name); }); }
                        });
                        commands[name] = { enabled: enabled };
                        self[name] = Command(function () { throw ENotSupported(); }, enabled.asReadOnly());
                    });
                    foreach(descriptor.members, function (desc, name) {
                        var href = Property({
                            // the value of href is set by the Resource::updated handler
                            get: function () { return href() || fetch().then(function (r) { return r.link(name).href; }); }
                        });
                        members[name] = href;
                        self[name] = ObservableResource(ucwa, href.asReadOnly(), desc);
                    });
                    ucwa.init().then(function () {
                        if (source instanceof Resource)
                            resource(source);
                        else if (isProperty(source))
                            source.changed(function (href) { return resource(ucwa.get(href)); });
                        else if (ucwa.exists(source))
                            resource(ucwa.get(source));
                    });
                    // start observing the resource once it becomes available
                    resource.once(function (r) { return !!r; }, function () {
                        var r = resource();
                        setHiddenProperty(self, Internal.sHref, r.href);
                        r.updated(function () {
                            writable(r.has('etag'), Exception('ETagMissing'));
                            foreach(collections, function (items, name) {
                                // items are added when new links appear
                                for (var _i = 0, _a = r.links(name); _i < _a.length; _i++) {
                                    var link = _a[_i];
                                    if (!items(link.href)) {
                                        var desc = items[sDescriptor];
                                        var item = isFunction(desc) ? desc(link.href) : ObservableResource(ucwa, link.href, desc);
                                        items.add(item, link.href);
                                    }
                                }
                            });
                            foreach(properties, function (p, name) {
                                var parse = p[sDescriptor].parse;
                                var value = r.has(name) ? parse(r.get(name)) : void 0;
                                p(value, sUpdated); // a custom reason invokes all observers
                            });
                            foreach(commands, function (m, name) {
                                m.enabled(r.hasLink(name));
                            });
                            foreach(members, function (href, name) {
                                if (r.hasLink(name))
                                    href(r.link(name).href);
                            });
                        });
                        r.dirty.when(true, function () {
                            dfdget = null;
                        });
                    });
                    return self;
                }
                Internal.ObservableResource = ObservableResource;
            })(Internal = Model_15.Internal || (Model_15.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                /**
                 * Wraps the rel=policies resource into an observable model.
                 *
                 * rel=policies represents the admin policies that can apply to a user's application.
                 * Policies include information such as whether emoticons are allowed in messages
                 * or photos are enabled for contacts in the user's organization. Note that policies
                 * are set by the admin; they cannot be changed by the user.
                 *
                 */
                var GeneralPolicies = (function () {
                    //#endregion
                    function GeneralPolicies(ucwa) {
                        return Internal.ObservableResource(ucwa, { rel: 'policies' }, function ($) {
                            $.property('audioOnlyOnWifi');
                            $.property('callLogArchiving');
                            $.property('customerExperienceImprovementProgram');
                            $.property('emergencyDialMask');
                            $.property('emergencyDialString');
                            $.property('emoticons');
                            $.property('clientExchangeConnectivity');
                            $.property('exchangeUnifiedMessaging');
                            $.property('htmlMessaging');
                            $.property('logging');
                            $.property('loggingLevel');
                            $.property('messageArchiving');
                            $.property('messagingUrls');
                            $.property('multiViewJoin');
                            $.property('onlineFeedbackUrl');
                            $.property('photos');
                            $.property('saveCallLogs');
                            $.property('saveCredentials');
                            $.property('saveMessagingHistory');
                            $.property('sendFeedbackUrl');
                            $.property('sharingOnlyOnWifi');
                            $.property('softwareQualityMetrics');
                            $.property('telephonyMode');
                            $.property('videoOnlyOnWifi');
                            $.property('voicemailUri');
                        });
                    }
                    return GeneralPolicies;
                }());
                Internal.GeneralPolicies = GeneralPolicies;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_16) {
            var Internal;
            (function (Internal) {
                'use strict';
                var Model = Web.Utils.Model;
                var Command = Web.Utils.Command;
                var EnabledCommand = Web.Utils.EnabledCommand;
                var Task = Web.Utils.Task;
                var Property = Web.Utils.Property;
                var BoolProperty = Web.Utils.BoolProperty;
                var ConstProperty = Web.Utils.ConstProperty;
                var Promise = Web.Utils.Promise;
                var Collection = Web.Utils.Collection;
                var StringEnum = Web.Utils.StringEnum;
                var map = Web.Utils.map;
                var sha256 = Web.Utils.sha256Hash;
                var isVoid = Web.Utils.isVoid;
                var isNotEmptyString = Web.Utils.isNotEmptyString;
                var foreach = Web.Utils.foreach;
                var extend = Web.Utils.extend;
                var async = Web.Utils.async;
                var bind = Web.Utils.bind;
                var EInvalidArgument = Web.Utils.EInvalidArgument;
                /**
                 * The base class for PersonOrGroupSearchQuery and ConversationSearchQuery
                 *
                 */
                var SearchQuery = (function () {
                    function SearchQuery() {
                        var Scope = StringEnum('AddressBook', 'SkypeDirectory', 'All');
                        var limit = Property({
                            value: 1,
                            check: function (value) {
                                if (!(value > 0 && (value | 0) == value))
                                    throw EInvalidArgument('limit', '`limit` must be a positive integer');
                            }
                        });
                        var text = Property({
                            check: function (value) {
                                if (!isNotEmptyString(value))
                                    throw EInvalidArgument('text', '`text` must be set as a no empty query string before searching.');
                            }
                        });
                        var sources = Property({
                            value: Scope.AddressBook,
                            check: function (value) {
                                if (!(value in Scope))
                                    throw EInvalidArgument('sources', '`sources` must be set as AddressBook, SkypeDirectory, or All.');
                            }
                        });
                        return Model({
                            text: text,
                            limit: limit,
                            sources: sources
                        });
                    }
                    return SearchQuery;
                }());
                Internal.SearchQuery = SearchQuery;
                /**
                 * Inherited from SearchQuery, it represents a search query for
                 * searching persons or groups. The search results will be provided
                 * after the request of searching query is resolved by server.
                 *
                 * var searchQuery = client.personsAndGroupsManager.createPersonSearchQuery();
                 * searchQuery.text("John");
                 * searchQuery.limit(10);
                 * searchQuery.getMore().then(function () {
                 *     if (searchQuery.getMore.enabled())
                 *         console.log("More results are available on the server");
                 *     else
                 *         console.log("No more results are available on the server");
                 *
                 *     searchQuery.results().forEach(function (r) {
                 *         console.log("person:", r.result.name());
                 *     });
                 * });
                 *
                 */
                var PersonOrGroupSearchQuery = (function () {
                    //#endregion
                    function PersonOrGroupSearchQuery(options) {
                        var ucwa = options.ucwa;
                        var type = options.type;
                        var remoteOnly = options.remoteOnly;
                        var contactmgr = options.contactmgr;
                        var me = options.me;
                        var self = new SearchQuery;
                        var supportedKeywords = Collection();
                        var keywords = Collection();
                        var results = Collection();
                        var moreResultsAvailable = Property({ value: false });
                        var enabled = BoolProperty(true);
                        var tm = options.tm;
                        var settings = {
                            emailSearchUsesCache: options.settings ? options.settings.emailSearchUsesCache : false
                        };
                        supportedKeywords.add('id');
                        function getMore() {
                            var sLink = ucwa.get({ rel: 'people' }).link('search');
                            var email = keywords['id'] || self.text() && self.text().slice(0, 3).toLowerCase() == 'id:' &&
                                self.text().slice(3);
                            var request = {};
                            var newResults = [];
                            function isMe(res) {
                                // we can use for comparison .uri property directly,
                                // as GET /search returns all found contacts with URI loaded
                                try {
                                    return res.properties['uri'].toLowerCase() === me.id().toLowerCase();
                                }
                                catch (err) {
                                    return false;
                                }
                            }
                            function addSearchResult(res) {
                                var item = Model({
                                    result: res,
                                    matches: {},
                                    relevance: ConstProperty(null)
                                });
                                results.add(item);
                                newResults.push(item);
                            }
                            enabled(false);
                            if (email && email.length >= 1) {
                                // starting from search.revision=2 UCWA supports lookup by email
                                if (sLink.revision >= 2) {
                                    request.headers = { 'X-MS-RequiresMinResourceVersion': 2 };
                                    request.query = { mail: email };
                                }
                                else {
                                    // fallback to lookup by query text.
                                    request.query = { query: email, limit: 1 };
                                }
                            }
                            else {
                                request.query = {
                                    query: self.text(),
                                    limit: self.limit()
                                };
                                if (tm)
                                    tm.excluded[self.text()] = true;
                            }
                            // only lookup cache if search limit is 1
                            if (self.limit() === 1) {
                                var v = email && email.length >= 1 && !settings.emailSearchUsesCache ?
                                    null : (email || self.text());
                                if (v) {
                                    var person = contactmgr.getTransientContact(v);
                                    if (person) {
                                        tm && tm.record(Web.TelemetryEvent.Search, {
                                            source: 'cached_contact'
                                        });
                                        addSearchResult(person);
                                        moreResultsAvailable(false);
                                        return Promise.resolve(newResults);
                                    }
                                }
                            }
                            // GET /search?query=abcdef&limit=50
                            var promise = ucwa.send('GET', sLink.href, request).then(function (sr) {
                                var srCount = Object.keys(sr.embedded).length;
                                foreach(sr.embedded, function (resource) {
                                    if (type == 'person' && resource.rel == 'contact') {
                                        // if it's a contact (excluding yourself), create a Person model
                                        if (remoteOnly === false || !isMe(resource)) {
                                            var person = contactmgr.get(resource.href, false /* don't cache yet */);
                                            // if result count is 1 try to cache. 
                                            // ContactManager may ignore if it is configured not to cache such transient contacts.
                                            if (srCount === 1)
                                                contactmgr.cacheTransientContact(person);
                                            addSearchResult(person);
                                        }
                                    }
                                    else if (type == 'group' && resource.rel == 'distributionGroup') {
                                        // if it's a group, create a group model,
                                        // but do not put it in any cache, since most likely
                                        // this search result will be shown only once in
                                        // the UI and then will be dismissed
                                        var group = new Internal.Group({
                                            ucwa: ucwa,
                                            contactmgr: contactmgr,
                                            source: resource.href,
                                            tm: tm
                                        });
                                        addSearchResult(group);
                                    }
                                });
                                moreResultsAvailable(!!sr.get('moreResultsAvailable', false));
                                return newResults;
                            }).catch(function (error) {
                                enabled(true);
                                throw error;
                            });
                            tm && tm.monitor(promise, Web.TelemetryEvent.Search, {
                                query: request.query && sha256(request.query.mail || request.query.query),
                                type: request.query && request.query.mail ? 'mail' : 'query'
                            });
                            return promise;
                        }
                        return extend(self, {
                            supportedKeywords: supportedKeywords.asReadOnly(),
                            keywords: keywords,
                            moreResultsAvailable: moreResultsAvailable.asReadOnly(),
                            getMore: Command(async(getMore), enabled),
                            results: results.asReadOnly()
                        });
                    }
                    return PersonOrGroupSearchQuery;
                }());
                Internal.PersonOrGroupSearchQuery = PersonOrGroupSearchQuery;
                /**
                 * It represents a search query for searching persons.
                 *
                 * It inherits from class PersonOrGroupSearchQuery with
                 * an additional parameter type = 'person' in the 'options'.
                 *
                 */
                var PersonSearchQuery = (function () {
                    function PersonSearchQuery(options) {
                        options.type = 'person';
                        return new PersonOrGroupSearchQuery(options);
                    }
                    return PersonSearchQuery;
                }());
                Internal.PersonSearchQuery = PersonSearchQuery;
                /**
                 * It represents a search query for searching groups.
                 *
                 * It inherits from class PersonOrGroupSearchQuery with
                 * an additional parameter type = 'group' in the 'options'.
                 *
                 */
                var GroupSearchQuery = (function () {
                    function GroupSearchQuery(options) {
                        options.type = 'group';
                        return new PersonOrGroupSearchQuery(options);
                    }
                    return GroupSearchQuery;
                }());
                Internal.GroupSearchQuery = GroupSearchQuery;
                /**
                 * Inherited from SearchQuery, it represents a search query for searching conversations locally.
                 *
                 * var searchQuery = client.conversationsManager.createSearchQuery();
                 * searchQuery.text("scrum planning");
                 * searchQuery.keywords['participant'] = 'frank';
                 * searchQuery.getMore().then(function () {
                 *     searchQuery.results().forEach(function (r) {
                 *         console.log("conversation  uri:", r.result.id());
                 *     });
                 * });
                 *
                 */
                var ConversationSearchQuery = (function () {
                    //#endregion
                    function ConversationSearchQuery(conversations) {
                        var self = new SearchQuery;
                        var results = Collection();
                        var supportedKeywords = Collection();
                        var keywords = Model();
                        // It is a unique exception object to be thrown in the
                        // comparing function when no 'match' is found.
                        var ne = {};
                        // An array of dictionaries, each of which has one conversation's field as the key,
                        // and its corresponding searching functions as the value.
                        // To add a new searching field for the conversation in the future,
                        // simply add a new dictionary with a new supported key and its searching function.
                        var supportedInternal = [
                            {
                                key: 'uri',
                                call: function (conv, txt) {
                                    return containsStr(conv.uri.get(), txt);
                                }
                            },
                            {
                                key: 'topic',
                                call: function (conv, txt) {
                                    return containsStr(conv.topic.get(), txt);
                                }
                            },
                            {
                                key: 'participant',
                                call: function (conv, txt) {
                                    return containsAny(conv.participants().concat([conv.selfParticipant]), txt, function (value, participant) {
                                        return containsStr(participant.name.get(), value);
                                    });
                                }
                            },
                            {
                                key: 'group',
                                call: function (conv, boolFlag) {
                                    return Task.wait(conv.isGroupConversation() != boolFlag).then(function (result) {
                                        if (result)
                                            throw ne;
                                    });
                                }
                            }
                        ];
                        /**
                         * It returns a promise, which will be resolved when 'stringA' contains 'stringB'.
                         *
                         * @param {Promise|String} stringA - A promise to be resolved as a string, or a string object.
                         *
                         * @param {Promise|String} stringB - A promise to be resolved as a string, or a string object.
                         *
                         * @returns {Promise} - Resolved when 'stringA' contains 'stringB'
                         *
                         *      An unique exception 'ne' will be thrown if 'stringA' does not contain 'stringB'.
                         *
                         */
                        function containsStr(stringA, stringB) {
                            return Task.waitAll([stringA, stringB]).then(function (resolved) {
                                if (resolved[0].toLowerCase().indexOf(resolved[1].toLowerCase()) < 0)
                                    throw ne;
                            });
                        }
                        /**
                         * It returns a promise, which will be resolved if any one in 'objects' contains 'stringA'
                         *
                         * @param {Promise|Collection} objects - A promise to be resolved a collection, or a collection object.
                         *
                         * @param {Promise|String} stringA - A promise to be resolved as a string,  or a object string.
                         *
                         * @param {Function} compareFunction - A function to compare the  one object's property with 'stringA'
                         *
                         *      It should throw the 'ne' exception if the object's property does not contain 'stringA'.
                         *
                         * @returns {Promise} - Resolved if any object contains 'stringA'.
                         *
                         *      An unique exception 'ne' will be thrown if none of objects contains 'stringA'.
                         *
                         */
                        function containsAny(objects, stringA, compareFunction) {
                            return Task.waitAll([objects, stringA]).then(function (resolved) {
                                // if objects is null, consider it as there is no 'match' found.
                                if (resolved[0].length == 0)
                                    throw ne;
                                return Task.waitAny(map(resolved[0], bind(compareFunction, resolved[1])));
                            });
                        }
                        // Returns a promise, which will be resolved if the conversation
                        // has a 'match' for the search query and keywords. Otherwise,
                        // it throws the unique 'ne' exception.
                        function compareConversation(conv) {
                            // check whether any one of conversation's fields contains 'text'
                            var pText = Task.waitAny(map(supportedInternal, function (field) {
                                return field.call(conv, self.text());
                            }));
                            // check whether each conversation's field contains its corresponding keyword's value if provided.
                            var pKW = Task.waitAll(map(supportedInternal, function (field) {
                                if (!isVoid(keywords[field.key])) {
                                    return field.call(conv, keywords[field.key]);
                                }
                            }));
                            // wait for both a 'match' in text property AND a 'match' in all provided keywords
                            return Task.waitAll([pText, pKW]);
                        }
                        function getMore() {
                            var newResults = [];
                            var convs = conversations();
                            var mConvs = map(convs, function (conv) {
                                return compareConversation(conv).then(function () {
                                    var item = {
                                        result: conv,
                                        matches: {},
                                        relevance: ConstProperty(null)
                                    };
                                    results.add(item);
                                    newResults.push(item);
                                }, function (error) {
                                    if (error != ne)
                                        throw error;
                                });
                            });
                            return Task.waitAll(mConvs).then(function () {
                                return newResults;
                            });
                        }
                        foreach(supportedInternal, function (field) {
                            supportedKeywords.add(field.key);
                        });
                        return extend(self, {
                            supportedKeywords: supportedKeywords.asReadOnly(),
                            keywords: keywords,
                            limit: ConstProperty(null),
                            moreResultsAvailable: ConstProperty(false),
                            getMore: EnabledCommand(async(getMore)),
                            results: results.asReadOnly()
                        });
                    }
                    return ConversationSearchQuery;
                }());
                Internal.ConversationSearchQuery = ConversationSearchQuery;
            })(Internal = Model_16.Internal || (Model_16.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_17) {
            var Internal;
            (function (Internal) {
                'use strict';
                var assert = Web.Utils.assert;
                var Command = Web.Utils.Command;
                var BoolProperty = Web.Utils.BoolProperty;
                var extend = Web.Utils.extend;
                var setHiddenProperty = Web.Utils.setHiddenProperty;
                var isNotEmptyString = Web.Utils.isNotEmptyString;
                var isObject = Web.Utils.isObject;
                var isPromise = Web.Utils.isPromise;
                var foreach = Web.Utils.foreach;
                var Property = Web.Utils.Property;
                var NumProperty = Web.Utils.NumProperty;
                var ConstProperty = Web.Utils.ConstProperty;
                var ComputedProperty = Web.Utils.ComputedProperty;
                var Collection = Web.Utils.Collection;
                var EInvalidArgument = Web.Utils.EInvalidArgument;
                var EDoesNotExist = Web.Utils.EDoesNotExist;
                var ENotSupported = Web.Utils.ENotSupported;
                var Task = Web.Utils.Task;
                var filter = Web.Utils.filter;
                var Model = Web.Utils.Model;
                /**
                 * A group that holds a collection of contacts and nested groups.
                 *
                 * An instance of Group represents a group of contacts, which
                 * can come from one of many sources:
                 *
                 *      -   the contact list that includes all contacts
                 *      -   a distribution group
                 *      -   a relationship group like Colleagues, Workgroup, Blocked
                 *      -   a user-created or a server-created group of contacts
                 *
                 * These sources are similar in a sense that they encapsulate a contact list,
                 * but the access path to that list may differ:
                 *
                 *     -    myContacts / contact[i]
                 *     -    myPrivacyRelationship / contact[i]
                 *     -    distributionGroup / contact[i]
                 *     -    pinnedGroup / groupContacts / contact[i]
                 *     -    defaultGroup / groupContacts / contact[i]
                 *     -    group / groupContacts / contact[i]
                 *
                 * For instance to get the list of rel=contact resources for a rel=group,
                 * the model at first gets rel=group, then it finds rel=groupContacts link
                 * in it, sends a GET to that link and finds rel=contact links in the response.
                 * To get the list of contacts for rel=myContacts and rel=myPrivacyRelationship
                 * it's enough to send a GET to these resources; in case of rel=distributionGroup
                 * the model sends a GET to distributionGroup/expandDistributionGroup.
                 *
                 */
                var Group = (function () {
                    //#endregion
                    function Group(options) {
                        var ucwa = options.ucwa;
                        var source = options.source;
                        var contactmgr = options.contactmgr;
                        var subscribe = options.subscribe;
                        var unsubscribe = options.unsubscribe;
                        // source can be the href string or Promise<String>
                        var rGroup = source && !isPromise(source) && ucwa.get(source);
                        var self = Model();
                        var properties = {};
                        var rGroupMemberships = options.groupMemberships;
                        var tm = options.tm;
                        var mgmtRevision = NumProperty();
                        var isMgmtRevisionKnown = BoolProperty(false);
                        var isSignedIn = BoolProperty(false);
                        // enable person management APIs properly if the resource
                        // revision is already loaded; otherwise enable the APIs
                        // so that they can be called, at which point the resource
                        // revision will be loaded and the APIs will be enabled
                        // or disabled properly
                        var personMgmtEnabled = ComputedProperty([mgmtRevision, isMgmtRevisionKnown, isSignedIn], function (r) { return r >= 2 || !r && !isMgmtRevisionKnown() && isSignedIn(); });
                        var persons = Collection({
                            get: loadContactsAndNestedGroups,
                            subscribed: subscribeContactsAndGroups,
                            unsubscribed: unsubscribeContactsAndGroups
                        });
                        var groups = Collection({
                            get: loadContactsAndNestedGroups,
                            subscribed: subscribeContactsAndGroups,
                            unsubscribed: unsubscribeContactsAndGroups
                        });
                        var types = {
                            group: 'Custom',
                            defaultGroup: 'Others',
                            pinnedGroup: 'Favorites',
                            distributionGroup: 'Distribution',
                            myPrivacyRelationship: 'PrivacyRelationship'
                        };
                        var dfdInfo; // tracks the progress of `loadInfo`
                        var dfdContacts; // tracks the progress of `loadContactsAndNestedGroups`
                        function subscribeContactsAndGroups() {
                            if (subscribe)
                                subscribe();
                            loadContactsAndNestedGroups();
                        }
                        function unsubscribeContactsAndGroups() {
                            if (unsubscribe)
                                unsubscribe();
                        }
                        function importContacts(resource) {
                            // TODO: the list of contacts on the server may be a subset
                            // of the list of contacts known to the client; in this case
                            // some contacts must be deleted from the list
                            foreach(resource.related.contact || [], function (link) {
                                if (!persons(link.href))
                                    persons.add(contactmgr.get(link.href), link.href);
                            });
                        }
                        function importGroups(r) {
                            foreach(r.links('distributionGroup'), function (link) {
                                if (!groups(link.href)) {
                                    var nestedGroup = new Group({
                                        source: link.href,
                                        ucwa: ucwa,
                                        contactmgr: contactmgr,
                                        subscribe: subscribe,
                                        unsubscribe: unsubscribe,
                                        tm: tm
                                    });
                                    groups.add(nestedGroup, link.href);
                                }
                            });
                        }
                        function getContactUri(contact) {
                            if (!contact || !(isObject(contact) || isNotEmptyString(contact)))
                                throw EInvalidArgument('contact', 'the given value is not a Person model or valid URI');
                            return Task.wait(null).then(function () {
                                return contact.id ? contact.id.get() : contact;
                            });
                        }
                        /*
                         * Add a contact to this Group.
                         *
                         * add operation is a POST request of the form:
                         * "POST /groupMemberships?groudId=...&contactUri=..."
                         * where the href is obtained via the 'myGroupMemberships' link, and
                         * the 'groupId=<gid>' query part can be omitted for the default group.
                         *
                         * Note: UCWA allows contact to be added to certain (but not all)
                         * groups. We will let UCWA respond to operations that are not allowed.
                         *
                         * @param {String|Person} contact - a contact URI or Person object
                         * @returns {Promise}
                         */
                        function addContact(contact) {
                            var dfdAdd = getContactUri(contact).then(function (uri) {
                                return Task.wait(null).then(function () {
                                    return self.id.get();
                                }).then(function () {
                                    return rGroup.get('id');
                                }).then(function (gid) {
                                    return initPersonMgmtAPI().then(function () {
                                        return ucwa.send('POST', { rel: 'myGroupMemberships' }, {
                                            headers: { 'X-MS-RequiresMinResourceVersion': 2 /* AddPerson */ },
                                            // no need to pass the gid if this is the default group
                                            query: rGroup.rel == 'defaultGroup' ?
                                                { contactUri: uri } :
                                                { groupId: gid, contactUri: uri }
                                        });
                                    });
                                }, function (error) {
                                    // the group does not have an id
                                    // wrap the ucwa error inside an ENotSupported error
                                    throw ENotSupported(error);
                                });
                            });
                            tm && tm.monitor(dfdAdd, Web.TelemetryEvent.ContactAdd);
                            return dfdAdd;
                        }
                        /*
                         * Filter the myGroupMembership resources that match the current group
                         * and the contact href passed in.
                         *
                         * @param {String} contactHref - the contact href
                         * @returns {Array<Resource>} - an array of matched resources
                         */
                        function filterMembershipLinks(contactHref) {
                            return filter(rGroupMemberships.links('myGroupMembership'), function (link) {
                                var gm = ucwa.get(link.href);
                                return gm.hasLink(rGroup.rel) &&
                                    gm.link(rGroup.rel).href == rGroup.href &&
                                    gm.link('contact').href == contactHref;
                            });
                        }
                        /*
                         * Retrieve the link to remove a contact from this Group.
                         *
                         * @param {Person} contact - a Person object
                         * @returns {Promise<String>} - a promise containing the link href
                         */
                        function getMembershipLink(contact) {
                            if (!contact || !contact.id)
                                throw EInvalidArgument('contact', 'the given value is not a Person model');
                            // always load myGroupMemberships to prevent out of sync with UCWA
                            // TODO: batch process multiple remove requests in sequence
                            return ucwa.send('GET', rGroupMemberships.href).then(function () {
                                // exactly one link needs to be available
                                var membershipLinks = filterMembershipLinks(contact[Internal.sHref]);
                                if (membershipLinks.length != 1) {
                                    if (rGroup.rel == 'distributionGroup' ||
                                        rGroup.rel == 'myPrivacyRelationship') {
                                        // contact management is currently not supported for
                                        // DG and privacy relationship, so throw a more
                                        // meaningful error. Need to remove this special
                                        // handling once support becomes available
                                        throw ENotSupported(EDoesNotExist(contact));
                                    }
                                    else {
                                        throw EDoesNotExist(contact);
                                    }
                                }
                                return membershipLinks[0].href;
                            });
                        }
                        /*
                         * Remove a contact from this Group.
                         *
                         * remove operation is a DELETE request of the form:
                         * "DELETE /groupMemberships/...,..."
                         * where the href must be one of the 'myGroupMembership' links, and
                         * the comma separated parts are group ID and contact uri.
                         *
                         * Note: UCWA allows contact to be removed from certain (but not all)
                         * groups. We will let UCWA respond to operations that are not allowed.
                         *
                         * @param {Person} contact - a Person object
                         * @returns {Promise}
                         */
                        function removeContact(contact) {
                            var dfdRemove = getMembershipLink(contact).then(function (href) {
                                return initPersonMgmtAPI().then(function () {
                                    return ucwa.send('DELETE', href, {
                                        headers: { 'X-MS-RequiresMinResourceVersion': 2 /* RemovePerson */ }
                                    });
                                });
                            });
                            tm && tm.monitor(dfdRemove, Web.TelemetryEvent.ContactRemove);
                            return dfdRemove;
                        }
                        //#region rename
                        /*
                         * Rename a group.
                         *
                         * renaming group is a PUT request of the form:
                         * "PUT /people/groups/<groupId>"
                         * where the data passed in the request contains the following properties:
                         * {
                         *      rel: 'group',
                         *      name: 'new group name',
                         *      id: '<group id>',
                         *      etag: '<some etag>',
                         *      <some-guid>: 'please pass this in a PUT request'
                         * }
                         * Except for the new name, all other properties should be directly
                         * associated with and obtained from the current group resource. The
                         * etag value will be inserted as the 'if-match' value in the header
                         * of the PUT request.
                         *
                         * Note: UCWA allows renaming for certain (but not all) groups. We will
                         * let UCWA respond to operations that are not allowed.
                         *
                         * @param {String} name - the new name specified
                         * @returns {Promise}
                         */
                        function rename(name) {
                            tm && tm.record(Web.TelemetryEvent.GroupRename);
                            if (!isNotEmptyString(name))
                                throw EInvalidArgument('name', 'The new name must be a non empty string.');
                            return !rGroup ? name : loadInfo().then(function () {
                                return initPersonMgmtAPI();
                            }).then(function () {
                                return ucwa.send('PUT', rGroup.href, {
                                    headers: { 'X-MS-RequiresMinResourceVersion': 2 /* RenameGroup */ },
                                    data: extend(rGroup.getSnapshot(), { name: name })
                                }).then(function () {
                                    // currently this PUT request results in a new group
                                    // created with the new name and the old group deleted.
                                    // The on success promise of this request will be used to
                                    // update the name of the old group, so we need to return
                                    // the name of the old group to make that update correct.
                                    return rGroup.get('name');
                                });
                            });
                        }
                        //#endregion
                        /*
                         * Enable person and group management APIs if supported.
                         */
                        function initPersonMgmtAPI() {
                            return ucwa.getRevisionOf(rGroupMemberships).then(function () {
                                isMgmtRevisionKnown(true);
                                if (!personMgmtEnabled())
                                    throw ENotSupported();
                            });
                        }
                        /**
                         * Expands the group by sending a GET request to the server
                         * and returns a promise that tracks the progress of that request.
                         * Note, that big distribution groups cannot be expanded, as
                         * the server returns a HTTP 403 with a "too many contacts" message
                         * in the response body.
                         *
                         * @returns {Promise}
                         */
                        function expand() {
                            // for regular groups
                            if (rGroup.hasLink('groupContacts'))
                                return ucwa.send('GET', rGroup.link('groupContacts').href);
                            // for distribution groups
                            if (rGroup.hasLink('expandDistributionGroup'))
                                return ucwa.send('GET', rGroup.link('expandDistributionGroup').href);
                            return new Task().reject(new Error('Missing the group expansion link.')).promise;
                        }
                        /**
                         * Adds a new observable property to the instance of Group.
                         * The given setter defines how to update the property.
                         */
                        function define(name, set) {
                            assert(!self[name]);
                            var p = Property({
                                subscribed: loadInfo,
                                get: function () {
                                    return loadInfo().then(function () {
                                        // a handler for the rGroup:updated event
                                        // has already updated this property
                                        return p();
                                    });
                                },
                                set: set
                            });
                            properties[name] = p;
                            self[name] = set ? p : p.asReadOnly();
                        }
                        function loadInfo() {
                            return Task.wait(source).then(function (href) {
                                dfdInfo = dfdInfo || ucwa.send('GET', href);
                                return dfdInfo;
                            });
                        }
                        function loadContactsAndNestedGroups() {
                            dfdContacts = dfdContacts || loadInfo().then(function () {
                                importContacts(rGroup);
                                importGroups(rGroup);
                                // these two group types do not need to be expanded
                                // since they do not have expansion links
                                if (rGroup.rel != 'myPrivacyRelationship' && rGroup.rel != 'myContacts') {
                                    return expand().then(function (r) {
                                        importContacts(r);
                                        importGroups(r);
                                    });
                                }
                            });
                            return dfdContacts;
                        }
                        function handleUcwaEvent(event) {
                            var scope = event['in'] || {};
                            var link = event.target || {};
                            if (scope.href == rGroup.href) {
                                if (event.type == 'deleted') {
                                    // if the contact does not exist in the collection,
                                    // nothing will happen
                                    persons.remove(link.href);
                                }
                                if (event.type == 'added') {
                                    if (!persons(link.href))
                                        persons.add(contactmgr.get(link.href), link.href);
                                }
                            }
                        }
                        define('name', rename);
                        define('uri');
                        define('relationshipLevel');
                        define('id');
                        Task.wait(source, 'sync').then(function (href) {
                            isSignedIn(true);
                            rGroup = rGroup || ucwa.get(href);
                            if (rGroup.rel != 'myPrivacyRelationship')
                                properties.relationshipLevel('None');
                            rGroup.updated(function () {
                                foreach(properties, function (p, name) {
                                    if (name in rGroup.properties)
                                        p(rGroup.properties[name], Property.sUpdated);
                                });
                            });
                            rGroupMemberships = rGroupMemberships || ucwa.get({ rel: 'myGroupMemberships' });
                            rGroupMemberships.updated(function () {
                                var rev = rGroupMemberships.link('self').revision;
                                mgmtRevision(+rev);
                            });
                            // the server tells over the event channel when a contact gets
                            // added to the group or removed from it
                            ucwa.event(handleUcwaEvent);
                            rGroup.deleted(function () {
                                ucwa.event.off(handleUcwaEvent);
                            });
                            try {
                                // import immediate contacts from rel=this/rel=contact[i]
                                importContacts(rGroup);
                            }
                            catch (err) {
                                Internal.log('Failed to import persons for ' + rGroup.href + ': ' + err);
                            }
                            try {
                                // import immediate groups from rel=this/rel=distributionGroup[i]
                                importGroups(rGroup);
                            }
                            catch (err) {
                                Internal.log('Failed to import groups for ' + rGroup.href + ': ' + err);
                            }
                            try {
                                // import indirect persons from rel=this/rel=groupContacts/rel=contact[i]
                                importContacts(ucwa.get(rGroup.link('groupContacts').href));
                            }
                            catch (_) {
                            }
                            // sHref will be a hidden symbol for Group objects
                            setHiddenProperty(self, Internal.sHref, rGroup.href);
                        });
                        // The add/remove methods of a Group object need to be overridden
                        // to do different things:
                        // 1) For a regular Group, add/remove are used to add/remove a
                        //    contact to/from the group.
                        // 2) For the root group that represents the "contact list", i.e.,
                        //    client.personsAndGroupsManager.all.persons, the add method is
                        //    not supported, and the remove method is used to remove a contact
                        //    from all groups.
                        return extend(self, {
                            avatarUrl: ConstProperty(null),
                            type: ConstProperty(types[rGroup && rGroup.rel || 'group']),
                            groups: groups.asReadOnly(),
                            persons: persons.asWritable({
                                add: Command(addContact, personMgmtEnabled),
                                remove: Command(removeContact, personMgmtEnabled)
                            })
                        });
                    }
                    return Group;
                }());
                Internal.Group = Group;
            })(Internal = Model_17.Internal || (Model_17.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_18) {
            var Internal;
            (function (Internal) {
                'use strict';
                var Command = Web.Utils.Command;
                var EnabledCommand = Web.Utils.EnabledCommand;
                var DisabledCommand = Web.Utils.DisabledCommand;
                var BoolProperty = Web.Utils.BoolProperty;
                var indexOf = Web.Utils.indexOf;
                var foreach = Web.Utils.foreach;
                var NumProperty = Web.Utils.NumProperty;
                var ConstProperty = Web.Utils.ConstProperty;
                var ComputedProperty = Web.Utils.ComputedProperty;
                var Collection = Web.Utils.Collection;
                var EInvalidArgument = Web.Utils.EInvalidArgument;
                var isNotEmptyString = Web.Utils.isNotEmptyString;
                var ENotSupported = Web.Utils.ENotSupported;
                var Exception = Web.Utils.Exception;
                var Task = Web.Utils.Task;
                var findIndex = Web.Utils.findIndex;
                var Model = Web.Utils.Model;
                var debounced = Web.Utils.debounced;
                /**
                 * The root group holds the list of all contacts and all groups known to the client.
                 * Those groups include the user-created,  server-created and relationship groups.
                 *
                 */
                var RootGroup = (function () {
                    //#endregion
                    function RootGroup(_a) {
                        var ucwa = _a.ucwa, contactmgr = _a.contactmgr, tm = _a.tm, autoPopulate = _a.autoPopulate;
                        var groupRels = ['group', 'pinnedGroup', 'distributionGroup', 'defaultGroup'];
                        var persons = Collection({
                            get: loadContacts,
                            subscribed: function () { return handleSubscribe(loadContacts); },
                            unsubscribed: unsubscribe
                        });
                        var groups = Collection({
                            get: loadGroups,
                            subscribed: function () { return handleSubscribe(loadGroups); },
                            unsubscribed: unsubscribe
                        });
                        var mgmtRevision = NumProperty();
                        var isMgmtRevisionKnown = BoolProperty(false);
                        var isSignedIn = BoolProperty(false);
                        // enable group management APIs properly if the resource
                        // revision is already loaded; otherwise enable the APIs
                        // so that they can be called, at which point the resource
                        // revision will be loaded and the APIs will be enabled
                        // or disabled properly
                        var groupMgmtEnabled = ComputedProperty([mgmtRevision, isMgmtRevisionKnown, isSignedIn], function (r) { return r >= 2 || !r && !isMgmtRevisionKnown() && isSignedIn(); });
                        // these 2 arrays are used to manage delayed loading of locally
                        // created (pending) groups. A pending group is a Group object
                        // created by the 'PersonsAndGroupsManager.createGroup' method
                        // (which delegates to the 'createLocalGroup' method). A pending group
                        // is not assigned an href until the user requests to add it to ucwa
                        // successfully, and receives the 'group added' event from ucwa.
                        // See the 'createLocalGroup' method for detailed explanations.
                        var pendingHrefs = [];
                        var pendingGroups = [];
                        var rSubscriptions; // rel=myContactsAndGroupsSubscription
                        var rGroupMemberships; // rel=myGroupMemberships
                        var rContacts; // rel=myContacts
                        var rGroups; // rel=myGroups
                        var rPrivacyRelationships; // rel=myPrivacyRelationships
                        var hTimer; // renews subscription
                        var dtSubscription = 30; // minutes
                        var nSubscriptions = 0; // avoid duplicate (un)subscriptions
                        function createGroup(source) {
                            return new Internal.Group({
                                source: source,
                                ucwa: ucwa,
                                contactmgr: contactmgr,
                                subscribe: subscribe,
                                unsubscribe: unsubscribe,
                                groupMemberships: rGroupMemberships,
                                tm: tm
                            });
                        }
                        /**
                         * first subscription when myContactsAndGroupsSubscription
                         * is not 'Connected' ('Disconnected' or 'Connecting') shall
                         * make its state from 'Disconnected' to 'Connecting' and
                         * finally to 'Connected'. This process shall trigger
                         * 'contact added' and 'group added' events from UCWA to
                         * populate contact list.
                         *
                         * first subscription when myContactsAndGroupsSubscription
                         * is already 'Connected' will not trigger 'contact added'
                         * and 'group added' events from UCWA; so need to GET
                         * contacts/groups in order to populate contact list.
                         *
                         * subsequent subscription shall be a noop (indicated by
                         * subscribe throwing an exception, which is ignored).
                         */
                        function handleSubscribe(load) {
                            subscribe().then(function () {
                                if (rSubscriptions.get('state') == 'Connected')
                                    load();
                            });
                        }
                        function loadContacts() {
                            var dfd = ucwa.init().then(function () {
                                return ucwa.send('GET', { rel: 'myContacts' }).then(importContacts);
                            });
                            tm && tm.monitor(dfd, Web.TelemetryEvent.ContactsLoad, function () {
                                return { nContacts: persons.size() };
                            });
                            dfd.then(function () {
                                autoPopulate(persons.size(), function (href) {
                                    persons.add(contactmgr.get(href, true, { isOrgContact: true }), href);
                                });
                            });
                            return dfd;
                        }
                        function loadGroups() {
                            return ucwa.init().then(function () {
                                return Task.waitAll([
                                    ucwa.send('GET', { rel: 'myGroups' }).then(importGroups),
                                    ucwa.send('GET', { rel: 'myPrivacyRelationships' }).then(importRelationships)
                                ]).then(function () {
                                    tm && tm.record(Web.TelemetryEvent.GroupsLoad, { nGroups: groups.size() });
                                    return;
                                });
                            });
                        }
                        function importContacts(r) {
                            foreach(r.related.contact || [], function (link) {
                                if (!persons(link.href))
                                    persons.add(contactmgr.get(link.href), link.href);
                            });
                        }
                        function importGroups(r) {
                            foreach(groupRels, function (rel) {
                                foreach(r.links(rel), function (link) {
                                    if (!groups(link.href))
                                        groups.add(createGroup(link.href), link.href);
                                });
                            });
                        }
                        function importRelationships(r) {
                            foreach(r.links('myPrivacyRelationship'), function (link) {
                                if (!groups(link.href))
                                    groups.add(createGroup(link.href), link.href);
                            });
                        }
                        /*
                        * Add method is currently not supported for the contact list.
                        *
                        * This method is not supported because contact list is the sum of all
                        * other groups therefore adding a contact to it is ambiguous - it is
                        * not clear which group the contact should be added to.
                        */
                        function addContactToContactList() {
                            throw ENotSupported();
                        }
                        //#region removeContactFromAllGroups
                        /*
                         * Remove a contact from all groups.
                         *
                         * removeContactFromAllGroups is a POST request of the form:
                         * "POST /groupMemberships/removeContactFromAllGroups?contactUri=..."
                         * where the href is obtained via the 'removeContactFromAllGroups' link.
                         *
                         * Note: the contact may not have been deleted when this request returns.
                         * It is actually removed from the group after UCWA sends the "contact deleted"
                         * event.
                         *
                         * Note: UCWA allows contact to be removed from certain (but not all)
                         * groups. We will let UCWA respond to operations that are not allowed.
                         *
                         */
                        function removeContactFromAllGroups(/** SIP URI or a Person object */ contact) {
                            var dfd = Task.wait(typeof contact === 'string' ? contact : contact.id.get()).then(function (uri) {
                                // always load myGroupMemberships to prevent out of sync with UCWA
                                // TODO: batch process multiple remove requests in sequence
                                return ucwa.send('GET', rGroupMemberships.href).then(function () {
                                    return initGroupMgmtAPI();
                                }).then(function () {
                                    return ucwa.send('POST', rGroupMemberships.link('removeContactFromAllGroups').href, {
                                        query: { contactUri: uri },
                                        headers: { 'X-MS-RequiresMinResourceVersion': 2 /* RemovePersonFromAllGroups */ }
                                    });
                                });
                            });
                            tm && tm.monitor(dfd, Web.TelemetryEvent.ContactRemove);
                            return dfd;
                        }
                        //#endregion
                        function fetchLink(rel) {
                            return ucwa.exists({ rel: rel }) ?
                                Task.wait({ href: ucwa.get({ rel: rel }).href }) :
                                ucwa.send('GET', rSubscriptions.href).then(function (r) {
                                    return r.link(rel);
                                });
                        }
                        function subscribe() {
                            nSubscriptions++;
                            // exception is used for caller to skip loadContacts/loadGroups
                            if (nSubscriptions > 1)
                                return Task.run(function () { throw Exception('AlreadySubscribed'); });
                            // TODO: subscribe followed by unsubscribe requires a more intricate fix
                            // Although it looks like it will work here the unsub runs first followed by sub
                            // Fix: Move subscription to the next event loop so that it can check if necessary and run 
                            return ucwa.init().then(function () {
                                return fetchLink('startOrRefreshSubscriptionToContactsAndGroups');
                            }).then(function (link) {
                                var renew = debounced(function () {
                                    return ucwa.send('POST', link.href, {
                                        query: { duration: dtSubscription }
                                    });
                                });
                                renew(); // subscribe once
                                hTimer = Web.setInterval(function () {
                                    renew().then(null, unsubscribe); // and cancel subscription if something went wrong
                                }, dtSubscription * 60 * 1000);
                            });
                        }
                        function unsubscribe() {
                            if (nSubscriptions == 0)
                                return;
                            nSubscriptions--;
                            if (nSubscriptions > 0)
                                return;
                            ucwa.init().then(function () {
                                Web.clearInterval(hTimer);
                                fetchLink('stopSubscriptionToContactsAndGroups').then(function (link) {
                                    return ucwa.send('POST', link.href);
                                });
                            });
                        }
                        /* A typical scenario to create a group and add it to the server
                         * consists of 4 steps: (pgm = client.personsAndGroupsManager)
                         *  1) Create a local group: g = pgm.createGroup()
                         *  2) Set the name of group: g.name("G1")
                         *  3) Request to add on server: pgm.all.groups.add(g)
                         *  4) Handling "group added" event: g is finally added
                         *
                         * These problems need to be solved to implement this scenario:
                         *  - both step 3 and step 4 are async
                         *  - the group is not added until after step 4
                         *  - the event in step 4 does not contain the group object in the
                         *    previous 3 steps
                         *  - the group object g is created in step 1 but loaded in step 4
                         *
                         * So the main issue is to correlate group g with the "group added"
                         * event, and load group resource when the right event is received.
                         *
                         * To solve the problem, we use a pattern used in the Conversation
                         * and Participant models (for adding a Participant object to the
                         * Conversation and load it later). The basic idea is as follows:
                         *
                         *  in step 1): create promise p to pass to Group constructor,
                         *      which will attach any resource-dependent operations with the
                         *      then clause of the promise. In addition, add p to an array
                         *      pendingHrefs and g to another array pendingGroups
                         *  in step 4): retrieve groupName from event; iterate pendingGroups
                         *      to locate g by name; add g to the groups collection; resolve
                         *      corresponding promise p in pendingHrefs (which will load the
                         *      group resource for g); deleting g from pendingGroups and p
                         *      from pendingHrefs
                         */
                        function createLocalGroup() {
                            tm && tm.record(Web.TelemetryEvent.GroupCreate);
                            var dfd = new Task(), group = createGroup(dfd.promise);
                            pendingHrefs.push(dfd);
                            pendingGroups.push(group);
                            return group;
                        }
                        /*
                         * Add a user defined group to the contact list.
                         *
                         * The group specified is either a locally created group object
                         * or a group object obtained from search. This operation is to
                         * request UCWA to add the group to the contact list.
                         *
                         * It is a POST request of the form:
                         * "POST /people/groups"
                         * where the body of the request shall contain an object:
                         * { 'displayName': 'group name' }.
                         *
                         * @param {Group} group - the Group object to be created on UCWA
                         * @returns {Promise}
                         */
                        function addNewGroup(group) {
                            var name = group.name();
                            if (!isNotEmptyString(name))
                                throw EInvalidArgument('name', 'The group name must be a non empty string.');
                            return initGroupMgmtAPI().then(function () {
                                var dfdAdd = ucwa.send('POST', { rel: 'myGroups' }, {
                                    data: { displayName: name },
                                    headers: { 'X-MS-RequiresMinResourceVersion': 2 /* AddGroup */ }
                                });
                                tm && tm.monitor(dfdAdd, Web.TelemetryEvent.GroupAdd, { type: group.type() });
                                return dfdAdd;
                            });
                        }
                        /*
                         * Add an existing distribution group to the contact list.
                         *
                         * add operation is a POST request of the form:
                         * "POST /people/groups/addToContactList?displayName=<dlname>&smtpAddress=<group@sample.com>"
                         * where the actual link used in this operation must exist on this group resource.
                         *
                         * @param {Group} group - the Group object to be added
                         * @returns {Promise}
                         */
                        function addDG(group) {
                            var link = ucwa.get(group[Internal.sHref]).link('addToContactList');
                            var dfdAdd = ucwa.send('POST', link.href);
                            tm && tm.monitor(dfdAdd, Web.TelemetryEvent.GroupAdd, { type: group.type() });
                            return dfdAdd;
                        }
                        /*
                         * Depending on the argument specified, either create a new user defined
                         * group in the contact list, or add an existing distribution group to
                         * the contact list.
                         *
                         * @param {Group} group - the Group object to be added
                         * @returns {Promise}
                         */
                        function addGroup(group) {
                            return group.type() == 'Distribution' ? addDG(group) : addNewGroup(group);
                        }
                        /*
                         * Delete a user defined group from the contact list.
                         *
                         * delete operation is a DELETE request of the form:
                         * "DELETE /people/groups/<groupId>"
                         * where the actual link used in this operation is the href of this group resource.
                         *
                         * @param {Group} group - the Group object to be deleted
                         * @returns {Promise}
                         */
                        function deleteGroup(group) {
                            return initGroupMgmtAPI().then(function () {
                                var dfdRemove = ucwa.send('DELETE', group[Internal.sHref], {
                                    headers: { 'X-MS-RequiresMinResourceVersion': 2 /* RemoveGroup */ }
                                });
                                tm && tm.monitor(dfdRemove, Web.TelemetryEvent.GroupRemove, { type: group.type() });
                                return dfdRemove;
                            });
                        }
                        /*
                         * Remove a distribution group from the contact list.
                         *
                         * add operation is a POST request of the form:
                         * "POST /people/groups/removeFromContactList?<groupId=mygid>"
                         * where the actual link used in this operation must exist on this group resource.
                         *
                         * @param {Group} group - the Group object to be added
                         * @returns {Promise}
                         */
                        function removeDG(group) {
                            var link = ucwa.get(group[Internal.sHref]).link('removeFromContactList');
                            var dfdRemove = ucwa.send('POST', link.href);
                            tm && tm.monitor(dfdRemove, Web.TelemetryEvent.GroupRemove, { type: group.type() });
                            return dfdRemove;
                        }
                        /*
                         * Depending on the argument specified, either delete a user defined
                         * group from the contact list, or remove a distribution group from
                         * the contact list.
                         *
                         * @param {Group} group - a Group object to be removed
                         * @returns {Promise}
                         */
                        function removeGroup(group) {
                            var rel = ucwa.get(group[Internal.sHref]).rel;
                            if (rel == 'group')
                                return deleteGroup(group); // delete a user defined group
                            else if (rel == 'distributionGroup')
                                return removeDG(group); // remove a distribution group
                            else
                                throw ENotSupported({ groupType: rel });
                        }
                        /*
                         * Enable person and group management APIs if supported.
                         */
                        function initGroupMgmtAPI() {
                            return ucwa.getRevisionOf(rGroupMemberships).then(function () {
                                isMgmtRevisionKnown(true);
                                rGroupMemberships.set('qqq', true);
                                if (!groupMgmtEnabled())
                                    throw ENotSupported();
                            });
                        }
                        /*
                         * add a group to the groups collection when a 'rel:group added' event is received from UCWA
                         */
                        function addToGroups(href) {
                            if (groups(href))
                                return;
                            if (pendingGroups.length > 0) {
                                Task.wait(null).then(function () {
                                    if (!ucwa.get(href).has('name'))
                                        return ucwa.send('GET', href);
                                }).then(function () {
                                    var i = findIndex(pendingGroups, function (g) { return g.name() == ucwa.get(href).get('name'); });
                                    if (i >= 0) {
                                        // add the group to the groups collection after it is initialized
                                        pendingHrefs[i].promise.then(function (href) {
                                            var i = findIndex(pendingGroups, function (g) { return g.name() == ucwa.get(href).get('name'); });
                                            pendingGroups[i] && groups.add(pendingGroups[i], href);
                                            pendingGroups.splice(i, 1);
                                            pendingHrefs.splice(i, 1);
                                        });
                                        pendingHrefs[i].resolve(href);
                                    }
                                    else {
                                        groups.add(createGroup(href), href);
                                    }
                                });
                            }
                            else {
                                groups.add(createGroup(href), href);
                            }
                        }
                        ucwa.init().then(function () {
                            isSignedIn(true);
                            // all these resources are missing in the anonymous mode
                            rGroupMemberships = ucwa.get({ rel: 'myGroupMemberships' }, null);
                            rSubscriptions = ucwa.get({ rel: 'myContactsAndGroupsSubscription' }, null);
                            rContacts = ucwa.get({ rel: 'myContacts' }, null);
                            rGroups = ucwa.get({ rel: 'myGroups' }, null);
                            rPrivacyRelationships = ucwa.get({ rel: 'myPrivacyRelationships' }, null);
                            if (rContacts)
                                importContacts(rContacts);
                            if (rGroups)
                                importGroups(rGroups);
                            if (rPrivacyRelationships)
                                importRelationships(rPrivacyRelationships);
                            if (rGroupMemberships) {
                                rGroupMemberships.updated(function () {
                                    var rev = rGroupMemberships.link('self').revision;
                                    mgmtRevision(+rev);
                                });
                            }
                        });
                        // the server tells over the event channel when a group gets added or removed;
                        // these events are not available for the relationship groups
                        ucwa.event(function (event) {
                            var scope = event['in'] || {}, link = event.target, href = link.href;
                            // these events are not available for the relationship groups
                            if (indexOf(groupRels, link.rel) >= 0) {
                                if (scope.rel == 'myGroups') {
                                    if (event.type == 'deleted') {
                                        // nothing will happen if the href is not in the collection
                                        groups.remove(href);
                                    }
                                    else if (event.type == 'added') {
                                        addToGroups(href);
                                    }
                                }
                                else if (link.rel == 'group' && event.type == 'updated' && groups(href)) {
                                    // group updated, get its latest values, the group model will
                                    // be updated automatically once the resource arrives
                                    ucwa.send('GET', href);
                                }
                            }
                            if (scope.rel == 'myContacts') {
                                if (event.type == 'added' && !persons(href)) {
                                    persons.add(contactmgr.get(href), href);
                                }
                                else if (event.type == 'deleted') {
                                    persons.remove(href);
                                }
                            }
                        });
                        return Model({
                            id: ConstProperty(null),
                            name: ConstProperty(null),
                            uri: ConstProperty(null),
                            avatarUrl: ConstProperty(null),
                            type: ConstProperty('Root'),
                            relationshipLevel: ConstProperty('None'),
                            createGroup: EnabledCommand(createLocalGroup),
                            // these commands are disabled when not signed in to
                            // simplify their implementation
                            persons: persons.asWritable({
                                // disable add method: currently not supported
                                add: DisabledCommand(addContactToContactList),
                                remove: Command(removeContactFromAllGroups, groupMgmtEnabled)
                            }),
                            groups: groups.asWritable({
                                add: Command(addGroup, groupMgmtEnabled),
                                remove: Command(removeGroup, groupMgmtEnabled)
                            })
                        });
                    }
                    return RootGroup;
                }());
                Internal.RootGroup = RootGroup;
                (function (RootGroup) {
                    ;
                })(RootGroup = Internal.RootGroup || (Internal.RootGroup = {}));
            })(Internal = Model_18.Internal || (Model_18.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_19) {
            var Internal;
            (function (Internal) {
                'use strict';
                var sdist = Web.Utils.sdist;
                var Model = Web.Utils.Model;
                var Exception = Web.Utils.Exception;
                var EnabledCommand = Web.Utils.EnabledCommand;
                var EnabledAsyncCommand = Web.Utils.EnabledAsyncCommand;
                /**
                 * It holds a root group, which contains the list of all clients and groups known to the client.
                 *
                 */
                var PersonsAndGroupsManager = (function () {
                    //#endregion
                    function PersonsAndGroupsManager(_a) {
                        var ucwa = _a.ucwa, psm = _a.psm, cm = _a.contactmgr, me = _a.me, remoteSearchResultsOnly = _a.remoteSearchResultsOnly, tm = _a.tm, settings = _a.settings;
                        var root = new Internal.RootGroup({
                            ucwa: ucwa,
                            contactmgr: cm,
                            tm: tm,
                            autoPopulate: autoPopulateOrgContacts
                        });
                        function createPersonSearchQuery() {
                            return new Internal.PersonSearchQuery({
                                ucwa: ucwa,
                                psm: psm,
                                contactmgr: cm,
                                remoteOnly: remoteSearchResultsOnly,
                                me: me,
                                settings: settings ? settings.searchSettings : {},
                                tm: tm
                            });
                        }
                        function createGroupSearchQuery() {
                            return new Internal.GroupSearchQuery({
                                ucwa: ucwa,
                                psm: psm,
                                contactmgr: cm,
                                tm: tm
                            });
                        }
                        function lookupPersonById(sipuri) {
                            if (!sipuri)
                                throw Exception('NoSipUri');
                            sipuri = sipuri.toLowerCase();
                            var matches = function (s) { return (s || '').toLowerCase() == sipuri; };
                            for (var _i = 0, _a = cm.get(); _i < _a.length; _i++) {
                                var p = _a[_i];
                                if (matches(p.id()))
                                    return p;
                            }
                            var q = createPersonSearchQuery();
                            q.text(sipuri);
                            q.limit(1);
                            return q.getMore().then(function () {
                                var r = q.results(0);
                                if (!r)
                                    throw Exception('NotFound', { sipuri: sipuri });
                                var p = q.results(0).result;
                                if (matches(p.id()))
                                    return p;
                                throw Exception('NotMatched', {
                                    sipuri: sipuri,
                                    // the point of throwing this exception is to
                                    // see it in the telemetry, but the exception
                                    // cannot contain sipuris as they are considered
                                    // to be PII and are removed/hashed; this number
                                    // is supposed to give an idea how different the
                                    // found sipuri is from the original one
                                    sdist: sdist(sipuri, p.id() || '')
                                });
                            });
                        }
                        function autoPopulateOrgContacts(numberOfExistingContacts, addToContacts) {
                            ucwa.init().then(function () {
                                if (!settings || !settings.getContactsFromGraph || numberOfExistingContacts > settings.getContactsFromGraphLowerLimit)
                                    return;
                                ucwa.graph.getTopNContacts(10).then(function (principals) {
                                    for (var _i = 0, principals_1 = principals; _i < principals_1.length; _i++) {
                                        var p = principals_1[_i];
                                        if (p.personType != 'Person')
                                            continue;
                                        var q = createPersonSearchQuery();
                                        q.text(p.emailAddresses[0].address);
                                        q.getMore().then(function (results) {
                                            if (!results[0])
                                                return;
                                            var contact = results[0].result;
                                            addToContacts(contact[Internal.sHref]);
                                            contact.displayName.get();
                                        });
                                    }
                                    ;
                                    tm && tm.record(Web.TelemetryEvent.ContactsAutoPopulate, {
                                        numberOfExistingContacts: numberOfExistingContacts,
                                        autoPopulateContactLowerLimit: settings.getContactsFromGraphLowerLimit,
                                        numberOfContactsToPopulate: principals && principals.length
                                    });
                                }).catch(function (err) {
                                    tm && tm.record(Web.TelemetryEvent.ContactsAutoPopulate, {
                                        result: 'failed',
                                        reason: err
                                    });
                                });
                            });
                        }
                        return Model({
                            mePerson: me,
                            all: root,
                            createPersonSearchQuery: EnabledCommand(createPersonSearchQuery),
                            createGroupSearchQuery: EnabledCommand(createGroupSearchQuery),
                            lookupPersonById: EnabledAsyncCommand(lookupPersonById),
                            createGroup: root.createGroup
                        });
                    }
                    return PersonsAndGroupsManager;
                }());
                Internal.PersonsAndGroupsManager = PersonsAndGroupsManager;
            })(Internal = Model_19.Internal || (Model_19.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var values = Web.Utils.values;
                var max = Web.Utils.max;
                /** It's simply a cache of all created person models. */
                var ContactManager = (function () {
                    function ContactManager(args) {
                        this.contacts = {}; // contacts[href] = Person(...)
                        this.contactExpiryTimers = {};
                        this.settings = {};
                        this.count = 0;
                        this.ucwa = args.ucwa;
                        this.psm = args.psm;
                        this.tm = args.tm;
                        args.settings = args.settings || {};
                        this.settings.maxCacheCount = args.settings.maxCacheCount || 1000;
                        this.settings.useCacheForTransientContacts = args.settings.useCacheForTransientContacts !== void 0 ?
                            args.settings.useCacheForTransientContacts : false;
                        this.settings.contactExpiryThreshold = args.settings.contactExpiryThreshold || 60 * 60 * 1000;
                        this.settings.linkedPropFetchInterval = args.settings.linkedPropFetchInterval;
                        this.settings.enableGetSubscribedProps = args.settings.enableGetSubscribedProps;
                    }
                    ContactManager.prototype.getTimeRemainingToExpiry = function (person) {
                        return max(+person.expires() - Web.Date.now() - this.settings.contactExpiryThreshold, 0);
                    };
                    ;
                    ContactManager.prototype.addToCache = function (href, person) {
                        var _this = this;
                        if (this.count < this.settings.maxCacheCount) {
                            this.contacts[href] = person;
                            this.count++;
                            var testAndDelete_1 = function () {
                                if (!_this.contacts[href])
                                    return;
                                var timetoExpiry = _this.getTimeRemainingToExpiry(_this.contacts[href]);
                                if (timetoExpiry > 0)
                                    _this.contactExpiryTimers[href] = Web.setTimeout(testAndDelete_1, timetoExpiry);
                                else
                                    _this.deleteFromCache(href);
                            };
                            person.expires.once(function (value) { return !!value; }, function () {
                                _this.contactExpiryTimers[href] = Web.setTimeout(testAndDelete_1, _this.getTimeRemainingToExpiry(person));
                            });
                        }
                        else {
                            this.tm && this.tm.record(Web.TelemetryEvent.ContactManager, {
                                result: 'cache_full',
                                count: this.count
                            });
                        }
                    };
                    ContactManager.prototype.deleteFromCache = function (href) {
                        if (!this.contacts[href])
                            return;
                        delete this.contacts[href];
                        Web.clearTimeout(this.contactExpiryTimers[href]);
                        delete this.contactExpiryTimers[href];
                        this.count--;
                        this.tm && this.tm.record(Web.TelemetryEvent.ContactManager, {
                            action: 'cached_contact_delete',
                            count: this.count
                        });
                    };
                    ContactManager.prototype.get = function (href, init, options) {
                        var _this = this;
                        if (!href)
                            return values(this.contacts);
                        var createPerson = function () { return new Internal.Person({
                            href: href,
                            name: init && init.name,
                            sipuri: init && init.sipuri,
                            photo: init && init.photo,
                            ucwa: _this.ucwa,
                            psm: _this.psm,
                            linkedPropFetchInterval: _this.settings.linkedPropFetchInterval,
                            enableGetSubscribedProps: _this.settings.enableGetSubscribedProps,
                            isOrgContact: options && options.isOrgContact
                        }); };
                        if (typeof href === 'string') {
                            if (this.contacts[href])
                                return this.contacts[href];
                            var p = createPerson();
                            if (init !== false)
                                this.addToCache(href, p);
                            return p;
                        }
                        else {
                            return createPerson();
                        }
                    };
                    /**
                     * Returns a person with the given sipuri if present in the cache.
                     * This is a noop if useCacheForTransientContacts is false
                     */
                    ContactManager.prototype.getTransientContact = function (sipUri) {
                        if (!sipUri)
                            return;
                        sipUri = sipUri.toLowerCase();
                        if (!this.settings.useCacheForTransientContacts)
                            return;
                        for (var personHref in this.contacts) {
                            if ((this.contacts[personHref].id() || '').toLowerCase() === sipUri)
                                return this.contacts[personHref];
                        }
                    };
                    /**
                     * Inserts a person into the cache only if it does not already exist.
                     * Lookup is done by person's href.
                     * This is a noop if useCacheForTransientContacts is false or maxCacheCount is reached.
                     */
                    ContactManager.prototype.cacheTransientContact = function (person) {
                        var href = person[Internal.sHref];
                        if (this.settings.useCacheForTransientContacts && href && !this.contacts[href])
                            this.addToCache(href, person);
                    };
                    return ContactManager;
                }());
                Internal.ContactManager = ContactManager;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                var sleep = Web.Utils.sleep;
                var repeat = Web.Utils.repeat;
                var Http = Web.Utils.Http;
                var Task = Web.Utils.Task;
                var NumProperty = Web.Utils.NumProperty;
                /**
                 * Creates and keeps a presence subscription to one or multiple SIP URIs.
                 *
                 */
                var PresenceSubscription = (function () {
                    /**
                     * @param duration Duration in minutes.
                     */
                    function PresenceSubscription(ucwa, uris, duration, tm) {
                        if (duration === void 0) { duration = 25; }
                        this.ucwa = ucwa;
                        this.uris = uris;
                        this.duration = duration;
                        this.tm = tm;
                        this._size = NumProperty();
                        this.active = {};
                        /** The number of SIP URIs in this subscription. */
                        this.size = this._size.asReadOnly();
                        this._size(uris.length);
                        for (var _i = 0, uris_1 = uris; _i < uris_1.length; _i++) {
                            var uri = uris_1[_i];
                            this.active[uri] = true;
                        }
                        this.init();
                    }
                    PresenceSubscription.prototype.init = function () {
                        var _this = this;
                        this.dfd = Task.wait(null, 'sync').then(function () {
                            // in the anonymous mode rel=presenceSubscriptions does not exist, so we
                            // don't send telemetry data for presence subscription.
                            var r = _this.ucwa.get({ rel: 'presenceSubscriptions' });
                            var dfd = _this.ucwa.send('POST', r.href, {
                                data: {
                                    duration: _this.duration,
                                    uris: _this.uris
                                }
                            });
                            _this.tm && _this.tm.monitor(dfd, Web.TelemetryEvent.PresenceSubscribe, { nUris: _this._size() });
                            return dfd;
                        }).then(function (r) {
                            _this.rSubscription = r;
                            // this logic should handle a more aggressive approach to extending existing
                            // presence subscription and should make it less likely that an 'updated'
                            // event will appear for this subscription
                            _this.rep = repeat(function () {
                                return sleep((_this.duration - 1) * 60).then(function () { return _this.extendDuration(); });
                            }).catch(function (err) {
                                // by this moment the stack layer should've deleted the subscription
                                // resource and fired the deleted event from it; after that the model
                                // needs to create a new subscription to the uris and continue as usual
                                if (err && err.code == 'RequestFailed' && err.rsp.status == 404 /* NotFound */)
                                    _this.init();
                                throw err;
                            });
                            // UCWA sends an empty "updated" event to warn that the subscription is about to expire
                            _this.rSubscription.dirty.when(true, function () { return _this.extendDuration(); });
                            // if UCWA deletes the subscription, the client should stop trying to extend it
                            _this.rSubscription.deleted(function () {
                                // TODO: however, if the subscription has been deleted
                                // due to a network loss, the model should rather restore
                                // the subscription and continue as though nothing has happened
                                _this.stop();
                                _this._size(0);
                                _this.active = {};
                            });
                        }).finally(function () {
                            _this.dfd = null;
                        });
                    };
                    PresenceSubscription.prototype.extendDuration = function () {
                        return this.ucwa.send('POST', this.rSubscription.href, {
                            query: { duration: this.duration }
                        });
                    };
                    PresenceSubscription.prototype.stop = function () {
                        if (this.rep) {
                            this.rep.cancel();
                            this.rep = null;
                        }
                    };
                    PresenceSubscription.prototype.add = function (uri) {
                        if (this.active[uri]) {
                        }
                        else {
                            this.active[uri] = true;
                            this._size.inc();
                        }
                    };
                    /**
                     * UCWA offers API to add one or multiple SIP URIs to an existing presence
                     * subscription, but doesn't offer an efficient way to remove a SIP URI.
                     * Thus this implementation doesn't offer a way to unsubscribe from a SIP URI
                     * without deleting the entire presence subscription. The remove method
                     * doesn't unsubscribe the given URI. Instead, it decrements an internal
                     * counter and when it reaches zero, it deletes the entire presence
                     * subscription.
                     */
                    PresenceSubscription.prototype.remove = function (uri) {
                        if (this.active[uri]) {
                            this.active[uri] = false;
                            this._size.dec();
                            if (this._size() == 0) {
                                if (this.rSubscription) {
                                    this.stop();
                                    this.ucwa.send('DELETE', this.rSubscription.href);
                                }
                                else if (this.dfd)
                                    try {
                                        this.dfd.cancel();
                                    }
                                    catch (err) {
                                    }
                            }
                        }
                    };
                    return PresenceSubscription;
                }());
                Internal.PresenceSubscription = PresenceSubscription;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                var batched = Web.Utils.batched;
                var Subscription = Web.Utils.Subscription;
                /**
                 * Creates, updates and deletes contact presence subscriptions.
                 *
                 * It's mainly responsible for merging several subscriptions into one
                 * which is supposed to reduce the pressure on the server.
                 *
                 * This is the outline of relationships between all involved resources:
                 *
                 *      /presenceSubscriptions
                 *          /presenceSubscription[i]
                 *              /addToPresenceSubscription
                 *              /memberships
                 *                  /presenceSubscriptionMembership[i]
                 *                      /presenceSubscription (link to parent)
                 *                      /contact
                 *      /subscribedContacts (a read-only view)
                 *          /contact[i]
                 *
                 */
                var PresenceSubscriptionManager = (function () {
                    function PresenceSubscriptionManager(ucwa, options) {
                        var _this = this;
                        this.subs = {};
                        this.refs = {};
                        this.dfds = {};
                        var maxBatchSize = options && options.maxBatchSize, duration = options && options.duration, tm = options && options.tm;
                        // one presence subscription cannot contain more than 75 URIs
                        this._subscribe = batched(function (uris) {
                            var psub = new Internal.PresenceSubscription(ucwa, uris, duration, tm);
                            psub.size.when(0, function () {
                                for (var _i = 0, uris_2 = uris; _i < uris_2.length; _i++) {
                                    var uri = uris_2[_i];
                                    _this.remove(uri);
                                }
                            });
                            return psub;
                        }, maxBatchSize || 75);
                    }
                    PresenceSubscriptionManager.prototype.unsubscribe = function (uri) {
                        var refs = this.refs;
                        var subs = this.subs;
                        var dfds = this.dfds;
                        refs[uri]--;
                        if (refs[uri] == 0) {
                            if (subs[uri]) {
                                subs[uri].remove(uri);
                            }
                            else {
                                try {
                                    dfds[uri].cancel();
                                }
                                catch (err) {
                                    // TODO: it's not clear what's causing this bug; suppressing it for now to not break the UI
                                    Internal.log('unsubscribe(' + uri + ') failed', err && err.stack || err);
                                }
                                this.remove(uri);
                            }
                        }
                    };
                    PresenceSubscriptionManager.prototype.remove = function (uri) {
                        delete this.dfds[uri];
                        delete this.refs[uri];
                        delete this.subs[uri];
                    };
                    /**
                     * Creates a presence subscription for the given SIP URI.
                     * The subscription manager may either create a standalone
                     * subscription or merge it with others to reduce pressure
                     * on the server.
                     *
                     *     var sub = psm.subscribe("sip:user123@contoso.com");
                     *     setTimeout(sub.dispose, 10000); // unsubscribe after 10 seconds
                     *
                     * This method may be invoked multiple times on the same SIP URI:
                     * the subscriptions manager will handle this correctly.
                     */
                    PresenceSubscriptionManager.prototype.subscribe = function (uri) {
                        var _this = this;
                        var refs = this.refs;
                        var subs = this.subs;
                        var dfds = this.dfds;
                        var isDisposed = false;
                        if (dfds[uri]) {
                            refs[uri]++;
                        }
                        else if (subs[uri]) {
                            refs[uri]++;
                            subs[uri].add(uri);
                        }
                        else {
                            refs[uri] = 1;
                            dfds[uri] = this._subscribe(uri).then(function (sub) {
                                subs[uri] = sub;
                                dfds[uri] = null;
                            });
                        }
                        return new Subscription(function () {
                            if (!isDisposed) {
                                isDisposed = true;
                                _this.unsubscribe(uri);
                            }
                        });
                    };
                    return PresenceSubscriptionManager;
                }());
                Internal.PresenceSubscriptionManager = PresenceSubscriptionManager;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_20) {
            var Internal;
            (function (Internal) {
                'use strict';
                var guid = Web.Utils.guid;
                var async = Web.Utils.async;
                var check = Web.Utils.check;
                var assert = Web.Utils.assert;
                var indexOf = Web.Utils.indexOf;
                var Task = Web.Utils.Task;
                var Event = Web.Utils.Event;
                var Model = Web.Utils.Model;
                var Property = Web.Utils.Property;
                var StringEnum = Web.Utils.StringEnum;
                var BoolProperty = Web.Utils.BoolProperty;
                /**
                 * The OnlineMeeting model encapsulates rel=onlineMeeting and rel=onlineMeetingInvitation
                 * resource objects and belongs to a Conversation model. When the endpoint receives
                 * an "onlineMeetingInvitation started" event, the OnlineMeeting model acts as the invitation
                 * and provides "accept" and "decline" methods. After the online meeting invitation is accepted,
                 * the model represents the rel=onlineMeeting resource object.
                 *
                 * Note, that UCWA has separate resource objects for scheduled online meetings:
                 * rel=myOnlineMeeting and rel=myLargeOnlineMeeting.
                 *
                 */
                var OnlineMeeting = (function () {
                    function OnlineMeeting(_a) {
                        //#region Locals
                        var ucwa = _a.ucwa, rInvitation = _a.rInvitation, rMeeting = _a.rMeeting, from = _a.from, threadId = _a.threadId, subject = _a.subject, priority = _a.priority, conversation = _a.conversation, contactManager = _a.contactManager;
                        var pState = Property();
                        var pSubject = Property();
                        var pUri = Property();
                        var pJoinUrl = Property();
                        var pPriority = Property();
                        var changed = new Event;
                        var tCreatorHref = new Task();
                        var pCreatorHref = Property({
                            get: function () { return tCreatorHref.promise; }
                        });
                        pCreatorHref.changed(function (href) { return tCreatorHref.resolve(href); });
                        var methods = {
                            start: async(start),
                            accept: async(accept),
                            decline: async(decline),
                            acknowledge: async(acknowledge)
                        };
                        var dialinhref = Property({
                            get: function () {
                                return rMeeting.link('phoneDialInInformation').href;
                            }
                        });
                        var self = Model({
                            from: from,
                            changed: changed.observer,
                            dialin: Internal.PhoneDialInInformation && new Internal.PhoneDialInInformation(ucwa, dialinhref),
                            state: pState.asReadOnly(),
                            subject: pSubject.asReadOnly(),
                            uri: pUri.asReadOnly(),
                            priority: pPriority.asReadOnly(),
                            joinUrl: pJoinUrl.asReadOnly(),
                            availableModalities: Model({
                                messaging: createAvailabilityProperty('Messaging'),
                                audio: createAvailabilityProperty('Audio'),
                                video: createAvailabilityProperty('Video'),
                                appSharing: createAvailabilityProperty('ApplicationSharing')
                            })
                        });
                        //#endregion
                        //#region Initialization
                        if (rInvitation) {
                            // the meeting model is created to represent
                            // an incoming invitation to a meeting
                            assert(from);
                            pState(OnlineMeeting.State.Notified);
                            self.accept = methods.accept;
                            self.decline = methods.decline;
                            self.acknowledge = methods.acknowledge;
                            rInvitation.updated(update);
                        }
                        else if (rMeeting) {
                            // the meeting model is created based on
                            // existing rel=onlineMeeting resource
                            pState(OnlineMeeting.State.Connected);
                            rMeeting.updated(update);
                        }
                        else {
                            // the meeting model is built from scratch
                            // to create a new online meeting
                            assert(threadId);
                            pState(OnlineMeeting.State.Created);
                            pSubject(subject);
                            pPriority(priority);
                            self.start = methods.start;
                        }
                        self.creator = contactManager.get(pCreatorHref);
                        //#endregion
                        ucwa.event(function (event) {
                            var target = event.target;
                            var resource = event.resource;
                            var context = event['in'];
                            if (event.type == 'added' && target.rel == 'onlineMeeting' && context && conversation[Internal.sHref] == context.href && !rMeeting) {
                                rMeeting = resource;
                                rMeeting.updated(update);
                            }
                        });
                        ucwa.event(function (event) {
                            var target = event.target;
                            var resource = event.resource;
                            if (event.type == 'completed' && target.rel == 'onlineMeetingInvitation' &&
                                resource.link('conversation').href == conversation[Internal.sHref] && resource.get('state') == 'Connected') {
                                pState(OnlineMeeting.State.Connected);
                            }
                        });
                        //#region Private Methods
                        function createAvailabilityProperty(modality) {
                            // it's possible to return a const false property
                            // in some cases, but this optimization will give
                            // nothing, while require more complicated code
                            var property = BoolProperty(false);
                            if (rInvitation) {
                                rInvitation.updated(function () {
                                    var modalities = rInvitation.get('availableModalities', []);
                                    var value = indexOf(modalities, modality) >= 0;
                                    property(value);
                                });
                            }
                            return property.asReadOnly();
                        }
                        /**
                         * At first it listens to rel=onlineMeetingInvitation and once it completes,
                         * it starts listening to rel=onlineMeeting.
                         */
                        function update() {
                            var r = rMeeting || rInvitation;
                            // note, that r can be either rel=onlineMeetingInvitation or rel=onlineMeeting
                            // and their property sets are similar but not identical
                            pSubject(r.get('subject', ''));
                            pUri(r.get('onlineMeetingUri', ''));
                            pJoinUrl(r.get('joinUrl', ''));
                            pPriority(r.get('importance', ''));
                            if (r.hasLink('organizer'))
                                pCreatorHref(r.link('organizer').href);
                            var state = r.has('state') && r.get('state');
                            if (state == 'Connected')
                                pState(OnlineMeeting.State.Connected);
                            else if (state == 'Failed')
                                pState(OnlineMeeting.State.Disconnected);
                        }
                        function sendMeetingJoinFailureCER(conferenceUri, event) {
                            if (!event)
                                return;
                            var app = ucwa.exists({ rel: 'application' }) && ucwa.get({ rel: 'application' });
                            if (app && app.hasLink('sendClientErrorReport')) {
                                return ucwa.send('POST', { rel: 'sendClientErrorReport' }, {
                                    data: {
                                        description: event.reason ? event.reason.message : 'Failed to join conference',
                                        conferenceUri: conferenceUri,
                                        clientErrorCode: event.reason ? event.reason.code : 'FAILURE',
                                        rel: event.target.rel
                                    },
                                    nobatch: true
                                });
                            }
                        }
                        //#endregion
                        //#region Public Methods
                        //#region start
                        /**
                         * Creates a new persistent online meeting or joins an existing one using its
                         * known URI. In addition to rel=onlineMeeting, UCWA creates a rel=conversation
                         * resource object. The sequence of requests and events is following:
                         *
                         *      - POST rel=startOnlineMeeting
                         *      - onlineMeetingInvitation started
                         *      - conversation added
                         *      - onlineMeeting added in conversation
                         *      - onlineMeetingInvitation completed
                         *
                         * After the meeting is created, the web app is supposed to add modalities.
                         *
                         * Note, that when joining an online meeting anonymously, the "onlineMeetingInvitation completed"
                         * event does not arrive until the owner of the meeting admits the anonymous
                         * guest, so before that moment OnlineMeeting::state is "Connecting" and the
                         * promise returned by OnlineMeeting::start is pending.
                         *
                         * @param {String} [uri] - The URI of an existing meeting to join.
                         * @param {String} [name] - The guest name when joining an online meeting anonymously.
                         *
                         * @returns {Promise}
                         */
                        function start(options) {
                            var uri = options && options.uri;
                            var name = options && options.name;
                            return Task.run(function () {
                                var operationId = guid(), dfdRequest, dfdStarted, dfdCompleted, dfdAdded;
                                pState(OnlineMeeting.State.Connecting);
                                // prevent calling start twice
                                delete self.start;
                                changed.fire();
                                // Send a POST to rel=startOnlineMeeting.
                                // The response to this request usually comes
                                // before any events, but this is not guaranteed.
                                if (uri) {
                                    dfdRequest = ucwa.send('POST', { rel: 'joinOnlineMeeting' }, {
                                        data: {
                                            operationId: operationId,
                                            threadId: threadId,
                                            anonymousDisplayName: name,
                                            onlineMeetingUri: uri
                                        }
                                    });
                                }
                                else {
                                    dfdRequest = ucwa.send('POST', { rel: 'startOnlineMeeting' }, {
                                        data: {
                                            operationId: operationId,
                                            threadId: threadId,
                                            subject: subject || '',
                                            importance: priority || 'Normal'
                                        }
                                    });
                                }
                                // Wait for "onlineMeetingInvitation started" event.
                                // The only reason to wait for this event is to get the rel=conversation link
                                // and then use that link to find the corresponding "onlineMeeting added" event.
                                // Note, that this event may not arrive at all, if UCWA rejected the attempt
                                // to create an online meeting.
                                dfdStarted = ucwa.wait({
                                    type: 'started',
                                    target: { rel: 'onlineMeetingInvitation' },
                                    resource: { operationId: operationId }
                                }).then(function (event) {
                                    assert(!rInvitation);
                                    rInvitation = event.resource;
                                    rInvitation.updated(update);
                                });
                                // Wait for "onlineMeetingInvitation completed" event.
                                // This event indicates the successful completion of
                                // the operation and this event usually arrives last.
                                // When joining anonymously an online meeting, this event
                                // arrives after the owner of the meeting admits the guest.
                                dfdCompleted = ucwa.wait({
                                    type: 'completed',
                                    target: { rel: 'onlineMeetingInvitation' },
                                    resource: { operationId: operationId }
                                }).then(function (event) {
                                    if (event.status != 'Success') {
                                        sendMeetingJoinFailureCER(uri, event);
                                        throw Internal.EInvitationFailed(event.reason);
                                    }
                                });
                                // Wait for "onlineMeeting added in conversation" event.
                                // After the invitation succeeds, UCWA sends a rel=onlineMeeting resource
                                // with the persistent join URL and other information about the meeting,
                                // so the ONlineMeeting model must start using this resource as the source
                                // of data.
                                dfdAdded = ucwa.wait({
                                    type: 'added',
                                    target: { rel: 'onlineMeeting' },
                                    resource: function (r) {
                                        return rInvitation && r.link('conversation').href == rInvitation.link('conversation').href;
                                    }
                                }).then(function (event) {
                                    // TODO: refactor this event handler with the other one.
                                    rInvitation.updated.off(update);
                                    if (!rMeeting) {
                                        rMeeting = event.resource;
                                        rMeeting.updated(update);
                                    }
                                });
                                return Task.waitAll([
                                    dfdRequest,
                                    dfdStarted,
                                    dfdCompleted,
                                    dfdAdded
                                ]);
                            }).then(function () {
                                pState(OnlineMeeting.State.Connected);
                            }).catch(function (error) {
                                // if something went wrong, restore the original state
                                self.start = methods.start;
                                pState(OnlineMeeting.State.Created, error);
                                changed.fire();
                                throw error;
                            });
                        }
                        //#endregion
                        //#region accept
                        /**
                         * Accepts the invitation to the online meeting. To do that this method:
                         *
                         *      - Sends a POST to rel=onlineMeetingInvitation/rel=accept.
                         *      - Waits for "onlineMeeting added" event to get the rel=onlineMeeting resource.
                         *      - Waits for "onlineMeetingInvitation completed" event.
                         *
                         * If the operation succeeds, the final state is:
                         *
                         *      - pState is "Connected"
                         *      - rMeeting is the rel=onlineMeeting resource
                         *
                         * If the operation fails, the final state is:
                         *
                         *      - pState is "Disconnected"
                         *
                         * The operation completes after receiving the "onlineMeetingInvitation completed" event.
                         * After the meeting is accepted, the corresponding conversation adds the messaging
                         * modality.
                         *
                         * @returns {Promise}
                         */
                        function accept() {
                            check.state(pState(), OnlineMeeting.State.Notified);
                            pState(OnlineMeeting.State.Connecting);
                            return Task.run(function () {
                                var dfdMeetingAdded; // "onlineMeeting added" event
                                var dfdInvitationCompleted; // "onlineMeetingInvitation completed" event
                                var dfdInvitationRequest; // POST rel=onlineMeetingInvitation/rel=accept
                                dfdInvitationRequest = ucwa.send('POST', rInvitation.link('accept').href);
                                dfdMeetingAdded = ucwa.wait({
                                    type: 'added',
                                    target: { rel: 'onlineMeeting' },
                                    resource: function (r) {
                                        return r.link('conversation').href == rInvitation.link('conversation').href;
                                    }
                                }).then(function (event) {
                                    // TODO: refactor this event handler with other one
                                    rInvitation.updated.off(update);
                                    if (!rMeeting) {
                                        rMeeting = event.resource;
                                        rMeeting.updated(update);
                                    }
                                });
                                dfdInvitationCompleted = ucwa.wait({
                                    type: 'completed',
                                    target: { rel: 'onlineMeetingInvitation', href: rInvitation.href }
                                }).then(function (event) {
                                    if (event.status != 'Success') {
                                        var onlineMeetingUri = event.resource.has('onlineMeetingUri') &&
                                            event.resource.get('onlineMeetingUri');
                                        sendMeetingJoinFailureCER(onlineMeetingUri, event);
                                        throw Internal.EInvitationFailed(event.reason);
                                    }
                                });
                                return Task.waitAll([
                                    dfdInvitationRequest,
                                    dfdMeetingAdded,
                                    dfdInvitationCompleted
                                ]);
                            }).then(function () {
                                delete self.accept;
                                delete self.decline;
                                pState(OnlineMeeting.State.Connected);
                                changed.fire();
                            }).catch(function (error) {
                                pState(OnlineMeeting.State.Disconnected, error);
                                throw error;
                            });
                        }
                        //#endregion
                        //#region decline
                        function decline(reason) {
                            if (reason === void 0) { reason = 'Global'; }
                            check.state(pState(), OnlineMeeting.State.Notified);
                            return ucwa.send('POST', rInvitation.link('decline').href, {
                                data: { reason: reason }
                            }).then(function () { return pState(OnlineMeeting.State.Disconnected); });
                        }
                        //#endregion
                        //#region acknowledge
                        function acknowledge() {
                            return ucwa.send('POST', rInvitation.link('acknowledge').href).then(function () {
                                pState(OnlineMeeting.State.Disconnected);
                            });
                        }
                        //#endregion
                        //#endregion
                        return self;
                    }
                    return OnlineMeeting;
                }());
                Internal.OnlineMeeting = OnlineMeeting;
                (function (OnlineMeeting) {
                    OnlineMeeting.State = StringEnum('Created', 'Notified', 'Connecting', 'Connected', 'Disconnected');
                    OnlineMeeting.AccessLevel = StringEnum('Everyone', 'Invited', 'Locked', 'SameEnterprise');
                    OnlineMeeting.AutomaticLeaderAssignment = StringEnum('Disabled', 'Everyone', 'SameEnterprise');
                    OnlineMeeting.EntryExitAnnouncement = StringEnum('Disabled', 'Enabled');
                    OnlineMeeting.LobbyBypassForPhoneUsers = StringEnum('Disabled', 'Enabled');
                    OnlineMeeting.PhoneUserAdmission = StringEnum('Disabled', 'Enabled');
                })(OnlineMeeting = Internal.OnlineMeeting || (Internal.OnlineMeeting = {}));
            })(Internal = Model_20.Internal || (Model_20.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var dateToTimeStamp = Web.Utils.dateToTimeStamp;
                var timeStampToDate = Web.Utils.timeStampToDate;
                var Property = Web.Utils.Property;
                /**
                 * Encapsulates rel=myOnlineMeeting resource object and is the result of
                 * scheduling a meeting. It basically takes the resource object and exposing properties as either
                 * settable or read-only using an ObservableResource. The settable properties can trigger an
                 * aggregated update of the underlying resource object if the new values differ. The onlineMeetingUri
                 * property can be used to start/join the meeting.
                 *
                 */
                var MyOnlineMeeting = (function () {
                    //#endregion
                    function MyOnlineMeeting(ucwa, _a) {
                        var _b = _a === void 0 ? {} : _a, href = _b.href, tm = _b.tm;
                        var pHRef = Property({
                            value: href,
                            get: function () {
                                var promise = ucwa.send('POST', { rel: 'myOnlineMeetings' }, {
                                    // before the request is sent to UCWA, it's serialized
                                    // by JSON.stringify which drops undefineds
                                    data: self.toJSON()
                                }).then(function (r) {
                                    tm && tm.record(Web.TelemetryEvent.ScheduleMeeting, { onlineMeetingId: r.get("onlineMeetingId", void 0) });
                                    return r.href;
                                }, function (e) {
                                    throw e;
                                });
                                tm && tm.monitor(promise, Web.TelemetryEvent.ScheduleMeeting, {}, { timeout: 5000 });
                                return promise;
                            }
                        });
                        var self = Internal.ObservableResource(ucwa, pHRef, function ($) {
                            $.property('accessLevel', { canInit: true });
                            $.property('attendees', { canInit: true }); // TODO: this needs to be a collection
                            $.property('automaticLeaderAssignment', { canInit: true });
                            $.property('description', { canInit: true });
                            $.property('entryExitAnnouncement', { canInit: true });
                            $.property('expirationTime', {
                                canInit: true,
                                parse: timeStampToDate,
                                convert: dateToTimeStamp,
                                prepare: function (val) { return val && val.toJSON(); }
                            });
                            $.property('joinUrl', { readOnly: true });
                            $.property('leaders', { canInit: true }); // TODO: this needs to be a collection
                            $.property('lobbyBypassForPhoneUsers', { canInit: true });
                            $.property('onlineMeetingId', { readOnly: true });
                            $.property('onlineMeetingUri', { readOnly: true });
                            $.property('organizerUri', { readOnly: true });
                            $.property('phoneUserAdmission', { canInit: true });
                            $.property('subject', { canInit: true });
                        });
                        return self;
                    }
                    return MyOnlineMeeting;
                }());
                Internal.MyOnlineMeeting = MyOnlineMeeting;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                var isString = Web.Utils.isString;
                var setHiddenProperty = Web.Utils.setHiddenProperty;
                var sanitizeHtml = Web.Utils.sanitizeHtml;
                var convertHtmlToText = Web.Utils.convertHtmlToText;
                var convertTextToHtml = Web.Utils.convertTextToHtml;
                var disableHtmlInText = Web.Utils.disableHtmlInText;
                var Property = Web.Utils.Property;
                var BaseModel = Web.Utils.BaseModel;
                var Collection = Web.Utils.Collection;
                var ConstProperty = Web.Utils.ConstProperty;
                /*
                 * Remove leading and trailing white spaces as well as empty <div>
                 * tags from the input html string.
                 *
                 */
                function trimHtml(html) {
                    var re = /^\s*<div>([\s\S]*)<\/div>\s*$/i;
                    return re.test(html) ?
                        trimHtml(html.replace(re, '$1')) :
                        html.trim();
                }
                /**
                 * This is an incoming or an outgoing instant message in a conversation.
                 *
                 */
                var Message = (function (_super) {
                    __extends(Message, _super);
                    function Message(_a) {
                        var ucwa = _a.ucwa, _b = _a.href, href = _b === void 0 ? '' : _b, sender = _a.sender, _c = _a.status, status = _c === void 0 ? Message.Status.Succeeded : _c, _d = _a.time, time = _d === void 0 ? new Web.Date : _d, participants = _a.participants, ndrs = _a.ndrs, text = _a.text, html = _a.html, direction = _a.direction;
                        var _this = _super.call(this) || this;
                        _this.isEdited = ConstProperty(false);
                        _this.isDeleted = ConstProperty(false);
                        text = (text || '').trim();
                        html = (html || '').trim();
                        // infer text from html
                        if (html && !text) {
                            try {
                                text = convertHtmlToText(html);
                            }
                            catch (err) {
                                text = '';
                            }
                        }
                        // infer html from text
                        if (text && !html) {
                            try {
                                html = convertTextToHtml(text);
                            }
                            catch (err) {
                                html = '';
                            }
                        }
                        var _href = !href || isString(href) ?
                            ConstProperty(href) :
                            href;
                        var _status = isString(status) ?
                            Property({ value: status }) :
                            status;
                        _href.changed(function (s) { return setHiddenProperty(_this, Internal.sHref, s); });
                        var _ndr_participants = Collection();
                        function addFailedDeliveryParticipants(ndrs) {
                            for (var _i = 0, ndrs_1 = ndrs; _i < ndrs_1.length; _i++) {
                                var link = ndrs_1[_i];
                                for (var _a = 0, _b = participants(); _a < _b.length; _a++) {
                                    var p = _b[_a];
                                    if (p[Internal.sHref] == link.href && !_ndr_participants(link.href))
                                        _ndr_participants.add(p, link.href);
                                }
                            }
                        }
                        if (ndrs && participants)
                            addFailedDeliveryParticipants(ndrs);
                        if (_status() != Message.Status.Succeeded) {
                            ucwa.wait({
                                type: 'completed',
                                target: { rel: 'message' },
                                resource: function (r) {
                                    // _href() is not available immediately
                                    return r.href == _href();
                                }
                            }).then(function (event) {
                                _status(event.status == 'Success' ?
                                    Message.Status.Succeeded :
                                    Message.Status.Failed, event.reason);
                                if (participants)
                                    addFailedDeliveryParticipants(event.resource.links('failedDeliveryParticipant'));
                            });
                        }
                        _this.sender = sender;
                        _this.text = ConstProperty(text && disableHtmlInText(text).trim()); // html is disabled to prevent xss
                        _this.html = ConstProperty(html && trimHtml(sanitizeHtml(html))); // sanitize html to prevent xss                
                        _this.timestamp = ConstProperty(time);
                        _this.direction = ConstProperty(direction || (_href() || _href() == '' ? Message.Direction.Incoming : Message.Direction.Outgoing));
                        _this.status = _status.asReadOnly();
                        _this.failedDeliveryParticipants = _ndr_participants.asReadOnly();
                        return _this;
                    }
                    return Message;
                }(BaseModel));
                Internal.Message = Message;
                (function (Message) {
                    var Status;
                    (function (Status) {
                        Status.Pending = 'Pending';
                        Status.Succeeded = 'Succeeded';
                        Status.Failed = 'Failed';
                    })(Status = Message.Status || (Message.Status = {}));
                    var Direction;
                    (function (Direction) {
                        Direction.Incoming = 'Incoming';
                        Direction.Outgoing = 'Outgoing';
                    })(Direction = Message.Direction || (Message.Direction = {}));
                })(Message = Internal.Message || (Internal.Message = {}));
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_21) {
            var Internal;
            (function (Internal) {
                'use strict';
                var random = Web.Utils.random;
                var inherit = Web.Utils.inherit;
                var Property = Web.Utils.Property;
                var BoolProperty = Web.Utils.BoolProperty;
                var ConstProperty = Web.Utils.ConstProperty;
                var Model = Web.Utils.Model;
                /**
                 * A general purpose activity item like a text message, a video call, etc.
                 *
                 * It takes an existing model as a prototype, creates a derived activity item
                 * object and augments it with missing properties.
                 *
                 */
                var ActivityItem = (function () {
                    function ActivityItem(type, key, prototype) {
                        var reason = Property();
                        if (prototype.status)
                            prototype.status.changed(function (newValue, newReason) { return reason(newReason); });
                        // create an object inherited from the prototype and add
                        // missing properties to the create object
                        return inherit(Model(prototype), {
                            type: ConstProperty(type),
                            key: ConstProperty(key || random()),
                            timestamp: ConstProperty(new Web.Date),
                            status: ConstProperty('Succeeded'),
                            reason: reason.asReadOnly(),
                            isRead: BoolProperty(false)
                        }, 'append');
                    }
                    return ActivityItem;
                }());
                Internal.ActivityItem = ActivityItem;
            })(Internal = Model_21.Internal || (Model_21.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_22) {
            var Internal;
            (function (Internal) {
                var map = Web.Utils.map;
                var keys = Web.Utils.keys;
                var take = Web.Utils.take;
                var async = Web.Utils.async;
                var assert = Web.Utils.assert;
                var extend = Web.Utils.extend;
                var foreach = Web.Utils.foreach;
                var inherit = Web.Utils.inherit;
                var indexOf = Web.Utils.indexOf;
                var isArray = Web.Utils.isArray;
                var isModel = Web.Utils.isModel;
                var isProperty = Web.Utils.isProperty;
                var isCollection = Web.Utils.isCollection;
                var isEmptyObject = Web.Utils.isEmptyObject;
                var timeStampToDate = Web.Utils.timeStampToDate;
                var isNotEmptyString = Web.Utils.isNotEmptyString;
                var setHiddenProperty = Web.Utils.setHiddenProperty;
                var disableHtmlInText = Web.Utils.disableHtmlInText;
                var URI = Web.Utils.URI;
                var Model = Web.Utils.Model;
                var Property = Web.Utils.Property;
                var Collection = Web.Utils.Collection;
                var StringEnum = Web.Utils.StringEnum;
                var Subscription = Web.Utils.Subscription;
                var ConstProperty = Web.Utils.ConstProperty;
                var TYPE_PHONE = 'Phone';
                /**
                 * A read-only representation of a Person in a contact list or in a search query.
                 *
                 * A Person model is created on top of a "contact" resource from UCWA.
                 * When created, it does not send any HTTP requests to get additional
                 * information about the Person, but waits for the view layer
                 * (or whoever created the Person model) to subscribe to one of the
                 * Person model properties. For example, when the caller starts
                 * listening to Person name changes
                 *
                 *      person1.displayName.changed(function (name) {
                 *          console.log("the contact's name is " + name);
                 *      });
                 *
                 * the Person model checks whether the property is already
                 * available and if so, the Person model does not fetches it
                 * again from the server, If the property value is not available,
                 * the Person model sends all HTTP server requests necessary to obtain
                 * that value. For example for the
                 * code snippet above where someone subscribes to the "displayName" property,
                 * the Person model sends up to one HTTP request to load the resource:
                 *
                 *      GET /contacts/126173
                 *
                 * For more complicated properties, like "status", it may be necessary
                 * to send extra HTTP requests to create a presence subscription. So when
                 * someone starts listening to the "status" property
                 *
                 *      sub = person1.status.subscribe();
                 *      person1.status.changed(onPresenceChanged);
                 *      function onPresenceChanged(presence) {
                 *          console.log("the contact is " + presence.availability);
                 *      }
                 *
                 * the Person model sends a POST request to create a presence subscription
                 * (in addition to all requests that are necessary to get the URL to which
                 * that POST request can be sent):
                 *
                 *      POST /contacts/126173/presencesubscriptions
                 *
                 *      {"Uris":["sip:johndoe@contoso.com"], "Duration":"11"}
                 *
                 * But after the view stops listening to the property
                 *
                 *      sub.dispose();
                 *
                 * the Person model sends a DELETE request to remove the presence subscription:
                 *
                 *      DELETE /contacts/126173/presencesubscriptions/2877816481
                 *
                 * This is why a well written web app should unsubscribe from Person models
                 * after it does not need them. The Person model cannot do this itself, because
                 * in JavaScript there is no concept of "finalizers" or "destructors" and so
                 * the Person model cannot know when it's no longer needed.
                 *
                 */
                var Person = (function () {
                    //#endregion
                    function Person(spec) {
                        var href = spec.href, ucwa = spec.ucwa, _name = spec.name, _sipuri = spec.sipuri, _photo = spec.photo, psm = spec.psm || new Internal.PresenceSubscriptionManager(ucwa), // defaults for unit tests
                        dfdGet, // tracks the progress of GET rel=contact
                        dfdGetLink = {}, // tracks the progress of GET rel=contactPresence for example
                        // Prevent app from calling the .get() method of any linked property of a Person model
                        // more than once in this amount of time. Additional calls to .get() within this interval
                        // will just return the cached value. Default value is 0, which ensures that a .get() always
                        // sends an actual GET request to the server
                        linkedPropFetchInterval = spec.linkedPropFetchInterval != void 0 ?
                            spec.linkedPropFetchInterval * 60 * 1000 :
                            0, 
                        // If false, attempting to call property.get() for a property to which we are subscribed
                        // will return the cached value, as the value of a subscribed property should be kept up
                        // to date by the fetches triggered by 'property updated' events alone.
                        enableGetSubscribedProps = spec.enableGetSubscribedProps != void 0 ?
                            spec.enableGetSubscribedProps : true, PropType = StringEnum('direct', 'linked', 'photo'), 
                        // presence subscription is needed when the Person wants to observe linked properties
                        // (status, activity, note, location, capabilities, relationship):
                        // - subscriptionRefCount tracks the number of observed linked properties and tells the
                        //   Person when to create or delete the subscription.
                        subscriptionRefCount = 0, subscription, 
                        // If true, UI can disable the deletion operation
                        isOrgContact = !!spec.isOrgContact, 
                        // Property<Resource> which gets the possibly empty rel=contact on demand
                        prContact = (typeof href === 'string' ? ConstProperty(href) : href).map(function (href) { return ucwa.get(href); }), proto = Model(), self = inherit(proto);
                        spec = null; // no need to use `spec` beyond this point
                        var properties = {};
                        initialize();
                        //#region methods
                        function getPropertyValue(name) {
                            var prop = properties[name];
                            return prContact.get().then(function (r) {
                                // the contact resource may contain an incomplete
                                // set of properties and links: UCWA reserves the right
                                // to return partial resources in certain cases (contact search)
                                var isValueAvailable = prop.type == PropType.direct ?
                                    r.has(prop.internalName) :
                                    r.hasLink(prop.internalName);
                                if (!isValueAvailable)
                                    return fetchContactResource();
                            }).then(function () {
                                switch (prop.type) {
                                    case PropType.linked:
                                        return fetchLinkedProperty(prop.link).then(function (result) {
                                            prop.lastFetched = Web.Date.now();
                                            prop.dirty = false;
                                            updatePropertyFromResource(prop, result);
                                        });
                                    case PropType.photo:
                                        return getPhoto();
                                }
                            }).then(function () {
                                // at this moment the updated value
                                // is in the cache of the property
                                return prop.property();
                            });
                        }
                        /**
                         * Defines a property of this Person.
                         *
                         * @param {string} name - public property name
                         * @param {object} def - an object with the following properties:
                         *
                         *      internal     - a name of this property in the UCWA contact resource.
                         *                     this can be an array of names if several UCWA properties
                         *                     are combined into one collection.
                         *      type         - property type (can be direct, linked or photo).
                         *      field        - the sub-property of the internal UCWA contact resource.
                         *      element      - the element name in the internal UCWA contact resource
                         *                     if the resource is an array.
                         *      isCollection - whether this property is a Collection or not.
                         *      transform    - a function used to transform the UCWA resource value
                         *                     into a form specifically needed by the property.
                         *
                         * @remark:
                         *
                         *  Fills out the internal properties of a Person model with the UCWA resources' definitions.
                         *
                         *  A value of the direct property can be found in the UCWA contact resource;
                         *  a linked property is accessible only via a link in the UCWA contact resource;
                         *  photo is also a linked property, but we make it a separate type because it
                         *  is retrieved from the server not like other linked properties.
                         *
                         *  Each property also has a "link" field; for linked properties it is the property
                         *  link in the UCWA contact resource; it is null for properties whose values are
                         *  immediately available in the contact resource.
                         *
                         * @returns {Property|Collection}
                         *
                         */
                        function defineProperty(name, def) {
                            assert(isNotEmptyString(name));
                            assert(!def || PropType[def.type]);
                            var property = (def && def.isCollection ? Collection : Property)({
                                value: def && def.value,
                                get: function () {
                                    var lf = properties[name].lastFetched;
                                    // If we are already subscribed to a property, and it has been fetched
                                    // at least once, calling prop.get() returns the cached value.
                                    if (properties[name].observed) {
                                        if (enableGetSubscribedProps || lf == void 0 /* can be 0 in UT */)
                                            return getPropertyValue(name);
                                        else
                                            return property();
                                    }
                                    else if (lf != void 0 && lf > Web.Date.now() - linkedPropFetchInterval)
                                        return property();
                                    else
                                        return getPropertyValue(name);
                                },
                                subscribed: function () {
                                    // fetch some properties from the server only when some other object is binding
                                    // to those properties for the first time
                                    onPropertySubscribed(properties[name]);
                                },
                                unsubscribed: function () {
                                    onPropertyUnsubscribed(properties[name]);
                                }
                            });
                            properties[name] = {
                                internalName: def && def.internal || name,
                                modelName: name,
                                type: def && def.type || PropType.direct,
                                field: def && def.field,
                                element: def && def.element,
                                observed: false,
                                dirty: false,
                                link: def && def.link || null,
                                transform: def && def.transform,
                                // Prevent too many GETs of a property within a configurable time interval.
                                // Any additional calls of .get() will return the cached value. This variable
                                // only ever becomes defined for linked properties.
                                lastFetched: null,
                                property: property
                            };
                            return properties[name].property.asReadOnly();
                        }
                        function initialize() {
                            // define properties
                            self.id = defineProperty('id', { internal: 'uri', type: PropType.direct, value: _sipuri });
                            self.sourceNetwork = defineProperty('sourceNetwork');
                            self.company = defineProperty('company');
                            self.department = defineProperty('department');
                            self.office = defineProperty('office');
                            self.title = defineProperty('title');
                            self.expires = defineProperty('expires', { transform: timeStampToDate, type: PropType.direct });
                            self.emails = defineProperty('emails', {
                                internal: 'emailAddresses',
                                type: PropType.direct,
                                isCollection: true,
                                transform: function (arr) {
                                    return map(arr || [], function (email) {
                                        return Model({
                                            type: ConstProperty(null),
                                            emailAddress: ConstProperty(email)
                                        });
                                    });
                                }
                            });
                            self.phoneNumbers = defineProperty('phoneNumbers', {
                                // phoneNumbers is an aggregate of 4 UCWA direct resources
                                internal: ['workPhoneNumber', 'homePhoneNumber', 'mobilePhoneNumber', 'otherPhoneNumber'],
                                type: PropType.direct,
                                isCollection: true,
                                transform: function (phones) {
                                    // keys are UCWA resource names, values are jCafe phone types
                                    var phoneTypes = {
                                        workPhoneNumber: 'Work',
                                        homePhoneNumber: 'Home',
                                        mobilePhoneNumber: 'Cell',
                                        otherPhoneNumber: 'Other'
                                    };
                                    /* phones is an array of objects:
                                     * [ {'workPhoneNumber':'xxx-xxx-xxxx'},
                                     *   {'homePhoneNumber':'xxx-xxx-xxxx'},
                                     *   {'mobilePhoneNumber':'xxx-xxx-xxxx'},
                                     *   {'otherPhoneNumber':'xxx-xxx-xxxx'} ]
                                     */
                                    return (phones || []).filter(function (phone) {
                                        var type = null, value = null, k = keys(phone);
                                        if (k.length == 1) {
                                            if (k[0] in phoneTypes) {
                                                type = phoneTypes[k[0]];
                                                value = phone[k[0]];
                                            }
                                        }
                                        return type && value;
                                    }).map(function (phone) {
                                        var k = keys(phone)[0], telUri = phone[k], displayString = Person.extractPhoneNumber(telUri);
                                        return Model({
                                            type: ConstProperty(phoneTypes[k]),
                                            telUri: ConstProperty(telUri),
                                            displayString: ConstProperty(displayString)
                                        });
                                    });
                                }
                            }).sort(function (p1, p2) { return p1.type() < p2.type(); });
                            self.workPhone = defineProperty('workPhone', { internal: 'workPhoneNumber', type: PropType.direct });
                            self.homePhone = defineProperty('homePhone', { internal: 'homePhoneNumber', type: PropType.direct });
                            self.mobilePhone = defineProperty('mobilePhone', { internal: 'mobilePhoneNumber', type: PropType.direct });
                            self.otherPhone = defineProperty('otherPhone', { internal: 'otherPhoneNumber', type: PropType.direct });
                            self.type = defineProperty('type', { type: PropType.direct, value: /;user=phone$/.test(_sipuri) ? 'Phone' : undefined });
                            self.displayName = defineProperty('displayName', { internal: 'name', type: PropType.direct, value: _name, transform: disableHtmlInText });
                            self.avatarUrl = defineProperty('avatarUrl', { internal: 'contactPhoto', type: PropType.photo, link: _photo });
                            self.status = defineProperty('status', { internal: 'contactPresence', type: PropType.linked, field: 'availability', transform: Person.fixStatus });
                            self.endpointType = defineProperty('endpointType', { internal: 'contactPresence', type: PropType.linked, field: 'deviceType', transform: Person.fixDeviceType });
                            self.lastSeenAt = defineProperty('lastSeenAt', { internal: 'contactPresence', type: PropType.linked, field: 'lastActive', transform: timeStampToDate });
                            self.activity = defineProperty('activity', { internal: 'contactPresence', type: PropType.linked, field: 'activity', transform: disableHtmlInText });
                            self.relationship = defineProperty('relationship', { internal: 'contactPrivacyRelationship', type: PropType.linked, field: 'relationshipLevel' });
                            self.location = defineProperty('location', { internal: 'contactLocation', type: PropType.linked, field: 'location', transform: disableHtmlInText });
                            // the location property contains a few sub-properties
                            // they are not defined by UCWA but needed in jCafe
                            extend(self.location, {
                                type: ConstProperty(null),
                                street: ConstProperty(null),
                                city: ConstProperty(null),
                                state: ConstProperty(null),
                                country: ConstProperty(null),
                                postalCode: ConstProperty(null)
                            });
                            // the Person#note object contains 2 sub-properties
                            // These properties need to be managed under the properties array
                            // to facilitate property subscription/unsubscription, and they
                            // should NOT be be added as direct properties of the Person model.
                            self.note = Model({
                                type: defineProperty('note.type', { internal: 'contactNote', type: PropType.linked, field: 'type' }),
                                text: defineProperty('note.text', { internal: 'contactNote', type: PropType.linked, field: 'message', transform: disableHtmlInText })
                            });
                            // the Person.capabilities object contains 5 sub-properties
                            // These properties need to be managed under the properties array
                            // to facilitate property subscription/unsubscription, and they
                            // should NOT be be added as direct properties of the Person model.
                            self.capabilities = Model({
                                chat: defineProperty('capabilities.chat', {
                                    internal: 'contactSupportedModalities',
                                    type: PropType.linked,
                                    field: 'modalities',
                                    element: 'Messaging'
                                }),
                                audio: defineProperty('capabilities.audio', {
                                    internal: 'contactSupportedModalities',
                                    type: PropType.linked,
                                    field: 'modalities',
                                    element: 'Audio'
                                }),
                                video: defineProperty('capabilities.video', {
                                    internal: 'contactSupportedModalities',
                                    type: PropType.linked,
                                    field: 'modalities',
                                    element: 'Video'
                                }),
                                screenSharing: defineProperty('capabilities.screenSharing', {
                                    internal: 'contactSupportedModalities',
                                    type: PropType.linked,
                                    field: 'modalities',
                                    element: 'ApplicationSharing'
                                }),
                                dataCollaboration: defineProperty('capabilities.dataCollaboration', {
                                    internal: 'contactSupportedModalities',
                                    type: PropType.linked,
                                    field: 'modalities',
                                    element: 'DataCollaboration'
                                })
                            });
                            // TODO: the setter of this property should move the contact to the Blocked group
                            self.isBlocked = ConstProperty(false, { code: 'NotSupported' });
                            self._isOrganizationContact = ConstProperty(isOrgContact);
                            // once the rel=contact resource becomes available...
                            prContact.once(function (r) { return !!r; }, function () {
                                var r = prContact();
                                // sHref will be a hidden symbol for Contact objects
                                setHiddenProperty(proto, Internal.sHref, r.href);
                                // listen to contact resource update events;
                                // this will also populate direct properties if we have a non-empty
                                // contact resource in the repository
                                r.updated(function () {
                                    foreach(properties, function (property) {
                                        var name = property.internalName;
                                        var value;
                                        // Phone contacts don't have a href to query capabilities, therefore we enable the audio
                                        // capability by default
                                        if (isPhoneContact()) {
                                            properties['capabilities.audio'].property(true);
                                        }
                                        if (property.type != PropType.direct) {
                                            property.link = r.relatedHref(name);
                                            return;
                                        }
                                        value = transformValue(getValue());
                                        // if there was an initial value for the property,
                                        // don't drop it if the resource is empty
                                        if (!r.dirty() || value !== undefined) {
                                            property.property(value);
                                        }
                                        function isPhoneContact() {
                                            return name === 'type' && r.properties[name] === TYPE_PHONE;
                                        }
                                        function getValue() {
                                            if (!isArray(name))
                                                return r.properties[name];
                                            return name.filter(function (i) { return r.properties[i]; }).map(function (i) { return take(r.properties, i); });
                                        }
                                        function transformValue(value) {
                                            if (property.transform)
                                                return property.transform(value);
                                            return value;
                                        }
                                    });
                                });
                            });
                            // properties like presence/note/location most likely have
                            // outdated values by the moment the connection is restored
                            ucwa.restored(function () {
                                for (var _i = 0, _a = ['status']; _i < _a.length; _i++) {
                                    var name_10 = _a[_i];
                                    var prop = properties[name_10];
                                    if (prop.observed)
                                        prop.property.get();
                                }
                            });
                            ucwa.event(onSubscriptionEvent);
                            // some linked properties may be available in the resource cache
                            updateLinkedPropsOrGetMissingProperties();
                            // the photo URL may be already available in the resource cache
                            getPhoto();
                        }
                        /**
                         * An internal event handler invoked only when some other object
                         * is binding to a Person property for the first time.
                         */
                        function onPropertySubscribed(p) {
                            p.observed = true;
                            switch (p.type) {
                                case PropType.direct:
                                    prContact.get().then(function (r) {
                                        if (!r.has(p.internalName))
                                            fetchContactResource();
                                    });
                                    break;
                                case PropType.linked:
                                    // the link href of the property isn't needed: the subscription
                                    // and the consequent updates can be handled without this link
                                    createSubscription(p);
                                    break;
                                case PropType.photo:
                                    // as of Oct 2014 UCWA doesn't have an API to create a subscription
                                    // to a contact's photo; if later it gets one, this is the right place
                                    // to invoke it; for now creating a subscription to a contact's photo
                                    // is no different from fetching it once
                                    p.property.get();
                                    break;
                            }
                        }
                        function onPropertyUnsubscribed(p) {
                            p.observed = false;
                            if (p.type == PropType.linked)
                                deleteSubscription();
                        }
                        /**
                         * Fetches the rel=contact resource once.
                         * Subsequent calls to this function return
                         * an already resolved promise.
                         */
                        function fetchContactResource() {
                            if (!dfdGet) {
                                dfdGet = prContact.get().then(function (r) {
                                    return ucwa.send('GET', r.href);
                                });
                                // if the server returned the rel=contact resource,
                                // don't fetch it again as it's unlikely it will change;
                                // but if the server failed to return the resource,
                                // allow further attempts to fetch it again
                                dfdGet.then(null, function () {
                                    dfdGet = null;
                                });
                            }
                            return dfdGet;
                        }
                        /**
                         * Sends only one GET to a linked resource even if invoked multiple times.
                         */
                        function fetchLinkedProperty(link) {
                            // TODO: This is a pretty common pattern which is known as debouncing.
                            if (!dfdGetLink[link]) {
                                dfdGetLink[link] = ucwa.send('GET', link).finally(function () {
                                    dfdGetLink[link] = null;
                                });
                            }
                            return dfdGetLink[link];
                        }
                        /**
                         * Fetches Person photo from the server
                         */
                        function getPhoto() {
                            var prop = properties['avatarUrl'];
                            if (prop.link) {
                                return Person.getPhotoUrl({
                                    ucwa: ucwa,
                                    path: prop.link
                                }).then(function (url) {
                                    prop.property(url);
                                });
                            }
                        }
                        function createSubscription(prop) {
                            subscriptionRefCount++;
                            if (subscriptionRefCount == 1) {
                                // fetch the SIP URI if it's not available
                                properties['id'].property.get().then(function (uri) {
                                    subscription = psm.subscribe(uri);
                                });
                            }
                            else if (prop.dirty) {
                                // subscription already exists but we ignored this property updates so far because
                                // there were no observers of this particular property - so we may not see another
                                // property update event and we need to fetch the property value explicitly.
                                //
                                // the check for subscription is needed to prevent GETs for props subscribed
                                // immediately after the first subscription in the same event cycle:
                                //
                                //    contact.status.changed(...) -> POST subscription
                                //    contact.note.text.changed(...) -> no GET here - we'll get the value from the 'note updated' event.
                                getPropertyValue(prop.modelName);
                            }
                        }
                        function deleteSubscription() {
                            subscriptionRefCount--;
                            if (subscriptionRefCount == 0 && subscription) {
                                subscription.dispose();
                                subscription = null;
                            }
                        }
                        /**
                         * presence subscription event handler
                         */
                        function onSubscriptionEvent(event) {
                            // prContact can be empty if this rel=contact is supposed to be inside a rel=participant
                            // which doesn't have the /contact link at the moment. However it wouldn't be correct to
                            // require the /contact link here as this event cannot be related to this contact. This
                            // follows from a simple observation: an event like "presence updated in contact" can arrive
                            // only if the model has created a presence subscription and the model creates a presence
                            // subscription only after it gets the /contact.uri value. You might have noticed that the ctor
                            // of the person model can theoretically take the .uri value from the parent rel=participant
                            // resource and create a presence subscription without fetching the rel=contact resource,
                            // but then prContact won't be empty. This event can be relevant while prContact is empty only
                            // if the following conditions are met:
                            //
                            //  1. This rel=contact is supposed to be a link in a rel=participant.
                            //  2. The rel=participant doesn't have the /contact link.
                            //  3. The rel=participant has the .uri value.
                            //  4. The implementation of the person model can take the .uri from the parent participant model.
                            //  5. The implementation of the person model can create a presence subscription without fetching rel=contact.
                            //
                            // This is theoretically possible and might be a good optimization in the future.
                            var r = prContact();
                            var target = event.target;
                            var scope = event['in'];
                            if (target && event.type == 'updated' && scope && r && scope.href == r.href) {
                                // status, activity, note, location, capabilities, relationship changes
                                foreach(properties, function (p) {
                                    if (p.type == PropType.linked && target.rel == p.internalName) {
                                        if (p.observed) {
                                            // This call bypasses the logic in p.property.get() that might
                                            // return the cached value of the property rather than fetching
                                            // it from the server.
                                            getPropertyValue(p.modelName);
                                        }
                                        else {
                                            p.dirty = true;
                                        }
                                    }
                                });
                            }
                        }
                        /**
                         * Sets linked properties with the values found in the repository.
                         * Those that lack data in the repository are returned by this function as an array.
                         *
                         * @returns An array of linked properties that need to be fetched from the server.
                         */
                        function updateLinkedPropsOrGetMissingProperties() {
                            var missing = [];
                            // check repository first, we may already have linked resources
                            foreach(properties, function (p) {
                                var r;
                                // when joining an online meeting anonymously, UCWA gives a limited
                                // subset of links that are given in the normal mode; e.g. rel=contactPresence
                                // is not available in the anonymous mode
                                if (p.type == PropType.linked && p.link) {
                                    r = ucwa.get(p.link);
                                    if (!isEmptyObject(r.properties))
                                        updatePropertyFromResource(p, r);
                                    else
                                        missing.push(p);
                                }
                            });
                            return missing;
                        }
                        /**
                         * Sets the property with the value from a resource property
                         *
                         * @param {object} p - element of the internal properties collection
                         * @param {Resource} r - resource containing that property data
                         */
                        function updatePropertyFromResource(p, r) {
                            // the following logic specially handles the internal
                            // properties of Person.capabilities
                            var value = !p.field ? r.get() :
                                p.element ? indexOf(r.get(p.field), p.element) >= 0 :
                                    r.properties[p.field];
                            p.property(p.transform ? p.transform(value) : value);
                        }
                        //#endregion
                        // return the read-only copy of Person properties
                        return extend(self, Person.prototype, {
                            // properties not defined by UCWA yet
                            firstName: ConstProperty(null),
                            lastName: ConstProperty(null)
                        });
                    }
                    /**
                     * Subscribes to every observed property and collection.
                     * This method is common for MePerson and Person and is
                     * used only by LWX and SWX. It's not meant to be used by
                     * other apps.
                     */
                    Person.prototype.subscribe = function () {
                        var subs = [], self = this;
                        foreach(self, function visit(member) {
                            if (isProperty(member) || isCollection(member)) {
                                if (member.observed())
                                    subs.push(member.subscribe());
                            }
                            if (isModel(member))
                                foreach(member, visit);
                        });
                        return new Subscription(function () {
                            for (var _i = 0, subs_1 = subs; _i < subs_1.length; _i++) {
                                var s = subs_1[_i];
                                s.dispose();
                            }
                            subs = [];
                        });
                    };
                    return Person;
                }());
                Internal.Person = Person;
                (function (Person) {
                    var Status;
                    (function (Status) {
                        Status.Away = 'Away';
                        Status.Busy = 'Busy';
                        Status.DoNotDisturb = 'DoNotDisturb';
                        Status.Offline = 'Offline';
                        Status.Online = 'Online';
                    })(Status = Person.Status || (Person.Status = {}));
                    function fixDeviceType(t) {
                        return { PC: 'Desktop', Mobile: 'Mobile', Web: 'Web' }[t] || 'Unknown';
                    }
                    Person.fixDeviceType = fixDeviceType;
                    /**
                     * Transform status values from UCWA to values known to jCafe.
                     * @param {string} s - status value from UCWA
                     */
                    function fixStatus(s) {
                        return Person.Status[s] || {
                            BeRightBack: Person.Status.Away,
                            Idle: Person.Status.Away,
                            IdleOnline: Person.Status.Away,
                            IdleBusy: Person.Status.Away,
                            Unknown: Person.Status.Offline
                        }[s] || Person.Status.Offline;
                    }
                    Person.fixStatus = fixStatus;
                    /**
                     * Transforms a tel uri to phone number
                     * @param {string} s - tel uri e.g tel:+441235530744
                     */
                    function extractPhoneNumber(s) {
                        return (s || '').replace(/^(.+:)?(.+)$/, '$2');
                    }
                    Person.extractPhoneNumber = extractPhoneNumber;
                    /**
                     * Takes a path to a Person's photo and returns the photo's URL
                     * that can be used by the <img> element.
                     *
                     * This function completes or fails synchronously in all production
                     * topologies.
                     *
                     * @param {UCWA} ucwa
                     * @param {String} path - href of the "contactPhoto" resource
                     *
                     * @returns {Promise<String>} URL usable by <img> elements.
                     */
                    Person.getPhotoUrl = async(function (_a) {
                        var ucwa = _a.ucwa, path = _a.path;
                        // Use the URI class to extract the domain name from
                        // the rel=applications href and combine it with the photo's path.
                        // After auto-discovery and authentication steps are passed, SkypeWeb
                        // sends a POST to rel=applications to create a rel=application
                        // resource; in a reply to that POST the server sends a cookie
                        // called cwt_ucwa which is associated with the .../photos path and
                        // thus is used by the browser to download contact photos.
                        // It's important to keep in mind that rel=applications and rel=user
                        // may belong to different pools and a web ticket issued by one pool
                        // may not work in another pool.
                        //
                        // TODO: Use URL or rel=xframe. Both rel=applications and rel=xframe
                        // contain the valid host name in their URLs, so no need to demand
                        // that a web app store rel=applications in a snapshot. Note, that
                        // in some topologies the client is redirected between pools and xframes
                        // during auto discovery and sign in, so the repository may contain
                        // multiple rel=xframe resources.
                        var app = ucwa.get({ rel: 'applications' });
                        var url = new URI(app.href).path(path).query('');
                        return url + '';
                    });
                })(Person = Internal.Person || (Internal.Person = {}));
            })(Internal = Model_22.Internal || (Model_22.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_23) {
            var Internal;
            (function (Internal) {
                'use strict';
                var map = Web.Utils.map;
                var clone = Web.Utils.clone;
                var assert = Web.Utils.assert;
                var extend = Web.Utils.extend;
                var batched = Web.Utils.batched;
                var foreach = Web.Utils.foreach;
                var inherit = Web.Utils.inherit;
                var debounce = Web.Utils.debounce;
                var isEmptyObject = Web.Utils.isEmptyObject;
                var timeStampToDate = Web.Utils.timeStampToDate;
                var setHiddenProperty = Web.Utils.setHiddenProperty;
                var disableHtmlInText = Web.Utils.disableHtmlInText;
                var Enum = Web.Utils.Enum;
                var Task = Web.Utils.Task;
                var Model = Web.Utils.Model;
                var Property = Web.Utils.Property;
                var Exception = Web.Utils.Exception;
                var Collection = Web.Utils.Collection;
                var ConstProperty = Web.Utils.ConstProperty;
                var SequentialStateMachine = Web.Utils.SequentialStateMachine;
                /**
                 * Represents the currently signed-in user and is built on top of the "me" resource.
                 *
                 */
                var MePerson = (function () {
                    //#endregion
                    function MePerson(ucwa, options) {
                        var supportsText = Property.bool(false);
                        var supportsHtml = Property.bool(false);
                        var supportsMessaging = supportsText.or(supportsHtml);
                        var supportsAudio = Property.bool(false);
                        var supportsPSTN = Property.bool(false);
                        var supportsVideo = Property.bool(false);
                        var supportsSharing = Property.bool(false);
                        var supportsConferencing = options && options.supportsConferencing || ConstProperty(false);
                        var guestName = options && options.guestName;
                        var reportMyActivityInterval = options && options.reportMyActivityInterval || 3 * 60 * 1000;
                        var meActiveChangedDelay = options && options.meActiveChangedDelay || 10000;
                        var canChangeCapabilities = Property.bool(true);
                        var eReconnecting = Exception('Reconnecting');
                        var dfdGet; // it's tracking the GET rel=me requests
                        var State = Enum('Unavailable', 'Available');
                        var sm = SequentialStateMachine(State.Unavailable);
                        var requests = {}; // requests.note = a GET for /me/note
                        var properties = {}; // Stores mePerson properties by name along with some meta-info about properties
                        var proto = Model();
                        var self = inherit(proto);
                        var tm = options && options.tm;
                        var sendActivityTelemetry = options && options.sendActivityTelemetry;
                        var preferredDesktopEndpoint = options && options.preferredDesktopEndpoint;
                        options = null; // reduce the scope of "options" to the initialization part
                        var dfdrMe = ucwa.init().then(function () {
                            var r = ucwa.get({ rel: 'me' });
                            return isEmptyObject(r.properties) ?
                                ucwa.send('GET', { rel: 'me' }).then(function () { return r; }) :
                                r;
                        });
                        sm.defineState(State.Available, function () {
                            return makeMeAvailable().then(function () {
                                startReportingActivity();
                                // every time ucwa fails and then gets restored,
                                // most of the state, including the availability,
                                // disappears and needs to be recreated
                                // In a multi-tab scenario, when second tab resumed that tab won't receive updated events
                                // for a number of 'me' properties and needs to refresh them manually. In this case, it
                                // will not be able to successfully post to a /makeMeAvailable link, either because:
                                // 1. It doesn't have cached makeMeAvailable link when first has already been resumed, in
                                //    which case makeMeAvailable() just returns without trying to send a POST.
                                // 2. It has a cached makeMeAvailable link but the first tab has already resumed and posted
                                //    so when it the second tab posts to it, it will fail with a 409.
                                // The manual refresh is only necessary when a second tab is being restored, but it isn't
                                // harmful to the standard, single tab restore scenario.
                                ucwa.restored(function () {
                                    available(false, eReconnecting);
                                    makeMeAvailable().then(function () {
                                        available(true);
                                    }).finally(function () { return refreshLinkedProperties(); });
                                });
                                ucwa.connected.when(false, function () {
                                    available(false);
                                });
                            });
                        });
                        //#region properties
                        defineProperty('id', {
                            source: 'uri'
                        });
                        defineProperty('displayName', {
                            source: 'name',
                            parse: disableHtmlInText
                        });
                        defineProperty('endpointUri', {
                            source: 'endpointUri'
                        });
                        defineProperty('title', {
                            source: 'title'
                        });
                        defineProperty('department', {
                            source: 'department'
                        });
                        defineProperty('emails', {
                            source: 'emailAddresses',
                            isCollection: true,
                            parse: function (value) {
                                return map(value || [], function (email) {
                                    return Model({
                                        type: ConstProperty(null),
                                        emailAddress: ConstProperty(email)
                                    });
                                });
                            }
                        });
                        defineProperty('email', {
                            source: 'emailAddresses',
                            parse: function (value) {
                                return value && value[0] || '';
                            }
                        });
                        self.phoneNumbers = defineLinkedProperty('phoneNumbers', {
                            source: 'phones',
                            isCollection: true,
                            parse: function (phones) {
                                return map(phones || [], function (phone) {
                                    var p = phone.properties, type = p && p.type && p.type.charAt(0).toUpperCase() + p.type.slice(1), telUri = p && p.number, displayString = Internal.Person.extractPhoneNumber(telUri);
                                    return {
                                        type: ConstProperty(type),
                                        telUri: ConstProperty(telUri),
                                        displayString: ConstProperty(displayString)
                                    };
                                });
                            },
                            fetchAll: function (r) {
                                return Task.waitAll(map(r.links('phone'), function (link) {
                                    return ucwa.send('GET', link.href);
                                }));
                            }
                        });
                        self.note = Model({
                            text: defineLinkedProperty('note.text', {
                                source: 'note',
                                fetchOnce: true,
                                parse: function (data) {
                                    return disableHtmlInText(data && data.message);
                                },
                                compose: function (message) {
                                    return message && message.message ? clone(message) :
                                        { message: message, type: self.note.type() || 'Personal' };
                                }
                            }),
                            type: defineLinkedProperty('note.type', {
                                source: 'note',
                                parse: function (data) {
                                    return data && data.type;
                                }
                            }).asReadOnly()
                        });
                        self.location = defineLinkedProperty('location', {
                            source: 'location',
                            fetchOnce: true,
                            parse: function (data) {
                                return disableHtmlInText(data && data.location);
                            },
                            compose: function (location) {
                                return { location: location };
                            }
                        });
                        // the location property contains a few sub-properties
                        // (they are not defined by UCWA but needed in jCafe)
                        extend(self.location, {
                            type: ConstProperty('Unknown'),
                            street: ConstProperty(null),
                            city: ConstProperty(null),
                            state: ConstProperty(null),
                            country: ConstProperty(null),
                            postalCode: ConstProperty(null)
                        });
                        self.status = defineLinkedProperty('status', {
                            source: 'presence',
                            value: 'Offline',
                            fetchOnce: true,
                            parse: function (object) {
                                return object ? Internal.Person.fixStatus(object.availability) : 'Offline';
                            },
                            compose: function (value) {
                                var object = {};
                                object.availability = value;
                                return object;
                            }
                        });
                        self.activity = defineLinkedProperty('activity', {
                            source: 'presence',
                            parse: function (object) {
                                return disableHtmlInText(object && object.activity);
                            }
                        }).asReadOnly();
                        self.endpointType = defineLinkedProperty('endpointType', {
                            source: 'presence',
                            parse: function (object) {
                                return Internal.Person.fixDeviceType(object && object.deviceType);
                            }
                        }).asReadOnly();
                        self.isBlocked = ConstProperty(false);
                        self.lastSeenAt = defineLinkedProperty('lastSeenAt', {
                            source: 'presence',
                            parse: function (object) {
                                return object && timeStampToDate(object.lastActive);
                            }
                        }).asReadOnly();
                        self.note.reset = function () { return sm.advanceTo(State.Available)
                            .then(function () { return ucwa.send('POST', { rel: 'note' }, { priority: 100 /* UserAction */, data: {} }); })
                            .then(function (r) { return null; }); };
                        self.status.reset = function () { return sm.advanceTo(State.Available)
                            .then(function () { return ucwa.send('POST', { rel: 'presence' }, { priority: 100 /* UserAction */, data: {} }); })
                            .then(function (r) { return null; }); };
                        self.location.reset = function () { return sm.advanceTo(State.Available)
                            .then(function () { return ucwa.send('POST', { rel: 'location' }, { priority: 100 /* UserAction */, data: {} }); })
                            .then(function (r) { return null; }); };
                        var photo = defineProperty('avatarUrl', {
                            source: 'photo'
                        });
                        var available = Property.bool(false);
                        // whenever me.available.set(true) is invoked
                        // send a POST request to rel=makeMeAvailable and
                        // only then change the value of me.available
                        self.available = available.fork(function (newValue) {
                            // if this throws, the cached value won't be changed
                            if (available() && !newValue)
                                throw new Error('cannot downgrade the availability by calling me.available(false)');
                            if (!available() && newValue) {
                                return sm.advanceTo(State.Available).then(function () {
                                    available(newValue);
                                    return newValue;
                                });
                            }
                            // this value will be set to MePerson::available
                            return newValue;
                        });
                        // Note, if adding a custom getter for self.active make sure to 
                        // change Endpoint to use .get().then()
                        self.active = Property.bool(true);
                        self.account = ConstProperty(null);
                        self.capabilities = Model({
                            chat: extend(supportsMessaging, {
                                text: supportsText.fork(canChangeCapabilities),
                                html: supportsHtml.fork(canChangeCapabilities)
                            }),
                            pstn: supportsPSTN.fork(canChangeCapabilities),
                            audio: supportsAudio.fork(canChangeCapabilities),
                            video: supportsVideo.fork(canChangeCapabilities),
                            screenSharing: supportsSharing.fork(canChangeCapabilities),
                            dataCollaboration: ConstProperty(false),
                            conferencing: supportsConferencing
                        });
                        //#endregion
                        //#region Internal Methods
                        //#region defineProperty
                        /**
                         * @param name - The desired name of the property in the MePerson model.
                         * @param options - An object with the following parameters:
                         * - source - The name of the property in the rel=me resource.
                         * - isCollection - A flag to indicate whether this is a Collection or Property.
                         * - parse
                         *
                         *      Takes the value from the resource and converts it to
                         *      a value that will be published in the model's properties.
                         *
                         * @returns {Property|Collection}
                         */
                        function defineProperty(name, options) {
                            assert(!self[name]);
                            var source = options && options.source;
                            var parse = options && options.parse || (function (x) { return x; });
                            var property = (options && options.isCollection ? Collection : Property)({
                                get: function () {
                                    // a user can legitimately write something like:
                                    //
                                    //      me.title.get().then(...);
                                    //      me.name.get().then(...);
                                    //      me.uri.get().then(...);
                                    //      ...
                                    //
                                    // and will reasonably expect to see only one GET request
                                    // to grab all these properties; dfdGet solves this case
                                    if (!dfdGet) {
                                        dfdGet = dfdrMe.then(function () {
                                            return ucwa.send('GET', { rel: 'me' });
                                        }).finally(function () {
                                            dfdGet = null;
                                        });
                                    }
                                    return dfdGet.then(function () {
                                        return property();
                                    });
                                }
                            });
                            property.fetchOnce = false;
                            properties[name] = property;
                            self[name] = property.asReadOnly();
                            dfdrMe.then(function (rMe) {
                                rMe.updated(function () {
                                    if (rMe.has(source))
                                        property(parse(rMe.get(source)));
                                });
                                rMe.deleted(function () {
                                    // reset properties when resource is deleted
                                    property(parse(void 0));
                                });
                            });
                            return property;
                        }
                        //#endregion
                        //#region defineLinkedProperty
                        /**
                         * @param name - The desired name of the property in the MePerson model.
                         * @param type - The type name.
                         * @param source - The rel of the link in the rel=me resource.
                         *
                         * @param parse
                         *
                         *      Takes the value from the resource and converts it to
                         *      a value that will be published in the model's properties.
                         *
                         * @param compose
                         *
                         *      Takes the value from the model's property, when the view specifies the new value,
                         *      and converts it to a format that is acceptable by UCWA.
                         *
                         * @returns {Property}
                         */
                        function defineLinkedProperty(name, options) {
                            assert(!self[name]);
                            var rel = options.source;
                            var source = { rel: rel };
                            var parse = options.parse;
                            var compose = options.compose;
                            var fetchAll = options.fetchAll;
                            var fetchOnce = options.fetchOnce;
                            var expected = {};
                            var property = (options && options.isCollection ? Collection : Property)({
                                subscribed: subscribe,
                                value: options.value,
                                get: function () {
                                    // The link appears only after the client sends a POST
                                    // to rel=makeMeAvailable. However if the link is already
                                    // available, don't send extra requests.
                                    return dfdrMe.then(function () {
                                        return ucwa.exists(source) ?
                                            fetch() :
                                            subscribe();
                                    });
                                },
                                set: function (value) {
                                    if (value === expected) {
                                        expected = {};
                                        return value;
                                    }
                                    tm && tm.record(Web.TelemetryEvent.MeSet, { rel: rel });
                                    return sm.advanceTo(State.Available).then(function () {
                                        return post(rel, compose(value));
                                    }).then(function () {
                                        // Leave the old value in the property.
                                        // It will be updated after the corresponding
                                        // "updated" event from the server.
                                        return property();
                                    });
                                }
                            });
                            function set(value) {
                                expected = value;
                                property(value);
                                return value;
                            }
                            function fetch() {
                                // send the GET only once, even if it has been requested many times
                                requests[rel] = requests[rel] || ucwa.send('GET', source).finally(function () {
                                    requests[rel] = null;
                                });
                                return requests[rel].then(function (r) {
                                    return Task.wait(fetchAll ? fetchAll(r) : r.properties).then(parse).then(set);
                                });
                            }
                            function subscribe() {
                                return sm.advanceTo(State.Available).then(fetch);
                            }
                            ucwa.event(function (event) {
                                if (event.type in { updated: 1, added: 1 } && event.target && event.target.rel == source.rel)
                                    fetch();
                                else if (event.type == 'deleted' && event.target && event.target.rel == source.rel) {
                                    // reset properties when resource is deleted
                                    set(parse(void 0));
                                }
                            });
                            dfdrMe.then(function () {
                                // The linked resource is there in two cases:
                                // 1. The app is being restored from a snapshot.
                                // 2. The app is connecting to an existing endpoint.
                                if (ucwa.exists(source)) {
                                    if (!isEmptyObject(ucwa.get(source).properties)) {
                                        // If the linked resource contains some data, the app is being restored
                                        // from a snapshot and the value of the property can be taken from there.
                                        set(parse(ucwa.get(source).properties));
                                    }
                                    else if (fetchOnce) {
                                        // If the link is there, but the corresponding resource has no data,
                                        // then the app must be connecting to an existing endpoint. If this was
                                        // a regular sign in, the init sequence would be as following:
                                        //
                                        //      POST /applications
                                        //      POST /me/makeMeAvailable
                                        //      GET /me
                                        //
                                        //      me updated
                                        //      note added
                                        //      presence added
                                        //      location added
                                        //
                                        //      GET /me/note
                                        //      GET /me/presence
                                        //      GET /me/location
                                        //
                                        // When the app is forking an endpoint, UCWA gives an already initialized
                                        // endpoint and the sequence changes to:
                                        //
                                        //      POST /applications
                                        //
                                        // Because the returned /me already has /reportMyActivity, the app
                                        // doesn't need to POST /me/makeMeAvailable and UCWA wouldn't send
                                        // these "updated" and "added" events anyway. Instead, it gives an
                                        // already initialized /me resource with all the links: /note, /presence,
                                        // /location, /phones and so on. Since in the regular sign in the
                                        // data from these links are always fetched and since the point of SDK
                                        // is to hide differences between the two types of sign ins, it's reasonable
                                        // to fetch data from these links if the app is forking an endpoint.
                                        fetch();
                                    }
                                }
                            });
                            // store fetchOnce to indicate if value of property changes frequently and
                            // should be manually refreshed if there's a chance it has become stale
                            property.fetchOnce = fetchOnce;
                            properties[name] = property;
                            return property;
                        }
                        //#endregion
                        //#region refreshLinkedProperties
                        /**
                         * Manually send a GET for all linked properties defined with fetchOnce = true
                         * This should only be necessary in the case of a second tab resuming in which case
                         * the resumed app doesn't receive any 'updated' events for its linked properties
                         * since another tab has already resumed.
                         */
                        function refreshLinkedProperties() {
                            for (var name in properties) {
                                if (properties[name].fetchOnce)
                                    properties[name].get();
                            }
                        }
                        //#endregion
                        //#region post
                        /**
                         * Sends a POST to the given rel.
                         *
                         * The actual POST request at the next event loop to handle the case
                         * when the same or related properties are set multiple times. If this
                         * happens, conflicting requests are merged at the next event loop and
                         * only one POST request is sent.
                         *
                         * @param {String} rel
                         * @param {Object} data
                         *
                         * @returns {Promise}
                         */
                        function post(rel, data) {
                            var resource = ucwa.get({ rel: rel });
                            post[rel] = post[rel] || batched(function (values) {
                                var merged = clone(resource.properties);
                                foreach(values, function (v) {
                                    extend(merged, v);
                                });
                                return ucwa.send('POST', { rel: rel }, {
                                    data: merged,
                                    priority: 100 /* UserAction */,
                                    nobatch: true
                                });
                            }, Infinity);
                            return post[rel](data, 0);
                        }
                        //#endregion
                        //#region makeMeAvailable
                        /**
                         * This lets other users see the presence of this user and
                         * also tells the server to send presence, location and note updates.
                         */
                        function makeMeAvailable() {
                            var isReconnecting = available.reason === eReconnecting;
                            return dfdrMe.then(function (rMe) {
                                var formats = [];
                                var modalities = [];
                                if (supportsText())
                                    formats.push('Plain');
                                if (supportsHtml())
                                    formats.push('Html');
                                if (supportsMessaging())
                                    modalities.push('Messaging');
                                // TODO: also set the "phoneNumber" property
                                if (supportsPSTN())
                                    modalities.push('PhoneAudio');
                                if (supportsAudio())
                                    modalities.push('Audio');
                                if (supportsVideo())
                                    modalities.push('Video');
                                if (supportsSharing())
                                    modalities.push('ApplicationSharing');
                                // if the client is restoring its state from a snapshot,
                                // it must take into account that previously another client
                                // may have sent a POST to rel=makeMeAvailable and UCWA
                                // does not allow to send this request twice; so the intent here
                                // is to check whether that POST request was sent and if it was,
                                // don't send it again
                                if (isReconnecting || !ucwa.exists({ rel: 'reportMyActivity' })) {
                                    // TODO: changing capabilities after POST rel=makeMeAvailable can be done with PUT rel=communication
                                    canChangeCapabilities(false);
                                    var dfd = Task.run(function () {
                                        // in the anonymous mode and in a multi-tab scenario, there is
                                        // no rel=makeMeAvailable link
                                        if (!rMe.hasLink('makeMeAvailable')) {
                                            // if anonymous, use PUT communication to set supported formats
                                            if (guestName && guestName()) {
                                                var r = ucwa.get({ rel: 'communication' });
                                                var has = r.has('supportedMessageFormats');
                                                if (!has || has && r.get('supportedMessageFormats') != formats) {
                                                    var properties = r.get();
                                                    properties['supportedMessageFormats'] = formats;
                                                    var dfdPut = ucwa.send('PUT', { rel: 'communication' }, {
                                                        data: properties,
                                                        priority: 100 /* UserAction */,
                                                        nobatch: true
                                                    });
                                                    tm && tm.monitor(dfdPut, Web.TelemetryEvent.Communication, {
                                                        supportedFormats: formats && formats.join()
                                                    }, { sendEndEventOnly: true });
                                                    return dfdPut;
                                                }
                                            }
                                            return;
                                        }
                                        var dfdPost = ucwa.send('POST', rMe.link('makeMeAvailable').href, {
                                            data: {
                                                SupportedModalities: modalities,
                                                SupportedMessageFormats: formats,
                                                preferredDesktopEndpoint: preferredDesktopEndpoint
                                            },
                                            priority: 100 /* UserAction */,
                                            nobatch: true
                                        });
                                        tm && tm.monitor(dfdPost, Web.TelemetryEvent.MeMakeAvailable, {
                                            supportedModalities: modalities && modalities.join(),
                                            supportedFormats: formats && formats.join(),
                                            preferredDesktopEndpoint: preferredDesktopEndpoint
                                        }, { sendEndEventOnly: true });
                                        return dfdPost;
                                    });
                                    return dfd.finally(function () {
                                        return ucwa.send('GET', { rel: 'me' }, { nobatch: true });
                                    });
                                }
                            });
                        }
                        //#endregion
                        //#region startReportingActivity
                        /**
                         * To let the server know that the web client is active a POST
                         * request to the "reportMyActivity" resource must be sent every
                         * 3 minutes. Otherwise the user's availability will be changed
                         * to a less available status.
                         */
                        function startReportingActivity() {
                            var timerId;
                            var postReportMyActivity = function () {
                                if (ucwa.connected() && !ucwa.appDeleted()) {
                                    if (!ucwa.exists({ rel: 'reportMyActivity' }))
                                        return;
                                    var dfd = ucwa.send('POST', { rel: 'reportMyActivity' }, {
                                        priority: 100 /* UserAction */,
                                        nobatch: true
                                    }).catch(function (err) {
                                        // After a long period of inactivity, the connection with UCWA is usually lost.
                                        // While the connection is being restored, MePerson resends POST /makeMeAvailable.
                                        // However this periodic timer doesn't know about that logic and keeps sending
                                        // POST /reportMyActivity as usual. If the timer happens to wake up before the
                                        // /makeMeAvailable is completed, UCWA will reject this /reportMyActivity with a
                                        // 409.MakeMeAvailableRequired error.
                                        if (err && err.code == 'RequestFailed' && err.rsp && err.rsp.status == 409)
                                            return;
                                        // if reportMyActivity stopped, something strange has happened.
                                        // we need to report the error to Aria
                                        tm && tm.record(Web.TelemetryEvent.ReportActivityStopped, { reason: err });
                                        Internal.log('%c reportMyActivity stopped', 'color:red;font-weight:bold', err);
                                        Web.clearInterval(timerId);
                                    });
                                    if (sendActivityTelemetry) {
                                        tm && tm.monitor(dfd, Web.TelemetryEvent.Activity, {
                                            action: 'report',
                                            doc_hidden: document && document.hidden,
                                            doc_visibility_state: document && document.visibilityState
                                        }, { sendEndEventOnly: true });
                                    }
                                }
                            };
                            var reportMyActivity = function (newValue, reason, oldValue) {
                                if (sendActivityTelemetry) {
                                    tm && tm.record(Web.TelemetryEvent.Activity, {
                                        action: 'user',
                                        active: newValue,
                                        doc_hidden: document && document.hidden,
                                        doc_visibility_state: document && document.visibilityState
                                    });
                                }
                                Web.clearInterval(timerId);
                                if (newValue) {
                                    postReportMyActivity();
                                    timerId = Web.setInterval(postReportMyActivity, reportMyActivityInterval);
                                }
                            };
                            self.active.changed(debounce(meActiveChangedDelay, reportMyActivity));
                        }
                        //#endregion
                        //#endregion Internal Methods
                        //#region initialization
                        if (guestName)
                            guestName.changed(properties.displayName);
                        dfdrMe.then(function (rMe) {
                            setHiddenProperty(proto, Internal.sHref, rMe.href);
                            // the rel=me/photo link may appear after the ctor of MePerson was invoked:
                            // to handle this case MePerson needs to subscribe to rel=me and fetch the photo
                            // when the rel=me/photo link becomes available
                            rMe.updated(function fn() {
                                if (rMe.hasLink('photo') && !photo()) {
                                    // no more events needed from rel=me
                                    rMe.updated.off(fn);
                                    // try to get the actual photo URL and if it's not possible,
                                    // use the original href as the URL
                                    Internal.Person.getPhotoUrl({
                                        ucwa: ucwa,
                                        path: rMe.link('photo').href
                                    }).catch(function () {
                                        return rMe.link('photo').href;
                                    }).then(function (url) {
                                        photo(url);
                                    });
                                }
                            });
                        });
                        // TODO: Bind these properties to .supportedModalities and .supportedMessageFormats
                        // of rel=communication. For now the values are read from the snapshot once before
                        // signing in. Note, that the binding shouldn't change the initial values set from
                        // outside (by UI for example) before signing in.
                        try {
                            var rc = ucwa.get(ucwa.app.relatedHref('communication'));
                            var sm_1 = rc.get('supportedModalities', []);
                            var sf = rc.get('supportedMessageFormats', []);
                            if (sf.indexOf('Plain') >= 0)
                                supportsText(true);
                            if (sf.indexOf('Html') >= 0)
                                supportsHtml(true);
                            if (sm_1.indexOf('PhoneAudio') >= 0)
                                supportsPSTN(true);
                            if (sm_1.indexOf('Audio') >= 0)
                                supportsAudio(true);
                            if (sm_1.indexOf('Video') >= 0)
                                supportsVideo(true);
                            if (sm_1.indexOf('ApplicationSharing') >= 0)
                                supportsSharing(true);
                        }
                        catch (_) {
                        }
                        //#endregion
                        return extend(self, Internal.Person.prototype, {
                            preferences: Collection.empty,
                            // properties not defined by UCWA yet
                            firstName: ConstProperty(null),
                            lastName: ConstProperty(null),
                            office: ConstProperty(null),
                            company: ConstProperty(null)
                        });
                    }
                    return MePerson;
                }());
                Internal.MePerson = MePerson;
            })(Internal = Model_23.Internal || (Model_23.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_24) {
            var Internal;
            (function (Internal) {
                var map = Web.Utils.map;
                var find = Web.Utils.find;
                var guid = Web.Utils.guid;
                var clone = Web.Utils.clone;
                var async = Web.Utils.async;
                var check = Web.Utils.check;
                var assert = Web.Utils.assert;
                var extend = Web.Utils.extend;
                var random = Web.Utils.random;
                var indexOf = Web.Utils.indexOf;
                var inherit = Web.Utils.inherit;
                var isArray = Web.Utils.isArray;
                var isString = Web.Utils.isString;
                var contains = Web.Utils.contains;
                var isPrimitive = Web.Utils.isPrimitive;
                var isDictionary = Web.Utils.isDictionary;
                var timeStampToDate = Web.Utils.timeStampToDate;
                var convertHtmlToText = Web.Utils.convertHtmlToText;
                var convertTextToHtml = Web.Utils.convertTextToHtml;
                var disableHtmlInText = Web.Utils.disableHtmlInText;
                var Task = Web.Utils.Task;
                var Model = Web.Utils.Model;
                var SipUri = Web.Utils.SipUri;
                var Symbol = Web.Utils.Symbol;
                var Command = Web.Utils.Command;
                var DataUri = Web.Utils.DataUri;
                var Property = Web.Utils.Property;
                var Collection = Web.Utils.Collection;
                var StringEnum = Web.Utils.StringEnum;
                var ConstProperty = Web.Utils.ConstProperty;
                var EAlreadyExists = Web.Utils.EAlreadyExists;
                var EInvalidArgument = Web.Utils.EInvalidArgument;
                // Modality.State.... stuff is too long: to avoid splitting one line into
                // had to make these shorter aliases; also good for minifying
                var cCreated = Internal.Modality.State.Created;
                var cNotified = Internal.Modality.State.Notified;
                var cConnected = Internal.Modality.State.Connected;
                var cConnecting = Internal.Modality.State.Connecting;
                var cDisconnected = Internal.Modality.State.Disconnected;
                var sStatus = Symbol('status'); // status property of a queued message
                var sStartingMessaging = Symbol('starting'); // serves as state.reason when state=Connecting    
                function makeMultipartRequest(request, context, contextType, revision, boundary) {
                    var contentId = '367A2DAE00F7417FB5CEFE6364C97D31';
                    var strRequest = JSON.stringify(extend({}, request, { customContent: 'CID:' + contentId }));
                    var payload = [
                        '--' + boundary,
                        'Content-Type: application/vnd.microsoft.com.ucwa+json',
                        'Content-Length: ' + strRequest.length,
                        '',
                        strRequest,
                        '--' + boundary,
                        'Content-Type: ' + contextType,
                        'Content-Id: ' + contentId,
                        // this specified field allows the multipart content always processed to
                        // the endpoint, which may not register 'text/json' as its supported format.
                        'Content-Disposition: render; handling=optional',
                        '',
                        context,
                        '--' + boundary + '--',
                        ''
                    ].join('\r\n');
                    return {
                        headers: {
                            'Content-Type': 'multipart/related;boundary=' + boundary + ';type="application/vnd.microsoft.com.ucwa+json"',
                            'Content-Length': payload.length,
                            'X-MS-RequiresMinResourceVersion': revision
                        },
                        data: payload
                    };
                }
                /**
                 * The ChatService model is one of conversation modalities, which establishes
                 * the channel for participants to send instant messages.
                 *
                 */
                var ChatService = (function () {
                    //#endregion
                    function ChatService(_a) {
                        var ucwa = _a.ucwa, conversation = _a.conversation, rInvitation = _a.rInvitation, guestName = _a.guestName, tm = _a.tm, settings = _a.settings;
                        //#region locals
                        var participants = conversation.participants;
                        var localParticipant = conversation.selfParticipant;
                        var subject = conversation.topic;
                        var priority = conversation.priority;
                        var threadId = conversation.threadId;
                        var messages = Collection();
                        /** Indexed by participant hrefs since this collection
                            is emptied after the conversation ends. */
                        var typingParticipants = Collection();
                        /** It's a name->name mapping. In the scenario this is needed, there is only one participant. */
                        var typingParticipantNames = Collection();
                        var rMessaging; // rel=messaging
                        var state = Property();
                        var AcceptType = StringEnum('Unknown', 'UserAccepted', 'AutoAccepted', 'ConnectedElsewhere', 'Other');
                        var acceptType = Property(AcceptType.Unknown);
                        var nMessageEvents = 0; // the number of received "message completed" events
                        var dfdSend; // promise returned by ChatService::sendMessage
                        var dfdStart; // promise returned by ChatService::start
                        var dfdAccept; // promise returned by ChatService::accept            
                        var lastMessage; // last message received
                        var invitationMessage; // last invitation message
                        var invitationMessageHref; // href of last invitation message
                        var callId;
                        var isConfWhenChatServiceStarted; // do not initialize a default value
                        var name = guestName && guestName();
                        var negotiatedFormats = Collection({
                            get: function () {
                                var formats = rMessaging.get('negotiatedMessageFormats');
                                var dict = map(formats, function (fmt) { return fmt == 'Plain' ? 'Text' : fmt; });
                                return StringEnum.apply(null, dict);
                            }
                        });
                        var self = Model({
                            state: state.asReadOnly(),
                            acceptType: acceptType.asReadOnly(),
                            messages: messages.asReadOnly(),
                            shouldNotify: function () { return true; },
                            supportedMessageFormats: negotiatedFormats.asReadOnly(),
                            typingParticipantNames: typingParticipantNames.asReadOnly(),
                            typingParticipants: typingParticipants.asReadOnly()
                        });
                        //#endregion
                        //#region internals
                        function getParticipant(href) {
                            return find(conversation.participants(), function (p) { return p[Internal.sHref] == href; });
                        }
                        function getMessageData(rMessage, rel) {
                            try {
                                // "data:text/plain;charset=utf-8,how+are+you%3F" => "how are you?"
                                return DataUri(rMessage.relatedHref(rel) || 'data:,').data || '';
                            }
                            catch (error) {
                                tm && tm.record(Web.TelemetryEvent.ChatMessageDecodingError, { reason: error });
                                return '\u25A1';
                            }
                        }
                        function isMessageFormatNegotiated(format) {
                            try {
                                return indexOf(rMessaging.get('negotiatedMessageFormats'), format) >= 0;
                            }
                            catch (err) {
                                // either rel=messaging is absent or it's missing the list of formats
                                return false;
                            }
                        }
                        function reset(reason) {
                            invitationMessage = null;
                            invitationMessageHref = null;
                            lastMessage = null;
                            // NotFound is triggered when app purges local conversations not on server
                            // rMessaging should also be set to null when receiving conversation deleted event.
                            // On conversation deleted event state = Disconnected and href is set to null.
                            if (reason && reason.code == 'NotFound' ||
                                conversation.state() == 'Disconnected' && !conversation[Internal.sHref]) {
                                rMessaging = null;
                                rInvitation = null;
                            }
                        }
                        //#region chooseMessageFormat
                        /**
                         * The point of this function is to chose one data format to
                         * send to the server based on a set of formats given to SkypeWeb
                         * and a set of formats accepted by the remote participant.
                         *
                         * It's unlikely that the SDK and UCWA will ever support RTF or
                         * other text formats that will be exotic to web clients, so this function
                         * can assume that only two formats exist: text/plain and text/html.
                         *
                         * This function must take into consideration remote clients
                         * that cannot read html (OWA for example).
                         */
                        function chooseMessageFormat(message) {
                            // if this is the very first message in a conversation
                            // that is being started, there will be no rel=messaging
                            // resource and the list of negotiated formats will be empty
                            if ('html' in message)
                                return isMessageFormatNegotiated('Html') || !rMessaging ?
                                    { type: 'text/html', data: message.html + '' } :
                                    { type: 'text/plain', data: convertHtmlToText(message.html + '') };
                            if ('text' in message)
                                return isMessageFormatNegotiated('Plain') || !isMessageFormatNegotiated('Html') ?
                                    { type: 'text/plain', data: message.text + '' } :
                                    { type: 'text/html', data: convertTextToHtml(message.text + '') };
                            throw EInvalidArgument('message', 'must contain either `text` or `html` format');
                        }
                        //#endregion
                        //#region addIncomingMessage
                        /**
                         * Reads a resource representing an incoming message
                         * and adds a corresponding message model to the collection.
                         */
                        function addIncomingMessage(resource) {
                            var phref = resource.link('participant').href;
                            var pname = resource.link('participant').title;
                            var sender = getParticipant(phref);
                            var person = sender && sender.person;
                            // in the MSEG scenario the same "agent" participant
                            // may have different names in different messages;
                            // this trick forks the person object to modify its
                            // name without altering the original person object
                            if (pname && person && person.displayName() != pname) {
                                person = inherit(person);
                                person.displayName = ConstProperty(disableHtmlInText(pname));
                            }
                            var message = new Internal.Message({
                                href: resource.href,
                                participants: participants,
                                sender: person,
                                text: getMessageData(resource, 'plainMessage'),
                                html: getMessageData(resource, 'htmlMessage'),
                                direction: Internal.Message.Direction.Incoming,
                                ucwa: ucwa
                            });
                            // don't add the invitation message twice to the collection
                            if (!isInvitationMessage(message)) {
                                messages.add(message);
                                // incoming im invites that are not accepted by us don't have a msg
                                // completed event, so we can't use this code path for invites.
                                // Hence, receive msg telemetry for invites is handled by processFirstMessageInInvitation.
                                tm && tm.record(Web.TelemetryEvent.Chat, {
                                    action: 'receiveMessage',
                                    type: conversation.isGroupConversation() ? 'conf' : 'p2p',
                                    format: resource.hasLink('htmlMessage') ? 'html' : 'plain',
                                    joinType: name && 'anon',
                                    callId: callId,
                                    remoteType: person && person.type()
                                });
                            }
                            else {
                                // update href and timestamp of the invitation message
                                invitationMessage && invitationMessage.timestamp._set(message.timestamp());
                                invitationMessageHref && invitationMessageHref(resource.href);
                            }
                            lastMessage = message;
                        }
                        //#endregion
                        function isInvitationMessage(message) {
                            return invitationMessage && invitationMessage === lastMessage &&
                                lastMessage.direction() == message.direction();
                        }
                        function processFirstMessageInInvitation() {
                            var dmsg = DataUri(rInvitation.relatedHref('message') || 'data:,');
                            var text = dmsg.mime == 'text/plain' ? dmsg.data : '';
                            var html = dmsg.mime == 'text/html' ? dmsg.data : '';
                            // inviter is placed in the participants collection when the conversation is
                            // created from the invitation.
                            var sender = isIncoming() ? participants(0) : localParticipant;
                            invitationMessageHref = Property();
                            var message = new Internal.Message({
                                href: invitationMessageHref,
                                sender: sender.person,
                                participants: participants,
                                text: text,
                                html: html,
                                direction: Internal.Message.Direction.Incoming,
                                ucwa: ucwa
                            });
                            // sometimes the invitation doesn't contain a message
                            if (text || html) {
                                lastMessage = invitationMessage = message;
                                messages.add(message);
                            }
                            // TODO: the .toast member is deprecated and will be removed
                            self.toast = Model({
                                sender: sender,
                                text: message.text,
                                html: message.html,
                                priority: ConstProperty(rInvitation.get('importance', void 0)),
                                subject: ConstProperty(disableHtmlInText(rInvitation.get('subject', void 0)))
                            });
                            tm && tm.record(Web.TelemetryEvent.Chat, {
                                action: 'receiveMessage',
                                type: conversation.isGroupConversation() ? 'conf' : 'p2p',
                                format: html ? 'html' : 'plain',
                                joinType: name && 'anon',
                                callId: callId,
                                isInvitation: true,
                                remoteType: sender.person && sender.person.type()
                            });
                        }
                        function addOutgoingMessage(options) {
                            var message = new Internal.Message({
                                href: options.href,
                                participants: participants,
                                sender: localParticipant.person,
                                ndrs: options.ndrs,
                                text: options.text,
                                html: options.html,
                                status: options.status,
                                time: options.timestamp,
                                direction: Internal.Message.Direction.Outgoing,
                                ucwa: ucwa
                            });
                            // for outgoing messages the caller may specify the id
                            messages.add(message, options.id || guid());
                            return message;
                        }
                        // message completed, direction=Incoming/Outgoing
                        ucwa.observe('message completed', function (event) {
                            var r = event.resource;
                            if (rMessaging && r.link('messaging').href == rMessaging.href) {
                                if (r.get('direction') == 'Incoming') {
                                    nMessageEvents++;
                                    addIncomingMessage(r);
                                }
                                else {
                                    var message = find(messages(), function (m) { return m[Internal.sHref] == r.href; });
                                    // receiving an outgoing "message completed" event for a message
                                    // that isn't in the collection means that the message was sent
                                    // by another tab.
                                    if (!message) {
                                        addOutgoingMessage({
                                            href: r.href,
                                            text: getMessageData(r, 'plainMessage'),
                                            html: getMessageData(r, 'htmlMessage'),
                                            ndrs: r.links('failedDeliveryParticipant'),
                                            status: event.status == 'Success' ? Internal.Message.Status.Succeeded : Internal.Message.Status.Failed,
                                            timestamp: timeStampToDate(r.get('timeStamp', null)) || new Web.Date
                                        });
                                    }
                                }
                            }
                        });
                        function observeMessagingState() {
                            assert(rMessaging, 'rel=messaging must be known before starting observing its state');
                            rMessaging.updated(function () {
                                var newState = rMessaging.get('state', '');
                                if (newState == 'Disconnected')
                                    state(Internal.Modality.State.Disconnected);
                                else if (newState == 'Connected')
                                    state(Internal.Modality.State.Connected);
                                // this triggers the custom getter that pulls the formats
                                // from the resource and updates the collection
                                negotiatedFormats.get();
                            });
                        }
                        function getConversationResource() {
                            // sHref is an internal id available in this file
                            var href = conversation[Internal.sHref];
                            return href ? ucwa.get(href) : null;
                        }
                        function isConferencing() {
                            var rc = getConversationResource();
                            return rc && rc.get('state', '') == 'Conferenced';
                        }
                        function isMessagingActive() {
                            var rc = getConversationResource();
                            var href = rc && rc.hasLink('messaging') && rc.link('messaging').href;
                            var rm = href && ucwa.exists(href) && ucwa.get(href);
                            return rm && rm.get('state', null) == 'Connected';
                        }
                        function isIncomingMeetingRequest() {
                            return conversation.meeting &&
                                conversation.meeting.state() == 'Notified' &&
                                conversation.meeting.availableModalities.messaging();
                        }
                        function isIncoming() {
                            return rInvitation ? rInvitation.get('direction') == 'Incoming' : false;
                        }
                        // participant added/deleted in typingParticipants
                        ucwa.event(function (event) {
                            var target = event.target;
                            var context = event['in'] || {};
                            // if the event includes the 'in' property, it indicates it is for
                            // a typingParticipant's 'added' or 'deleted' events, other than for a participant's events.
                            if (rMessaging && rMessaging.hasLink('typingParticipants') && context.href == rMessaging.link('typingParticipants').href) {
                                if (event.type == 'deleted') {
                                    typingParticipants.remove(target.href);
                                    typingParticipantNames.remove(target.title);
                                }
                                else if (event.type == 'added') {
                                    var typingParticipant = getParticipant(target.href);
                                    if (typingParticipant && !typingParticipants(target.href))
                                        typingParticipants.add(typingParticipant, target.href);
                                    if (target.title && !typingParticipantNames(target.title))
                                        typingParticipantNames.add(target.title, target.title);
                                }
                            }
                        });
                        // messagingInvitation started
                        ucwa.event(function (event) {
                            var resource = event.resource;
                            var target = event.target;
                            // messaging can be added to an existing 1:1 conversation by the remote participant
                            // messagingInvitation can also be outgoing in the multi-tab scenario
                            if (event.type == 'started' && target.rel == 'messagingInvitation' &&
                                resource.link('conversation').href == conversation[Internal.sHref]) {
                                rInvitation = resource;
                                processInvitation();
                            }
                        });
                        // onlineMeeting added
                        ucwa.event(function (event) {
                            var resource = event.resource;
                            var target = event.target;
                            if (target.rel === 'onlineMeeting' && event.type === 'added' &&
                                resource.hasLink('conversation') && resource.link('conversation').href === conversation[Internal.sHref]) {
                                if (isConfWhenChatServiceStarted === false) {
                                    callId = guid(); // all subsequent activity should use this new conf callid
                                    tm && tm.record(Web.TelemetryEvent.Chat, {
                                        action: 'escalate',
                                        type: 'conf',
                                        joinType: name && 'anon',
                                        callId: callId,
                                        remoteType: participants(0) && participants(0).person.type()
                                    });
                                }
                            }
                        });
                        // onlineMeetingInvitation completed
                        ucwa.event(function (event) {
                            var resource = event.resource;
                            var target = event.target;
                            if (target.rel === 'onlineMeetingInvitation'
                                && event.type === 'completed'
                                && resource.hasLink('conversation')
                                && resource.link('conversation').href === conversation[Internal.sHref]) {
                                if (event.reason && event.reason.subcode === 'AutoAccepted') {
                                    acceptType(AcceptType.AutoAccepted);
                                    tm && tm.record(Web.TelemetryEvent.Chat, {
                                        action: 'accept',
                                        by: 'auto',
                                        type: conversation.isGroupConversation() ? 'conf' : 'p2p',
                                        joinType: name && 'anon',
                                        callId: callId,
                                        result: 'succeeded',
                                        remoteType: participants(0) && participants(0).person.type()
                                    });
                                }
                                else if (event.reason && event.reason.subcode === 'ConnectedElsewhere') {
                                    acceptType(AcceptType.ConnectedElsewhere);
                                    tm && tm.record(Web.TelemetryEvent.Chat, {
                                        action: 'accept',
                                        by: 'other',
                                        type: conversation.isGroupConversation() ? 'conf' : 'p2p',
                                        joinType: name && 'anon',
                                        callId: callId,
                                        result: 'succeeded',
                                        remoteType: participants(0) && participants(0).person.type()
                                    });
                                }
                                else {
                                    acceptType(AcceptType.Other);
                                }
                            }
                        });
                        function setResource(r) {
                            rMessaging = r;
                            rMessaging.deleted(function () { return rMessaging = null; });
                        }
                        function setResourceAndObserveState(href) {
                            setResource(ucwa.get(href));
                            observeMessagingState();
                        }
                        function conversationUpdated() {
                            var rc = getConversationResource();
                            if (!rMessaging && rc.hasLink('messaging')) {
                                setResourceAndObserveState(rc.link('messaging').href);
                                rc.updated.off(conversationUpdated);
                            }
                        }
                        function defineAsyncCommand(name, states, method) {
                            var enabled = Property();
                            self[name] = Command(async(method), enabled);
                            state.changed(function (value) {
                                var isEnabled = contains(states, function (s) {
                                    return isArray(s) ?
                                        value == s[0] && state.reason === s[1] :
                                        value == s;
                                });
                                enabled(isEnabled);
                            });
                        }
                        //#endregion
                        //#region start
                        /**
                         * Sends the messaging invitation to participants.
                         * Under the hood it does the following to start messaging:
                         *
                         *      - Sends a POST to rel=startMessaging or rel=conversation/messaging/addMessaging.
                         *      - Waits for "messagingInvitation completed" event.
                         *      - Starts receiving "message completed" events.
                         *
                         * @param {String} to - SIP URI of whom to send the invitation to.
                         * @param {String} [name] - Display name for anonymously joined meetings.
                         * @param {String|Object} [message] - The first message in the conversation.
                         *
                         *  The message can contain the desired id of the first message:
                         *  see comments for the `send` method.
                         *
                         *  To start the conversation with the first plain text message use:
                         *
                         *      im.start('This is a plain text message');
                         *      im.start({ text : 'This is a plain text message' });
                         *
                         *  To start the conversation with the first html message use:
                         *
                         *      im.start({ html : '<b>This is a html message</b>' });
                         *
                         *  Note, that if the first message contains only the html format
                         *  and it's invalid, the .start method will return a rejected promise.
                         *
                         * @param [context] - An arbitrary object that can be serialized.
                         *
                         *  If set, the POST request to UCWA will be sent in a special multipart
                         *  format with all the regular invitation parameters plus this context.
                         *  The context is supposed to describe the invitation, so that the remote
                         *  participant may know why the request is sent.
                         *
                         * @returns {Promise<Message>}
                         */
                        defineAsyncCommand('start', [cCreated, [cConnecting, sStartingMessaging], cDisconnected], function (options) {
                            options = options || {};
                            var message = options.message;
                            name = options.name || guestName && guestName();
                            var to = options.to;
                            var contextType = (options.context === void 0) ?
                                void 0 : isPrimitive(options.context) ? (options.contextType || 'text/plain') : 'text/json';
                            var context = isPrimitive(options.context) ? options.context : JSON.stringify(options.context);
                            var timestamp = options.timestamp;
                            var boundary = options.boundary; // can be given by unit tests
                            var operationId = options.operationId || guid(); // can be given by unit tests
                            var sessionContext = options.sessionContext || guid(); // can be given by unit tests
                            // state gets reset below so isIncomingMeetingInvite has to be saved here for use below
                            var isIncomingMeetingInvite = state() === cConnecting && state.reason === sStartingMessaging;
                            options = null;
                            if (to && !SipUri.test(to))
                                throw Error('.to must be a valid SIP URI');
                            if (message && !isString(message) && !isDictionary(message))
                                throw Error('.message must be a string or a { text: "...", html: "..." } object');
                            var firstMessage; // firstMessage === await im.start(...)
                            var status; // status of firstMessage
                            var isMeeting = conversation.isGroupConversation();
                            isConfWhenChatServiceStarted = isMeeting;
                            if (isString(message))
                                message = { text: message };
                            // in p2p mode take URI of the remote participant
                            if (!isMeeting) {
                                if (!to)
                                    to = participants(0).uri();
                                else
                                    check(participants.size() == 0, 'ambiguous remote party in 1:1 call');
                                check(to, 'the remote participant URI is not specified');
                            }
                            state(Internal.Modality.State.Connecting);
                            dfdStart = Task.run(function () {
                                if (conversation.meeting) {
                                    if (conversation.meeting.state() == Internal.OnlineMeeting.State.Created) {
                                        return conversation.meeting.start({
                                            name: name,
                                            uri: conversation.uri()
                                        });
                                    }
                                }
                                else if (isMeeting) {
                                    return conversation.addMeeting().start({
                                        // Needed for joining meetings anonymously.
                                        name: name,
                                        // If it's null, a new meeting will be created.
                                        // If it's not null, we will join that meeting.
                                        uri: conversation.uri()
                                    });
                                }
                            }).then(function () {
                                var rc = getConversationResource();
                                // if there is no existing rel=conversation resource yet,
                                // send the messaging invitation to the global rel=startMessaging link;
                                // otherwise add the messaging modality to an existing conversation by
                                // sending the invitation to rel=conversation/messaging/addMessaging link.
                                if (!rc) {
                                    var link = ucwa.get(ucwa.app.relatedHref('communication')).link('startMessaging');
                                    link.rel = 'startMessaging';
                                    return link;
                                }
                                var rm = ucwa.get(rc.link('messaging').href);
                                // if /messaging/addMessaging is available, no need to send the GET
                                if (rm.hasLink('addMessaging')) {
                                    var link = rm.link('addMessaging');
                                    link.rel = 'addMessaging';
                                    return link;
                                }
                                else {
                                    return ucwa.send('GET', rm.href).then(function (r) {
                                        var link = r.link('addMessaging');
                                        link.rel = 'addMessaging';
                                        return link;
                                    });
                                }
                            }).then(function (messagingLink) {
                                // the next step is to send a POST request to initiate a messaging invitation
                                // and to await the "messagingInvitation started" event that corresponds to
                                // the initiated invitation
                                var parameters = {
                                    operationId: operationId,
                                    threadId: threadId()
                                };
                                // parameters specific to 1:1 conversations
                                if (!isConferencing()) {
                                    extend(parameters, {
                                        to: messagingLink.rel == 'addMessaging' ? void 0 : to,
                                        // in 1:N conversations these parameters are set
                                        // on the conversation as a whole, not on the modality
                                        importance: priority(),
                                        subject: subject(),
                                        sessionContext: sessionContext
                                    });
                                }
                                // check whether the user specified the first message in
                                // the conversation: this message should be embedded into
                                // the messaging invitation
                                if (message) {
                                    var content = chooseMessageFormat(message);
                                    parameters.message = 'data:' + content.type + ',' + DataUri.encodeData(content.data);
                                    status = Property();
                                    status(Internal.Message.Status.Pending);
                                    var href_2 = Property();
                                    // If the invitation has a message embedded, there will be the following
                                    // sequence of events from UCWA:
                                    //
                                    //      messagingInvitation started
                                    //      conversation added
                                    //      message started
                                    //      messagingInvitation completed
                                    //      message completed
                                    //
                                    // The `message completed` event must match a message in the collection of messages,
                                    // as otherwise that message will be considered to have been sent from another tab.
                                    ucwa.wait({
                                        type: 'started',
                                        target: { rel: 'message' },
                                        sender: function (link) { return rInvitation && rInvitation.link('conversation').href == link.href; }
                                    }).then(function (event) {
                                        href_2(event.target.href);
                                    });
                                    // add the first message in the conversation to the chat history
                                    firstMessage = addOutgoingMessage({
                                        id: message.id,
                                        href: href_2.asReadOnly(),
                                        text: message.text,
                                        html: message.html,
                                        timestamp: timestamp,
                                        status: status
                                    });
                                }
                                function constructRequest() {
                                    var req = (context !== void 0) && messagingLink.revision >= 2 ?
                                        makeMultipartRequest(parameters, context, contextType, 2, boundary || random()) :
                                        { data: parameters };
                                    // UCWA rejects attempts to send the POST request inside a batch request
                                    req.nobatch = true;
                                    return req;
                                }
                                var request = constructRequest();
                                var dfdPost = ucwa.send('POST', messagingLink.href, request).catch(function (err) {
                                    // If threadId is too long, UCWA will reject it with a 400 'badRequest.' 
                                    // In this case, reset the threadId and resend the request.
                                    if (conversation.isThreadIdRejectedError(err)) {
                                        conversation.resetThreadId();
                                        parameters.threadId = threadId();
                                        request = constructRequest();
                                        return ucwa.send('POST', messagingLink.href, request);
                                    }
                                    throw err;
                                });
                                // Wait for the "messagingInvitation started" event to get the invitation resource for the cancellation purpose
                                // even before the 'messagingInvitation completed' arrives
                                var dfdStarted = ucwa.wait({
                                    type: 'started',
                                    target: { rel: 'messagingInvitation' },
                                    resource: function (r) { return r.get('operationId', '') == operationId || r.get('threadId', '') == threadId(); }
                                }).then(function (event) {
                                    rInvitation = event.resource;
                                });
                                // wait for the "messagingInvitation completed" event that corresponds to the given conversation
                                var dfdCompleted = ucwa.wait({
                                    type: 'completed',
                                    target: { rel: 'messagingInvitation' },
                                    resource: function (r) { return r.get('operationId', '') == operationId || r.get('threadId', '') == threadId(); }
                                }).then(function (event) {
                                    if (event.status == 'Failure')
                                        throw Internal.EInvitationFailed(event.reason, event.debug);
                                    rInvitation = event.resource;
                                    setResource(ucwa.get(rInvitation.link('messaging').href));
                                    // if the messaging is started in a conference, UCWA sends
                                    // the rel=messagingInvitation/rel=acceptedByParticipant resource
                                    // that does not contain the "name" property and contains invalid "uri"
                                    // (it points to the URI of the online meeting instead of the participant);
                                    // however UCWA returns the correct values if it's asked for them
                                    // explicitly - via a GET request to the rel=participant
                                    if (isConferencing() && rInvitation.hasLink('acceptedByParticipant'))
                                        ucwa.send('GET', rInvitation.link('acceptedByParticipant').href);
                                });
                                // The intent here is to:
                                //
                                //      1. Send a POST to rel=startMessaging.
                                //      2. Wait for the "messagingInvitation completed" event.
                                //      3. If the event arrives, cancel the POST and proceed.
                                //      4. If the event has not arrived, but the POST failed, stop waiting for the event and fail.
                                //      5. If the POST succeeds, continue waiting for the event.
                                //
                                // Note, that the event may arrive before a response from the POST.
                                // The Task.waitAll below lets achieve 1, 2, 4, 5 but not 3. However, #3
                                // (cancelling the POST if the event arrives first) will not make
                                // any difference, as almost always POST completes before the event arrives.
                                // The problem is what if the POST completes, but the event never arrives:
                                // the task will stuck in this state indefinitely.
                                return Task.waitAll([dfdPost, dfdStarted, dfdCompleted]);
                            }).then(function () {
                                if (status)
                                    status(Internal.Message.Status.Succeeded);
                                observeMessagingState();
                                // add participants to a meeting created by this start().
                                if (isConferencing())
                                    conversation[Internal.sInternal].inviteParticipants();
                                // UCWA has accepted the request to start messaging,
                                // so now it's time to wrap everything up: set the
                                // final state and so on.
                                state(Internal.Modality.State.Connected);
                                return firstMessage;
                            }).catch(function (error) {
                                // if something went wrong, set the final state and quit
                                state(Internal.Modality.State.Disconnected, error);
                                if (status)
                                    status(Internal.Message.Status.Failed, error);
                                if (rInvitation && rInvitation.hasLink('cancel'))
                                    ucwa.send('POST', rInvitation.link('cancel').href);
                                // rethrow the error, so that it may be processed by the caller
                                throw error;
                            }).finally(function () {
                                dfdStart = null;
                            });
                            if (!isIncomingMeetingInvite) {
                                // incoming meeting invite triggers a chatservice.start before
                                // chatservice.accept. Hence, create a callId and send telemetry 
                                // here only if this is not an incoming meeting invite.
                                callId = guid();
                                // Name should be undefined except in the case of an anonymously signed in user
                                tm && tm.monitor(dfdStart, Web.TelemetryEvent.Chat, {
                                    action: 'start',
                                    type: conversation.isGroupConversation() ? 'conf' : 'p2p',
                                    joinType: name && 'anon',
                                    callId: callId,
                                    contextType: contextType,
                                    remoteType: participants(0) && participants(0).person.type()
                                });
                            }
                            return dfdStart;
                        });
                        //#endregion
                        //#region sendMessage
                        /**
                         * Sends a message to all the participants in the conversation.
                         *
                         * @param message - The content of the message to send.
                         *
                         *      If this parameter is a plain string, SkypeWeb
                         *      assumes that it is in the text/plain format.
                         *      If this parameter has the form of { html : "..." }
                         *      then the message is sent as text/html.
                         *
                         *          im.sendMessage("This is a plain text message");
                         *          im.sendMessage({ text : "This is a plain text message." });
                         *          im.sendMessage({ html : "This text is <span style="color:blue">blue</span>." });
                         *
                         *      If several message formats are specified, only one of them
                         *      will be chosen. Note, that if the given html representation
                         *      of the message appears invalid, the .send method returns
                         *      a rejected promise.
                         *
                         * @param [format="text"] - Either "text" or "html".
                         *
                         *      The are two ways to specify the format of the message:
                         *
                         *          im.sendMessage("abc", "html");
                         *          im.sendMessage({ html: "abc" });
                         *
                         * @param {String} [.text] - The text/plain format of the message.
                         * @param {String} [.html] - The text/html format of the message.
                         * @param {String} [.id] - The unique id of the message.
                         *
                         *      This id will be used as the key to the `messages` collection
                         *      and thus can be used to associated the message object in the
                         *      `messages` collection with the message sent via the `send` method:
                         *
                         *          var id = Math.random();
                         *          var promise = im.sendMessage({ text: "Hi", id: id }); // it's pending
                         *          var msg = im.messages(id); // this is the pending message
                         *          assert.equal(msg.status(), "Processing");
                         *
                         *      If the given `id` conflicts with an existing message id,
                         *      no message will be sent to the server or added to the collection
                         *      and the returned promise will be rejected.
                         *
                         * @returns {Promise<Message>}
                         *
                         *      As usual, this method returns a promise that resolves
                         *      after the operation succeeds or gets rejected after
                         *      the operation fails. To track the progress of the
                         *      operation one can use the following code snippet:
                         *
                         *          im.sendMessage(message).then(
                         *              function (msg) { alert("The message has been sent.") },
                         *              function (err) { alert("The message could not be sent.") });
                         *
                         *      The returned promise has the "status" observable
                         *      property that can be used to monitor the progress:
                         *
                         *          im.sendMessage(message).status.changed(function (status) {
                         *              console.log("im.send: " + status);
                         *          });
                         *
                         *      It is noteworthy that the message gets added to the `messages`
                         *      collection immediately after the call to `send` and the status of the
                         *      added message is "Pending". Then the server sends an event
                         *      that changes the status to "Succeeded".
                         */
                        defineAsyncCommand('sendMessage', [cCreated, cNotified, cConnecting, cConnected, cDisconnected], function (message, format) {
                            if (isString(message)) {
                                message = format && format.toLowerCase() == 'html' ?
                                    { html: message } :
                                    { text: message };
                            }
                            // the status should be a property here, since it is to be updated
                            // when processing events from the server
                            var status = message[sStatus] || Property({ value: 'Pending' });
                            var href = message[Internal.sHref] || Property();
                            var id = message.id || guid();
                            // sendMessage can be used to start or accept conversation
                            if (state() != cConnected) {
                                return Task.run(function () {
                                    if (!(dfdStart || dfdAccept || state() == cNotified)) {
                                        var dfd_1 = self.start({ message: message });
                                        // This scenario sends both chat start, and chat sendMessage
                                        tm && tm.monitor(dfd_1, Web.TelemetryEvent.Chat, {
                                            action: 'sendMessage',
                                            type: conversation.isGroupConversation() ? 'conf' : 'p2p',
                                            format: format ? format.toLowerCase() : 'plain',
                                            joinType: name && 'anon',
                                            callId: callId,
                                            remoteType: participants(0) && participants(0).person.type()
                                        });
                                        return dfd_1;
                                    }
                                    if (messages(id))
                                        throw EAlreadyExists('message.id = ' + id);
                                    addOutgoingMessage({
                                        id: id,
                                        href: href,
                                        text: message.text,
                                        html: message.html,
                                        status: status
                                    });
                                    return (dfdStart || dfdAccept || self.accept()).then(function () {
                                        return self.sendMessage(extend(message, (_a = {
                                                id: id
                                            },
                                            _a[Internal.sHref] = href,
                                            _a[sStatus] = status,
                                            _a)));
                                        var _a;
                                    }).catch(function (err) {
                                        status(Internal.Message.Status.Failed, err);
                                        throw err;
                                    });
                                });
                            }
                            if (messages(id) && !message[Internal.sHref])
                                throw EAlreadyExists('message.id = ' + id);
                            var content = chooseMessageFormat(message);
                            // when sending messages to this bot the actual message must not be sent
                            // for privacy concerns. However, the actual message needs to be shown on the UI.
                            if (participants(0)
                                && participants(0).person.type
                                && participants(0).person.type() == 'ReplayBot') {
                                try {
                                    content = chooseMessageFormat(extend(clone(message), {
                                        text: '*****',
                                        html: '*****'
                                    }));
                                }
                                catch (err) {
                                }
                            }
                            // The message model should be created and added to the "messages"
                            // collection right away, but at this moment UCWA has neither replied
                            // to the POST request to rel=sendMessage, nor has it sent the
                            // "message completed" event. To handle this difficulty, the message
                            // model is given two properties with no value: the "href" and the
                            // "status" properties. The message model takes them and waits until
                            // the "href" property changes its value: this value is set after
                            // the modality receives a HTTP 201 reply to the POST request - the HTTP 201
                            // contains the Location header with the href of the rel=message resource.
                            var msgobj = messages(id) || addOutgoingMessage({
                                id: id,
                                href: href,
                                text: message.text,
                                html: message.html,
                                status: status
                            });
                            // if multiple POSTs are sent one after another, without waiting
                            // for previous POSTs to complete, UCWA may add messages in a wrong order
                            var dfd = Task.wait(dfdSend).then(function () {
                                return ucwa.send('POST', rMessaging.link('sendMessage').href, {
                                    headers: { 'Content-Type': content.type },
                                    data: content.data,
                                    nobatch: true // UCWA fails with HTTP 500 if an IM is sent inside a batch request
                                });
                            });
                            dfdSend = dfd.finally(function () { return dfdSend = null; });
                            dfd.then(function (rMessage) {
                                // the message model could not receive "message completed" event
                                // and update its status, because it did not know the href of the
                                // message resource; now the href becomes known (it arrives inside
                                // the Location header)
                                href(rMessage.href);
                            }).catch(function (err) {
                                status(Internal.Message.Status.Failed, err);
                            });
                            tm && tm.monitor(dfd, Web.TelemetryEvent.Chat, {
                                action: 'sendMessage',
                                type: conversation.isGroupConversation() ? 'conf' : 'p2p',
                                format: format ? format.toLowerCase() : 'plain',
                                joinType: name && 'anon',
                                callId: callId,
                                remoteType: participants(0) && participants(0).person.type()
                            });
                            return dfd.then(function () { return msgobj; });
                        });
                        //#endregion
                        //#region stop
                        /**
                         * Terminates the ongoing messaging session.
                         */
                        defineAsyncCommand('stop', [Internal.Modality.State.Connected, Internal.Modality.State.Connecting], function () {
                            if (dfdStart) {
                                dfdStart.cancel();
                                return;
                            }
                            state(Internal.Modality.State.Disconnecting);
                            var dfdStop = ucwa.send('POST', rMessaging.link('stopMessaging').href).then(function () {
                                state(Internal.Modality.State.Disconnected);
                            }).catch(function (error) {
                                // restore the original state
                                state(Internal.Modality.State.Connected);
                                throw error;
                            });
                            tm && tm.monitor(dfdStop, Web.TelemetryEvent.Chat, {
                                action: 'stop',
                                type: conversation.isGroupConversation() ? 'conf' : 'p2p',
                                joinType: name && 'anon',
                                callId: callId,
                                remoteType: participants(0) && participants(0).person.type()
                            });
                            return dfdStop;
                        });
                        //#endregion
                        //#region reject
                        /**
                         * Rejects the incoming messaging invitation.
                         * reason: 'Local' - reject just on this endpoint, 'Global' (default) - reject on all.
                         */
                        defineAsyncCommand('reject', [Internal.Modality.State.Notified], function (reason) {
                            if (reason === void 0) { reason = 'Global'; }
                            state(Internal.Modality.State.Disconnecting);
                            var dfdReject = Task.wait().then(function () {
                                // in UCWA an incoming meeting request tells which modalities
                                // are available in the meeting; if Messaging is available, then
                                // the chat's reject command can decline the meeting request
                                return isIncomingMeetingRequest() ?
                                    conversation.meeting.decline(reason) :
                                    ucwa.send('POST', rInvitation.link('decline').href, {
                                        data: { reason: reason }
                                    });
                            }).then(function () {
                                state(Internal.Modality.State.Disconnected);
                            });
                            tm && tm.monitor(dfdReject, Web.TelemetryEvent.Chat, {
                                action: 'decline',
                                joinType: name && 'anon',
                                type: conversation.isGroupConversation() ? 'conf' : 'p2p',
                                callId: callId,
                                remoteType: participants(0) && participants(0).person.type()
                            });
                            return dfdReject;
                        });
                        //#endregion
                        //#region accept
                        /**
                         * To accept the messaging invitation, it does the following:
                         *
                         *      - Sends a POST request to rel=messagingInvitation.
                         *      - Waits for "messagingInvitation completed" event.
                         */
                        defineAsyncCommand('accept', [Internal.Modality.State.Notified], function (args) {
                            acceptType(args && args.acceptType || AcceptType.UserAccepted); // Must be set before accept becomes disabled
                            state(Internal.Modality.State.Connecting); // Causes accept to become disabled
                            isConfWhenChatServiceStarted = conversation.isGroupConversation();
                            // The incoming invite triggers a new callId so don't set a new one here.
                            // in UCWA an incoming meeting request tells which modalities
                            // are available in the meeting; to accept a modality the app
                            // needs to accept the meeting request first and then send to UCWA
                            // a request to start the modality
                            dfdAccept = Task.wait(null).then(function () {
                                if (isIncomingMeetingRequest()) {
                                    return conversation.meeting.accept().then(function () {
                                        // enable the .start command
                                        state(Internal.Modality.State.Connecting, sStartingMessaging);
                                        // args.operationId is set by unit tests
                                        return self.start(args);
                                    });
                                }
                                // send a POST request to rel=messagingInvitation/accept
                                var dfdPost = ucwa.send('POST', rInvitation.link('accept').href);
                                // await "messagingInvitation completed" event
                                var dfdCompleted = ucwa.wait({
                                    type: 'completed',
                                    target: { rel: 'messagingInvitation', href: rInvitation.href }
                                }).then(function () {
                                    setResource(ucwa.get(rInvitation.link('messaging').href));
                                });
                                return Task.waitAll([dfdPost, dfdCompleted]).then(function () {
                                    observeMessagingState();
                                    // now the invitation is considered to be successfully accepted,
                                    // so set the final state, make available certain methods and so on
                                    state(Internal.Modality.State.Connected);
                                });
                            }).catch(function (error) {
                                // if something went wrong, set the final state and quit
                                state(Internal.Modality.State.Disconnected, error);
                                // rethrow the error, so that it may be catched by the caller
                                throw error;
                            }).finally(function () {
                                dfdAccept = null;
                            });
                            tm && tm.monitor(dfdAccept, Web.TelemetryEvent.Chat, {
                                action: 'accept',
                                by: 'user',
                                type: conversation.isGroupConversation() ? 'conf' : 'p2p',
                                joinType: name && 'anon',
                                callId: callId,
                                remoteType: participants(0) && participants(0).person.type()
                            });
                            return dfdAccept;
                        });
                        //#endregion
                        //#region sendIsTyping
                        /**
                         * To set IsTyping for the function is used to broadcast the user's typing status.
                         * When the function is called, the setIsTyping resource will start a short timer on
                         * the server during which the user will show up in the typingParticipants (UCWA)
                         * for this conversation (UCWA). If the  function is not called again within that time,
                         * the user will be removed from typingParticipants.
                         */
                        defineAsyncCommand('sendIsTyping', [Internal.Modality.State.Connected], function () {
                            return ucwa.send('POST', rMessaging.link('setIsTyping').href, {
                                nobatch: true
                            });
                        });
                        //#endregion
                        //#region processInvitation
                        /**
                         * Handles an incoming 1:1 messaging invitation:
                         * reads the embedded message and adds it to the
                         * collection, enables the accept/reject commands
                         * and so on. This method can be invoked multiple
                         * times in the conversation merging scenario.
                         */
                        function processInvitation() {
                            // if another tab starts a conversation, all other tabs get the
                            // outgoing invitation event (with no message link); and they
                            // do not need to process the toast message
                            if (isIncoming()) {
                                callId = guid(); // incoming invites trigger a new callid
                                acceptType(AcceptType.Unknown); // can't reset this on conversation deleted so reset it here
                                processFirstMessageInInvitation();
                                state(cNotified);
                            }
                            else {
                                // if the outgoing invitation contains a message, there will be
                                // "message completed" event shortly after this invitation event:
                                // to recognize that message, the rel=messaging needs to be known
                                if (rInvitation.hasLink('messaging'))
                                    setResource(ucwa.get(rInvitation.link('messaging').href));
                                state(cConnecting);
                            }
                            // the invitation can be cancelled by the remote party
                            // and this must be somehow reflected in the modality
                            ucwa.wait({
                                type: 'completed',
                                status: 'Failure',
                                target: { rel: 'messagingInvitation', href: rInvitation.href }
                            }).then(function (event) {
                                state(Internal.Modality.State.Disconnected, event.reason);
                                if (isIncoming() && event.reason && event.reason.subcode === 'ConnectedElsewhere') {
                                    // conversation accepted by another endpoint
                                    acceptType(AcceptType.ConnectedElsewhere);
                                    tm && tm.record(Web.TelemetryEvent.Chat, {
                                        action: 'accept',
                                        by: 'other',
                                        type: conversation.isGroupConversation() ? 'conf' : 'p2p',
                                        joinType: name && 'anon',
                                        callId: callId,
                                        result: 'succeeded',
                                        remoteType: participants(0) && participants(0).person.type()
                                    });
                                }
                                else if (isIncoming()) {
                                    acceptType(AcceptType.Other);
                                }
                            });
                            // the invitation can be accepted by the server without the client's consent
                            ucwa.wait({
                                type: 'completed',
                                status: 'Success',
                                target: { rel: 'messagingInvitation', href: rInvitation.href }
                            }).then(function (event) {
                                // if the state is still Notified and the invitation is incoming,
                                // then the "completed" event is sent because another endpoint has
                                // accepted the request as the accept() method would've changed
                                // the state to Connecting; if the invitation is outgoing because
                                // it was started on another tab, this tab must also recognize the
                                // completion of the invitation and move to the Connected state
                                if (state() == cNotified || state() == cConnecting && !isIncoming()) {
                                    setResourceAndObserveState(rInvitation.link('messaging').href);
                                    state(Internal.Modality.State.Connected, event.reason);
                                }
                                if (isIncoming() && event.reason && event.reason.subcode === 'AutoAccepted') {
                                    // auto accepted on this endpoint. In a multi tab scenario with same
                                    // endpointId this will be generated on each tab.
                                    acceptType(AcceptType.AutoAccepted);
                                    tm && tm.record(Web.TelemetryEvent.Chat, {
                                        action: 'accept',
                                        by: 'auto',
                                        type: conversation.isGroupConversation() ? 'conf' : 'p2p',
                                        joinType: name && 'anon',
                                        callId: callId,
                                        result: 'succeeded',
                                        remoteType: participants(0) && participants(0).person.type()
                                    });
                                    if (!conversation.isGroupConversation() &&
                                        participants(0) &&
                                        participants(0).person.type &&
                                        participants(0).person.type() == 'ReplayBot' &&
                                        conversation.acknowledge.enabled()) {
                                        conversation.acknowledge();
                                    }
                                }
                                else if (isIncoming()) {
                                    acceptType(AcceptType.Other);
                                }
                            }).catch(function (error) {
                                state(Internal.Modality.State.Disconnected, error);
                            });
                        }
                        //#endregion
                        //#region processIncomingMeetingRequest
                        function processIncomingMeetingRequest() {
                            callId = guid(); // new callId for incoming meeting invite
                            acceptType(AcceptType.Unknown);
                            // this also enables .accept and .reject commands
                            state(Internal.Modality.State.Notified);
                            // set resource once meeting is connected and messaging
                            // becomes available, necessary for establishing IM upon
                            // UCWA auto accept
                            conversation.meeting.state.when(Internal.OnlineMeeting.State.Connected, function () {
                                var rc = getConversationResource();
                                if (!rMessaging && !dfdStart && !dfdAccept) {
                                    if (rc.hasLink('messaging'))
                                        setResourceAndObserveState(rc.link('messaging').href);
                                    else
                                        rc.updated(conversationUpdated);
                                }
                            });
                            // An incoming meeting invitation may fail before we accepted it or while 
                            // we ignored it because the invitation may be accepted on another endpoint 
                            // or UCWA auto-accept may not be enabled. 
                            conversation.meeting.state.when(Internal.OnlineMeeting.State.Disconnected, function () { return state(Internal.Modality.State.Disconnected); });
                        }
                        //#endregion
                        //#region init
                        if (isMessagingActive()) {
                            // TODO: restore the messaging history (as of Mar 2014, UCWA doesn't support this)
                            state(Internal.Modality.State.Connected);
                            setResourceAndObserveState(getConversationResource().link('messaging').href);
                            // Messaging already active when chatService initialized.
                            // Create a new callId since accept/start/processInvite may not be called
                            callId = guid();
                        }
                        else if (rInvitation) {
                            processInvitation();
                            // Special code that handles replaybot conversations
                            if (settings &&
                                settings.replayBot &&
                                participants(0) &&
                                participants(0).uri() &&
                                participants(0).uri().toLowerCase().indexOf(settings.replayBot.sipUri || 'replaybot@domain.com') >= 0) {
                                Web.setTimeout(function () {
                                    // fake the type to auto accepted so that swx keeps the toast alive
                                    // needs to be done after 2 seconds to give swx time to attach handlers
                                    self.accept({ acceptType: AcceptType.AutoAccepted });
                                }, 2000);
                            }
                        }
                        else if (!isIncomingMeetingRequest()) {
                            state(Internal.Modality.State.Created);
                        }
                        state.when(Internal.Modality.State.Disconnected, reset);
                        // If conversation becomes disconnected from server, make sure modality state also disconnected.
                        conversation.state.when(Internal.Conversation.State.Disconnected, function (reason) { return state(Internal.Modality.State.Disconnected, reason); });
                        // in unit tests a conversation mock may not have .changed event
                        if (conversation.changed) {
                            // the same conversation can be used to handle multiple
                            // chat sessions; in this case the .changed event may be
                            // fired multiple times and each time the chat service
                            // must be able to accept the invitation.
                            //
                            // in fact this event is fired only when a meeting is either
                            // added to or removed from a conversation.
                            conversation.changed(function () {
                                if (isIncomingMeetingRequest())
                                    processIncomingMeetingRequest();
                            });
                        }
                        Internal.watch('ChatService::state', state);
                        //#endregion
                        return self;
                    }
                    return ChatService;
                }());
                Internal.ChatService = ChatService;
                (function (ChatService) {
                    var Options;
                    (function (Options) {
                        ;
                    })(Options = ChatService.Options || (ChatService.Options = {}));
                })(ChatService = Internal.ChatService || (Internal.ChatService = {}));
            })(Internal = Model_24.Internal || (Model_24.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_25) {
            var Internal;
            (function (Internal) {
                'use strict';
                var bind = Web.Utils.bind;
                var assert = Web.Utils.assert;
                var foreach = Web.Utils.foreach;
                var inherit = Web.Utils.inherit;
                var isString = Web.Utils.isString;
                var isEmptyObject = Web.Utils.isEmptyObject;
                var disableHtmlInText = Web.Utils.disableHtmlInText;
                var setHiddenProperty = Web.Utils.setHiddenProperty;
                var Enum = Web.Utils.Enum;
                var Task = Web.Utils.Task;
                var Model = Web.Utils.Model;
                var Command = Web.Utils.Command;
                var Property = Web.Utils.Property;
                var Exception = Web.Utils.Exception;
                var Collection = Web.Utils.Collection;
                var BoolProperty = Web.Utils.BoolProperty;
                var ConstProperty = Web.Utils.ConstProperty;
                var EDoesNotExist = Web.Utils.EDoesNotExist;
                var EInvalidArgument = Web.Utils.EInvalidArgument;
                var SequentialStateMachine = Web.Utils.SequentialStateMachine;
                /**
                 * A participant represents a contact in a conversation.
                 *
                 * In large online meetings there may be hundreds of participants, so to
                 * reduce the network traffic the server sends as little information as
                 * possible. UI needs to choose a small subset of participants that are
                 * currently being displayed to the user and subscribe to only these
                 * participant models:
                 *
                 *      visibleParticipants.forEach(function (participantView) {
                 *          var participant = participantView.getModel();
                 *
                 *          // now subscribe to the participant
                 *          bindProperty(participant.admit.enabled, buttonAdmit);
                 *          bindProperty(participant.reject.enabled, buttonReject);
                 *      });
                 *
                 * A subscription to a participant model tells that model to keep itself
                 * up to date by sending extra requests to the server. Too many such
                 * subscriptions may add too much network traffic.
                 *
                 */
                var Participant = (function () {
                    //#endregion
                    function Participant(options) {
                        var contactManager = options.contactManager;
                        var ucwa = options.ucwa;
                        var tm = options.tm;
                        var href = isString(options.href) ? ConstProperty(options.href) : options.href;
                        var title = options.name;
                        var sipuri = options.uri;
                        var isLocal = ConstProperty(!!options.isLocal);
                        var convState = options.convState || ConstProperty(null);
                        var rParticipant = href() && ucwa.get(href());
                        var State = Enum('PureHref', 'Fetched');
                        var sm = SequentialStateMachine(State.PureHref);
                        var isTyping = Property({ value: false });
                        var messagingState = Property({ value: Internal.Modality.State.Disconnected });
                        var state = Property({ value: Participant.State.Disconnected });
                        var inConference = options.inConference;
                        // should be undefined initially to avoid "changed" notification right away
                        var isJoined = BoolProperty();
                        var properties = {};
                        var methods = {};
                        var nRefs = 0; // the number of subscriptions to this model
                        var audioState = Property({ value: Internal.Modality.State.Disconnected }), audioMuted = Property({ value: false }), audioOnHold = Property({ value: false }), isSpeaking = Property({ value: false }), videoStartedBeforeHold = Property();
                        var endpoint = Property({
                            value: sipuri,
                            set: function (v) {
                                if (v && isValidEndpoint(v))
                                    return v;
                                throw EInvalidArgument('endpoint', 'the given value is not a valid uri');
                            }
                        });
                        var videoState = Property({ value: Internal.Modality.State.Disconnected }), vsEmpty = Internal.MediaStream && new Internal.MediaStream, videoChannels = Collection(), videoChannel;
                        // these ids are needed for video subscription in a conference
                        var audioSourceId = Property({ value: -1 }), videoSourceId = Property({ value: -1 }), isInMediaRoster = {};
                        var pContactHref = Property({
                            value: getContactHrefOr(void 0),
                            get: function () {
                                return pContactHref() || getAndFetchParticipantResource().then(function () {
                                    // a handler for the rel=participant:updated event
                                    // has already updated this model property, so its new value is cached
                                    return pContactHref();
                                });
                            }
                        });
                        // There are three ways to get the person model:
                        //
                        //  1. Take it from the ctor args if this is an "outgoing" participant.
                        //  2. Wrap existing /participant/contact link.
                        //  3. Create it without the link and fetch the link later.
                        //
                        // The call to inherit is important: it creates a fork of the original
                        // person object and thus perfectly reflects the state of that object
                        // and even changes if the original object changes, but allows to modify
                        // the forked object without modifying the original person object.
                        var person = inherit(options.person || contactManager.get(pContactHref() || pContactHref));
                        var proto = Model();
                        var self = inherit(proto, {
                            state: state.asReadOnly(),
                            person: person,
                            screenSharing: Model({
                                state: ConstProperty(Internal.Modality.State.Disconnected),
                                isControlling: ConstProperty(false),
                                stream: Model({
                                    state: ConstProperty('Stopped'),
                                    width: ConstProperty(0),
                                    height: ConstProperty(0),
                                    source: Model({
                                        sink: Model({
                                            container: ConstProperty(null)
                                        })
                                    })
                                })
                            }),
                            chat: Model({
                                isTyping: isTyping.asReadOnly(),
                                state: messagingState.asReadOnly()
                            }),
                            audio: Model({
                                state: audioState.asReadOnly(),
                                isMuted: audioMuted.fork(Command(muteUnmute, inConference)),
                                isOnHold: audioOnHold.asReadOnly(),
                                isSpeaking: isSpeaking.asReadOnly(),
                                endpoint: endpoint,
                                isUnmuteRequested: Property({ value: false })
                            }),
                            video: Model({
                                state: videoState.asReadOnly(),
                                channels: videoChannels,
                                _videoSourceId: videoSourceId.asReadOnly()
                            }),
                            isJoined: isJoined.asReadOnly(),
                            reset: reset
                        });
                        options = null;
                        if (Internal.VideoChannel) {
                            videoChannel = new Internal.VideoChannel({
                                name: isLocal() ? 'Self Channel' : 'Render Channel',
                                isLocal: isLocal()
                            });
                            videoChannel.stream.setSource(vsEmpty);
                            videoChannels.add(videoChannel);
                        }
                        //#region properties
                        defineProperty('displayName');
                        defineProperty('name');
                        defineProperty('role');
                        defineProperty('uri');
                        defineProperty('sourceNetwork');
                        defineProperty('workPhoneNumber');
                        defineProperty('otherPhoneNumber');
                        defineProperty('isAnonymous', 'anonymous');
                        defineProperty('organizer');
                        //#endregion
                        //#region methods
                        defineMethod('admit');
                        defineMethod('reject');
                        defineMethod('eject');
                        defineMethod('promote');
                        defineMethod('demote');
                        //#endregion
                        //#region internal methods
                        function isValidEndpoint(v) {
                            v = v.toLowerCase();
                            return properties.uri() && properties.uri().toLowerCase() == v ||
                                properties.workPhoneNumber() && properties.workPhoneNumber().toLowerCase() == v ||
                                properties.otherPhoneNumber() && properties.otherPhoneNumber().toLowerCase() == v ||
                                person.phoneNumbers.contains(function (p) {
                                    return p.telUri() && p.telUri.toLowerCase() == v;
                                });
                        }
                        function getContactHrefOr(value) {
                            return rParticipant && rParticipant.hasLink('contact') && rParticipant.link('contact').href || value;
                        }
                        function getParticipantResource() {
                            return href.get().then(function () {
                                attach();
                                return rParticipant;
                            });
                        }
                        function attach() {
                            // It seems strange to check here for existence of the resource,
                            // but there is a special case when this is needed. An attempt to
                            // send a message to an offline contact results in a batch of events:
                            //
                            //      messagingInvitation completed, status=Failure
                            //      localParticipant added
                            //      localParticipant deleted
                            //
                            // The added event makes the conversation object resolve the href promise,
                            // which invokes its .then(...) listeners only after the entire batch of
                            // events is processed, but by that moment the href is no longer valid.
                            // Not checking the existence of the resource makes ucwa.get fail an assert(...)
                            // which is annoying during a debugging session, as this assertion doesn't
                            // indicate any real problem.
                            if (!ucwa.exists(href()))
                                throw EDoesNotExist(href());
                            // in case there are multiple href.get() calls at the same time, 
                            // once the first call complete and have rParticipant available,
                            // the rest calls just need to return the resource without adding 
                            // listeners again.
                            if (rParticipant)
                                return;
                            setHiddenProperty(proto, Internal.sHref, href());
                            rParticipant = ucwa.get(href());
                            rParticipant.updated(function () {
                                isJoined(true);
                                foreach(rParticipant.properties, function (value, name) {
                                    if (name in properties)
                                        properties[name](value);
                                });
                                foreach(methods, function (method, rel) {
                                    method.enabled(rParticipant.hasLink(rel));
                                });
                                pContactHref(getContactHrefOr(pContactHref()));
                                // I think this might be a bug; we seem to get another update to participant
                                // after the one that contains the participantMessaging link in the case of 
                                // an incoming p2p invitation. Or maybe UCWA should just supply the participantMessaging
                                // link in the embedded participant resource in the messageInvitation completed event.
                                // We should only set this to disconnected when we get a 'participantMessagingDeleted'
                                // event.
                                // messagingState(rParticipant.hasLink('participantMessaging') ? Modality.State.Connected : Modality.State.Disconnected);
                                if (rParticipant.hasLink('participantMessaging')) {
                                    messagingState(Internal.Modality.State.Connected);
                                }
                                if (rParticipant.hasLink('participantAudio')) {
                                    self[Internal.sInternal].audioLink = rParticipant.link('participantAudio').href;
                                }
                                // TODO: UCWA used to drop participant modality links from the participant resource event if they were
                                // present. This was fixed in UCWA (DEVEX-1999) on 12/12/14, but it takes such a long time to reach our
                                // test servers, so I rely on participantAudio/Video events for now.
                                // audioState(rParticipant.hasLink('participantAudio') ? 'Connected' : 'Disconnected');
                                // videoState(rParticipant.hasLink('participantVideo') ? 'Connected' : 'Disconnected');
                            });
                            rParticipant.deleted(onParticipantDeleted);
                            rParticipant.memberships.changed(function () {
                                var typing = rParticipant.memberships.contains(function (m) { return m.rel == 'typingParticipants'; });
                                isTyping(typing);
                            });
                            // In online meetings the participant resources may get invalidated
                            // by empty "participant updated" events. The client may not unconditionally
                            // fetch the actual state of the participant resource after every such an
                            // updated event to avoid generating too much traffic. So whenever the
                            // participant resource gets invalidated, the model checks whether the view
                            // is observing this participant model and if it is, it sends a GET to the server.
                            rParticipant.dirty.changed(refreshIfNeeded);
                        }
                        function getAndFetchParticipantResource() {
                            return getParticipantResource().then(function () {
                                var p = sm.advanceTo(State.Fetched);
                                p.then(); // creates a dangling promise that prevents cancellation of sm
                                return p.then();
                            });
                        }
                        function onParticipantDeleted(reason) {
                            state(Participant.State.Disconnected, reason);
                            // We don't always get a 'participant messaging deleted' event for remote
                            // participants, but it doesn't work to change this state based solely on updates
                            // to rParticipant.
                            messagingState(Internal.Modality.State.Disconnected, reason);
                            // TODO: Maybe audio too?
                            isJoined(false, reason);
                            for (var name_11 in methods)
                                methods[name_11].enabled(false, reason);
                        }
                        /** Reset state of all variables related to the participant.
                         *  If endpoint is asleep or for another reason does not receive expected
                         *  participant updated events, the conversation will be disconnected upon
                         *  restoring, and at the same time it must reset the state of all
                         *  participants in the conversation.
                        */
                        function reset(reason) {
                            onParticipantDeleted(reason);
                            isTyping(false, reason);
                            audioState(Internal.Modality.State.Disconnected, reason);
                            audioMuted(false, reason);
                            audioOnHold(false, reason);
                            isSpeaking(false, reason);
                            videoStartedBeforeHold(undefined, reason);
                            self.audio.isUnmuteRequested(false, reason);
                            videoState(Internal.Modality.State.Disconnected, reason);
                            // TODO: videoChannels? videoChannel?
                            audioSourceId(-1, reason);
                            videoSourceId(-1, reason);
                            isInMediaRoster = {};
                        }
                        function defineProperty(name, attr) {
                            attr = attr || name;
                            var p = Property({
                                get: function () {
                                    return getAndFetchParticipantResource().then(function () {
                                        // a handler for the rel=participant:updated event
                                        // has already updated this model property, so its new value is cached
                                        return p();
                                    });
                                },
                                unsubscribed: decRef,
                                subscribed: function () {
                                    incRef();
                                    // if the property is in the resource already, do not
                                    // send any requests to the server to load this property
                                    getParticipantResource().then(function () {
                                        if (!rParticipant.has(attr))
                                            sm.advanceTo(State.Fetched);
                                    });
                                }
                            });
                            properties[attr] = p;
                            self[name] = p.asReadOnly();
                        }
                        function defineMethod(name) {
                            var enabled = Property({
                                unsubscribed: decRef,
                                subscribed: function () {
                                    incRef();
                                    getParticipantResource().then(function () {
                                        if (!rParticipant.hasLink(name))
                                            sm.advanceTo(State.Fetched);
                                    });
                                },
                                get: function () {
                                    return getParticipantResource().then(function () {
                                        return rParticipant.hasLink(name) || sm.advanceTo(State.Fetched).then(function () {
                                            // the handler of rParticipant.updated has already updated this property
                                            return enabled();
                                        });
                                    });
                                }
                            });
                            methods[name] = {
                                enabled: enabled
                            };
                            self[name] = Command(bind(post, name), enabled);
                        }
                        function refreshIfNeeded() {
                            if (rParticipant.dirty() && nRefs > 0)
                                ucwa.send('GET', rParticipant.href);
                        }
                        function post(rel) {
                            return ucwa.send('POST', rParticipant.link(rel).href);
                        }
                        function incRef() {
                            nRefs++;
                        }
                        function decRef() {
                            nRefs--;
                        }
                        // Attempt to mute or unmute a remote participant
                        // According to UCWA documentation, if you don't have permission to mute a remote
                        // participant, when you fetch the participantAudio resource the muteAudio link will
                        // simply not be present.
                        function muteUnmute(val) {
                            var rel = val ? 'muteAudio' : 'unmuteAudio', rAudio = ucwa.get(self[Internal.sInternal].audioLink);
                            return Task.run(function () {
                                if (!rAudio || !rAudio.hasLink(rel))
                                    return ucwa.send('GET', self[Internal.sInternal].audioLink);
                                else
                                    return rAudio;
                            }).then(function (resource) {
                                if (!resource)
                                    throw Exception('CannotMuteUnmuteRemoteParticipant', { reason: 'AudioResourceNotFound', type: rel });
                                else if (!resource.hasLink(rel)) {
                                    // Muting the specified participant is disabled if 
                                    // the link is still not present after a fetch
                                    throw Exception('CannotMuteUnmuteRemoteParticipant', { reason: 'LinkNotPresent', type: rel });
                                }
                                return ucwa.send('POST', resource.link(rel).href);
                            }).then(function () {
                                return val;
                            }).catch(function (err) {
                                tm && tm.record(Web.TelemetryEvent.AudioMuteUnmuteRemoteFailed, { reason: err, type: rel });
                                throw err;
                            });
                        }
                        //#region setMediaSourceId
                        // extract media source ids from "participantAudio/Video added/updated in
                        // participant/localParticipant" events
                        // for the local participant MSIs are extracted from the event resource,
                        // for the remote one msi is in event.target.title
                        function setMediaSourceId(event) {
                            var target = event.target, resource = event.resource, rel = target.rel, scope = event['in'], scopeRel = scope && scope.rel, type = event.type, modality, res, msiNone = -1, msi;
                            res = /^participant(Audio|Video)$/.exec(rel);
                            if (!res)
                                return;
                            modality = res[1]; // Audio or Video
                            if (type == 'added' || type == 'updated') {
                                res = /^(local)?participant$/i.exec(scopeRel);
                                if (!res)
                                    return;
                                msi = res[1] != 'local' ? +target.title :
                                    modality == 'Audio' ?
                                        +resource.get('audioSourceId', -1) :
                                        +resource.get('videoSourceId', -1);
                                if (isNaN(msi))
                                    msi = msiNone;
                                if (modality == 'Audio') {
                                    self[Internal.sInternal].audioLink = target.href;
                                    audioSourceId(msi);
                                }
                                else {
                                    self[Internal.sInternal].videoLink = target.href;
                                    videoSourceId(msi);
                                }
                            }
                            else if (type == 'deleted' && modality == 'Video') {
                                // we don't reset audio source id because we need to keep the
                                // pair of audio and video MSIs intact to remove this participant
                                // from the media manager roster. But we do this while processing
                                // 'participantVideo deleted' event, so we can reset both MSIs here.
                                audioSourceId(msiNone);
                                videoSourceId(msiNone);
                            }
                        }
                        //#endregion
                        function watchParticipantProperty(p, name) {
                            p.changed(function (newVal, reason, oldVal) {
                                Internal.log('Participant (' + (properties.displayName() || properties.uri() || '') + ')::' + name + '::', oldVal + '=>' + newVal, reason);
                            });
                        }
                        //#endregion
                        //#region AV-related stuff
                        setHiddenProperty(proto, Internal.sInternal, {
                            state: state,
                            audioState: audioState,
                            videoState: videoState,
                            isSpeaking: isSpeaking,
                            audioSourceId: audioSourceId,
                            videoSourceId: videoSourceId,
                            isInMediaRoster: isInMediaRoster,
                            setMediaSourceId: setMediaSourceId,
                            isLocal: isLocal,
                            audioOnHold: audioOnHold,
                            audioMuted: audioMuted,
                            videoStartedBeforeHold: videoStartedBeforeHold,
                            setVideoStarted: function (val) {
                                assert(videoChannel.isStarted);
                                videoChannel.isStarted._set(val);
                            },
                            setVideoStream: function (vs) {
                                var stream = videoChannel.stream, format = stream.source.sink.format(), container = stream.source.sink.container();
                                stream.setSource(vs || vsEmpty);
                                Web.Media.log('Participant::SetVideoStream  stream %c' + (vs && vs._id()) + ', ' + properties.displayName(), 'color:green;font-weight:bold');
                                // retain the video format and container after setting a new video stream
                                // set format and container on the sourced stream, if available
                                if (vs) {
                                    vs.source.sink.format(format);
                                    vs.source.sink.container(container);
                                }
                                else {
                                    stream.source.sink.format(format);
                                    stream.source.sink.container(container);
                                }
                            }
                        });
                        watchParticipantProperty(audioSourceId, 'audioSourceId');
                        watchParticipantProperty(videoSourceId, 'videoSourceId');
                        watchParticipantProperty(state, 'state');
                        watchParticipantProperty(audioState, 'audio state');
                        watchParticipantProperty(videoState, 'video state');
                        //#endregion
                        //#region init
                        // the participant's name can be embedded in the link: { href: "...", title: "..." }
                        if (title)
                            properties.name(title);
                        // the participant's uri can be known even before the href is known
                        // if the participant object is created for a known uri and then
                        // resolved once the href becomes available:
                        //
                        //      participants.add("sip:johndoe@contoso.com");
                        //
                        if (sipuri)
                            properties.uri(sipuri);
                        properties.uri.changed(endpoint);
                        // participant.displayName <- person.displayName || participant.name || participant.uri
                        Property.observe([person.displayName || ConstProperty(null), properties.name, properties.uri], function (cn, pn, pu) { return properties.displayName(pn || cn || pu || ''); });
                        // participant.person.displayName = participant.displayName
                        person.displayName = properties.displayName.asReadOnly().map(disableHtmlInText);
                        // participant.id <- person.id || participant.uri
                        Property.observe([person.id || ConstProperty(null), properties.uri], function (cu, pu) { return properties.uri(pu || cu); });
                        // participant.person.id = participant.uri
                        person.id = properties.uri.asReadOnly();
                        sm.defineState(State.Fetched, function () {
                            if (isEmptyObject(rParticipant.properties))
                                return ucwa.send('GET', rParticipant.href);
                        });
                        href.changed(function () {
                            rParticipant = null;
                            setHiddenProperty(proto, Internal.sHref, href());
                            sm.reset();
                            // if the href isn't available at the moment,
                            // pull it and then attach to the resource;
                            // otherwise attach to the resource immediately
                            // to let UI see the property values without
                            // a delay introduced by a .get() call
                            if (!href())
                                href.get().then(attach);
                            else
                                try {
                                    attach();
                                }
                                catch (err) {
                                }
                        });
                        Property.observe([messagingState, audioState, videoState, convState], function (ms, as, vs, cs) {
                            // videoState check is not needed since AV state is defined by audio
                            state(cs == Internal.Conversation.State.InLobby ? Participant.State.InLobby :
                                ms == Internal.Modality.State.Connected || as == Internal.Modality.State.Connected ? Participant.State.Connected :
                                    Participant.State.Disconnected);
                        });
                        ucwa.observe('participantMessaging deleted', function (event) {
                            var scope = event['in'];
                            if (scope && scope.href == href())
                                messagingState(Internal.Modality.State.Disconnected);
                        });
                        //#endregion
                        return self;
                    }
                    return Participant;
                }());
                Internal.Participant = Participant;
                (function (Participant) {
                    var State;
                    (function (State) {
                        State.Connected = 'Connected';
                        State.Disconnected = 'Disconnected';
                        State.InLobby = 'InLobby';
                    })(State = Participant.State || (Participant.State = {}));
                })(Participant = Internal.Participant || (Internal.Participant = {}));
            })(Internal = Model_25.Internal || (Model_25.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var guid = Web.Utils.guid;
                var Radix = Web.Utils.Radix;
                var Base64 = Web.Utils.Base64;
                /** this is where FILETIME starts counting from */
                var dt1601 = new Web.Date('1601-01-01T00:00:00Z');
                /** FILETIME measures time in 100 ns units */
                var dt100ns = 0.0001;
                /** in the root thread's FILETIME the last 2 bytes are dropped,
                    hence it measures time in 100 ns * 2^16 = 6.5536 ms units  */
                var dt100ns16 = dt100ns * (1 << 16);
                /** in the continued threads last 18 bits are dropped from FILETIME,
                    hence they measure time in 100 ns * 2^18 = 26.2144 ms units */
                var dt100ns18 = dt100ns16 * (1 << 2);
                /** if the time measured in dt100b18 units doesn't fit in 31 bits, 5 more bits
                    are dropped and the time is measured in 100 ns * 2^23 = 838.8608 ms units */
                var dt100ns23 = dt100ns18 * (1 << 5);
                /** tells that the time diff is measured in dt100ns23 units
                    this flag maps to the 7-th bit because MSB is written first */
                var kLowRes = 0x80000000;
                var r256 = new Radix(0x100);
                /**
                 * A thread id is a base64-encoded sequence of 22+5*N bytes.
                 * When a conversation starts, it's described by a 22 byte id.
                 * Every time it's ended and continued, a 5 byte block is added.
                 * In the binary representation the most significant byte (MSB)
                 * is written first (known as network byte order):
                 *
                 *   +0x00: 1 byte
                 *
                 *      Always set to 0x01. This must be the version of the format.
                 *
                 *   +0x01: 5 bytes
                 *
                 *      The number of 6.5536 ms intervals between the moment when
                 *      the conversation started and Jan 1, 1601. The author of the
                 *      first implementation decided to use the 8-byte FILETIME type
                 *      which tells the number of 100 ns intervals from Jan 1, 1601.
                 *      The author was smart, so he realized that 8 bytes was too much
                 *      and the resolution is too fine, so he discarded the most significant
                 *      byte and two least significant bytes and essentially ended up with a
                 *      5 byte meta-FILETIME type which tells the number of 100 ns * 2^16
                 *      intervals since Jan 1, 1601. Note, that since the MSB byte was discarded,
                 *      its value is assumed to be 0x01.
                 *
                 *  +0x06: 16 bytes
                 *
                 *      The GUID of the first conversation. See RFC 4122.
                 *
                 *  +0x16+5*N: 4 bytes
                 *
                 *      The number of either 26.2144 ms or 838.8608 ms intervals
                 *      between when this thread started and when the previous thread
                 *      started. Apparently, the author of this format noticed that the
                 *      next thread is started shortly (considering the length of epochs
                 *      that his meta-FILETIME can measure) after the previous thread and
                 *      it's possible to save a few bits by storing only the diff between
                 *      the two threads. Unfortunately, this diff didn't fit in 4 bytes,
                 *      so his optimization was pointless. So he discarded two more bits
                 *      (hence the odd 26 ms = 100 ns * 2^16 * 4 interval) and was able fit
                 *      the diff if it was less than 2 years. This worked well until someone
                 *      decided to continue a conversation 2 years later: the diff didn't fit
                 *      into the 4 bytes. So the author invented a smart trick: he said, that
                 *      if the diff fits in 31 bits, it's stored in those 4 bytes; if it doesn't
                 *      fit in the 31 bits, then 5 more bits are discarded (hence the second
                 *      odd interval: 838 ms = 100 ns * 2^16 * 4 * 2^5) and the 31-st bit is set.
                 *      This was enough to store diffs up to 50 years with a little bit less
                 *      resolution.
                 *
                 *
                 *  +0x1a+5*N: 1 byte
                 *
                 *      Most significant 4 bits (4..7) contain a random number in 0..15 range,
                 *      while the least significant 4 bits (0..3) contain some "sequence number"
                 *      which is in the author's library set to 0.
                 *
                 * This format is already implemented in existing clients and has to be implemented
                 * exactly the same way here to enable interop with those clients.
                 *
                 */
                var ThreadId = (function () {
                    function ThreadId(id, uuid) {
                        if (id === void 0 || id instanceof Web.Date) {
                            this.time = id || new Web.Date;
                            this.guid = uuid || guid();
                            this.next = [];
                        }
                        else if (typeof id === 'string') {
                            var bytes = Base64.decodeBytes(id);
                            if (bytes.length < 22 || (bytes.length - 22) % 5 != 0)
                                throw SyntaxError('Invalid threadId: ' + id);
                            // bytes 1..5: time in 6.5536 ms intervals since Jan 1, 1601 (UTC)
                            var dtbs = bytes.slice(1, 6).reverse().concat([1]);
                            var dtms = r256.number(dtbs) * dt100ns16 + (+dt1601);
                            this.time = new Web.Date(Web.Math.round(dtms));
                            // bytes 6..21: GUID (RFC 4122 specifies the order of bytes)
                            this.guid = guid.parse(bytes.slice(6, 22));
                            // bytes 22..(22 + Nx5): conversation continuations
                            this.next = [];
                            for (var i = 22, base = this.time; i < bytes.length; i += 5) {
                                // bytes 0..3: the time diff with the previous thread
                                var dtbs_1 = r256.number(bytes.slice(i, i + 4).reverse());
                                var diff = dtbs_1 >= kLowRes ? (dtbs_1 - kLowRes) * dt100ns23 : dtbs_1 * dt100ns18;
                                var time = new Web.Date((+base) + diff);
                                // bits 0..3 in byte 4: the sequence number
                                var seqn = bytes[i + 4] & 0x0F;
                                // bits 4..7 in byte 4: the random number
                                var rand = bytes[i + 4] >> 4;
                                this.next.push({
                                    time: time,
                                    seqn: seqn,
                                    rand: rand
                                });
                                // the next thread starts counting from this timestamp
                                base = time;
                            }
                        }
                    }
                    ThreadId.prototype.toString = function () {
                        // the first byte must be 0x01 (version?)
                        var bytes = [1];
                        // next 5 bytes: time in 6.5536 ms intervals since Jan 1, 1601 (UTC)
                        bytes.push.apply(bytes, r256.digits(((+this.time) - (+dt1601)) / dt100ns16).slice(0, 5).reverse().map(function (b) { return b | 0; }));
                        // next 16 bytes: GUID            
                        bytes.push.apply(bytes, guid.bytes(this.guid));
                        // next Nx5 bytes: conversation continuations
                        var time = this.time;
                        for (var _i = 0, _a = this.next; _i < _a.length; _i++) {
                            var leaf = _a[_i];
                            var diff = (+leaf.time) - (+time); // in milliseconds                
                            // next 4 bytes: the diff in either 26.2144 ms intervals or 838.8608 ms intervals
                            // if the most significant bit of the 1st byte is set (the 7-th bit)
                            var dtbs = r256.digits(diff / dt100ns18 < Web.Math.pow(2, 31) ?
                                Web.Math.round(diff / dt100ns18) :
                                Web.Math.round(diff / dt100ns23) + kLowRes);
                            for (var i = 3; i >= 0; i--)
                                bytes.push(dtbs[i] || 0);
                            // next 1 byte: a random number and the sequence number
                            bytes.push(((leaf.rand & 0x0F) << 4) | (leaf.seqn & 0x0F));
                            // the i-th 5-bytes block contains a diff between .next[i].time and .next[i-1].time
                            time = leaf.time;
                        }
                        return Base64.encodeBytes(bytes);
                    };
                    ThreadId.prototype.push = function (time, rand, seqn) {
                        if (time === void 0) { time = new Web.Date; }
                        if (rand === void 0) { rand = Web.Math.random() * 16 | 0; }
                        if (seqn === void 0) { seqn = this.next.length; }
                        this.next.push({
                            time: time,
                            rand: rand,
                            seqn: seqn
                        });
                    };
                    ThreadId.prototype.pop = function () {
                        this.next.pop();
                    };
                    return ThreadId;
                }());
                Internal.ThreadId = ThreadId;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_26) {
            var Internal;
            (function (Internal) {
                'use strict';
                var AsyncCommand = Web.Utils.AsyncCommand;
                var DataUri = Web.Utils.DataUri;
                var Exception = Web.Utils.Exception;
                var isPrimitive = Web.Utils.isPrimitive;
                var Model = Web.Utils.Model;
                var Property = Web.Utils.Property;
                var setHiddenProperty = Web.Utils.setHiddenProperty;
                /**
                 * An extension to the conversation that serves as an opaque communication channel
                 * with an external service
                 */
                var ConversationExtension = (function () {
                    function ConversationExtension(options) {
                        //#region input
                        var rExtension = options.rExtension;
                        var ucwa = options.ucwa;
                        var tm = options.tm;
                        //#region private
                        var canSend = Property({ value: true });
                        var contentType = Property();
                        var content = Property();
                        var serviceName = Property();
                        var defaultCid = '4f97946f-dfe1-4954-aa51-7cff2c83f070';
                        var defaultBoundary = '3cd718e7-a311-4775-8178-e028bb921daa';
                        //#endregion
                        /**
                         *  Handles updates to the conversationExtension resource
                         */
                        function processResource() {
                            var c = DataUri(rExtension.relatedHref('content') || 'data:,');
                            // Do not try to process the content in any way.
                            // Ucwa classifies external resources as types that it does not understand.
                            // Hence it will pass along mime types that are non-standard.
                            contentType.set(c.mime);
                            content.set(c.data);
                            serviceName.set(rExtension.get('serviceName'));
                        }
                        /**
                         * A channel for the client to communicate back to the service.
                         * @param content Any content in a string format. The SDK just passes it along.
                         * @param contentType A mime type identifying the type of content. Non standard
                         * mime types are acceptable here since the SDK just passes it along.
                         */
                        function postExtension(content, contentType, boundary) {
                            if (content == void 0)
                                throw Exception('ContentRequired');
                            if (contentType == void 0)
                                throw Exception('ContentTypeRequired');
                            // api contract specifies string content. In case users pass non primitives then stringify.
                            content = isPrimitive(content) ? content : JSON.stringify(content);
                            var request = createMultipartRequest(boundary || defaultBoundary, content, contentType);
                            var dfd = ucwa.send('POST', rExtension.href, request).then(function (ceResult) {
                                // result is a ucwa ExternalResource, just pass it along.
                                var result = DataUri(ceResult.relatedHref('result') || 'data:,');
                                return {
                                    content: result.data,
                                    contentType: result.mime
                                };
                            });
                            tm && tm.monitor(dfd, Web.TelemetryEvent.ConversationExtension, {
                                action: 'send_data',
                                href: rExtension.href
                            });
                            return dfd;
                        }
                        function createMultipartRequest(boundary, content, contentType) {
                            var payload = [
                                '--' + boundary,
                                'Content-Type: application/vnd.microsoft.com.ucwa+json',
                                '',
                                JSON.stringify({ input: 'CID:' + defaultCid }),
                                '--' + boundary,
                                'Content-Type: ' + contentType,
                                'Content-Id: ' + defaultCid,
                                '',
                                content,
                                '--' + boundary + '--',
                                ''
                            ].join('\r\n');
                            return {
                                headers: {
                                    'Content-Type': 'multipart/related;boundary=' + boundary + ';type="application/vnd.microsoft.com.ucwa+json"'
                                },
                                data: payload
                            };
                        }
                        //#endregion
                        rExtension.updated(function () {
                            processResource();
                            tm && tm.record(Web.TelemetryEvent.ConversationExtension, {
                                action: 'ucwa_updated'
                            });
                        });
                        var self = Model({
                            content: content.asReadOnly(),
                            contentType: contentType.asReadOnly(),
                            serviceName: serviceName.asReadOnly(),
                            sendData: AsyncCommand(postExtension, canSend)
                        });
                        setHiddenProperty(self, Internal.sHref, rExtension.href);
                        return self;
                    }
                    return ConversationExtension;
                }());
                Internal.ConversationExtension = ConversationExtension;
            })(Internal = Model_26.Internal || (Model_26.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="ThreadId.ts" />
/// <reference path="ConversationExtension.ts" />
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_27) {
            var Internal;
            (function (Internal) {
                var find = Web.Utils.find;
                var guid = Web.Utils.guid;
                var size = Web.Utils.size;
                var check = Web.Utils.check;
                var sleep = Web.Utils.sleep;
                var assert = Web.Utils.assert;
                var extend = Web.Utils.extend;
                var random = Web.Utils.random;
                var foreach = Web.Utils.foreach;
                var indexOf = Web.Utils.indexOf;
                var inherit = Web.Utils.inherit;
                var contains = Web.Utils.contains;
                var debounced = Web.Utils.debounced;
                var decorated = Web.Utils.decorated;
                var getOption = Web.Utils.getOption;
                var disableHtmlInText = Web.Utils.disableHtmlInText;
                var setHiddenProperty = Web.Utils.setHiddenProperty;
                var Task = Web.Utils.Task;
                var Event = Web.Utils.Event;
                var Model = Web.Utils.Model;
                var Command = Web.Utils.Command;
                var DataUri = Web.Utils.DataUri;
                var WeakMap = Web.Utils.WeakMap;
                var Promise = Web.Utils.Promise;
                var Property = Web.Utils.Property;
                var Exception = Web.Utils.Exception;
                var Collection = Web.Utils.Collection;
                var NumProperty = Web.Utils.NumProperty;
                var BoolProperty = Web.Utils.BoolProperty;
                var AsyncCommand = Web.Utils.AsyncCommand;
                var ConstProperty = Web.Utils.ConstProperty;
                var ENotSupported = Web.Utils.ENotSupported;
                var EnabledCommand = Web.Utils.EnabledCommand;
                var DisabledAsyncCommand = Web.Utils.DisabledAsyncCommand;
                var ConstCollection = Web.Utils.ConstCollection;
                var SourcedProperty = Web.Utils.SourcedProperty;
                var ComputedProperty = Web.Utils.ComputedProperty;
                var EInvalidArgument = Web.Utils.EInvalidArgument;
                var EnabledAsyncCommand = Web.Utils.EnabledAsyncCommand;
                /**
                 * An ongoing conversation with one or multiple participants.
                 *
                 * The conversation model consists of
                 *
                 *  - the local (self) participant
                 *  - the list of remote participants where the inviter is the first
                 *  - the chat/audio/video services
                 *  - common properties (such as "subject")
                 *
                 * To start an outgoing messaging conversation:
                 *
                 *      var messaging = conversation.chatService;
                 *
                 *      messaging.start({
                 *          message: 'How are you?',
                 *          to: 'sip:user@company.com'
                 *      });
                 *
                 * Participants can be added later:
                 *
                 *      conversation.participants.add("sip:user2@contoso.com");
                 *      conversation.participants.add("sip:user3@contoso.com");
                 *      conversation.participants.add("sip:user4@contoso.com");
                 */
                var Conversation = (function () {
                    //#endregion
                    function Conversation(options) {
                        // a conversation is either incoming, outgoing, a meeting with a uri or a restored conversation:
                        // 1. an incoming conversation is identified by rInvitation
                        // 2. an outgoing conversation is identified by the thread id
                        // 3. a meeting is identified by a uri  (called from getConversationByUri)
                        // 4. a restored conversation is identified by href
                        // 5. an outgoing conversation created from an outgoing invitation that arrived from another tab
                        //#region Locals
                        var ucwa = options.ucwa;
                        var me = options.me;
                        var href = options.href;
                        var clt = options.clt; // if null, conv logs are disabled
                        var contactManager = options.contactManager;
                        var mediaPlugin = options.mediaPlugin;
                        var devices = options.devices;
                        var sharedResources = options.sharedResources;
                        var rInvitation = options.rInvitation;
                        var guestName = options.guestName;
                        var muteNdrForMeeting = options.muteNdrForMeeting;
                        var isIncoming = false; // assigned by processInvitation
                        // threadId identifies the conversation: it's specified by the client
                        // when the client starts an outgoing conversation and it's specified
                        // by the server when the client receives an incoming invitation from
                        // the server; every time the conversation is ended and continued, the
                        // threadId is appended a 5 byte block which encodes the time when it
                        // was continued; threadId is a base64 encoded binary format
                        var threadId = Property({ value: options.threadId || new Internal.ThreadId + '' });
                        var subject = Property({ value: options.topic || '' });
                        var priority = Property({ value: options.priority || 'Normal' });
                        // the uri of the onlineMeeting (if it exists)
                        var uri = Property({ value: options.uri || null });
                        /** Created once in the ctor. */
                        var localParticipant;
                        var tm = options.tm;
                        var settings = options.settings;
                        /**
                         * Participants are indexed by random unguessable keys.
                         * They aren't indexed by participant hrefs because
                         * the same participant object can be reused by this
                         * conversation model when it is reattached to different
                         * p2p sessions.
                         */
                        var participants = options.participants || Collection({
                            get: function () { return Task.run(function () {
                                return ucwa.send('GET', rConversation.link('participants').href).then(function (rs) {
                                    var rps = rs.links('participant').map(function (r) { return ucwa.get(r.href); }); // list of rel=participant resources
                                    var tasks = rps.map(function (r) { return ucwa.send('GET', r.href).catch(); });
                                    // the cache may contain rel=participant resources that appear
                                    // to be linked to this conversation, but were removed from
                                    // the conversation long ago; this is why it's better
                                    // to use the up-to-date list of participants from the GET response
                                    return Task.waitAll(tasks).then(function () { return restoreParticipants(rps); });
                                });
                            }).catch(); }
                        });
                        var isConferenceByDefault = rInvitation ? rInvitation.rel == 'onlineMeetingInvitation' :
                            'isConference' in options ? !!getOption(options, 'isConference') : true;
                        var isConference = BoolProperty(isConferenceByDefault);
                        // it does not make sense to create a P2P conversation with more than one participant
                        assert(isConference() || participants.size() < 2);
                        options = null; // no need to use options beyond this point
                        var state = Property({ value: Conversation.State.Created });
                        var modalities = Collection();
                        var changed = new Event({
                            added: function (listener) { return listener(); }
                        });
                        var rConversation; // rel=conversation
                        var isChatActive = Property({ value: false });
                        var isAudioActive = Property({ value: false });
                        var isVideoActive = Property({ value: false });
                        var isSharingActive = Property({ value: false });
                        var isCollabActive = Property({ value: false });
                        var canAcknowledge = Property({ value: false });
                        var wasChatActive = Property.just(false);
                        var wasAudioActive = Property.just(false);
                        var wasVideoActive = Property.just(false);
                        var wasSharingActive = Property.just(false);
                        var wasCollabActive = Property.just(false);
                        var isConferencing = state.equalsAny(Conversation.State.Conferenced, Conversation.State.Conferencing);
                        var activityItems = Collection();
                        var chat;
                        var extensions = Collection({
                            get: function () { return Task.run(function () {
                                if (!rConversation.hasLink('conversationExtensions'))
                                    return;
                                var dfd = ucwa.send('GET', rConversation.link('conversationExtensions').href).then(function (rConvExtensions) {
                                    var validExtensionHrefs = rConvExtensions.links('conversationExtension').map(function (r) { return r.href; });
                                    // remove local extensions that are no longer part of this conversation
                                    extensions.removeAll(function (ce) { return validExtensionHrefs.indexOf(ce[Internal.sHref]) < 0; });
                                    // GET on conversationExtensions should return a list of embedded conversationExtension resources
                                    updateExtensions(validExtensionHrefs);
                                });
                                tm && tm.monitor(dfd, Web.TelemetryEvent.Conversation, {
                                    action: 'getConvExtensions',
                                    href: rConversation.link('conversationExtensions').href
                                });
                                return dfd;
                            }).catch(); }
                        });
                        var proto = Model();
                        var self = inherit(proto, {
                            /** Once set, the id cannot be changed: that's
                                the contract between the SDK and the UI. */
                            id: ConstProperty(guid()),
                            threadId: threadId.asReadOnly(),
                            /** Deprecated. */
                            changed: changed.observer,
                            state: state.asReadOnly(),
                            isJoiningEnabled: ConstProperty(true),
                            topic: subject.fork(Command(function (x) { return x; }, state.equals('Created'))),
                            priority: priority.asReadOnly(),
                            uri: uri.asReadOnly(),
                            context: getInvitationContext(),
                            attachConvLog: attachConvLog,
                            modalities: extend(modalities.asReadOnly(), {
                                chat: wasChatActive.asReadOnly(),
                                audio: wasAudioActive.asReadOnly(),
                                video: wasVideoActive.asReadOnly(),
                                screenSharing: wasSharingActive.asReadOnly(),
                                dataCollaboration: wasCollabActive.asReadOnly()
                            }),
                            activeModalities: Model({
                                chat: isChatActive.asReadOnly(),
                                audio: isAudioActive.asReadOnly(),
                                video: isVideoActive.asReadOnly(),
                                screenSharing: isSharingActive.asReadOnly(),
                                dataCollaboration: isCollabActive.asReadOnly()
                            }),
                            isGroupConversation: isConference.asReadOnly(),
                            acknowledge: AsyncCommand(debounced(acknowledge), canAcknowledge),
                            confirm: EnabledAsyncCommand(decorated([tm && tm.monitored(Web.TelemetryEvent.ConfAck)], function () { return self.meeting.acknowledge(); })),
                            addModality: addModality,
                            addMeeting: addMeeting,
                            forceDisconnectConversation: forceDisconnectConversation,
                            resetThreadId: resetThreadId,
                            isThreadIdRejectedError: isThreadIdRejectedError,
                            // .leave must be disabled when state is Disconnected:
                            // it's a requirement from the UI team
                            leave: AsyncCommand(stop, state.map(function (x) { return x != 'Created' && x != 'Disconnected'; })),
                            createParticipant: EnabledCommand(createParticipantFromPersonOrUri),
                            participantsCount: participants.size,
                            participants: participants.fork({
                                // Add/remove a participant in the conversation: it is safe to invoke
                                // this method many times in a row: SkypeWeb will merge all the requests
                                // into one batch request.
                                //     conversation.participants.add("sip:user1@contoso.com");
                                //     conversation.participants.add("sip:user2@contoso.com");
                                //     conversation.participants.add("sip:user3@contoso.com");
                                // Note:
                                //     - adding a participant to a P2P conversation escalates it
                                //       to the multiparty mode and creates an online meeting
                                //     - removing a participant from a 3-person meeting does not
                                //       downgrade it to a P2P conversation
                                add: Command(addParticipant, state.equalsAny(Conversation.State.Created, Conversation.State.Connected, Conversation.State.Conferenced, Conversation.State.Disconnected)),
                                remove: AsyncCommand(removeParticipant, participants.reduce(function (f, p) { return f ||
                                    p.eject && p.eject.enabled() || p.state && p.state() == 'Disconnected'; }, false))
                            }),
                            avatarUrlSmall: ConstProperty(null),
                            avatarUrlLarge: ConstProperty(null),
                            createInvitation: function () {
                                var args = [];
                                for (var _i = 0; _i < arguments.length; _i++) {
                                    args[_i] = arguments[_i];
                                }
                                return void 0;
                            },
                            pendingInvitations: Collection.empty,
                            spawnedConversation: ConstProperty(null),
                            extensions: extensions.asReadOnly()
                        });
                        /** These conv logs are added by the conversation manager. */
                        var convlogs = [];
                        /** participantHrefs.get(p) is the href property given to p */
                        var participantHrefs = new WeakMap();
                        /** initial number of remote participants upon joining the conference (local included)
                            as reported by "conversation added/updated" events */
                        var participantCountOnJoin = NumProperty();
                        /** number of participants joined the conference (local included) as reported by
                            "participant added" events */
                        var participantCount = NumProperty(0);
                        /** ignoring participant added/deleted events for some time after joining the conference
                            to avoid multiple notifications for all participants who are already in the conference */
                        var pactivityTimeoutExpired = BoolProperty(false);
                        /** allow "participant joined/left" activity items */
                        var allowPActivityItems = ComputedProperty([isConferencing, participantCountOnJoin, participantCount, pactivityTimeoutExpired], function (isConf, pcJoin, pc, expired) {
                            return isConf && (pc > pcJoin || expired);
                        });
                        /** The task is resolved by changing corresponding "href" property. */
                        var dfdLocalParticipantHref = new Task();
                        /** Setting the value of this property immediately resolves the
                            corresponding task which the Participant model is waiting on. */
                        var pLocalParticipantHref = Property({
                            get: function () { return pLocalParticipantHref() || dfdLocalParticipantHref.promise; }
                        });
                        pLocalParticipantHref.changed(function (href) {
                            if (href && dfdLocalParticipantHref) {
                                dfdLocalParticipantHref.resolve(href);
                                dfdLocalParticipantHref = null;
                            }
                        });
                        var avm;
                        var stopAudioEnabled = Property({ value: false });
                        var stopVideoEnabled = Property({ value: false });
                        //#endregion
                        //#region participantActivityItems
                        /** add a participant activity item */
                        function addParticipantActivityItem(itemType, participant, error, key, reason) {
                            var person = participant.person;
                            var item = new Internal.ActivityItem(itemType, key, {
                                author: person,
                                persons: ConstCollection([person]),
                                context: ConstProperty(void 0, ENotSupported()),
                                status: ConstProperty(error ? 'Failed' : 'Succeeded', reason || error)
                            });
                            item.isRead(true);
                            activityItems.add(item);
                        }
                        /** sets up conditional creation of participant activity items */
                        function initParticipantActivityItems(localParticipant) {
                            state.when('Conferenced', function () {
                                addParticipantActivityItem('ParticipantJoined', localParticipant);
                                state.once('Disconnected', function (reason) {
                                    addParticipantActivityItem('ParticipantLeft', localParticipant, null, null, reason);
                                });
                            });
                            participants.added(function (p) {
                                p.isJoined.changed(function (val) {
                                    if (allowPActivityItems())
                                        addParticipantActivityItem(val ? 'ParticipantJoined' : 'ParticipantLeft', p);
                                });
                            });
                        }
                        //#endregion
                        //#region calling activity items
                        /**
                         * CallMissed = a transition from Notified to Disconnected that bypasses Connected.
                         * CallStarted = a transition from Connecting to Connected
                         * CallEnded = a transition from Connected to Disconnected
                         */
                        function initCallingActivityItems(state) {
                            var subMissed, subStarted, subCanceled, subEscalated, subEnded, started;
                            function callActivity(activity, dir, duration) {
                                var item = new Internal.ActivityItem(activity, null, {
                                    direction: ConstProperty(dir),
                                    duration: ConstProperty(duration || null)
                                });
                                item.isRead(true);
                                activityItems.add(item);
                                return item;
                            }
                            function callMissed(reason) {
                                // reason=AcceptedElsewhere or reason.subcode=ConnectedElsewhere
                                // for state=Disconnected means connected on another tab or client, so it is not a missed call.
                                if (reason != 'AcceptedByOtherInstance' && !(reason && reason.subcode == 'ConnectedElsewhere'))
                                    callActivity('CallMissed', 'Incoming');
                                subMissed = null;
                            }
                            function callStarted() {
                                started = callActivity('CallStarted', isIncoming ? 'Incoming' : 'Outgoing');
                                if (subCanceled) {
                                    subCanceled.dispose();
                                    subCanceled = null;
                                }
                                subStarted = null;
                                subEscalated = state.once('Connecting', callEscalated);
                                subEnded = state.once('Disconnected', callEnded);
                            }
                            function callCanceled() {
                                if (subStarted) {
                                    subStarted.dispose();
                                    subStarted = null;
                                }
                            }
                            function callEscalated() {
                                // dispose the CallEnded handler for the original P2P call
                                // since a new handler will be created for the escalated group call
                                if (subEnded) {
                                    subEnded.dispose();
                                    subEnded = null;
                                }
                                subEscalated = null;
                            }
                            function callEnded() {
                                callActivity('CallEnded', isIncoming ? 'Incoming' : 'Outgoing', Web.Math.round((Web.Date.now() - started.timestamp()) / 1000));
                                if (subEscalated) {
                                    subEscalated.dispose();
                                    subEscalated = null;
                                }
                                subEnded = null;
                            }
                            // incoming: ready to capture the 'CallMissed' activity item
                            state.when('Notified', function () {
                                subMissed = state.once('Disconnected', callMissed);
                            });
                            state.when('Connecting', function () {
                                if (subMissed) {
                                    subMissed.dispose();
                                    subMissed = null;
                                }
                                // incoming/outgoing: 'Connecting' to 'Connected' transition
                                subStarted = state.once('Connected', callStarted);
                                // incoming/outgoing: 'Connecting' to 'Disconnected' transition
                                subCanceled = state.once('Disconnected', callCanceled);
                            });
                        }
                        //#endregion
                        //#region createAvatarUrl
                        /** sets up conversation avatar url depending on the conversation type */
                        function createAvatarUrl() {
                            var avatarSub;
                            var avatarUrl = SourcedProperty();
                            // Note that isConference may change its value exactly once: 
                            // when a 1:1 conversation is escalated to a conference (false -> true)
                            isConference.when(false, function () {
                                // in 1:1 conversations we use the remote participant's photo
                                avatarSub = participants.size.when(1, function () { return avatarUrl.setSource(participants(0).person.avatarUrl); });
                            });
                            isConference.when(true, function () {
                                // UCWA does not have a conference picture concept, nothing to set
                                avatarUrl.setSource(ConstProperty(null));
                                // need to dispose to avoid avatar change if only one remote participant
                                // is left in a conversation escalated to a conference from a 1:1 conv.
                                if (avatarSub) {
                                    avatarSub.dispose();
                                    avatarSub = null;
                                }
                            });
                            return avatarUrl.asReadOnly();
                        }
                        //#endregion
                        //#region processInvitation
                        /** this function may be called first time when the conversation model is
                            being initialized by init(), or when this conversation is disconnected
                            and then receives a new invitation event */
                        function processInvitation(r) {
                            rInvitation = r;
                            isIncoming = rInvitation.get('direction') == 'Incoming';
                            setResource(ucwa.get(rInvitation.link('conversation').href));
                            threadId.set(rInvitation.get('threadId') + '');
                            self.context = getInvitationContext();
                            // in outgoing invitation /from points to the local participant
                            // which must not be added to the .participants collection
                            if (rInvitation.hasLink('from') && isIncoming) {
                                var senderHref = rInvitation.link('from').href; // rel=participant
                                var senderName = ucwa.get(senderHref).get('name', void 0);
                                // despite the inviter appears to be a rel=participant,
                                // it doesn't have to belong to the list of participants:
                                // this rare case happens when someone, usually a service,
                                // invites to a conference while not being in that conference;
                                // in this case the inviter will initially be added to the participants
                                // collection, but will be removed after the conference is actually joined
                                resolveParticipant(senderHref, senderName);
                            }
                            else if (rInvitation.hasLink('to') && !isIncoming) {
                                var receiverHref_1 = rInvitation.link('to').href; // rel=person
                                var matchingParticipants = participants.filter(function (p) { return p.person[Internal.sHref] == receiverHref_1; });
                                if (matchingParticipants.size() == 0) {
                                    var person = contactManager.get(receiverHref_1);
                                    var participant = createParticipantFromPersonOrUri(person);
                                    addParticipant(participant);
                                }
                            }
                            state(isIncoming ? Conversation.State.Incoming : Conversation.State.Connecting);
                            if (rInvitation.rel == 'onlineMeetingInvitation') {
                                self.meeting = new Internal.OnlineMeeting({
                                    ucwa: ucwa,
                                    rInvitation: rInvitation,
                                    from: isIncoming ? participants(0) : localParticipant,
                                    conversation: self,
                                    contactManager: contactManager
                                });
                                changed.fire();
                            }
                        }
                        //#endregion
                        //#region syncParticipants
                        // This function is supposed to GET /participants and sync them:
                        //
                        //  1. remove those that aren't in the conversation 
                        //  2. add those that are in the conversation
                        //
                        // For now this function just removes those participant objects
                        // that have a href not in the /conversation/participants list:
                        // this shouldn't remove participants that are being added.
                        //
                        // participants.get() is supposed to do a similar thing, but it
                        // also does a GET on every participant, which may be too slow
                        // in large meetings with many participants.
                        function syncParticipants() {
                            return Task.run(function () {
                                var phref = rConversation.link('participants').href;
                                return ucwa.send('GET', phref).then(function (rs) {
                                    var pkeys = []; // participants to be removed
                                    participants.each(function (p, key) {
                                        var href = p[Internal.sHref];
                                        var joined = find(rs.links('participant'), function (link) { return link.href == href; });
                                        // participants that are being added don't have the href
                                        if (href && !joined)
                                            pkeys.push(key);
                                    });
                                    for (var _i = 0, pkeys_1 = pkeys; _i < pkeys_1.length; _i++) {
                                        var key = pkeys_1[_i];
                                        participants.remove(key);
                                    }
                                });
                            });
                        }
                        //#endregion
                        /** It's invoked once and essentially plays the role of the constructor. */
                        function init() {
                            setHiddenProperty(proto, Internal.sHref, href);
                            setHiddenProperty(proto, Internal.sInternal, {
                                inviteParticipants: inviteParticipants,
                                processInvitation: processInvitation
                            });
                            self.participants.sync = syncParticipants;
                            if (href) {
                                setResource(ucwa.get(href));
                                threadId.set(rConversation.get('threadId', threadId()));
                                restoreParticipants();
                                restoreMeeting();
                                restoreExtensions();
                            }
                            localParticipant = createParticipant({
                                href: pLocalParticipantHref.asReadOnly(),
                                person: me,
                                convState: state,
                                isLocal: true
                            });
                            self.selfParticipant = localParticipant;
                            if (rInvitation) {
                                processInvitation(rInvitation);
                            }
                            else if (uri()) {
                                // called from getConversationByUri to create
                                // a meeting based on the meeting's uri
                                self.meeting = new Internal.OnlineMeeting({
                                    ucwa: ucwa,
                                    threadId: threadId(),
                                    subject: subject(),
                                    priority: priority(),
                                    conversation: self,
                                    contactManager: contactManager
                                });
                            }
                            if (self.meeting)
                                self.meeting.uri.changed(uri);
                            chat = new Internal.ChatService({
                                ucwa: ucwa,
                                guestName: guestName,
                                conversation: self,
                                rInvitation: rInvitation && rInvitation.rel == 'messagingInvitation' && rInvitation,
                                tm: tm,
                                settings: settings
                            });
                            self.chatService = chat;
                            // the Created state is for internal use only, map it to Disconnected for external users
                            localParticipant.chat.state = chat.state.map(function (v) { return v == 'Created' ? 'Disconnected' : v; });
                            var unreadCount = NumProperty(0);
                            var lastModified = Property({ value: new Web.Date });
                            var keyPrefix = random();
                            var makeKey = function (key) { return keyPrefix + ':' + key; };
                            chat.messages.added(function (message, key) { return addMessageActivityItem(message, makeKey(key)); });
                            chat.messages.removed(function (message, key) { return activityItems.remove(makeKey(key)); });
                            activityItems.added(function (item) {
                                // it's assumed that if an item gets read, it cannot be un-read
                                if (!item.isRead()) {
                                    unreadCount.inc();
                                    item.isRead.once(true, function () { return unreadCount.dec(); });
                                }
                                if (item.timestamp() > lastModified())
                                    lastModified(item.timestamp());
                            });
                            self.historyService = Model({
                                activityItems: activityItems.sort(function (lhs, rhs) { return lhs.timestamp() < rhs.timestamp(); }),
                                unreadActivityItemsCount: unreadCount.asReadOnly(),
                                isHistoryDisclosed: ConstProperty(false),
                                getMoreActivityItems: AsyncCommand(debounced(fetchLogs), ComputedProperty([isConference, participants.size], function (c, n) { return !c && n == 1 && !!clt; })),
                                markAllAsRead: EnabledAsyncCommand(function () { return activityItems.each(function (item) { return item.isRead(true); }); }),
                                removeAll: EnabledAsyncCommand(function () { return activityItems.empty(); }),
                                addCustomActivityItem: EnabledCommand(function (type, props) { return void activityItems.add(new Internal.ActivityItem(type, null, props)); }),
                                removeCustomActivityItem: EnabledCommand(function (type) { return void activityItems.removeAll(function (item) { return item.type() == type; }); })
                            });
                            setHiddenProperty(self, 'addMessageActivityItem', addMessageActivityItem);
                            self.lastModificationTimestamp = lastModified.asReadOnly();
                            self.phoneAudioService = Internal.PhoneAudio && new Internal.PhoneAudio({
                                tm: tm,
                                ucwa: ucwa,
                                name: guestName,
                                invitation: rInvitation && rInvitation.rel == 'phoneAudioInvitation' ? rInvitation : null,
                                conversation: self
                            });
                            avm = Internal.AudioVideoModality && new Internal.AudioVideoModality({
                                ucwa: ucwa,
                                guestName: guestName,
                                mediaPlugin: mediaPlugin,
                                devices: devices,
                                participants: participants.asReadOnly(),
                                selfParticipant: localParticipant,
                                conversation: self,
                                rConversation: rConversation,
                                me: me,
                                rInvitation: rInvitation,
                                tm: tm,
                                settings: settings
                            });
                            self.audioService = avm && Model({
                                callConnected: avm.connectedAt,
                                state: avm.audioState,
                                start: Command(avm.start, ComputedProperty([me.capabilities.audio, avm.audioState, avm.start.enabled], function (enabled, state, startEnabled) { return enabled && (state == Internal.Modality.State.Disconnected || (state == Internal.Modality.State.Notified && startEnabled)); })),
                                stop: Command(avm.stop, stopAudioEnabled),
                                accept: Command(avm.accept, ComputedProperty([me.capabilities.audio, avm.audioState], function (enabled, state) { return enabled && state == Internal.Modality.State.Notified; })),
                                reject: Command(avm.decline, avm.audioState.equals(Internal.Modality.State.Notified)),
                                transfer: avm.transfer,
                                sendDtmf: avm.sendDtmf
                            });
                            self.videoService = avm && Model({
                                state: avm.videoState,
                                start: AsyncCommand(function (options) { return avm.start(extend(options, { video: true }, 'append')); }, ComputedProperty([me.capabilities.video, avm.audioState, avm.videoState, avm.start.enabled], function (enabled, audio, video, startEnabled) { return enabled &&
                                    (video == Internal.Modality.State.Disconnected || (video == Internal.Modality.State.Notified && startEnabled)) &&
                                    (audio == Internal.Modality.State.Connected || (audio == Internal.Modality.State.Disconnected || (audio == Internal.Modality.State.Notified && startEnabled))); })),
                                stop: AsyncCommand(function () { return avm.stop('video'); }, stopVideoEnabled),
                                // avm.videoState.equalsAny(Modality.State.Connected, Modality.State.Connecting)),
                                accept: AsyncCommand(function (options) { return avm.accept(extend(options, { video: true })); }, ComputedProperty([me.capabilities.video, avm.videoState], function (enabled, state) {
                                    return enabled && state == Internal.Modality.State.Notified;
                                })),
                                reject: Command(avm.decline, avm.videoState.equals(Internal.Modality.State.Notified)),
                                maxVideos: ConstProperty(null),
                                videoMode: avm && avm.videoMode,
                                activeSpeaker: avm && avm.activeSpeaker
                            });
                            self.screenSharingService = Model({
                                sharer: ConstProperty(null),
                                sharedResources: Collection.empty,
                                controller: ConstProperty(null),
                                controlRequesters: Collection.empty,
                                requestControl: DisabledAsyncCommand(),
                                releaseControl: DisabledAsyncCommand(),
                                acceptControlRequest: DisabledAsyncCommand(),
                                rejectControlRequest: DisabledAsyncCommand(),
                                start: DisabledAsyncCommand(),
                                stop: DisabledAsyncCommand(),
                                accept: DisabledAsyncCommand(),
                                reject: DisabledAsyncCommand()
                            });
                            self.fileTransferService = Model({
                                files: Collection.empty,
                                send: DisabledAsyncCommand()
                            });
                            // override properties of the self participant audio excluding isSpeaking
                            avm && extend(localParticipant.audio, {
                                isMuted: avm.muted,
                                isOnHold: avm.onHold,
                                isUnmuteRequested: Property({ value: false })
                            });
                            // TODO: use SourcedModel to change the creator properly when resuming the conversation
                            self.creator = self.meeting ? self.meeting.creator :
                                isIncoming ? participants(0).person :
                                    rInvitation ? localParticipant.person :
                                        href ? restoreCreator() :
                                            localParticipant.person; // P2P outgoing conversation
                            state.changed(function () {
                                switch (state()) {
                                    case Conversation.State.Connecting:
                                    case Conversation.State.Connected:
                                        isConference(false);
                                        break;
                                    case Conversation.State.Conferencing:
                                    case Conversation.State.Conferenced:
                                        isConference(true);
                                        break;
                                }
                            });
                            uri.changed(function () {
                                if (!!uri())
                                    isConference(true);
                            });
                            participants.size.changed(function () {
                                switch (state()) {
                                    case Conversation.State.Created:
                                    case Conversation.State.Disconnected:
                                        // we defer to the initial status even when there are no remote participants to
                                        // 1. avoid property change after a participant is added to a conversation
                                        //    created by the {isConference: true} parameter
                                        // 2. to support starting a conversation service with the {to: sipUri} parameter
                                        isConference(participants.size() > 1 || isConferenceByDefault);
                                        break;
                                }
                            });
                            initParticipantActivityItems(localParticipant);
                            initCallingActivityItems(localParticipant.audio.state);
                            self.avatarUrl = createAvatarUrl();
                            // when chat becomes active in a meeting determine if we need to start chat service automatically.
                            isChatActive.when(true, autoStartChatIfRequired);
                            // when video becomes active in a meeting determine if we need to start video service automatically in receive mode.
                            isVideoActive.when(true, autoStartVideoIfRequired); // handles video addition during an already joined meeting
                            avm && avm.audioState.when(Internal.Modality.State.Connected, autoStartVideoIfRequired); // handles video addition when joining or rejoining a meeting.
                            avm && observeStopAVEnabled();
                        }
                        //#region Internal Methods
                        /* The stop command is enabled if and only if
                         * audioState and selfParticipant.audio.state are either
                         * 'Connected' or 'Connecting'. Also need to ensure that
                         * participant(0).audio.state does not become 'Disconnected'
                         * before audioState.
                         */
                        function observeStopAVEnabled() {
                            var pAudioState, pVideoState, observedStates = [avm.audioState, avm.videoState];
                            if (!isConferencing()) {
                                pAudioState = Property();
                                pVideoState = Property();
                                localParticipant.audio.state.changed(pAudioState);
                                localParticipant.video.state.changed(pVideoState);
                                observedStates.push(pAudioState);
                                observedStates.push(pVideoState);
                            }
                            Property.observe(observedStates, function (audioState, videoState, selfAudioState, selfVideoState) {
                                var states = [Internal.Modality.State.Connected, Internal.Modality.State.Connecting];
                                var isAudioEnabled = contains(states, function (state) { return audioState == state; });
                                if (!isConferencing() && selfAudioState)
                                    isAudioEnabled = isAudioEnabled && contains(states, function (state) { return selfAudioState == state; });
                                var isVideoEnabled = contains(states, function (state) { return videoState == state; });
                                if (!isConferencing() && selfVideoState)
                                    isVideoEnabled = isVideoEnabled && contains(states, function (state) { return selfVideoState == state; });
                                stopAudioEnabled(isAudioEnabled);
                                stopVideoEnabled(isVideoEnabled);
                            });
                        }
                        //#region addMessageActivityItem
                        /** Internally the activity items aren't sorted.
                            However the interface exposes a list sorted by the timestamp. */
                        function addMessageActivityItem(message, key) {
                            var proto = message;
                            if (muteNdrForMeeting && message.direction() == 'Outgoing' && self.isGroupConversation()) {
                                // TODO: In the case of groupConversation, if the message cannot be delivered to
                                // any of the participants, a NDR event is sent from UCWA. In this case we mute the
                                // failure status and the reason. This should be done in the UI layer.
                                // note: if the status is Failed and contains a reason field, the new status is changed
                                // to Succeeded but the reason field is still there.
                                proto = inherit(message, {
                                    status: message.status.map(function (newValue) {
                                        if (newValue == 'Failed' && message.status.reason && message.status.reason['code'] == 'RemoteFailure') {
                                            return 'Succeeded';
                                        }
                                        return newValue;
                                    })
                                });
                            }
                            var item = new Internal.ActivityItem('TextMessage', key, proto);
                            if (message.direction() == 'Outgoing')
                                item.isRead(true);
                            activityItems.add(item, key);
                            return item;
                        }
                        //#endregion
                        //#region conv logs
                        function attachConvLog(log) {
                            convlogs.push(log);
                            var props = {
                                Messaging: wasChatActive,
                                Audio: wasAudioActive,
                                Video: wasVideoActive,
                                ApplicationSharing: wasSharingActive,
                                DataCollaboration: wasCollabActive
                            };
                            for (var name_12 in props)
                                if ((log.modalities() || []).indexOf(name_12) >= 0)
                                    props[name_12].set(true);
                        }
                        // Pulls a few messages from conv logs associated with this conversation.
                        function fetchLogs() {
                            // check if an audio transcript has been added already
                            function missingAudioItem(audiolog, type) {
                                var items = self.historyService.activityItems();
                                // iterate by ascending order of timestamp
                                for (var i = 0; i < items.length; i++) {
                                    var item = items[i];
                                    if (item.type() == type && item.direction() == audiolog.direction()) {
                                        var d = +item.timestamp() - +audiolog.timestamp();
                                        if (d == 0) {
                                            // exact match: do not add again
                                            return false;
                                        }
                                        else if (d > 0) {
                                            // locally added items do not have the sender field
                                            if (!item.sender && d < 60000) {
                                                // there is already an item added locally of
                                                // the same type, direction, and with timestamp
                                                // no later than 60 seconds
                                                return false;
                                            }
                                            // if no match so far, cannot find a better match
                                            // in the ordered collection
                                            break;
                                        }
                                    }
                                }
                                return true;
                            }
                            // check if a message has been added already
                            function missingMessage(message) {
                                // if one archived conversation was a continuation of another,
                                // they will have the same set of messages in the beginning
                                for (var _i = 0, _a = activityItems(); _i < _a.length; _i++) {
                                    var item = _a[_i];
                                    if (item.type() != 'TextMessage')
                                        continue;
                                    var m = item;
                                    // if a message is first received, then archived and pulled from the archive,
                                    // then the message from the archive will have same text, but different html
                                    // representation
                                    if (m.text() == message.text() && m.direction() == message.direction())
                                        return false;
                                }
                                return true;
                            }
                            // the order in which conv logs are pulled doesn't matter:
                            // transcripts will be sorted by timestamp anyway
                            var tasks = convlogs.map(function (log) {
                                return log.conversationLogTranscripts.conversationLogTranscript.get().then(function (transcripts) {
                                    for (var _i = 0, transcripts_1 = transcripts; _i < transcripts_1.length; _i++) {
                                        var transcript = transcripts_1[_i];
                                        var time = transcript.timeStamp();
                                        var href_3 = transcript.contact.href();
                                        if (clt.test('AudioLog')) {
                                            var status_3 = transcript.audioTranscript.status();
                                            // check if this is an audio transcript
                                            if (status_3) {
                                                var type = status_3 == 'Ended' ? 'CallEnded' :
                                                    status_3 == 'Connected' ? 'CallStarted' : '';
                                                var audiolog = new Internal.ActivityItem(type, null, {
                                                    direction: Property.readonly(log.direction()),
                                                    duration: Property.readonly(+transcript.audioTranscript.duration() || null),
                                                    timestamp: Property.readonly(time),
                                                    sender: href_3 ? contactManager.get(href_3) : me
                                                });
                                                if (missingAudioItem(audiolog, type)) {
                                                    activityItems.add(audiolog);
                                                    audiolog.isRead(true);
                                                }
                                            }
                                        }
                                        if (clt.test('MessageLog')) {
                                            var messageTranscript = transcript.messageTranscript;
                                            var html = messageTranscript.htmlMessage.href();
                                            var text = messageTranscript.plainMessage.href();
                                            // check if this is a message transcript
                                            if (html || text) {
                                                var message = new Internal.Message({
                                                    ucwa: ucwa,
                                                    sender: href_3 ? contactManager.get(href_3) : me,
                                                    participants: participants.asReadOnly(),
                                                    time: time,
                                                    text: text,
                                                    // some clients have a little idea about html syntax and can write something like this:
                                                    // <span style="font-family:" SegoeUI?,sans-serif;color:black;?="">...</span>
                                                    html: (html || '').replace(/style="[^"]+"[^"]+""/img, ''),
                                                    direction: href_3 ? 'Incoming' : 'Outgoing'
                                                });
                                                // incoming messages are considered to be unread by default
                                                if (missingMessage(message))
                                                    addMessageActivityItem(message).isRead(true);
                                            }
                                        }
                                    }
                                }).catch(); // if this task fails, don't cancel other tasks
                            });
                            convlogs.length = 0; // don't pull the same logs twice - it's a very expensive operation
                            return Promise.all(tasks).then(function () { });
                        }
                        //#endregion
                        //#region createParticipant
                        /** this is the only function that should be called internally to
                            create participants (both self and remote) */
                        function createParticipant(options) {
                            extend(options, {
                                ucwa: ucwa,
                                tm: tm,
                                contactManager: contactManager,
                                inConference: isConference.asReadOnly()
                            });
                            var p = new Internal.Participant(options), pvideoState = Property(), remoteEnabled = Property({ value: false });
                            var selfEnabled;
                            var dfdShow, dfdRemove, dfdShowRet, dfdRemoveRet;
                            // show or remove participant video
                            function participantVideo(val) {
                                // serialize and debounce turning participant video on/off
                                if (val) {
                                    if (!dfdShow) {
                                        var promise = dfdRemove ? dfdRemove : Promise.resolve();
                                        dfdShowRet = dfdShow = promise.then(function () {
                                            return avm.showParticipantVideo(p);
                                        }).then(function () { return val; });
                                        dfdShow.finally(function () {
                                            dfdShow = null;
                                        });
                                    }
                                    return dfdShowRet;
                                }
                                else {
                                    if (!dfdRemove) {
                                        var promise = dfdShow ? dfdShow : Promise.resolve();
                                        dfdRemoveRet = dfdRemove = promise.then(function () {
                                            return avm.removeParticipantVideo(p);
                                        }).then(function () { return val; });
                                        dfdRemove.finally(function () {
                                            dfdRemove = null;
                                        });
                                    }
                                    return dfdRemoveRet;
                                }
                            }
                            function isMultiViewEnabled() {
                                return avm && avm.videoMode() != 'ActiveSpeaker';
                            }
                            // if AV is present in this SDK version
                            if (p.video.channels(0)) {
                                if (options.isLocal) {
                                    selfEnabled = p.video.state.map(function (v) { return v == Internal.Modality.State.Connected; });
                                    p.video.channels(0).isStarted = Property({
                                        value: false,
                                        set: Command(participantVideo, selfEnabled)
                                    });
                                }
                                else {
                                    // conversion from a jCafe.Property to an internal Property, so that Property.observe could be used
                                    p.video.state.changed(function (v) { return pvideoState(v); });
                                    // videoChanel.isStarted.set should be enabled for a remote participant only in a conference 
                                    // on a platform that supports multi-view
                                    Property.observe([isConferencing, pvideoState], function (isc, pvs) { return remoteEnabled(isMultiViewEnabled() && isc && pvs == Internal.Modality.State.Connected); });
                                    p.video.channels(0).isStarted = Property({
                                        value: false,
                                        set: Command(participantVideo, remoteEnabled)
                                    });
                                }
                            }
                            return p;
                        }
                        //#endregion
                        function getInvitationContext() {
                            if (rInvitation && rInvitation.rel == 'onlineMeetingInvitation') {
                                // online meeting invitations don't have the customContent field because adding something like
                                // this supposedly breaks lync desktop. To work around this ucwa passes any context (not in
                                // the datauri format) in the onlineMeetingInvitation's subject field.
                                var context_1 = ConstProperty(rInvitation.get('subject', ''));
                                context_1.type = ConstProperty(void 0);
                                return context_1;
                            }
                            else {
                                var href = rInvitation && rInvitation.relatedHref('customContent');
                                var context, dataUri = DataUri(href || 'data:,');
                                context = ConstProperty(dataUri.mime === 'text/json' || dataUri.mime === 'application/json' ?
                                    JSON.parse(dataUri.data) : dataUri.data);
                                context.type = ConstProperty(dataUri.mime);
                                return context;
                            }
                        }
                        function restoreParticipants(rParticipants) {
                            rParticipants = rParticipants || ucwa.find(function (r) {
                                return r.rel == 'participant' &&
                                    r.hasLink('conversation') &&
                                    r.link('conversation').href == rConversation.href;
                            });
                            rParticipants.forEach(function (rParticipant) {
                                if (rParticipant.get('local', false))
                                    pLocalParticipantHref(rParticipant.href);
                                else
                                    resolveParticipant(rParticipant.href, rParticipant.get('name', void 0));
                            });
                        }
                        function restoreMeeting() {
                            if (rConversation.hasLink('onlineMeeting')) {
                                self.meeting = new Internal.OnlineMeeting({
                                    ucwa: ucwa,
                                    rMeeting: ucwa.get(rConversation.link('onlineMeeting').href),
                                    conversation: self,
                                    contactManager: contactManager
                                });
                            }
                        }
                        function restoreExtensions() {
                            var rExtensions = ucwa.get({ rel: 'conversationExtensions' }, null);
                            if (rExtensions && rConversation.hasLink('conversationExtensions')
                                && rConversation.link('conversationExtensions').href == rExtensions.href
                                && rExtensions.hasLink('conversationExtension')) {
                                updateExtensions(rExtensions.links('conversationExtension').map(function (r) { return r.href; }));
                            }
                        }
                        function updateExtensions(extensionHrefs) {
                            foreach(extensionHrefs, function (href) {
                                var idx = extensions.index(href);
                                if (idx < 0 || idx == void 0) {
                                    // only add those that are new. Resource updated events will take care of existing items.
                                    var ce = new Internal.ConversationExtension({
                                        ucwa: ucwa,
                                        rExtension: ucwa.get(href),
                                        tm: tm
                                    });
                                    extensions.add(ce, href);
                                }
                            });
                        }
                        function restoreCreator() {
                            var rInvitations = ucwa.find(function (r) {
                                return /Invitation$/.test(r.rel) &&
                                    r.hasLink('conversation') &&
                                    r.get('direction') == 'Incoming' &&
                                    r.link('conversation').href == rConversation.href;
                            });
                            return rInvitations.length > 0 ?
                                participants(0).person :
                                self.selfParticipant.person;
                        }
                        function resetThreadId() {
                            var oldThreadId = threadId();
                            threadId.set(new Internal.ThreadId + '');
                            var activeModalities = [];
                            for (var m in self.activeModalities) {
                                if (self.activeModalities[m]())
                                    activeModalities.push(m);
                            }
                            tm && tm.record(Web.TelemetryEvent.Conversation, {
                                action: 'reset_thread_id',
                                threadId: oldThreadId,
                                newThreadId: threadId(),
                                type: isConference() ? 'conf' : 'p2p',
                                modalities: JSON.stringify(activeModalities)
                            });
                        }
                        // Used by different modalities to identify the error returned when the server
                        // rejects a request to start the modality due to the threadId being too long
                        function isThreadIdRejectedError(err) {
                            return err && err.rsp && err.rsp.status == 400 &&
                                err.rsp.data && err.rsp.data.subcode == 'ParameterValidationFailure' &&
                                err.rsp.data.parameters && err.rsp.data.parameters[0] &&
                                err.rsp.data.parameters[0].name == 'threadId';
                        }
                        // We need to expose this function internally so that when app is restored
                        // and we refresh our collection of conversations, we perform the necessary
                        // cleanup of conversations that might have become disconnected without us
                        // receiving the expected 'deleted' events
                        function forceDisconnectConversation(reason) {
                            onConversationDeleted(reason);
                            isChatActive(false, reason);
                            isAudioActive(false, reason);
                            isVideoActive(false, reason);
                            isSharingActive(false, reason);
                            isCollabActive(false, reason);
                            canAcknowledge(false, reason);
                            self.selfParticipant.reset(reason);
                            for (var _i = 0, _a = participants(); _i < _a.length; _i++) {
                                var p = _a[_i];
                                p.reset(reason);
                            }
                        }
                        function onConversationDeleted(reason) {
                            self[Internal.sHref] = null;
                            href = null;
                            rConversation = null;
                            rInvitation = null;
                            // next time if the conversation object is used to continue the conversation,
                            // the threadId for that continued conversation must be derived in a special
                            // way; however this doesn't mean that the derived threadId will be used: if
                            // shortly after the conversation is ended, an incoming invitation from the
                            // same person or to the same conference arrives, the incoming threadId will
                            // replace this derived id
                            try {
                                var t = new Internal.ThreadId(threadId());
                                t.push(); // derive a threadId for the next conversation
                                threadId.set(t + '');
                            }
                            catch (e) {
                            }
                            // the participant href contains the conversation id, so
                            // it becomes invalid once the conversation is gone
                            for (var _i = 0, _a = participants(); _i < _a.length; _i++) {
                                var p = _a[_i];
                                participantHrefs.get(p).set(null);
                            }
                            // when leaving a meeting we remove all remote participants
                            if (isConference())
                                participants.empty();
                            // setting to undefined initially before we get the real count from ucwa
                            // would still fail the comparison with this value
                            participantCountOnJoin(void 0);
                            participantCount(0);
                            delete self.meeting;
                            changed.fire();
                            state(Conversation.State.Disconnected, reason);
                            isIncoming = false;
                        }
                        /** handles conversation resource updates and resource deletion */
                        function setResource(r) {
                            href = r.href;
                            rConversation = r;
                            setHiddenProperty(self, Internal.sHref, href);
                            rConversation.deleted(onConversationDeleted);
                            rConversation.updated(function () {
                                function update(attr, prop, excluded) {
                                    // if the property isn't available in rel=conversation,
                                    // do not change the corresponding model property
                                    if (rConversation.has(attr) && !(excluded && rConversation.get(attr) == excluded))
                                        prop(disableHtmlInText('' + rConversation.get(attr)));
                                }
                                update('state', state, 'Disconnected');
                                update('importance', priority);
                                update('subject', subject);
                            });
                            rConversation.updated(function () {
                                var modalities = rConversation.get('activeModalities', []);
                                isChatActive(indexOf(modalities, 'Messaging') >= 0);
                                isAudioActive(indexOf(modalities, 'Audio') >= 0);
                                isVideoActive(indexOf(modalities, 'Video') >= 0);
                                isSharingActive(indexOf(modalities, 'ApplicationSharing') >= 0);
                                isCollabActive(indexOf(modalities, 'DataCollaboration') >= 0);
                            });
                            rConversation.updated(function () {
                                canAcknowledge(rConversation.hasLink('userAcknowledged'));
                            });
                            // initial participant count in meetings
                            var subPCountOnJoin = rConversation.updated(function () {
                                if (rConversation.has('participantCount'))
                                    participantCountOnJoin(+rConversation.get('participantCount'));
                            });
                            // if we start a new adhoc meeting and immediately invite participants 
                            // (by creating a new conversation, adding participants and starting 
                            // any conversation service), rConversation.participantCount will take the
                            // initial count of 1 for local participant and then will be updated when
                            // some of the added participants join. We need to keep the initial value 
                            // and ignore subsequent updates. The check for 'adhoc' uri works because
                            // uri is updated by "onlineMeetingInvitation added" event which always
                            // precedes "conversation added". Note that later "onlineMeetingInvitation
                            // updated" event will change uri to the real meeting uri.
                            participantCountOnJoin.once(function (v) { return v > 0 && (uri() == 'adhoc' || !uri()); }, function () { return subPCountOnJoin.dispose(); });
                            pactivityTimeoutExpired(false);
                            sleep(10).then(function () { return pactivityTimeoutExpired(true); });
                        }
                        // participant-related events
                        ucwa.event(function (event) {
                            var sender = event.sender;
                            var target = event.target;
                            var context = event['in'];
                            if (sender.href == href && /^(localParticipant|participant)$/.test(target.rel)) {
                                // it's necessary to check the presence of the "in" property, because
                                // if in.rel = "typingParticipants" then the event means that a
                                // participant started or stopped typing, but is still in the
                                // conversation
                                if (!context) {
                                    if (event.type == 'deleted') {
                                        // in a 1:1 conversation the remote participant must remain in the collection 
                                        // but switch to the "disconnected" state which is implemented in the 
                                        // Participant model; participants who left the meeting are deleted
                                        if (isConferencing() && target.rel == 'participant') {
                                            // no need to null the entry in participantHrefs weak map because the value
                                            // (href) in that map is contained in the key (participant), so deleting the 
                                            // participant would delete the map entry. If we do it anyway p[sHref]
                                            // will be nulled and we won't be able to find participant for removal below.
                                            Task.run(function () {
                                                return avm[Internal.sInternal].onParticipantDeleted(event);
                                            }).finally(function () {
                                                var n = participants.removeAll(function (p) { return p[Internal.sHref] == target.href; });
                                                if (n == 0) {
                                                }
                                            });
                                        }
                                    }
                                    else if (event.type == 'added') {
                                        participantCount.inc();
                                        if (target.rel == 'localParticipant') {
                                            pLocalParticipantHref(target.href);
                                        }
                                        else {
                                            // if "participant added" arrives without the "title" attribute, sip uri
                                            // can be extracted from the href to let the UI display something meaningful
                                            var sipuri = /\/(\w+@\w+\.\w+)$/.exec(target.href);
                                            resolveParticipant(target.href, target.title || sipuri && sipuri[1]);
                                        }
                                    }
                                }
                                else if (event.type == 'added' && context.rel == 'lobby') {
                                    // if a participant in lobby event is added, the participant must be in this 
                                    // conversation already, and its state should be updated to 'InLobby'.
                                    var participant = getParticipant(target.href);
                                    participant[Internal.sInternal].state('InLobby');
                                }
                            }
                        });
                        // onlineMeeting
                        ucwa.event(function (event) {
                            var target = event.target;
                            var context = event['in'] || {};
                            // if in a peer to peer conversation the remote participant adds
                            // another participant to escalate the conversation to the multiparty
                            // mode, this participant receives a bunch of events with two among them:
                            //
                            //      conversation updated - rel=conversation.state becomes "Conferenced"
                            //      onlineMeeting added in conversation - rel=conversation/rel=onlineMeeting appears
                            //
                            if (event.type == 'added' && target.rel == 'onlineMeeting' && context.href == href) {
                                // if self.meeting is already there, then the conversation model
                                // was created to react to an onlineMeetingInvitation event, so
                                // no need to recreate it
                                if (!self.meeting) {
                                    // TODO: use a sourced model here instead of replacing the member
                                    self.meeting = new Internal.OnlineMeeting({
                                        ucwa: ucwa,
                                        rMeeting: event.resource,
                                        conversation: self,
                                        contactManager: contactManager
                                    });
                                    // TODO: use a sourced model here instead of replacing the member
                                    self.creator = self.meeting.creator;
                                    self.meeting.uri.changed(uri);
                                    changed.fire();
                                }
                            }
                        });
                        ucwa.event(function (event) {
                            // after an onlineMeetingInvitation is completed, the conversation
                            // resource is not updated promptly (possibly due to a UCWA bug).
                            // This would cause the 'userAcknowledged' link not to appear in
                            // the auto-accept scenario; so we need to fetch the conversation
                            // resource explicitly in order to correctly enable/disable the
                            // acknowledge command
                            if (event.type == 'completed' && event.target.rel == 'onlineMeetingInvitation' &&
                                event.status == 'Success' && event.resource.link('conversation').href == href)
                                ucwa.send('GET', href);
                        });
                        // extracts rel=conversation href
                        ucwa.event(function (event) {
                            var resource = event.resource;
                            // for outgoing conversations the client specifies threadId
                            // and the server sends the href of the created "conversation"
                            // resource
                            if (resource && resource.rel == 'conversation' && resource.get('threadId', '') == threadId() && !rConversation)
                                setResource(resource);
                        });
                        // merges incoming invitations with the same threadId
                        ucwa.event(function (event) {
                            var resource = event.resource;
                            if (!href && event.type == 'started' && resource.get('threadId', '') == threadId() &&
                                /Invitation$/.test(resource.rel) && resource.get('direction', '') == 'Incoming')
                                processInvitation(resource);
                        });
                        // participantAudio/participantVideo
                        ucwa.event(function (event) {
                            var sender = event.sender;
                            var target = event.target;
                            var context = event['in'] || {};
                            // in meetings we receive the participantAudio/Video events even if we don't have AudioVideo modality (we
                            // hooked up messaging only). After we add A/V we won't get these events again. Moreover, even if we join
                            // a meeting with A/V right away, 'participantAudio/Video added' events for participants that are already
                            // in the meeting are fired before we even issued an AV invitation. So we need to track MSIs for such
                            // participants here.
                            if (sender.href == href && isConferencing() && context.rel == 'participant' && /^participant(Audio|Video)$/.test(target.rel)) {
                                var participant = getParticipant(context.href);
                                if (participant) {
                                    // if video is on, a deleted event should be handled by AVModality; otherwise AVModality
                                    // won't be able to take this participant out of the media roster because by the
                                    // time it has a chance to process this event the participant media source ids
                                    // will have already been reset by this handler
                                    if (event.type == 'added' || event.type == 'updated' || !isVideoActive())
                                        participant[Internal.sInternal].setMediaSourceId(event);
                                    var modalityState = event.type == 'deleted' ?
                                        Internal.Modality.State.Disconnected :
                                        Internal.Modality.State.Connected;
                                    if (target.rel == 'participantAudio')
                                        participant[Internal.sInternal].audioState(modalityState);
                                    else
                                        participant[Internal.sInternal].videoState(modalityState);
                                }
                            }
                        });
                        // conversationExtension
                        ucwa.event(function (event) {
                            var sender = event.sender;
                            var target = event.target;
                            var resource = event.resource;
                            if (sender.href == href && target.rel == 'conversationExtension') {
                                switch (event.type) {
                                    case 'added':
                                        var ce = new Internal.ConversationExtension({
                                            ucwa: ucwa,
                                            rExtension: resource,
                                            tm: tm
                                        });
                                        extensions.add(ce, target.href);
                                        tm && tm.record(Web.TelemetryEvent.ConversationExtension, {
                                            action: 'ucwa_added'
                                        });
                                        break;
                                    case 'deleted':
                                        extensions.remove(target.href);
                                        break;
                                }
                            }
                        });
                        // once the conference is joined, remove the inviter if it's not in the list
                        state.when('Conferenced', function (reason, prev) {
                            if (isIncoming)
                                syncParticipants();
                        });
                        function getParticipant(href) {
                            return find(participants(), function (p) { return p[Internal.sHref] == href; });
                        }
                        //#region resolveParticipant
                        /**
                         * For a given participant href adds a new participant model to the collection if it wasn't
                         * there or matches an existing participant model created from a person model or a SIP URI
                         * to the given href.
                         */
                        function resolveParticipant(href, name) {
                            return Task.run(function () {
                                // Find unresolved participants, i.e. those that were created based on a person model 
                                // or a SIP URI and thus don't have an href. A participant in a disconnected 1:1
                                // conversation becomes an unresolved participant as well, because his href is nulled
                                // when the conversation is disconnected (terminated).  
                                var locals = {}; // indexed by /contact.href or SIP URI
                                for (var _i = 0, _a = participants(); _i < _a.length; _i++) {
                                    var p = _a[_i];
                                    // First check if the participant already exists in the collection.
                                    // One common scenario when this "merging" happens is: messagingInvitation/from
                                    // points to a rel=participant which is immediately added to the collection, then
                                    // UCWA sends a `participant added` event for the same participant, so it gets merged.
                                    if (p[Internal.sHref] == href)
                                        return p;
                                    // collect unresolved participants
                                    if (!p[Internal.sHref]) {
                                        var cHref = p.person[Internal.sHref];
                                        var cUri = p.person.id();
                                        assert(cHref || cUri, 'either /contact.href or uri must be known');
                                        locals[cHref || cUri.toLowerCase()] = p;
                                    }
                                }
                                // If no participants were added to the conversation by this client there is no
                                // need for getting the contact href of this participant to find the matching
                                // Participant model and we can avoid one extra GET per participant which would
                                // be nice when we join a meeting with many participants.
                                if (size(locals) == 0)
                                    return null;
                                // It's just a guess to avoid fetching rel=participant: if it's a p2p conversation,
                                // the only participant in the collection must be the one who the `participant added`
                                // event is targeting at.
                                if (participants.size() == 1 && !isConference())
                                    return participants(0);
                                // In the worst case we don't know which of the locally added participants
                                // corresponds to the `participant added` event and hence we need to get
                                // the /contact href or /participant.uri to find it.
                                var notfound = {};
                                function resolve() {
                                    var r = ucwa.get(href); // rel=participant
                                    var link = r.hasLink('contact') && r.link('contact');
                                    var uri = r.has('uri') && r.get('uri') || '';
                                    var p = link && locals[link.href] || locals[uri.toLowerCase()];
                                    if (p)
                                        return p;
                                    if (link && uri)
                                        throw notfound;
                                }
                                return Task.run(function () {
                                    return resolve() || ucwa.send('GET', href).then(resolve);
                                }).catch(function (err) {
                                    if (err === notfound)
                                        return null;
                                    throw err;
                                });
                            }).then(function (participant) {
                                if (participant) {
                                    // if the participant matching the given href is found
                                    // in the collection, update the href property given to
                                    // that participant object: this resolves href.get() which
                                    // the participant object is waiting for
                                    var pHref = participantHrefs.get(participant);
                                    pHref(href);
                                }
                                else {
                                    // if there is no matching participant object, create one:
                                    // this usually happens after a `participant added` event
                                    var pHRef = Property({ value: href });
                                    // local participant is not a member of the participants collection
                                    assert(!ucwa.get(href).get('local', false));
                                    participant = createParticipant({
                                        href: pHRef.asReadOnly(),
                                        name: name
                                    });
                                    participants.add(participant);
                                    participantHrefs.set(participant, pHRef);
                                }
                            });
                        }
                        //#endregion
                        //#region createParticipantFromPerson
                        /** this is the Conversation::createParticipant method */
                        function createParticipantFromPersonOrUri(person) {
                            var dfd = new Task();
                            dfd.promise.then(); // this task cannot be cancelled
                            var href = Property({
                                get: function () {
                                    if (href())
                                        return href();
                                    if (!dfd) {
                                        dfd = new Task();
                                        dfd.promise.then();
                                    }
                                    return dfd.promise;
                                }
                            });
                            href.changed(function (href) {
                                if (href && dfd) {
                                    dfd.resolve(href);
                                    dfd = null;
                                }
                            });
                            if (typeof person === 'object') {
                                // this assertion simply says that the given
                                // person model must be based on an existing
                                // rel=contact resource which is the case if
                                // the person was obtained from a search; this
                                // is needed to match the locally created participant
                                // model with "participant added" events from UCWA
                                assert(person[Internal.sHref], 'rel=contact is unknown');
                            }
                            var participant = createParticipant((_a = {
                                    href: href.asReadOnly()
                                },
                                _a[typeof person === 'object' ? 'person' : 'uri'] = person,
                                _a));
                            participantHrefs.set(participant, href);
                            return participant;
                            var _a;
                        }
                        //#endregion
                        //#region addParticipant
                        /** this is the Conversation::participants.add method */
                        function addParticipant(participant) {
                            if (typeof participant === 'string')
                                participant = createParticipantFromPersonOrUri(participant);
                            // ts@1.5.0-beta wasn't able to see that `participant` here is a Participant, not a string
                            if (typeof participant === 'object') {
                                if (!participantHrefs.has(participant))
                                    throw EInvalidArgument('participant', 'is not created by this conversation');
                                participants.add(participant);
                                if (state() == 'Connected' || state() == 'Conferenced')
                                    return inviteParticipant(participant);
                            }
                        }
                        //#endregion
                        //#region removeParticipant
                        /** this is the Conversation::participants.remove method */
                        function removeParticipant(participant /*: Participant | string*/) {
                            if (typeof participant === 'string') {
                                participant = find(participants(), function (p) {
                                    var lhs = (p.uri() + '').toLowerCase();
                                    var rhs = (participant + '').toLowerCase();
                                    return lhs == rhs;
                                });
                            }
                            // ts@1.5.0-beta wasn't able to see that `participant` here is a Participant, not a string
                            if (typeof participant === 'object') {
                                // check that the participant has been added to the collection
                                if (participants.contains(function (p) { return p === participant; })) {
                                    return Task.run(function () {
                                        // if the /participant/eject link is present,
                                        // the participant is in the conference                        
                                        if (participant.eject.enabled())
                                            return participant.eject();
                                        if (participant.state() == 'Disconnected')
                                            return;
                                        // TODO: what about p2p conversations?
                                        // TODO: removing a participant that is being added is not supported yet
                                        throw Exception('InvalidState');
                                    }).then(function () {
                                        participants.removeAll(function (p) { return p === participant; });
                                        participantHrefs.delete(participant);
                                    });
                                }
                            }
                            // either the participant was created by Conversation::createParticipant and hasn't
                            // been added or it was created by another conversation object; either way there is
                            // nothing to remove
                            throw Exception('InvalidState');
                        }
                        //#endregion
                        //#endregion
                        //#region inviteParticipantByUri
                        /**
                         * If the conversation was in the 1:1 (peer-to-peer) mode, it will be
                         * escalated to the 1:N (multiparty) mode. If the conversation was already
                         * in the 1:N mode, it will merely get a new participant.
                         *
                         * The new participant gets added to the Conversation::participants collection
                         * after the server notifies the client that the participant has been successfully
                         * invited.
                         *
                         * The endpoint that is adding a participant observes these events:
                         *
                         *      - participantInvitation started
                         *      - conversation updated (the state changes to "Conferenced")
                         *      - localParticipant updated (the role changes to "Leader")
                         *      - participant added in leaders (the participant denotes the local participant)
                         *      - onlineMeeting added in conversation
                         *      - participant added (the remote participant gets added)
                         *      - participantInvitation completed
                         *
                         * The participant being added observes these events:
                         *
                         *      - onlineMeetingInvitation started
                         *      - conversation added
                         *      - onlineMeeting added in conversation
                         *      - onlineMeetingInvitation completed
                         *
                         * The other participant that has been in the conversation observes these events:
                         *
                         *      - conversation updated (the state changes to "Conferenced")
                         *      - onlineMeeting added in conversation
                         *
                         */
                        function inviteParticipantByUri(uri) {
                            return ucwa.send('POST', rConversation.link('addParticipant').href, {
                                data: { to: uri }
                            }).then(function (rParticipantInvitation) {
                                return ucwa.wait({
                                    type: 'completed',
                                    target: { rel: 'participantInvitation', href: rParticipantInvitation.href }
                                });
                            }).then(function (event) {
                                if (event.status != 'Success')
                                    throw Internal.EInvitationFailed(event.reason);
                            });
                        }
                        //#endregion
                        //#region acknowledge
                        /**
                         * Acknowledge that the user is aware of an auto-accepted conversation.
                         *
                         */
                        function acknowledge() {
                            return ucwa.send('POST', rConversation.link('userAcknowledged').href);
                        }
                        //#endregion
                        //#region inviteParticipants (internal)
                        /**
                         * Reconciles participants added to the conversation by the local participant
                         * with the participants that are already in the conversation.
                         *
                         * Called by start() method of a conversation service.
                         *
                         * A typical scenario:
                         *    conv = convManager.createConversation();
                         *    conv.participants.add(p1);
                         *    conv.participants.add(p2);
                         *    conv.chatService.start();
                         *
                         * This results in a conversation model that represents a new online meeting. The
                         * participants p1 and p2 must be added to the conversation after the meeting
                         * is created.
                         *
                         *    conv.chatService.stop();
                         *    ....
                         *    conv.chatService.start();
                         *
                         * If the chat service is stopped participants are still in the conversation. When
                         * the chat service is restarted we should not add participants again.
                         *
                         */
                        function inviteParticipants() {
                            participants.each(function (p) {
                                // in an outgoing invitation different services may invoke this method multiple 
                                // times.In a group conversation each service's start method calls this helper, 
                                // for example when AV is started after chat or vice versa 
                                if (!p[Internal.sHref] && p.state() == 'Disconnected')
                                    inviteParticipant(p);
                            });
                        }
                        //#endregion
                        //#region inviteParticipant (internal)
                        /**
                         * Invites participants added to the conversation by the local participant
                         *
                         */
                        function inviteParticipant(p) {
                            assert(!p[Internal.sHref] && p.state() == 'Disconnected');
                            p[Internal.sInternal].state('Connecting');
                            return inviteParticipantByUri(p.person.id()).then(function (res) { return p[Internal.sInternal].state('Connected'); }, function (err) {
                                p[Internal.sInternal].state('Disconnected', err);
                                addParticipantActivityItem('ParticipantJoinFailed', p, err);
                                participants.removeAll(function (pcur) { return p === pcur; });
                                participantHrefs.delete(p);
                            });
                        }
                        //#endregion
                        // TODO: This method is legacy and not used anymore. It needs to be removed.
                        function addModality(type, options) {
                            check(type == Conversation.ModalityType.AppSharing, 'NotImplemented', { modality: type });
                            assert(!modalities(type), 'AlreadyExists', { item: type });
                            var modality;
                            options = options || {};
                            // every modality needs these objects
                            extend(options, {
                                ucwa: ucwa,
                                contactManager: contactManager,
                                participants: participants.asReadOnly(),
                                threadId: threadId(),
                                rConversation: rConversation,
                                me: me,
                                topic: subject(),
                                priority: priority()
                            });
                            if (options.resource) {
                                options.invitation = Internal.AppSharingInvitation({
                                    resource: options.resource,
                                    // TODO: remove once AppSharing is converted to a service
                                    createParticipant: function (resource) {
                                        return new Internal.Participant({
                                            href: resource.href,
                                            ucwa: ucwa,
                                            tm: tm,
                                            contactManager: contactManager,
                                            inConference: isConference.asReadOnly()
                                        });
                                    },
                                    ucwa: ucwa
                                });
                            }
                            options.mediaPlugin = mediaPlugin;
                            options.sharedResources = sharedResources;
                            modality = Internal.AppSharingModality(options);
                            modalities.add(modality, type);
                            modality.state.when('Disconnected', function () {
                                modalities.remove(type);
                            });
                            return modality;
                        }
                        function addMeeting() {
                            assert(!self.meeting);
                            self.meeting = new Internal.OnlineMeeting({
                                ucwa: ucwa,
                                threadId: threadId(),
                                subject: subject(),
                                priority: priority(),
                                conversation: self,
                                contactManager: contactManager
                            });
                            self.meeting.uri.changed(uri);
                            changed.fire();
                            return self.meeting;
                        }
                        //#region stop
                        /**
                         * After UCWA accepts all requests to stop the modalities,
                         * it also sends a "conversation deleted" event and this conversation
                         * model disappears from the conversations collection.
                         *
                         * @returns {Promise}
                         *
                         *      A task that resolves after all modalities report
                         *      that they are done with stopping themselves.
                         */
                        function stop() {
                            var tasks = [];
                            if (state() == Conversation.State.Disconnected)
                                return;
                            if (self.phoneAudioService)
                                tasks.push(self.phoneAudioService.stop().catch());
                            for (var _i = 0, _a = modalities(); _i < _a.length; _i++) {
                                var m = _a[_i];
                                tasks.push(m.stop().catch());
                            }
                            // ignore all errors from the .stop() call
                            tasks.push(chat.stop().catch());
                            if (self.audioService)
                                tasks.push(self.audioService.stop().catch());
                            return Task.waitAll(tasks).then(function () {
                                // DELETE rel=conversation to quit the conference;
                                // if the conversation is peer-to-peer, there is no harm in deleting
                                // the rel=conversation resource explicitly
                                if (rConversation)
                                    return ucwa.send('DELETE', rConversation.href);
                            });
                        }
                        //#endregion
                        function autoStartChatIfRequired() {
                            if ((!settings || settings.supportsMessaging !== false) &&
                                isConferencing() &&
                                self.meeting) {
                                // The meeting becomes Connected once we get an onlineMeetingInvitation completed event.
                                // At that time all tabs (instances) that did not accept the call set their audio service to Disconnected
                                // check that chat modality is still present, and this is the tab that accepted audio, before starting chat.
                                self.meeting.state.once(Internal.OnlineMeeting.State.Connected, function () {
                                    if (isChatActive() && self.chatService.start.enabled() && avm.state() != Internal.Modality.State.Disconnected)
                                        self.chatService.start();
                                });
                            }
                        }
                        function autoStartVideoIfRequired() {
                            if ((!settings || settings.supportsVideo !== false) &&
                                isConferencing() &&
                                self.meeting) {
                                // once meeting is connected check if video modality is present in the conversation and start video receive only.
                                // avm.state != Disconnected check is required to ensure that only the current tab starts video
                                self.meeting.state.once(Internal.OnlineMeeting.State.Connected, function () {
                                    if (isVideoActive() && self.videoService.start.enabled() && (avm.state() == Internal.Modality.State.Connected || avm.state() == Internal.Modality.State.Connecting)) {
                                        // videoservice.start getting enabled does not mean avm's start method is enabled
                                        // Both avm.audioState and avm.state should be Connected in order to start videoService so run on next loop.
                                        Web.setTimeout(function () {
                                            self.videoService.start({
                                                video: { direction: 'recvonly' }
                                            });
                                        }, 0);
                                    }
                                });
                            }
                        }
                        init();
                        return self;
                    }
                    return Conversation;
                }());
                Internal.Conversation = Conversation;
                (function (Conversation) {
                    var State;
                    (function (State) {
                        State.Created = 'Created';
                        State.Conferenced = 'Conferenced';
                        State.Conferencing = 'Conferencing';
                        State.Connected = 'Connected';
                        State.Connecting = 'Connecting';
                        State.Disconnected = 'Disconnected';
                        State.Disconnecting = 'Disconnecting';
                        State.Incoming = 'Incoming';
                        /** InLobby is a transient state while the client is joining an online
                            meeting anonymously. After an owner of the meeting admits the anonymous
                            participant, the state goes from InLobby to Conferenced. */
                        State.InLobby = 'InLobby';
                    })(State = Conversation.State || (Conversation.State = {}));
                    ;
                    var ModalityType;
                    (function (ModalityType) {
                        ModalityType.AppSharing = 'AppSharing';
                    })(ModalityType = Conversation.ModalityType || (Conversation.ModalityType = {}));
                })(Conversation = Internal.Conversation || (Internal.Conversation = {}));
            })(Internal = Model_27.Internal || (Model_27.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_28) {
            var Internal;
            (function (Internal) {
                'use strict';
                var find = Web.Utils.find;
                var hash = Web.Utils.hash;
                var assert = Web.Utils.assert;
                var extend = Web.Utils.extend;
                var filter = Web.Utils.filter;
                var isVoid = Web.Utils.isVoid;
                var foreach = Web.Utils.foreach;
                var isString = Web.Utils.isString;
                var debounced = Web.Utils.debounced;
                var decorated = Web.Utils.decorated;
                var getOption = Web.Utils.getOption;
                var isDictionary = Web.Utils.isDictionary;
                var isNotEmptyString = Web.Utils.isNotEmptyString;
                var disableHtmlInText = Web.Utils.disableHtmlInText;
                var Task = Web.Utils.Task;
                var Model = Web.Utils.Model;
                var Promise = Web.Utils.Promise;
                var Property = Web.Utils.Property;
                var Exception = Web.Utils.Exception;
                var Collection = Web.Utils.Collection;
                var NumProperty = Web.Utils.NumProperty;
                var AsyncCommand = Web.Utils.AsyncCommand;
                var ConstProperty = Web.Utils.ConstProperty;
                var EnabledCommand = Web.Utils.EnabledCommand;
                var ConversationsManager = (function () {
                    //#endregion
                    function ConversationsManager(_a) {
                        var ucwa = _a.ucwa, me = _a.me, gcs = _a.gcs, contactManager = _a.contactManager, convLogSettings = _a.convLogSettings, mediaPlugin = _a.mediaPlugin, devices = _a.devices, sharedResources = _a.sharedResources, guestName = _a.guestName, muteNdrForMeeting = _a.muteNdrForMeeting, tm = _a.tm, settings = _a.settings;
                        var _this = this;
                        /** indexed by Conversation::id */
                        var conversations = Collection({
                            subscribed: function () { return conversations.get(); },
                            // In some scenarios, the local conversations collection might not be in sync
                            // with active conversations of the UCWA application instance. So, one can fetch the
                            // active conversations by calling: conversations.get();
                            get: function () { return ucwa.send('GET', { rel: 'conversations' }).then(function (rActiveConversations) {
                                // TODO: if the conversation exists and its properties are not in
                                // sync with the corresponding server instance, we will need to update the local
                                // conversation object accordingly.
                                var isHrefKnown = function (href) { return conversations.contains(function (c) { return c[Internal.sHref] == href; }); };
                                var tasks = rActiveConversations.links('conversation').filter(function (link) {
                                    return !isHrefKnown(link.href);
                                }).map(function (link) {
                                    return ucwa.send('GET', link.href).then(function (r) {
                                        return Task.waitAll([
                                            ucwa.send('GET', r.link('localParticipant').href),
                                            ucwa.send('GET', r.link('messaging').href),
                                            r.hasLink('onlineMeeting') && ucwa.send('GET', r.link('onlineMeeting').href).then(function (r) {
                                                // there might be an existing conversation object with uri, but without href:
                                                // such a conversation represents an ongoing invitation that might get one of
                                                // hrefs returned by GET /conversations
                                                var uris = conversations()
                                                    .filter(function (c) { return !c[Internal.sHref] && !!c.uri(); })
                                                    .map(function (c) { return c.uri().toLowerCase(); });
                                                var uri = r.get('onlineMeetingUri', '').toLowerCase();
                                                if (uris.indexOf(uri) >= 0)
                                                    throw uri; // throw something as it'll be caught later anyway
                                            })
                                        ]);
                                    }).then(function () {
                                        // By this moment the conversation's href may have been resolved.
                                        // TODO: What happens if one of pending conversations get its href shortly
                                        // after this check is made? There will be a duplicate conversation object.
                                        if (isHrefKnown(link.href))
                                            throw link; // throw something as it'll be caught later anyway
                                        var conversation = createConversationModel({
                                            href: link.href,
                                            threadId: ucwa.get(link.href).get('threadId')
                                        });
                                        addConversation(conversation);
                                        return conversation.participants.get(); // GET /participants
                                    }).catch();
                                });
                                return Task.waitAll(tasks).then(function () { return null; }); // get() must return a Promise<void>
                            }); }
                        });
                        // /myOnlineMeetings/myOnlineMeeting[i] is the list of scheduled meetings:
                        // they have expiration time and other data like subject and attendees,
                        // but don't have timestamps when they start and end - this data is on EWS
                        var meetings = Internal.ObservableResource(ucwa, { rel: 'myOnlineMeetings' }, function ($) {
                            $.collection('myOnlineMeeting', [function (href) { return new Internal.MyOnlineMeeting(ucwa, { href: href, tm: tm }); }]);
                        }).myOnlineMeeting;
                        var isHistoryEnabled = (gcs ? gcs.conversationHistory : ConstProperty(null)).map(function (value) { return value == 'Enabled'; }, // the mapping function
                        function (// the mapping function
                            isEnabled) { return isEnabled ? 'Enabled' : 'Disabled'; }); // the unmapping function
                        var getMoreConversationsEnabled = Property({ value: true });
                        var unreadConversationsCount = NumProperty(0);
                        //#region initialization
                        function createConversationModel(options) {
                            extend(options, {
                                ucwa: ucwa,
                                me: me,
                                clt: pattern,
                                guestName: guestName,
                                sharedResources: sharedResources,
                                contactManager: contactManager,
                                mediaPlugin: mediaPlugin,
                                devices: devices,
                                muteNdrForMeeting: muteNdrForMeeting,
                                tm: tm,
                                settings: settings
                            });
                            return new Internal.Conversation(options);
                        }
                        ucwa.init().then(function () {
                            // If endpoint was asleep/unable to receive events, a conversation
                            // might have been disconnected/deleted without our knowledge. Calling
                            // get will correct the state of any deleted conversations.
                            ucwa.restored(function () {
                                disconnectStaleConversations();
                            });
                            var connected = ucwa.find({
                                rel: 'conversation'
                            }).filter(function (rConversation) {
                                return rConversation.get('state', '') in { Connected: 1, Conferenced: 1 };
                            });
                            foreach(connected, function (rConversation) {
                                var conversation = createConversationModel({
                                    href: rConversation.href,
                                    threadId: rConversation.get('threadId')
                                });
                                addConversation(conversation);
                            });
                        });
                        //#endregion
                        //#region internal methods
                        /** Query UCWA for active conversations and forcibly disconnect and reset the states of
                         *  any conversations in our collection which are not connected according to UCWA.
                         */
                        function disconnectStaleConversations() {
                            ucwa.send('GET', { rel: 'conversations' }).then(function (rActiveConversations) {
                                var activeConvHrefs = rActiveConversations.links('conversation').map(function (link) { return link.href; });
                                for (var _i = 0, _a = conversations(); _i < _a.length; _i++) {
                                    var c = _a[_i];
                                    if (activeConvHrefs.indexOf(c[Internal.sHref]) === -1 &&
                                        c.state() != Internal.Conversation.State.Disconnected &&
                                        c.state() != Internal.Conversation.State.Created) {
                                        var activeModalities = [];
                                        for (var m in c.activeModalities) {
                                            if (c.activeModalities[m]())
                                                activeModalities.push(m);
                                        }
                                        c.forceDisconnectConversation(Exception('NotFound'));
                                        tm && tm.record(Web.TelemetryEvent.Conversation, {
                                            action: 'force_disconnect',
                                            threadId: c.threadId(),
                                            type: c.isGroupConversation() ? 'conf' : 'p2p',
                                            modalities: JSON.stringify(activeModalities)
                                        });
                                    }
                                }
                            });
                        }
                        //#endregion
                        //#region public methods
                        /**
                        * Creates an empty conversation model.
                        *
                        * The created conversation model is empty: it has no modalities, no participants
                        * and it's not connected to the server. To make it connected, add modalities,
                        * start them and add participants:
                        *
                        *     var conversation = client.conversationsManager.createConversation();
                        *     var messaging = conversation.chatService;
                        *
                        *     conversation.participants.add("sip:johndoe@contoso.com");
                        *
                        *     messaging.start().then(() => {
                        *         console.log("messaging started");
                        *     });
                        *
                        * Right after the conversation is created, it appears in the `conversations` collection.
                        */
                        function createConversation(options) {
                            assert(isVoid(options) || isDictionary(options));
                            options = options || {};
                            var conversation = createConversationModel({
                                isConference: getOption(options, 'isConference', true),
                                threadId: options.threadId,
                                topic: options.topic,
                                priority: options.priority,
                                participants: options.participants // unit tests may give a collection mock
                            });
                            addConversation(conversation);
                            return conversation;
                        }
                        /** Either find an existing conversation model that represents an existing multiparty conversation
                            (meeting) or create a new model representing that meeting. */
                        function getConversationByUri(uri, args) {
                            assert(isNotEmptyString(uri));
                            var conversation = find(conversations(), function (conv) { return conv.uri() == uri; });
                            if (!conversation) {
                                var threadId = void 0;
                                if (args && args.wac && uri) {
                                    var timeStamp = args.timeStamp || new Web.Date();
                                    timeStamp.setHours(0, 0, 0, 0);
                                    threadId = new Internal.ThreadId(timeStamp, hash(uri)) + '';
                                }
                                conversation = createConversationModel({ uri: uri, threadId: threadId });
                                addConversation(conversation);
                            }
                            return conversation;
                        }
                        /** Either find an existing 1:1 conversation with this person or create a new one. */
                        function getConversation(person, options) {
                            assert(isVoid(options) || isDictionary(options));
                            options = options || {};
                            var convs = filter(conversations(), function (conv) {
                                // Multiparty conversations with one remote participant are excluded per interface contract:
                                // this method is supposed to return a 1:1 conversation only (the single Skype conversation).
                                // TODO: In a meeting a participant may have a person object without the contact href,
                                // or other unique properties so we would have to fetch the contact ref which would make this
                                // method async.
                                return conv.participants.size() == 1 && !conv.isGroupConversation() &&
                                    (isString(person) ? conv.participants(0).person.id().toLowerCase() === person.toLowerCase() :
                                        conv.participants(0).person[Internal.sHref] == person[Internal.sHref]);
                            });
                            // There may be multiple ongoing conversations with the same participant,
                            // so we return the first one.
                            if (convs.length > 0)
                                return convs[0];
                            var conversation = createConversationModel({
                                isConference: false,
                                threadId: options.threadId,
                                topic: options.topic,
                                priority: options.priority
                            });
                            addConversation(conversation);
                            var participant = conversation.createParticipant(person);
                            conversation.participants.add(participant);
                            // if a search is done that yields multiple results, and one of those Person
                            // objects is used as input to this method then that Person is not cached.
                            // This line adds that Person to the cache.
                            if (typeof person == 'object' && person[Internal.sHref])
                                contactManager.cacheTransientContact(person);
                            return conversation;
                        }
                        /**
                         * Pulls the list of active conversations from UCWA
                         * as well as conv logs for p2p conversations.
                         */
                        function getMoreConversations() {
                            if (convLogSettings) {
                                convLogsActive = true; // SWX invokes this method once it shows the UI
                                var r_1 = ucwa.get(gcs[Internal.sHref]);
                                // wait for the communication/conversationLogs link to appear
                                // and then sync the logs: the UI may invoke sync conversations
                                // before the link appears and it appears after the PUT /communication
                                // that enables conv history
                                r_1.updated(function fn() {
                                    if (!gcs.conversationLogs[Internal.sHref])
                                        return;
                                    r_1.updated.off(fn);
                                    syncConversationLogs();
                                });
                                if (convLogSettings.poll !== 0)
                                    Web.setInterval(syncConversationLogs, (convLogSettings.poll || 3600) * 1000);
                            }
                            return conversations.get().then(function () {
                                getMoreConversationsEnabled(false);
                            });
                        }
                        //#endregion public methods
                        //#region conversation logs
                        var syncedLogs = {};
                        var pattern = convLogSettings && new RegExp(convLogSettings.type || '^(Audio|Message)Log$');
                        // it's made debounced as it can be invoked from multiple places:
                        // by the "missedItems updated" event handler and by getMoreConversations
                        var syncConversationLogs = decorated([
                            debounced,
                            tm && tm.monitored(Web.TelemetryEvent.ConvLogs)
                        ], function () { return __awaiter(_this, void 0, Promise, function () {
                            var _this = this;
                            var href, err_1, tasks, links, logs, _loop_7, _i, _a, log_1;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        href = gcs.conversationLogs[Internal.sHref];
                                        href && ucwa.get(href).dirty(true);
                                        _b.label = 1;
                                    case 1:
                                        _b.trys.push([1, 3, , 7]);
                                        return [4 /*yield*/, gcs.conversationLogs.conversationLog.get()];
                                    case 2:
                                        _b.sent();
                                        return [3 /*break*/, 7];
                                    case 3:
                                        err_1 = _b.sent();
                                        if (!err_1 || err_1.code != 'RequestFailed' || err_1.rsp.status != 409)
                                            throw err_1;
                                        // if GET /conversationLogs fails with a 409, this may indicate that
                                        // the link has actually disappeared on UCWA side and the client needs
                                        // to resend the PUT /communication to re-enable the conv history
                                        ucwa.get(gcs[Internal.sHref]).dirty(true);
                                        return [4 /*yield*/, gcs.conversationHistory.get()];
                                    case 4:
                                        // the theory was that the conv history got disabled,
                                        // i.e. after a 404.ApplicationNotFound
                                        if ((_b.sent()) == 'Enabled')
                                            throw err_1;
                                        // re-enable it and sync the rel=communication resource
                                        return [4 /*yield*/, gcs.conversationHistory.set('Enabled')];
                                    case 5:
                                        // re-enable it and sync the rel=communication resource
                                        _b.sent();
                                        ucwa.get(href).dirty(true); // make sure the GET /conversationLogs is resent
                                        return [4 /*yield*/, gcs.conversationLogs.conversationLog.get()];
                                    case 6:
                                        _b.sent();
                                        return [3 /*break*/, 7];
                                    case 7:
                                        tasks = [];
                                        links = ucwa.get({ rel: 'conversationLogs' }).links('conversationLog');
                                        logs = links.slice(0, convLogSettings.size || 20).map(function (link) { return gcs.conversationLogs.conversationLog(link.href); });
                                        _loop_7 = function (log_1) {
                                            // skip already loaded logs
                                            if (syncedLogs[log_1[Internal.sHref]])
                                                return "continue";
                                            syncedLogs[log_1[Internal.sHref]] = true;
                                            var task = (function () { return __awaiter(_this, void 0, Promise, function () {
                                                var _a, _b, _c, recipients, r, href, p, threadId, conversation;
                                                return __generator(this, function (_d) {
                                                    switch (_d.label) {
                                                        case 0:
                                                            _b = (_a = pattern).test;
                                                            return [4 /*yield*/, log_1.type.get()];
                                                        case 1:
                                                            if (!_b.apply(_a, [_d.sent()]))
                                                                return [2 /*return*/];
                                                            return [4 /*yield*/, log_1.conversationLogRecipient.get()];
                                                        case 2:
                                                            recipients = _d.sent();
                                                            // p2p conversations only
                                                            if (recipients.length != 1)
                                                                return [2 /*return*/];
                                                            r = recipients[0];
                                                            return [4 /*yield*/, r.contact.href.get()];
                                                        case 3:
                                                            href = _d.sent();
                                                            p = contactManager.get(href, {
                                                                sipuri: r.sipUri(),
                                                                name: r.displayName(),
                                                                photo: r.contactPhoto.href()
                                                            });
                                                            threadId = new Internal.ThreadId(log_1.threadId());
                                                            threadId.push(); // once the conversation is started, it must use this extended threadId
                                                            conversation = getConversation(p, {
                                                                threadId: threadId + '',
                                                                // the desktop client sets subject to "Conversation with <...>" if the conversation didn't have a subject;
                                                                // also the SWX UI don't have room to render long title like "Missed conver..." so such subjects are removed
                                                                // to let SWX use the remote participant name as the subject
                                                                topic: (log_1.subject() || '').replace(/^(Missed )?Conversation with (.*)$/i, '')
                                                            });
                                                            conversation.attachConvLog(log_1);
                                                            return [2 /*return*/];
                                                    }
                                                });
                                            }); })();
                                            task.catch(function (err) {
                                                // report the failure and continue with other logs
                                                tm && tm.record(Web.TelemetryEvent.ConvLogs, {
                                                    result: 'failed',
                                                    reason: err,
                                                    href: log_1[Internal.sHref]
                                                });
                                            });
                                            tasks.push(task);
                                        };
                                        // reverse the list to put most recent logs at the top in UI
                                        for (_i = 0, _a = logs.reverse(); _i < _a.length; _i++) {
                                            log_1 = _a[_i];
                                            _loop_7(log_1);
                                        }
                                        return [4 /*yield*/, Promise.all(tasks)];
                                    case 8:
                                        _b.sent();
                                        return [2 /*return*/];
                                }
                            });
                        }); });
                        if (convLogSettings) {
                            var lastLogsCount = 0;
                            var convLogsActive = false; // it's set once the UI is shown
                            // sync logs every time missedItems.conversationLogsCount changes:
                            // this event arrives about half a minute after the conversation
                            // is closed and archived
                            ucwa.observe('missedItems updated', function (event) {
                                var r = event.resource;
                                var n = r.get('conversationLogsCount', 0);
                                if (n > lastLogsCount) {
                                    lastLogsCount = n;
                                    // pull the conv logs only if the UI is shown
                                    if (convLogsActive)
                                        syncConversationLogs();
                                }
                            });
                        }
                        //#endregion conversation logs
                        ucwa.event(function (event) {
                            var invitation = event.resource;
                            // Creates a conversation on the first incoming invitation. All subsequent invitations for other
                            // modalities should be handled by the respective services. For example, this handler creates a
                            // new conversation when an audio/video invitation is received. Later, when the remote party adds
                            // messaging, the messagingInvitation is not handled here but is processed by the conversation's
                            // chat service.
                            //
                            // In the multitab scenario this handler is used to react on an outgoing invitation sent by another
                            // tab: that tab starts a conversation, while other tabs receive the same sequence of events and
                            // create matching conversation objects.
                            if (event.type == 'started' && /^(messaging|audioVideo|phoneAudio|onlineMeeting|applicationSharing)Invitation$/.test(invitation.rel)) {
                                var threadId_1 = invitation.get('threadId') + '';
                                var isIncoming_1 = invitation.get('direction') == 'Incoming';
                                // this invitation could be initiated by an existing conversation object:
                                // if this is the case, such an invitation will be handled by that conversation
                                var conversation = find(conversations(), function (cv) { return cv.threadId() == threadId_1; });
                                // All p2p conversations with the same person should be merged into one.
                                // If it's a p2p incoming invitation, find a disconnected p2p conversation
                                // with the same person: if such a conversation exists, it can be used to
                                // handle this invitation. The point of this merging is to simplify UI.
                                if (!conversation) {
                                    var disconnected = conversations().filter(function (c) {
                                        return c.state() == Internal.Conversation.State.Disconnected ||
                                            c.state() == Internal.Conversation.State.Created;
                                    });
                                    if (invitation.rel == 'onlineMeetingInvitation') {
                                        var meetingUri_1 = invitation.get('onlineMeetingUri', '').toLowerCase();
                                        conversation = find(disconnected, function (cv) {
                                            return (cv.uri() + '').toLowerCase() == meetingUri_1;
                                        });
                                    }
                                    else {
                                        // find a disconnected p2p conversation with the same person
                                        conversation = find(disconnected, function (cv) {
                                            if (cv.isGroupConversation() || cv.participants.size() != 1)
                                                return false;
                                            var remote = cv.participants(0).person;
                                            if (isIncoming_1) {
                                                var from = ucwa.get(invitation.link('from').href); // rel=participant
                                                return (remote.id() + '').toLowerCase() == (from.get('uri') + '').toLowerCase() ||
                                                    remote[Internal.sHref] == from.link('contact').href;
                                            }
                                            else {
                                                // it's a disconnected conversation revived by an outgoing invitation
                                                // sent by another tab to this contact
                                                return remote[Internal.sHref] == invitation.link('to').href; // rel=contact
                                            }
                                        });
                                    }
                                    if (conversation)
                                        // processInvitation supports outgoing and incoming 1:1 and 1:N invitation
                                        conversation[Internal.sInternal].processInvitation(invitation);
                                }
                                if (!conversation) {
                                    conversation = createConversationModel({
                                        rInvitation: invitation,
                                        threadId: threadId_1,
                                        topic: disableHtmlInText(invitation.get('subject', '')),
                                        priority: invitation.get('importance', 'Normal')
                                    });
                                    addConversation(conversation);
                                }
                                // TODO: this is the update part that will go away once we have ScreenSharing service
                                if (invitation.rel == 'applicationSharingInvitation' && !Web.Settings.mediaAgent)
                                    conversation.addModality(Internal.Conversation.ModalityType.AppSharing, { resource: invitation });
                            }
                        });
                        function addConversation(conversation) {
                            if (!conversations(conversation.id()))
                                conversations.add(conversation, conversation.id());
                            conversation.historyService.unreadActivityItemsCount.changed(function () {
                                unreadConversationsCount(conversations().filter(function (conversation) {
                                    return conversation.historyService.unreadActivityItemsCount() > 0;
                                }).length);
                            });
                        }
                        function removeConversation(conversation) {
                            return conversation.leave().catch().then(function () { return conversations.remove(conversation.id()); });
                        }
                        // All these commands are enabled only when signed in.
                        // Some commands can be theoretically enabled any time,
                        // but then they will need a more sophisticated implementation.
                        return Model({
                            conversations: conversations.asWritable({
                                add: EnabledCommand(addConversation),
                                remove: EnabledCommand(removeConversation)
                            }),
                            unreadConversationsCount: unreadConversationsCount.asReadOnly(),
                            isHistoryEnabled: extend(isHistoryEnabled, { auto: Property.bool(true) }),
                            createConversation: EnabledCommand(createConversation),
                            getConversation: EnabledCommand(getConversation),
                            getConversationByUri: EnabledCommand(getConversationByUri),
                            getMoreConversations: AsyncCommand(debounced(getMoreConversations), getMoreConversationsEnabled),
                            syncConversationLogs: syncConversationLogs,
                            createMeeting: EnabledCommand(function () { return new Internal.MyOnlineMeeting(ucwa, { tm: tm }); }),
                            meetings: meetings.asReadOnly(),
                            createSearchQuery: EnabledCommand(function () { return new Internal.ConversationSearchQuery(conversations); })
                        });
                    }
                    return ConversationsManager;
                }());
                Internal.ConversationsManager = ConversationsManager;
            })(Internal = Model_28.Internal || (Model_28.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var timeStampToDate = Web.Utils.timeStampToDate;
                var DataUri = Web.Utils.DataUri;
                /**
                 * Wraps /communication into an observable model.
                 *
                 */
                var Communication = (function () {
                    function Communication(ucwa) {
                        // TODO: once ObservableResource becomes a class,
                        // this must be converted into a super(...) call
                        return Internal.ObservableResource(ucwa, { rel: 'communication' }, function ($) {
                            $.member('conversationLogs', function ($) {
                                $.collection('conversationLog', function ($) {
                                    $.collection('conversationLogRecipient', function ($) {
                                        $.property('sipUri');
                                        $.property('displayName');
                                        $.member('contact', function ($) {
                                            return $.property('href');
                                        });
                                        $.member('contactPhoto', function ($) {
                                            return $.property('href');
                                        });
                                    });
                                    $.member('conversationLogTranscripts', function ($) {
                                        $.collection('conversationLogTranscript', function ($) {
                                            $.member('audioTranscript', function ($) {
                                                $.property('status');
                                                $.property('duration');
                                            });
                                            $.member('messageTranscript', function ($) {
                                                $.member('htmlMessage', function ($) {
                                                    return $.property('href', function (href) { return DataUri(href).data; });
                                                });
                                                $.member('plainMessage', function ($) {
                                                    return $.property('href', function (href) { return DataUri(href).data; });
                                                });
                                            });
                                            $.member('contact', function ($) {
                                                return $.property('href');
                                            });
                                            $.property('timeStamp', timeStampToDate);
                                        });
                                    });
                                    $.property('type');
                                    $.property('subject');
                                    $.property('threadId');
                                    $.property('direction');
                                    $.property('modalities');
                                    $.property('creationTime', timeStampToDate);
                                    $.property('totalRecipientsCount');
                                });
                            });
                            $.property('conversationHistory');
                            $.property('audioPreference');
                            $.property('phoneNumber');
                            $.property('voipFallbackToPhoneAudioTimeOut');
                            $.command('joinOnlineMeeting');
                        });
                    }
                    return Communication;
                }());
                Internal.Communication = Communication;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            var clone = Utils.clone;
            var errorCategories = {
                InvalidSetup: {
                    identifier: 'InvalidSetup',
                    description: 'Please check with the administrator of your tenant.'
                },
                InternalError: {
                    identifier: 'InternalError',
                    description: 'An internal error occured. This may be a transient error. Please use exponential retry to try again. Stop retrying after 3 attempts.'
                },
                Unauthorized: {
                    identifier: 'Unauthorized',
                    description: 'The user is unauthorized. Make sure the user is authenticated with a valid access token before making the request.'
                }
            };
            var errorsByDiagCode = {
                /*
                X-Ms-Diagnostics code: 28000
                Reason string: User is not SIP enabled.
                */
                28000: {
                    code: 28000,
                    message: 'The user does not have a valid Skype for Business Online license assigned.',
                    category: errorCategories['InvalidSetup'].identifier
                },
                28001: {
                    code: 28001,
                    message: 'Internal error while processing Windows authentication or authorization.',
                    category: errorCategories['InternalError'].identifier
                },
                28032: {
                    code: 28032,
                    message: 'The web ticket is invalid.',
                    category: errorCategories['Unauthorized'].identifier
                },
                28033: {
                    code: 28033,
                    message: 'The web ticket has expired.',
                    category: errorCategories['Unauthorized'].identifier
                },
                28055: {
                    code: 28055,
                    message: 'The OAuth token is invalid.',
                    category: errorCategories['Unauthorized'].identifier
                },
                28056: {
                    code: 28056,
                    message: 'The OAuth token has expired.',
                    category: errorCategories['Unauthorized'].identifier
                },
                28072: {
                    code: 28072,
                    message: 'The ticket presented could not be verified, a new ticket is required.',
                    category: errorCategories['Unauthorized'].identifier
                },
                28077: {
                    code: 28077,
                    message: 'Invalid Audience in the web ticket.',
                    category: errorCategories['Unauthorized'].identifier
                },
                28081: {
                    code: 28081,
                    message: 'No user principal name is found in JWT security token.',
                    category: errorCategories['Unauthorized'].identifier
                }
            };
            var otherErrors = {
                1: {
                    code: 1,
                    message: 'The user appears to be homed on premise. Make sure to home the user online to use this service.',
                    category: errorCategories['InvalidSetup'].identifier
                }
            };
            Utils.errorMapper = {
                map: function (targetObject, request, response, tm) {
                    var mappedError = null;
                    if (!response || response.status < 400 || response.status === 401) {
                        return;
                    }
                    mappedError = attachErrorByDiagnosticCode(getDiagnosticsCode(response));
                    if (!mappedError) {
                        mappedError = isUserHomedOnPrem(request, response);
                    }
                    exposeError(mappedError, targetObject);
                    if (!mappedError) {
                        tm.record(Web.TelemetryEvent.UnmappedError, {
                            diagCode: getDiagnosticsCode(response),
                            diagHeader: response.headers && response.headers['X-Ms-Diagnostics'],
                            code: response.data && response.data.code,
                            subcode: response.data && response.data.subcode,
                            status: response.status
                        });
                    }
                }
            };
            function exposeError(mappedError, target) {
                if (mappedError) {
                    target.errorDetails = mappedError;
                }
            }
            function isUserHomedOnPrem(req, res) {
                var mappedError = null;
                if (res.status == 404 &&
                    // autodiscoverservice.svc/root/oauth/user fails with 404 when a homepool for a user
                    // exists  online but the user in question has not been migrated from onprem to online and can therefore
                    // not be found on the homepool yet.
                    req && /\/autodiscoverservice\.svc\/root\/oauth\/user/i.test(req.url)) {
                    mappedError = clone(otherErrors['1']);
                    mappedError.category = errorCategories[otherErrors['1'].category];
                }
                return mappedError;
            }
            function attachErrorByDiagnosticCode(diagCode) {
                var mappedError = null;
                if (diagCode) {
                    if (errorsByDiagCode[diagCode]) {
                        mappedError = clone(errorsByDiagCode[diagCode]);
                        mappedError.category = errorCategories[mappedError.category];
                    }
                }
                return mappedError;
            }
            function getDiagnosticsCode(res) {
                var diag = res.headers['X-Ms-Diagnostics'] || '';
                return parseInt(diag.split(';')[0], 10) || null;
            }
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="../utils/errorMapper.ts" />
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Auth;
        (function (Auth) {
            'use strict';
            var errorMapper = Web.Utils.errorMapper;
            Auth.customAuth = {
                wrap: function (originalAuth, tm) {
                    var wrappedAuth = function (req, send) {
                        var wrappedSend = function (req) {
                            return send(req).then(function (res) {
                                errorMapper.map(res, req, res, tm);
                                return res;
                            });
                        };
                        return originalAuth(req, wrappedSend);
                    };
                    return wrappedAuth;
                }
            };
        })(Auth = Web.Auth || (Web.Auth = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="RequestPriorities.ts" />
/// <reference path="ObservableResource.ts" />
/// <reference path="SignInManager.ts" />
/// <reference path="GeneralPolicies.ts" />
/// <reference path="Search.ts" />
/// <reference path="Group.ts" />
/// <reference path="RootGroup.ts" />
/// <reference path="PersonsAndGroupsManager.ts" />
/// <reference path="ContactManager.ts" />
/// <reference path="PresenceSubscription.ts" />
/// <reference path="PresenceSubscriptionManager.ts" />
/// <reference path="OnlineMeeting.ts" />
/// <reference path="MyOnlineMeeting.ts" />
/// <reference path="Message.ts" />
/// <reference path="ActivityItem.ts" />
/// <reference path="Person.ts" />
/// <reference path="MePerson.ts" />
/// <reference path="ChatService.ts" />
/// <reference path="Participant.ts" />
/// <reference path="Conversation.ts" />
/// <reference path="ConversationsManager.ts" />
/// <reference path="Communication.ts" />
/// <reference path="../auth/customAuth.ts" />
/// <reference path="../utils/errorMapper.ts" />
"use strict";
/// <reference path="../../spec/s4b.sdk/Application.d.ts"/>
/// <reference path="../../spec/int/Application.d.ts"/>
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_29) {
            var Internal;
            (function (Internal) {
                var guid = Web.Utils.guid;
                var keys = Web.Utils.keys;
                var hash = Web.Utils.hash;
                var async = Web.Utils.async;
                var sleep = Web.Utils.sleep;
                var extend = Web.Utils.extend;
                var indexOf = Web.Utils.indexOf;
                var getOption = Web.Utils.getOption;
                var debugInfo = Web.Utils.debug.debugInfo;
                var sha256Hash = Web.Utils.sha256Hash;
                var repeatAndExit = Web.Utils.repeatAndExit;
                var setHiddenProperty = Web.Utils.setHiddenProperty;
                var Model = Web.Utils.Model;
                var Symbol = Web.Utils.Symbol;
                var Command = Web.Utils.Command;
                var EnvInfo = Web.Utils.EnvInfo;
                var Property = Web.Utils.Property;
                var Exception = Web.Utils.Exception;
                var EnabledCommand = Web.Utils.EnabledCommand;
                var EInvalidArgument = Web.Utils.EInvalidArgument;
                var DisabledCommand = Web.Utils.DisabledCommand;
                var UCWA = Web.Stack.UCWA;
                var customAuth = Web.Auth.customAuth;
                var errorMapper = Web.Utils.errorMapper;
                /** application[sUCWA] = the UCWA stack for the app */
                var sUCWA = 'ucwa';
                /** window[sInstances] keeps the list of all created apps */
                var sInstances = Symbol('apps');
                /** application[sContactManager] = the contact manager */
                var sContactManager = Symbol('contactmanager');
                /**
                 * The root object in the object model.
                 *
                 * One instance of Application creates one UCWA endpoint that
                 * can sign in with its own credentials. The constructor
                 * is not a singleton as it is possible to create several
                 * UCWA endpoints in one web app and make them chat with
                 * each other via the UCWA protocol.
                 *
                 */
                var Application = (function () {
                    //#endregion
                    function Application(options) {
                        if (options === void 0) { options = {}; }
                        if (Web.ls.bp.ctor.get())
                            debugger;
                        var state = Property();
                        var settings = extend(options.settings, Web.ls.ctor.get());
                        var app = Model();
                        var ConversationsManagerCtor = options.ConversationsManager || Internal.ConversationsManager;
                        var telemetryManager = options.telemetryManager;
                        var tenantToken = settings.cafeTenantToken;
                        var muteNdrForMeeting = !!settings.muteNdrForMeeting;
                        var tm = new Web.TelemetryRecorder(telemetryManager, tenantToken, settings.telemetry === false ? { '*': {} } : settings.telemetry && settings.telemetry.disabled, settings.telemetry && settings.telemetry.ttt, settings.tzip_url || 'https://swx.cdn.skype.com/jLync/tzip/index.html');
                        var guestName = Property();
                        var sid = guid();
                        var isAnon; // set to true for either p2p anon or meetings anon
                        var wasReplayMessageEnabledForThisSession = false;
                        var appInitParams = options.initParams;
                        // a unit test may give a mock of the UCWA stack
                        var ucwa = options.ucwa || new UCWA({
                            tm: tm,
                            logs: settings.logs && settings.logs.ucwa
                        });
                        var dfdSignedIn;
                        var dfdSignedOut;
                        var conversationsManager;
                        debugInfo.api_key = settings.apiKey || appInitParams && appInitParams.apiKey;
                        if (tm && settings.apiKey)
                            tm.defaults.api_key = settings.apiKey;
                        debugInfo.sdk_session = sid;
                        debugInfo.correlation_ids = appInitParams && appInitParams.correlationIds || {};
                        if (tm) {
                            if (settings.ttt)
                                tm.defaults.ttt = true;
                            tm.defaults.sdk_session = sid;
                            // initParams are added through the sdk's bootstrapper code. SWX's bootstrapper doesn't pass in these values
                            // but SWX packages have their own telemetry manager so the initParams are added as defaults in there.
                            tm.addCorrelationIds(appInitParams);
                        }
                        if (settings.logs) {
                            if (settings.logs.saveConsole)
                                Web.Settings.saveConsole = settings.logs.saveConsole;
                            if (settings.logs.size)
                                Web.Settings.logSize = settings.logs.size;
                        }
                        // the idea of this if(...) is to detect the dev mode and
                        // enable the re-entrance check for Property::set(...) calls:
                        // it's costly, so it can't be enabled all the time
                        if (Web.Settings.logHttp)
                            Property.srcheck = true;
                        function init() {
                            state(Application.State.SignedOut);
                            app.suspended = ucwa.suspended;
                            // expose the UCWA stack to simplify debugging
                            // with the dev console, but make it impossible
                            // to use by other js code
                            setHiddenProperty(app, sUCWA, ucwa);
                            // eventually some of these settings might become a part of
                            // the external interface, but for now they remain internal
                            var gcs = new Internal.Communication(ucwa);
                            var me = new Internal.MePerson(ucwa, {
                                guestName: guestName.asReadOnly(),
                                supportsConferencing: gcs.joinOnlineMeeting.enabled.asReadOnly(),
                                reportMyActivityInterval: settings.reportMyActivityInterval,
                                sendActivityTelemetry: !!settings.sendActivityTelemetry,
                                meActiveChangedDelay: settings.meActiveChangedDelay,
                                preferredDesktopEndpoint: settings.pde,
                                tm: tm
                            });
                            var psm = new Internal.PresenceSubscriptionManager(ucwa, {
                                maxBatchSize: settings.presenceSubscriptionsBatchSize,
                                duration: settings.presenceSubscriptionDuration,
                                tm: tm
                            });
                            var contactManager = new Internal.ContactManager({
                                ucwa: ucwa,
                                psm: psm,
                                settings: settings.contactManager,
                                tm: tm
                            });
                            // setting hidden prop for debugging only
                            setHiddenProperty(app, sContactManager, contactManager);
                            var mediaPlugin = Internal.MediaPlugin && new Internal.MediaPlugin(ucwa, tm, settings);
                            var devices = Web.Media && Web.Media.useBrowserMedia() ?
                                Internal.WebRtcDevicesManager && new Internal.WebRtcDevicesManager(ucwa) :
                                Internal.PluginDevicesManager && new Internal.PluginDevicesManager({
                                    mediaPlugin: mediaPlugin,
                                    msi: settings['plugin'] && settings['plugin'].download && settings['plugin'].download.msi,
                                    pkg: settings['plugin'] && settings['plugin'].download && settings['plugin'].download.pkg,
                                    dmg: settings['plugin'] && settings['plugin'].download && settings['plugin'].download.dmg,
                                    tm: tm
                                });
                            var sharedResources = Internal.SharedResources && Internal.SharedResources(mediaPlugin);
                            var pgm = new Internal.PersonsAndGroupsManager({
                                ucwa: ucwa,
                                psm: psm,
                                contactmgr: contactManager,
                                remoteSearchResultsOnly: settings.remoteSearchResultsOnly,
                                me: me,
                                tm: tm,
                                settings: settings.pgm
                            });
                            conversationsManager = new ConversationsManagerCtor({
                                ucwa: ucwa,
                                me: me,
                                gcs: gcs,
                                guestName: guestName.asReadOnly(),
                                mediaPlugin: mediaPlugin,
                                contactManager: contactManager,
                                devices: devices,
                                sharedResources: sharedResources,
                                convLogSettings: settings.convLogSettings,
                                muteNdrForMeeting: muteNdrForMeeting,
                                tm: tm,
                                settings: settings
                            });
                            app.mediaPolicies = Internal.MediaPolicies && new Internal.MediaPolicies(ucwa);
                            app.personsAndGroupsManager = pgm;
                            app.conversationsManager = conversationsManager;
                            app.windows = sharedResources && sharedResources.windows;
                            app.monitors = sharedResources && sharedResources.monitors;
                            app.policies = new Internal.GeneralPolicies(ucwa);
                            app.devicesManager = devices;
                            app.connected = ucwa.connected;
                            app.collectOII = Property({
                                value: tm && tm.collectOII,
                                set: function (value) {
                                    // if there is no telemetry at all, let it fail
                                    tm.collectOII = value;
                                    return value;
                                }
                            });
                            state.when(Application.State.SignedIn, function () {
                                if (tm && settings.heartbeat) {
                                    Web.setInterval(function () {
                                        tm.record(Web.TelemetryEvent.Heartbeat);
                                    }, settings.heartbeat * 1000);
                                }
                                // if the event channel doesn't get connected in a minute...
                                Web.setTimeout(function () {
                                    if (!ucwa.connected()) {
                                        tm && tm.record(Web.TelemetryEvent.EventChannel, {
                                            result: 'timeout',
                                            timeout: 60,
                                            status: ucwa.ecstatus(),
                                            reason: ucwa.connected.reason
                                        });
                                    }
                                }, 60 * 1000);
                                // if the event channel doesn't get connected in 5 minutes...
                                Web.setTimeout(function () {
                                    if (!ucwa.connected()) {
                                        tm && tm.record(Web.TelemetryEvent.EventChannel, {
                                            result: 'timeout',
                                            timeout: 300,
                                            status: ucwa.ecstatus(),
                                            reason: ucwa.connected.reason
                                        });
                                    }
                                }, 300 * 1000);
                                ucwa.connected.when(true, function () {
                                    tm && tm.record(Web.TelemetryEvent.EventChannel, { result: 'connected' });
                                });
                                // .connected means connected to the event channel,
                                // so the stack can be signed in but disconnected
                                var sub = ucwa.connected.when(false, function (reason, wasConnected) {
                                    // right after sign in the stack may still be connecting
                                    if (state() !== Application.State.SigningOut && wasConnected) {
                                        tm && tm.record(Web.TelemetryEvent.EventChannel, { result: 'lost', state: state(), reason: reason });
                                        exposeErrorDetail(reason, settings.signIn, tm);
                                        state(Application.State.SignedOut, reason);
                                    }
                                });
                                ucwa.appDeleted.once(true, function (reason) {
                                    exposeErrorDetail(reason, settings.signIn, tm);
                                    state(Application.State.SignedOut, reason);
                                });
                                // publish the self presence and let others send IMs to this client
                                if (settings.events !== false)
                                    me.available(true);
                                if (tm) {
                                    // this is how the aria lib adds the EventInfo.Time field
                                    tm.defaults.signed_in_at = (new Web.Date).toISOString();
                                    me.id.changed(function (newVal, reason, oldVal) {
                                        newVal = /^sip(?:%3A|:)/i.test(newVal) ? newVal.substring(4) : newVal;
                                        tm.defaults.sdk_user_id = newVal ? sha256Hash(newVal) : void 0;
                                        // 'abc@contoso.com' => ['abc@contoso.com', 'abc', 'contoso.com']
                                        var parts = /([\w+-.%]+)@(.*)/i.exec(newVal);
                                        if (parts && parts.length == 3) {
                                            tm.defaults.sdk_user_alias = [parts[1], Web.TelemetryRecorder.PIIType.Identity];
                                            tm.defaults.sdk_user_domain = tm.oiiPropertyValue(parts[2]);
                                            debugInfo.sdk_user_domain = parts[2];
                                        }
                                    });
                                }
                                try {
                                    // There is a special anon join case when the server returns a conf id:
                                    //
                                    //  -> GET https://ext.vdomain.com:4443/platformservice/discover?anonymousMeetingJoinContext=psat%253deyJ0e...
                                    //  
                                    //  <- 200 OK
                                    //  
                                    //  { "rel": "ms:rtc:saas:discover",
                                    //    "conferenceId": "sip:ucapuser1@ucaptenant.com;gruu;opaque=app:conf:focus:id:<...>",
                                    //    "_links": {
                                    //      "self": { "href":"https://ext.vdomain.com:4443/platformservice/discover?anonymousMeetingJoinContext=psat%253deyJ0..." },
                                    //      "anonApplications": { "href": "https://ext.vdomain.com:4443/ucwa/psanon/v1/applications" } } }
                                    //
                                    var user = ucwa.get({ rel: 'ms:rtc:saas:discover' });
                                    var conf = user.get('conferenceId'); // conf SIP URI
                                    // create a conference object, but let the UI decide when to join it
                                    conversationsManager.getConversationByUri(conf);
                                }
                                catch (_) {
                                }
                                // ** TEMPORARY ** how fast conversation history can be enabled depends on whether replayMessage was enabled.
                                // if the command was enabled for this signin session then enable conv history only after configured time.
                                updateReplayMessageCommandState();
                                if (!settings.disableConversationHistory && !isAnon && settings.events !== false) {
                                    // the setting can be changed only when the stack is connected
                                    // to the server and when rel=communication has an etag value
                                    conversationsManager.isHistoryEnabled.set.enabled.once(true, function () {
                                        if (!conversationsManager.isHistoryEnabled.auto())
                                            return;
                                        var delay = wasReplayMessageEnabledForThisSession ? (settings.replayBot.convHistoryEnableDelay || 960) : 4.12;
                                        // If the PUT /communication is sent after POST /makeMeAvailable
                                        // and before the "communication updated" event with a new etag
                                        // value, the PUT will be rejected with a 412.PreconditionFailed.
                                        // This happens because the POST changes the etag once the server
                                        // gets the request, but the client remains unaware of the new etag
                                        // value until the "updated" event arrives.
                                        repeatAndExit(function (exit) {
                                            // without a delay an attempt to enable the conversation history
                                            // flag results in a cryptic error: 412 code=PreconditionFailed;
                                            // and a delay of 4.12 seconds seems to be good enough to fix it
                                            return sleep(delay).then(function () {
                                                delay *= 2;
                                                // unconditionally enable the conversation history feature:
                                                // this will also make UCWA auto-accept IM requests and archive
                                                // them in Exchange; otherwise if this is the only available
                                                // endpoint and it gets an IM request which is not accepted,
                                                // it gets auto-declined and not archived anywhere
                                                return conversationsManager.isHistoryEnabled.set(true).then(exit, function (err) {
                                                    // there is a subcode=PreconditionFailed field in the response body,
                                                    // but since the status code 412 already means that a precondition
                                                    // failed, the subcode is ignored
                                                    var is412 = err.code == 'RequestFailed' && err.rsp.status == 412;
                                                    if (!is412)
                                                        throw err;
                                                });
                                            });
                                        });
                                    });
                                }
                                state.once(Application.State.SignedOut, function (reason) {
                                    updateReplayMessageCommandState();
                                    devices && devices.uninit();
                                    mediaPlugin && mediaPlugin.uninitMedia();
                                    tm && delete tm.defaults.sdk_user_id;
                                    sub.dispose();
                                    ucwa.uninit(reason);
                                });
                            });
                        }
                        function defineCommand(states, fn) {
                            var enabled = Property();
                            var command = Command(fn, enabled);
                            state.changed(function (value) {
                                enabled(indexOf(states, value) >= 0);
                            });
                            return command;
                        }
                        function defineAsyncCommand(states, fn) {
                            return defineCommand(states, async(fn));
                        }
                        //#region signIn
                        var cmdSignIn = settings.supportsSignIn === false ?
                            DisabledCommand(Exception('ECS')) :
                            defineAsyncCommand([Application.State.SignedOut], function (options) {
                                extend(options, settings.signIn); // ECS can override sign in params
                                // if the user is on-prem, add lyncdiscover paths to auto-d
                                if (settings.onprem !== undefined)
                                    options.eopd = settings.onprem;
                                if (options.cors == 'test') {
                                    options.cors = ['outlook.office.com', 'outlook.office365.com'].indexOf(location.hostname) >= 0
                                        && ['Chrome', 'Safari', 'Firefox'].indexOf(EnvInfo.getBrowserName()) >= 0;
                                }
                                if (location && /\.force\.com$/.test(location.hostname)) {
                                    // A hack for SalesForce 206 where they don't pass endpoint id.
                                    // In SalesForce 208 they will pass it and once it releases we can 
                                    // remove this code.
                                    // Hardcoding endpoint id to prevent SF to generate too many Applications
                                    // and overloading UCWA.
                                    options.id = 'f07523aa-0781-4a59-9628-07c4f659c65c';
                                    // The SF app creates multiple iframes with
                                    // an instance of websdk in each iframe and lets them sign in. Since
                                    // they share the same endpoint id, the websdk saves the snapshot
                                    // from the first iframe and then reuses it in others. This leads to 409s
                                    // and 404s as they all are trying to use the same app/ events href.
                                    // This line tells to not save instance-id-specific hrefs so the iframes
                                    // could coexist by having their own rel=application hrefs and yet benefit
                                    // from the rel=applications href that allows to skip autodiscovery.
                                    options.ssrels = 'applications|root|xframe';
                                }
                                if (tm && options.version)
                                    tm.defaults.appVersion = options.version; // this prop may be missing, which is fine
                                debugInfo.client_id = options.client_id;
                                if (tm && options.client_id)
                                    tm.defaults.client_id = options.client_id;
                                if (tm) {
                                    tm.defaults.signInType = options.client_id || options.get_oauth_token ? 'online' : 'onprem';
                                    debugInfo.signin_type = tm.defaults.signInType;
                                }
                                if (tm && options.ecws)
                                    tm.defaults.ecws = options.ecws;
                                if (settings.retry)
                                    options.retry = settings.retry;
                                isAnon = !!(options.meeting || options.name);
                                if (options.name)
                                    guestName(options.name);
                                if (options.meeting) {
                                    if (!options.name)
                                        throw EInvalidArgument('name', 'Default display name in anonymous meetings is required.');
                                    delete options.name; // the name parameter tells the stack to use the p2p anon auth
                                }
                                if (settings.lockEndpointId) {
                                    if (options.id)
                                        throw new Error('.id cannot be set as it is computed automatically');
                                    if (!options.version)
                                        throw new Error('.version is mandatory');
                                    options.id = hash(options.version);
                                }
                                if (options.auth) {
                                    // wrapped the passed in custom auth method to expose preformatted errors.
                                    // see errorMapper.ts
                                    options.auth = customAuth.wrap(options.auth, tm);
                                }
                                var capabilities = app.personsAndGroupsManager.mePerson.capabilities;
                                // internal is the default. It is private, and controlled either through ecs or a signin parameter.
                                // It takes effect only if supportsAudio/Video/Sharing is not specified.
                                // Either user or ECS can specify supports* to false to turn off the capability for everyone.
                                if (settings.enableInternalNS !== undefined)
                                    options.enableInternalNS = settings.enableInternalNS;
                                // as of Dec 2015 the internal flag is required to use the UCWA media APIs
                                capabilities.chat.text(getOption(settings, 'supportsText', getOption(settings, 'supportsMessaging', true)));
                                capabilities.chat.html(getOption(settings, 'supportsHtml', getOption(settings, 'supportsMessaging', true)));
                                capabilities.audio(getOption(settings, 'supportsAudio', options.enableInternalNS));
                                capabilities.video(getOption(settings, 'supportsVideo', options.enableInternalNS));
                                capabilities.screenSharing(getOption(settings, 'supportsSharing', options.enableInternalNS));
                                if (settings.remotePresenceOnlyMode)
                                    settings.events = false;
                                if (settings.events !== undefined)
                                    options.events = settings.events;
                                options.user = options.user || {
                                    isActive: app.personsAndGroupsManager.mePerson.active.asReadOnly(),
                                    inactivityTimeout: settings.userInactivityTimeout || 900000 // default 15 mins
                                };
                                options.supportsWebRtc = Web.Media && Web.Media.isWebRtc();
                                var hp = appInitParams && appInitParams.correlationIds && appInitParams.correlationIds.hostProperty ||
                                    telemetryManager && telemetryManager.hostname;
                                hp && (options.hostProperty = hp);
                                debugInfo.host_property = hp;
                                state(Application.State.SigningIn);
                                var sp = {}; // sign-in props sent for sign-in tm events (started/succeeded/failed)
                                // ucwa should have been uninitialized already and thus
                                // a call to .init(...) shouldn't throw any exceptions
                                dfdSignedIn = ucwa.init(options).then(function (res) {
                                    state(Application.State.SignedIn);
                                    // if it's a anon join mode...
                                    if (options.name) {
                                        if (options.join_url) {
                                            sp.anon_join_type = 'onprem';
                                        }
                                        else if (options.root && (options.token || options.auth)) {
                                            var conf = ucwa.exists({ rel: 'ms:rtc:saas:discover' });
                                            // the 3rd type will be "user_pool" for anon joined online meetings
                                            sp.anon_join_type = conf ? 'resource_forest' : 'p2p';
                                        }
                                    }
                                }, function (err) {
                                    exposeErrorDetail(err, settings.signIn, tm);
                                    state(Application.State.SignedOut, err);
                                    throw err;
                                });
                                if (tm) {
                                    for (var arg in options) {
                                        var val = options[arg];
                                        var type = typeof val;
                                        sp['sp_' + arg] = /number|boolean/.test(type) ? val :
                                            type == 'string' ? '<hash:' + hash(val) + '>' : '<type:' + type + '>';
                                    }
                                    // if the tab is background, sign in will be much slower, hence 3 mins
                                    tm.monitor(dfdSignedIn, Web.TelemetryEvent.SignIn, sp, { timeout: 3 * 60 * 1000 });
                                }
                                return dfdSignedIn;
                            });
                        //#endregion
                        //#region signOut
                        var cmdSignOut = defineAsyncCommand(keys(Application.State), function () {
                            switch (state()) {
                                case Application.State.SignedOut:
                                    return; // already signed out
                                case Application.State.SigningIn:
                                    state(Application.State.SigningOut);
                                    dfdSignedIn.cancel(Exception('SignedOut'));
                                    // suppress all errors as sign-out must always succeed
                                    return dfdSignedIn.catch();
                                case Application.State.SigningOut:
                                    return dfdSignedOut;
                                case Application.State.SignedIn:
                                    state(Application.State.SigningOut);
                                    // even though the DELETE request may fail,
                                    // the client still goes to the signed-out state,
                                    // because otherwise the client won't be usable at all
                                    dfdSignedOut = ucwa.deleteApp().then(function (res) {
                                        state(Application.State.SignedOut);
                                    }, function (err) {
                                        state(Application.State.SignedOut, err);
                                        throw err;
                                    });
                                    tm && tm.monitor(dfdSignedOut, Web.TelemetryEvent.SignOut, { timeout: 10000 });
                                    return dfdSignedOut;
                            }
                        });
                        //#endregion
                        //#region startMessaging
                        /**
                         * Starts an IM conversation with a given participant.
                         *
                         * @param {String} to - SIP URI of the participant.
                         * @param {String} [message=""]
                         * @param {String} [priority="Normal"]
                         * @param {String} [topic=""]
                         * @param [context]
                         *
                         * @returns {Promise<Conversation>}
                         *
                         * @example
                         *
                         *      client.startMessaging({
                         *          to: 'sip:johndoe@contoso.com',
                         *          message: 'How are you?',
                         *          topic: 'A very important conversation',
                         *          priority: 'Urgent'
                         *      }).then(function (conversation) {
                         *          console.log('conversation started');
                         *          return conversation.chatService.sendMessage('Hi!');
                         *      }).then(function () {
                         *          console.log('IM sent');
                         *      });
                         */
                        var cmdStartMessaging = defineAsyncCommand([Application.State.SignedIn], function (options) {
                            var conversation = app.conversationsManager.createConversation({
                                isConference: false,
                                topic: options.topic,
                                priority: options.priority,
                                threadId: options.threadId
                            });
                            var messaging = conversation.chatService;
                            return messaging.start({
                                to: options.to,
                                message: options.message,
                                context: options.context,
                                contextType: options.contextType,
                                // these are given by unit tests:
                                boundary: options.boundary,
                                operationId: options.operationId,
                                sessionContext: options.sessionContext
                            }).then(function () {
                                return conversation;
                            });
                        });
                        //#endregion
                        //#region startAudioVideo
                        /**
                         * Starts an audio/video call with a given participant.
                         *
                         * @param {String} to - SIP URI of the participant.
                         * @param {Dictionary} [video] - If present start an audio/video call, otherwise start just an audio call.
                         *
                         *      {HTMLElement} container - parent DOM element for video window
                         *
                         * @returns {Promise<Conversation>}
                         *
                         * @example
                         *
                         *      // start audio
                         *      client.startAudioVideo({
                         *          to: 'sip:johndoe@contoso.com'
                         *      }).then(function (conversation) {
                         *          console.log('audio started');
                         *          conversation.audioService.stop();
                         *      }).then(function () {
                         *          console.log('audio stopped');
                         *      });
                         *
                         *      // start audio and video
                         *      client.startAudioVideo({
                         *          to: 'sip:johndoe@contoso.com',
                         *          video: { container: document.getElementById('myVideoWindowContainer') }
                         *      });
                         */
                        var cmdStartAudioVideo = defineAsyncCommand([Application.State.SignedIn], function (options) {
                            var conversation = app.conversationsManager.createConversation({
                                isConference: false,
                                threadId: options.threadId
                            });
                            var dfd = options.video ?
                                conversation.videoService.start(options) :
                                conversation.audioService.start(options);
                            return dfd.then(function () { return conversation; });
                        });
                        //#endregion
                        //#region startAppSharing
                        /**
                         * Starts an app-sharing call with a given participant.
                         *
                         * @param {String} to - SIP URI of the participant.
                         * @param {ShareableWindow} window - Window resource to share
                         * @param {ShareableMonitor} monitor - Monitor resource to share
                         * @param {HTMLElement} container - DOM element used for viewing shared content
                         *
                         * @returns {Promise<Conversation>}
                         *
                         * @example
                         *
                         *      // start app-sharing
                         *      client.startAppSharing({
                         *          to: 'sip:johndoe@contoso.com',
                         *          window: window,
                         *          monitor: monitor,
                         *          container: document.getElementById('appSharingViewer')
                         *      }).then(function (conversation) {
                         *          console.log('app-sharing started');
                         *          var appSharing = conversation.modalities('AppSharing');
                         *          appSharing.stop();
                         *      }).then(function () {
                         *          console.log('app-sharing stopped');
                         *      });
                         */
                        var cmdStartAppSharing = defineAsyncCommand([Application.State.SignedIn], function (options) {
                            var conversation = app.conversationsManager.createConversation({
                                isConference: false,
                                threadId: options.threadId
                            });
                            var as = conversation.addModality(Internal.Conversation.ModalityType.AppSharing);
                            return as.start(options).then(function () { return conversation; });
                        });
                        //#endregion
                        //#region startMeeting
                        /**
                         * Creates an online meeting. The created meeting is represented by a
                         * Conversation model with an OnlineMeeting model inside. The created
                         * conversation does not have any modalities, so needed modalities
                         * need to be added first and then needed participants need to be
                         * brought into the meeting:
                         *
                         *      client.startMeeting({
                         *          topic: 'A very important meeting.',
                         *          priority: 'Urgent'
                         *      }).then(function (conversation) {
                         *          conversation.addParticipant('sip:user1@contoso.com');
                         *          conversation.addParticipant('sip:user2@contoso.com');
                         *          conversation.addParticipant('sip:user3@contoso.com');
                         *      });
                         *
                         * Note, that modalities have to be added before participants.
                         * The created conversation has the messaging modality, so it can
                         * be used to send and receive messages right away. To join an existing
                         * meeting with a known URI, specify the "uri" parameter:
                         *
                         *      client.startMeeting({
                         *          uri: "sip:user5@contoso.com;gruu;opaque=app:conf:focus:id:WHBSYO8R"
                         *      }).then(function (conversation) {
                         *          var text = "Hi everybody! I'm " + client.personsAndGroupsManager.mePerson.name() + ".";
                         *          conversation.chatService.sendMessage(text);
                         *      });
                         *
                         * @param {String} [topic=""]
                         * @param {String} [priority="Normal"]
                         * @param {String} [uri] - The URI of an existing meeting to join.
                         * @param {String} [name] - The guest name when joining an online meeting anonymously.
                         *
                         * @returns {Promise<Conversation>}
                         */
                        var cmdStartMeeting = defineAsyncCommand([Application.State.SignedIn], function (options) {
                            if (options === void 0) { options = {}; }
                            var conversation = app.conversationsManager.createConversation({
                                isConference: true,
                                topic: options.topic,
                                priority: options.priority,
                                threadId: options.threadId
                            });
                            return conversation.addMeeting().start({
                                uri: options.uri,
                                name: options.name
                            }).then(function () {
                                return conversation.chatService.start();
                            }).then(function () {
                                return conversation;
                            });
                        });
                        //#endregion
                        //#region getSnapshot
                        var cmdGetSnapshot = defineCommand([Application.State.SignedIn], function () {
                            return ucwa.getSnapshot();
                        });
                        //#endregion
                        //#region getErrorReport
                        function getErrorReport() {
                            var data = JSON.stringify({
                                session: sid,
                                logs: settings.logs && settings.logs.ucwa && ucwa.logs,
                                snapshot: settings.logs && settings.logs.ucwa && ucwa.getSnapshot()
                            });
                            // anything that looks like a email address
                            data = data.replace(/([-\.\w]+@[-\.\w]+)/img, '<<$1>>');
                            // messages in data:text/plain;charset=utf-8,... format, e.g. invitation messages
                            data = data.replace(/\x22(data:text\/\w+(?:;charset=utf-8)?,)(.+?)\x22/img, '"$1<<$2>>"');
                            // content of outgoing messages: they are sent in the request body of POST /messages
                            data = data.replace(/(\/messages\x22\],\[\x22)(.+?)(\x22\])/img, '$1<<$2>>$3');
                            // certain props in all resources, mostly in rel=contact
                            data = data.replace(/\x22(name|title|department|company|workPhoneNumber|subject)\x22:\x22(.*?)\x22/img, '"$1":"<<$2>>"');
                            // now remove everything that have been marked as PII; hashing is also an option, but there is a simpler solution here
                            var piid = {}, pnum = 0;
                            return data.replace(/<<(.+?)>>/img, function (_, s) { return 'PII-' + (piid[s] = piid[s] || ++pnum); });
                        }
                        //#endregion
                        var replayMessageEnabled = Property({ value: false });
                        function updateReplayMessageCommandState() {
                            if (!settings.replayBot) {
                                replayMessageEnabled(false, Exception('DisabledByECS'));
                                return;
                            }
                            if (state() != Application.State.SignedIn) {
                                replayMessageEnabled(false, Exception('NotSignedIn'));
                                return;
                            }
                            if (!ucwa.exists({ rel: 'replayMessage' })) {
                                replayMessageEnabled(false, Exception('Unsupported'));
                                return;
                            }
                            if (conversationsManager.isHistoryEnabled()) {
                                replayMessageEnabled(false, Exception('ConversationHistoryEnabled'));
                                return;
                            }
                            try {
                                if (Web.localStorage.getItem(settings.replayBot.key)) {
                                    replayMessageEnabled(false, Exception('AlreadyReplayed-LS'));
                                    return;
                                }
                            }
                            catch (err) {
                            }
                            try {
                                var reg = new RegExp('\\breplaybot=' + settings.replayBot.key, 'i');
                                if (reg.test(document.cookie)) {
                                    replayMessageEnabled(false, Exception('AlreadyReplayed-Cookie'));
                                    return;
                                }
                            }
                            catch (err) {
                                replayMessageEnabled(false, Exception('CookieReadFailure'));
                                return;
                            }
                            replayMessageEnabled(true, 'NoPriorState');
                            wasReplayMessageEnabledForThisSession = true;
                        }
                        /**
                         * Send the payload to ucwa (title, firstmsg, lastmsg, toastmsg, idletimeout)
                         * set flags in localstorage and cookie (as requested by spec)
                         * re-evaluate the command state.
                         */
                        var cmdReplayMessage = Command(function (displayName, initialMessage, terminationMessage, toastMessage) {
                            var payload = [
                                '--ef12279a-4107-40f9-8191-3765f3ebb9b1',
                                'Content-Type: application/json',
                                '',
                                JSON.stringify({
                                    idleTimeoutInSeconds: settings.replayBot.idleTimeoutInSeconds,
                                    replayDisplayName: displayName,
                                    replayMessage: 'CID:1',
                                    terminationMessage: 'CID:2',
                                    toastMessage: toastMessage
                                }),
                                '--ef12279a-4107-40f9-8191-3765f3ebb9b1',
                                'Content-Type: text/html',
                                'Content-Id: 1',
                                '',
                                initialMessage,
                                '--ef12279a-4107-40f9-8191-3765f3ebb9b1',
                                'Content-Type: text/html',
                                'Content-Id: 2',
                                '',
                                terminationMessage,
                                '--ef12279a-4107-40f9-8191-3765f3ebb9b1--',
                                ''
                            ].join('\r\n');
                            var dfd = ucwa.send('POST', { rel: 'replayMessage' }, {
                                headers: {
                                    'Content-Type': 'multipart/related;boundary=ef12279a-4107-40f9-8191-3765f3ebb9b1;type="application/json"'
                                },
                                data: payload
                            }).then(function (value) {
                                try {
                                    Web.localStorage.setItem(settings.replayBot.key, "true");
                                }
                                catch (err) {
                                }
                                try {
                                    document.cookie =
                                        'replaybot=' + settings.replayBot.key + ';max-age=15552000'; // 180 days
                                }
                                catch (err) {
                                }
                            }).finally(updateReplayMessageCommandState);
                            tm && tm.monitor(dfd, Web.TelemetryEvent.ReplayMessage, { displayName: displayName });
                            return dfd;
                        }, replayMessageEnabled);
                        if (!Web.isUnitTested) {
                            if (!Web.window[sInstances]) {
                                // the app may not want to make these apps accessible to anyone,
                                // so to expose this array in the debugging console and yet to
                                // not break encapsulation, the array is accessible at a hidden
                                // symbol which can be read manually in the dev console, but cannot
                                // be read programmatically; note, that in unit tests symbols are
                                // plain strings, so tests can access this property directly
                                setHiddenProperty(Web.window, sInstances, []);
                            }
                            Web.window[sInstances].push(app);
                        }
                        init();
                        return extend(app, {
                            signInManager: Model({
                                state: state.asReadOnly(),
                                createPasswordSignInParameter: EnabledCommand(function (x) { return extend(x, { type: 'Password' }); }),
                                createImplicitOAuthSignInParameter: EnabledCommand(function (x) { return extend(x, { type: 'ImplicitOAuth' }); }),
                                signIn: cmdSignIn,
                                signOut: cmdSignOut
                            }),
                            startMessaging: cmdStartMessaging,
                            startAudioVideo: cmdStartAudioVideo,
                            startAppSharing: cmdStartAppSharing,
                            startMeeting: cmdStartMeeting,
                            getSnapshot: cmdGetSnapshot,
                            getErrorReport: getErrorReport,
                            conversationsManager: conversationsManager,
                            replayMessage: cmdReplayMessage
                        });
                    }
                    return Application;
                }());
                Internal.Application = Application;
                (function (Application) {
                    var Options;
                    (function (Options) {
                        ;
                    })(Options = Application.Options || (Application.Options = {}));
                    var State;
                    (function (State) {
                        State.SignedOut = 'SignedOut';
                        State.SignedIn = 'SignedIn';
                        State.SigningOut = 'SigningOut';
                        State.SigningIn = 'SigningIn';
                    })(State = Application.State || (Application.State = {}));
                })(Application = Internal.Application || (Internal.Application = {}));
                /** Extract some detail from the error object and expose as known properties. */
                function exposeErrorDetail(err, signInSettings, tm) {
                    if (err && typeof err == 'object') {
                        var response = err.rsp || err.response || {};
                        var noretry = signInSettings && signInSettings.noretry;
                        // onprem users typically get a 404 NotFound against autod/root/oauth/user. 
                        // This is not airtight, but closest we can get.
                        var isOnPremFailure = noretry && noretry.indexOf('onprem') >= 0 &&
                            response.data && response.data.code == 'NotFound' && response.status == 404 &&
                            err.req && /\/autodiscoverservice\.svc\/root\/oauth\/user/i.test(err.req.url);
                        // people without sfb license fail with '28000;source="DM12A00EDG06.infra.lync.com";reason="User is not SIP enabled.' 
                        // Again, not airtight as the error code may (rarely) change.
                        var isNotSfbUser = noretry && noretry.indexOf('notsfbuser') >= 0 &&
                            response && response.headers && /^28000/.test(response.headers['X-Ms-Diagnostics']);
                        // 403 with diagcode 28070 "service does not allow a cross domain request from this origin"
                        var is403CrossDomain = noretry && noretry.indexOf('403crossdomain') >= 0 &&
                            response && response.status == 403 && response.headers && /^28070/.test(response.headers['X-Ms-Diagnostics']);
                        extend(err, {
                            debug: {
                                code: response.data && response.data.code,
                                subcode: response.data && response.data.subcode,
                                status: response.status,
                                diag: response.headers && response.headers['X-Ms-Diagnostics'],
                                isRetryable: !(isOnPremFailure || isNotSfbUser || is403CrossDomain)
                            }
                        });
                        errorMapper.map(err, err.req, err.rsp || err.response, tm);
                    }
                }
            })(Internal = Model_29.Internal || (Model_29.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            if (Skype.ttt)
                Skype.ttt.ctor = Model.Internal.Application;
            Model.Application = Web.isUnitTested ? Model.Internal.Application : function ApplicationTTT(args) {
                try {
                    var ls_1 = Skype.$window.localStorage;
                    var key = 'lwsdk.ttt';
                    var val = 'ecs';
                    // TTT can be enabled or disabled manually: in this case ECS shouldn't interfere
                    if (/^(null|ecs)$/.test(ls_1.getItem(key))) {
                        // ttt can only be enabled at the very beginning:
                        // enabling it in the ctor call is too late; so
                        // if ecs tells to enable ttt, set a flag in local
                        // storage to enable ttt next time the websdk starts
                        if (args && args.settings && args.settings.ttt)
                            ls_1.setItem(key, val);
                        else if (ls_1.getItem(key) == val)
                            ls_1.removeItem(key);
                    }
                }
                catch (_) {
                }
                return Skype.ttt ? Skype.ttt.root(args) : new Model.Internal.Application(args);
            };
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
"use strict";
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var extend = Web.Utils.extend;
        var isObject = Web.Utils.isObject;
        // doesn't need to be exported, but unit tests need to test this somehow, so it's exported
        function onLoaded() {
            try {
                Skype.onExperienceLoaded({
                    init: function (configWrapper, onSuccess) {
                        onSuccess && onSuccess({
                            application: function (args) {
                                if (args === void 0) { args = {}; }
                                var ecsConfig = configWrapper.config || {};
                                var initParams = configWrapper.initParams || {};
                                var settings = isObject(args.settings) ? args.settings : {};
                                // ECS config wins over user settings
                                extend(settings, ecsConfig);
                                // to align with cc bootstrapper bring jLync.* directly under settings
                                extend(settings, ecsConfig.jLync);
                                delete settings.jLync; // to prevent confusion on where to read jLync specific settings
                                // app expects cafeTenantToken to be under settings
                                if (ecsConfig.telemetry) {
                                    settings.cafeTenantToken = ecsConfig.telemetry.cafeTenantToken;
                                    delete settings.telemetry.cafeTenantToken; // to prevent confusion on which cafeTenantToken is to be used
                                }
                                if (initParams.apiKey)
                                    settings.apiKey = initParams.apiKey;
                                extend(args, { settings: settings });
                                extend(args, { initParams: initParams });
                                return new Web.Model.Internal.Application(args);
                            }
                        });
                    }
                });
            }
            catch (_) {
            }
        }
        Web.onLoaded = onLoaded;
        onLoaded();
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="ttt.ts" />
/// <reference path="utils.ts" />
/// <reference path="telemetry.ts" />
/// <reference path="ucwa.ts" />
/// <reference path="model.common.ts" />
/// <reference path="media-model.ts" />
/// <reference path="model/Application.ts" />
"use strict";
/// <reference path="sdk-init.ts" />
}(Skype = window.Skype || {});
